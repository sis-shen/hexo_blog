{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/cycle-linkedList.md","hash":"74916d6cc64e7c2c351e15ab26f5dadf285b0467","modified":1697412159046},{"_id":"source/_posts/BiiigInt.md","hash":"dfbe478fc943aa6861f53ffb0c7205f67d5a241f","modified":1697725312123},{"_id":"source/_posts/mistake1.md","hash":"a41e9e5c4da71c5f65b3a805932faae31768575b","modified":1698893776057},{"_id":"source/_posts/mine-clearance.md","hash":"7101753e6261790be615ebeff83a83b380c904d7","modified":1699240767050},{"_id":"source/_posts/mutiInput.md","hash":"5b5a217dad47a6a046a6e1eccd2393e59bdcd436","modified":1698892694363},{"_id":"source/_posts/useScanf.md","hash":"379b450f4dd7064e38a6cb4e0678aed33c534da1","modified":1697688639080},{"_id":"source/_data/link.yml","hash":"58f368035b02bf3025c359e09957f4ec9e3282b7","modified":1693126524025},{"_id":"source/_posts/str-arr.md","hash":"6d9cb48cd425abe95589887383e9212330bf7bc4","modified":1699753853558},{"_id":"source/_posts/vueTheRoad.md","hash":"17ae22a0bb84da2f46a97e4d1b78cb08905ffd22","modified":1696335138219},{"_id":"source/_posts/算法_按位异或.md","hash":"e51933ba4ee14a1be1aec18c6ff1692b246084b6","modified":1693832739587},{"_id":"source/_posts/双指针.md","hash":"5c8b0b528e391f1fa87492b53de74d2837e9fb58","modified":1698892541743},{"_id":"source/about/indext.md","hash":"027bb7a8a9c784f4d4ab627f4499badd230d6447","modified":1693711042396},{"_id":"source/categories/index.md","hash":"18e05b31ef1a2e110125bf8d58af5d6a34c207ab","modified":1693711421819},{"_id":"source/movies/index.md","hash":"099bae90e3915a0a5fcfa629ad800d394bb2f851","modified":1693710999092},{"_id":"source/coss/custom.css","hash":"2fc60914d6e055b13d217d1db06ec681349fb125","modified":1693349656840},{"_id":"source/music/index.md","hash":"bd2f1125276eb96beff686c37bfb3b9d4764027a","modified":1692767438267},{"_id":"source/link/index.md","hash":"c7f7df8d112cf56622d1ed5781e05681e99e5577","modified":1692669996323},{"_id":"source/tags/index.md","hash":"35efb0659ff518aade575bc5d18cf19881a3da79","modified":1692669998683},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":1692667980637},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":1692772104793},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":1692667980909},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1692667980421},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"656d8b548940d7d214459cd8853007af38e6c465","modified":1692667980636},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":1692667980639},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1692667980907},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1692667980906},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1692667980916},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1692667980667},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1692667980701},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1692667980787},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1692667980816},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1692667980914},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1692667980798},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1692667980765},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1692667980905},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1692667980914},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1692667980904},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1692667980653},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1692667980644},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1692667980908},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1692667980912},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1692667980741},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":1692667980808},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1692667980729},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1692667980770},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1692667980879},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1692667980788},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1692667980534},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1692667980810},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1692667980902},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1692667980640},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1692667980542},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1692667980607},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1692667980575},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1692667980590},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1692667980527},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1692667980630},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1692667980628},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1692667980579},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1692667980564},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1692667980618},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1692667980632},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1692667980621},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1692667980569},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1692667980581},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1692667980616},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1692667980619},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1692667980573},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1692667980582},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1692667980613},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1692667980587},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1692667980594},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1692667980588},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1692667980595},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1692667980610},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1692667980624},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1692667980597},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1692667980623},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1692667980608},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1692667980620},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1692667980785},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1692667980706},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1692667980739},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":1692667980708},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1692667980783},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1692667980799},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1692667980802},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1692667980744},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1692667980782},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1692667980663},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1692667980776},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1692667980812},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1692667980813},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1692667980732},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":1692667980798},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1692667980676},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1692667980786},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1692667980727},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1692667980749},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1692667980796},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1692667980713},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1692667980807},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1692667980818},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1692667980794},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1692667980699},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1692667980722},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1692667980789},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1692667980801},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":1692667980792},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1692667980681},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1692667980815},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1692667980665},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1692667980678},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1692667980688},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1692667980682},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1692667980687},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1692667980691},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1692667980689},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1692667980694},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1692667980698},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1692667980683},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1692667980696},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1692667980763},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1692667980692},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":1692667980874},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":1692667980872},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1692667980849},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1692667980841},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1692667980897},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1692667980848},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1692667980861},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1692667980884},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":1692667980867},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1692667980890},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":1692667980864},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":1692667980888},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1692667980887},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1692667980894},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1692667980899},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1692667980892},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":1692667980889},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":1692667980853},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1692667980893},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1692667980839},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1692667980847},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1692667980850},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":1692667980873},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1692667980861},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1692667980838},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1692667980878},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1692667980897},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1692667980885},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1692667980866},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1692667980844},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1692667980868},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1692667980881},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1692667980835},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1692667980881},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1692667980870},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1692667980886},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1692667980483},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1692667980648},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1692667980557},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1692667980900},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1692667980600},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1692667980750},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1692667980716},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1692667980669},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1692667980724},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1692667980751},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1692667980895},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1692667980822},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1692667980803},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":1692667980671},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":1692667980718},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1692667980826},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":1692667980723},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":1692667980719},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":1692667980755},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":1692667980830},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":1692667980735},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":1692667980823},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":1692667980733},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1692667980772},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":1692667980825},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1692667980827},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":1692667980804},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1692667980767},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1692667980831},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1692667980705},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1692667980709},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1692667980780},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1692667980769},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1692667980756},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1692667980711},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1692667980820},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1692667980753},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":1692667980778},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1692667980673},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1692667980715},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1692667980775},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1692667980738},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1692667980804},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1692667980821},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1692667980829},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1692667980650},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1692667980758},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1692667980657},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":1692667980832},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1692667980761},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1692667980660},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1692667980774},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1692667980809},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1692667980759},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1692667980721},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1692667980875},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1692667980859},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1692667980882},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1692667980856},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1692667980877},{"_id":"public/search.xml","hash":"f5666aa3f44cfb8b30286424d3e8eea05ffcd0d6","modified":1699753859833},{"_id":"public/coss/custom.css","hash":"30a41bf8495adcb1d4a1bc1f8d7f5e16657e5643","modified":1699753859833},{"_id":"public/404.html","hash":"080c3f5af97e545966f1634eed951b4bd3cfc08f","modified":1699753859833},{"_id":"public/movies/index.html","hash":"bde8faac0ecd32374787ae133a9fae71f58dd84d","modified":1699753859833},{"_id":"public/categories/index.html","hash":"dae6ebaed000fcefccff473d3ac2a3afe2c10aed","modified":1699753859833},{"_id":"public/music/index.html","hash":"a78aecf5731e5f3dd855507d22601970b71af25d","modified":1699753859833},{"_id":"public/link/index.html","hash":"82ae4216eec8bc9677a19b7123e670f32b59f2d9","modified":1699753859833},{"_id":"public/tags/index.html","hash":"c90c3711e21c9941a737acc91854e02db675c629","modified":1699753859833},{"_id":"public/about/indext.html","hash":"1ef34cd2d7b53f446c4cbfe823df8a45ad858a13","modified":1699753859833},{"_id":"public/2023/11/08/str-arr/index.html","hash":"d116c80fdc6520d732cd0aadadfa7ab8a69a1566","modified":1699753859833},{"_id":"public/2023/10/30/mine-clearance/index.html","hash":"e2a798fd882721f8163500b25be108ffae1aa2f0","modified":1699753859833},{"_id":"public/2023/10/18/mutiInput/index.html","hash":"13731eef4ad34febf3950bf6dc9fbab0f0428fd4","modified":1699753859833},{"_id":"public/2023/10/14/BiiigInt/index.html","hash":"b401300ec6ab9bbd3c600761332f1b1c9c574054","modified":1699753859833},{"_id":"public/2023/10/08/cycle-linkedList/index.html","hash":"998f6bb3faaaf5f98c5d96d81d31761d83124a28","modified":1699753859833},{"_id":"public/2023/10/05/useScanf/index.html","hash":"fc9d24139827beb67ba80bce98a210f7aa707f41","modified":1699753859833},{"_id":"public/2023/09/04/算法_按位异或/index.html","hash":"935924227dde46573699baf26251f17317f1e9d7","modified":1699753859833},{"_id":"public/2023/09/12/双指针/index.html","hash":"301a4cab4715f3e3ddc7e1bce473fac7127d159c","modified":1699753859833},{"_id":"public/2023/09/23/vueTheRoad/index.html","hash":"a999ec0de6e2cc28a57f0996059e43c3bf3269f3","modified":1699753859833},{"_id":"public/2023/08/28/mistake1/index.html","hash":"4382d06b9218237f99dd1d5d657b18dd8bf8c696","modified":1699753859833},{"_id":"public/archives/index.html","hash":"0164c784c80a43dcbc4eaf2ec32964e4c12094fa","modified":1699753859833},{"_id":"public/archives/2023/index.html","hash":"c0f5df04ed81aba4bbcbaba6c51bec3c2b2e4675","modified":1699753859833},{"_id":"public/archives/2023/08/index.html","hash":"ddd42a3c982c6caba7d592dacb5acdde11c26817","modified":1699753859833},{"_id":"public/archives/2023/09/index.html","hash":"0e9b886128066c05e8aff74d187c499ef5e5f510","modified":1699753859833},{"_id":"public/archives/2023/10/index.html","hash":"b4997b7f6a42d34b9b89ac2411dccba8995c21cf","modified":1699753859833},{"_id":"public/index.html","hash":"56cbdd9113fccecdc11e29d01f8a2f639575aa6b","modified":1699753859833},{"_id":"public/archives/2023/11/index.html","hash":"2ffd517362c173ae252b74c4dc9aba52f14715bd","modified":1699753859833},{"_id":"public/tags/算法/index.html","hash":"9851b9659da5b94b1c8025128dd8f30b60fdda4f","modified":1699753859833},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1699753859833},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1699753859833},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1699753859833},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1699753859833},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1699753859833},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1699753859833},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1699753859833},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1699753859833},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1699753859833},{"_id":"public/css/index.css","hash":"3db711ba85c6ee09832da7cc10b118fbe1a257d5","modified":1699753859833}],"Category":[],"Data":[{"_id":"link","data":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}],"Page":[{"title":"电影","date":"2023-08-23T04:00:00.000Z","type":"movie","_content":"","source":"movies/index.md","raw":"---\ntitle: 电影\ndate: 2023-08-23 12:00:00\ntype: \"movie\"\n---","updated":"2023-09-03T03:16:39.092Z","path":"movies/index.html","comments":1,"layout":"page","_id":"cloutk93f0000kkg65r1se8bl","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed.supdriver.top/img/avatar.png","cover_type":"img","excerpt":"","more":""},{"title":"categories","date":"2023-09-03T03:23:20.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-09-03 11:23:20\ntype: \"categories\"\n---\n","updated":"2023-09-03T03:23:41.819Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cloutk93n0002kkg6a3kd6gkc","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","cover_type":"img","excerpt":"","more":""},{"title":"音乐","date":"2023-08-23T04:00:00.000Z","_content":"","source":"music/index.md","raw":"---\ntitle: 音乐\ndate: 2023-08-23 12:00:00\n---","updated":"2023-08-23T05:10:38.267Z","path":"music/index.html","comments":1,"layout":"page","_id":"cloutk93q0004kkg61s3rc2ov","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed.supdriver.top/img/avatar.png","cover_type":"img","excerpt":"","more":""},{"_content":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }","source":"coss/custom.css","raw":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }","date":"2023-08-29T22:54:16.840Z","updated":"2023-08-29T22:54:16.840Z","path":"coss/custom.css","layout":"false","title":"","comments":1,"_id":"cloutk93r0006kkg6hln85wna","content":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","cover_type":"img","excerpt":"","more":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }"},{"title":"link","date":"2023-08-22T01:56:32.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2023-08-22 09:56:32\ntype: \"link\"\n---\n","updated":"2023-08-22T02:06:36.323Z","path":"link/index.html","comments":1,"layout":"page","_id":"cloutk93t0008kkg60e9jhnxc","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","cover_type":"img","excerpt":"","more":""},{"title":"tags","date":"2023-08-22T01:54:41.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-08-22 09:54:41\ntype: \"tags\"\n---\n","updated":"2023-08-22T02:06:38.683Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cloutk93t0009kkg62c4072j9","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","cover_type":"img","excerpt":"","more":""},{"title":"关于","date":"2023-08-23T04:00:00.000Z","type":"about","_content":"","source":"about/indext.md","raw":"---\ntitle: 关于\ndate: 2023-08-23 12:00:00\ntype: \"about\"\n---","updated":"2023-09-03T03:17:22.396Z","path":"about/indext.html","comments":1,"layout":"page","_id":"cloutk93u000akkg60uo79l9y","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","cover_type":"img","excerpt":"","more":""}],"Post":[{"title":"=数据结构=循环链表/链表带环(修改中)","date":"2023-10-08T05:28:52.000Z","_content":"","source":"_posts/cycle-linkedList.md","raw":"---\ntitle: =数据结构=循环链表/链表带环(修改中)\ndate: 2023-10-08 13:28:52\ntags:\n---\n","slug":"cycle-linkedList","published":1,"updated":"2023-10-15T23:22:39.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloutk93j0001kkg6d1u4alp6","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed.supdriver.top/img/avatar.png","cover_type":"img","excerpt":"","more":""},{"title":"=C语言= 整型变量与过大的整数","date":"2023-10-13T23:09:14.000Z","_content":"## 整型家族 #\n在使用C语言写程序时，会储存各种长度的整型,而在整型家族中，长度的比较如下\n\n`char < short <= int <= long <long long `\n\n## 整型是如何储存在内存中的 #\n*以`char`为例*\n![char](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-14_15-33-30.jpg)\n\n`char`的长度为1个`字节`，8个`比特位`,其中**最高位**是**符号位**,`0`表示正数，`1`表示负数，剩下的位数用于储存变量的**绝对值**\n\n---\n而当使用无符号整型(带前缀`unsigned`)时，只需把符号位也用于存值即可\n\n## 能够储存的最大正整数 #\n\n`int`长度为4`字节`,能够储存的最大值为`2的31次方-1`,即**2,147,483,647**\n\n`unsigned int`能够储存的最大值为**4294967295**\n\n`unsigned long long`长度为8`字节`,能够储存的最大值为`2的64次方-1`,即**18,446,744,073,709,551,615**\n\n---\n\n## 限制 #\n\n虽然`unsigned long long`已经很大了，但当遇到`指数`,`阶乘`之类的运算时仍然可能**存不下!**(光`21!`就比`unsigned long long`长了)\n\n## 思路 #\n过大的整数，可能出现在**程序的过程**中，也可能出现在**输出**中，对于过程，可以尝试**改变实现思路**，让过程中不出现过大的整数；对于输出，可以尝试**改变输出的类型**，采用输出**字符或字符串**\n\n# 以下皆为例题 #\n\n## 1.求n!的结尾有多少个0\n\n最直白的思路就是把`n!`算出来，然后用`%10`再`/=10`的方法统计末尾的`0`,想法很简单，“实现”起来也不难，**但不幸的是**，`21!`就已经储存不了了，所以不能暴力求解\n\n所以要**改变思路**，先从末尾0是怎么来的下手。末尾的n个0来自因式分解后10的n次方，而采用质因数分解的方法，可以发现`0`来自分解后`2的n次方`和`5的n次方`,而一个数分解后`2的n次方`必定比`5的n次方` 多，所以只需统计`5的n次方`。**注意**：就别再倒回去，想着先算出阶乘再求`5的n次方`了。\n\n**这里采用逐步计数的方法**：结果中的`5的n次方`来自各个因数中`5的N次方`的累乘,所以只需要历遍每个因数，并统计其中`因数5`的次数。这样过程中就不会有过大的数字了\n\n```C\n//代码实现\nint count_num0(int n)\n{\n    int count = 0;\n    for(int i = 1;i<=n;i++)\n    {\n        int copy = i//防止改变循环变量\n        while(copy%5 == 0)//统计因数5的出现次数\n        {\n            if(copy%5 == 0)\n            {\n                count++;\n            }\n            copy/=5;\n        }\n    }\n\n    return count;\n}\n\n```\n\n## 快速输出1+2+……+10^n #\n*如下图*：当我们试图算一算答案时，发现`n`到了`10`时就已经算不出答案了\n\n![计算结果](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/gao_si.png)\n\n所以要**改变输出答案答案的方式**,观察一下`n`在`1~9`时的输出\n\n![输出](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_07-26-54.jpg)\n\n这时我们发现**答案颇有规律**：每个输出都是**两段**`先一个5，然后n-1个0`！\n\n这样我们只需**从最高位往最低位**逐位打印即可,代码如下\n\n```C\nvoid printChar(int n)//版本一，逐位打印字符(串)\n{\n    printf(\"5\");\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"0\");\n    }\n    //再重复一段\n    printf(\"5\");\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"0\");\n    }\n    printf(\"\\n\");\n}\n\nvoid printNum(int n)//版本二，逐位打印整型\n{\n    printf(\"%d\",5);\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"%d\",0);\n    }\n    //再重复一段\n    printf(\"%d\",5);\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"%d\",0);\n    }\n    printf(\"\\n\");\n}\n```","source":"_posts/BiiigInt.md","raw":"---\ntitle: =C语言= 整型变量与过大的整数\ndate: 2023-10-14 07:09:14\ntags:\n---\n## 整型家族 #\n在使用C语言写程序时，会储存各种长度的整型,而在整型家族中，长度的比较如下\n\n`char < short <= int <= long <long long `\n\n## 整型是如何储存在内存中的 #\n*以`char`为例*\n![char](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-14_15-33-30.jpg)\n\n`char`的长度为1个`字节`，8个`比特位`,其中**最高位**是**符号位**,`0`表示正数，`1`表示负数，剩下的位数用于储存变量的**绝对值**\n\n---\n而当使用无符号整型(带前缀`unsigned`)时，只需把符号位也用于存值即可\n\n## 能够储存的最大正整数 #\n\n`int`长度为4`字节`,能够储存的最大值为`2的31次方-1`,即**2,147,483,647**\n\n`unsigned int`能够储存的最大值为**4294967295**\n\n`unsigned long long`长度为8`字节`,能够储存的最大值为`2的64次方-1`,即**18,446,744,073,709,551,615**\n\n---\n\n## 限制 #\n\n虽然`unsigned long long`已经很大了，但当遇到`指数`,`阶乘`之类的运算时仍然可能**存不下!**(光`21!`就比`unsigned long long`长了)\n\n## 思路 #\n过大的整数，可能出现在**程序的过程**中，也可能出现在**输出**中，对于过程，可以尝试**改变实现思路**，让过程中不出现过大的整数；对于输出，可以尝试**改变输出的类型**，采用输出**字符或字符串**\n\n# 以下皆为例题 #\n\n## 1.求n!的结尾有多少个0\n\n最直白的思路就是把`n!`算出来，然后用`%10`再`/=10`的方法统计末尾的`0`,想法很简单，“实现”起来也不难，**但不幸的是**，`21!`就已经储存不了了，所以不能暴力求解\n\n所以要**改变思路**，先从末尾0是怎么来的下手。末尾的n个0来自因式分解后10的n次方，而采用质因数分解的方法，可以发现`0`来自分解后`2的n次方`和`5的n次方`,而一个数分解后`2的n次方`必定比`5的n次方` 多，所以只需统计`5的n次方`。**注意**：就别再倒回去，想着先算出阶乘再求`5的n次方`了。\n\n**这里采用逐步计数的方法**：结果中的`5的n次方`来自各个因数中`5的N次方`的累乘,所以只需要历遍每个因数，并统计其中`因数5`的次数。这样过程中就不会有过大的数字了\n\n```C\n//代码实现\nint count_num0(int n)\n{\n    int count = 0;\n    for(int i = 1;i<=n;i++)\n    {\n        int copy = i//防止改变循环变量\n        while(copy%5 == 0)//统计因数5的出现次数\n        {\n            if(copy%5 == 0)\n            {\n                count++;\n            }\n            copy/=5;\n        }\n    }\n\n    return count;\n}\n\n```\n\n## 快速输出1+2+……+10^n #\n*如下图*：当我们试图算一算答案时，发现`n`到了`10`时就已经算不出答案了\n\n![计算结果](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/gao_si.png)\n\n所以要**改变输出答案答案的方式**,观察一下`n`在`1~9`时的输出\n\n![输出](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_07-26-54.jpg)\n\n这时我们发现**答案颇有规律**：每个输出都是**两段**`先一个5，然后n-1个0`！\n\n这样我们只需**从最高位往最低位**逐位打印即可,代码如下\n\n```C\nvoid printChar(int n)//版本一，逐位打印字符(串)\n{\n    printf(\"5\");\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"0\");\n    }\n    //再重复一段\n    printf(\"5\");\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"0\");\n    }\n    printf(\"\\n\");\n}\n\nvoid printNum(int n)//版本二，逐位打印整型\n{\n    printf(\"%d\",5);\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"%d\",0);\n    }\n    //再重复一段\n    printf(\"%d\",5);\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"%d\",0);\n    }\n    printf(\"\\n\");\n}\n```","slug":"BiiigInt","published":1,"updated":"2023-10-19T14:21:52.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloutk93o0003kkg6csss4t1t","content":"<h2 id=\"整型家族\"><a href=\"#整型家族\" class=\"headerlink\" title=\"整型家族\"></a>整型家族</h2><p>在使用C语言写程序时，会储存各种长度的整型,而在整型家族中，长度的比较如下</p>\n<p><code>char &lt; short &lt;= int &lt;= long &lt;long long </code></p>\n<h2 id=\"整型是如何储存在内存中的\"><a href=\"#整型是如何储存在内存中的\" class=\"headerlink\" title=\"整型是如何储存在内存中的\"></a>整型是如何储存在内存中的</h2><p><em>以<code>char</code>为例</em><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-14_15-33-30.jpg\" alt=\"char\"></p>\n<p><code>char</code>的长度为1个<code>字节</code>，8个<code>比特位</code>,其中<strong>最高位</strong>是<strong>符号位</strong>,<code>0</code>表示正数，<code>1</code>表示负数，剩下的位数用于储存变量的<strong>绝对值</strong></p>\n<hr>\n<p>而当使用无符号整型(带前缀<code>unsigned</code>)时，只需把符号位也用于存值即可</p>\n<h2 id=\"能够储存的最大正整数\"><a href=\"#能够储存的最大正整数\" class=\"headerlink\" title=\"能够储存的最大正整数\"></a>能够储存的最大正整数</h2><p><code>int</code>长度为4<code>字节</code>,能够储存的最大值为<code>2的31次方-1</code>,即<strong>2,147,483,647</strong></p>\n<p><code>unsigned int</code>能够储存的最大值为<strong>4294967295</strong></p>\n<p><code>unsigned long long</code>长度为8<code>字节</code>,能够储存的最大值为<code>2的64次方-1</code>,即<strong>18,446,744,073,709,551,615</strong></p>\n<hr>\n<h2 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h2><p>虽然<code>unsigned long long</code>已经很大了，但当遇到<code>指数</code>,<code>阶乘</code>之类的运算时仍然可能<strong>存不下!</strong>(光<code>21!</code>就比<code>unsigned long long</code>长了)</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>过大的整数，可能出现在<strong>程序的过程</strong>中，也可能出现在<strong>输出</strong>中，对于过程，可以尝试<strong>改变实现思路</strong>，让过程中不出现过大的整数；对于输出，可以尝试<strong>改变输出的类型</strong>，采用输出<strong>字符或字符串</strong></p>\n<h1 id=\"以下皆为例题\"><a href=\"#以下皆为例题\" class=\"headerlink\" title=\"以下皆为例题\"></a>以下皆为例题</h1><h2 id=\"1-求n-的结尾有多少个0\"><a href=\"#1-求n-的结尾有多少个0\" class=\"headerlink\" title=\"1.求n!的结尾有多少个0\"></a>1.求n!的结尾有多少个0</h2><p>最直白的思路就是把<code>n!</code>算出来，然后用<code>%10</code>再<code>/=10</code>的方法统计末尾的<code>0</code>,想法很简单，“实现”起来也不难，<strong>但不幸的是</strong>，<code>21!</code>就已经储存不了了，所以不能暴力求解</p>\n<p>所以要<strong>改变思路</strong>，先从末尾0是怎么来的下手。末尾的n个0来自因式分解后10的n次方，而采用质因数分解的方法，可以发现<code>0</code>来自分解后<code>2的n次方</code>和<code>5的n次方</code>,而一个数分解后<code>2的n次方</code>必定比<code>5的n次方</code> 多，所以只需统计<code>5的n次方</code>。<strong>注意</strong>：就别再倒回去，想着先算出阶乘再求<code>5的n次方</code>了。</p>\n<p><strong>这里采用逐步计数的方法</strong>：结果中的<code>5的n次方</code>来自各个因数中<code>5的N次方</code>的累乘,所以只需要历遍每个因数，并统计其中<code>因数5</code>的次数。这样过程中就不会有过大的数字了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">count_num0</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> copy = i<span class=\"comment\">//防止改变循环变量</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(copy%<span class=\"number\">5</span> == <span class=\"number\">0</span>)<span class=\"comment\">//统计因数5的出现次数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(copy%<span class=\"number\">5</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            copy/=<span class=\"number\">5</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"快速输出1-2-……-10-n\"><a href=\"#快速输出1-2-……-10-n\" class=\"headerlink\" title=\"快速输出1+2+……+10^n\"></a>快速输出1+2+……+10^n</h2><p><em>如下图</em>：当我们试图算一算答案时，发现<code>n</code>到了<code>10</code>时就已经算不出答案了</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/gao_si.png\" alt=\"计算结果\"></p>\n<p>所以要<strong>改变输出答案答案的方式</strong>,观察一下<code>n</code>在<code>1~9</code>时的输出</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_07-26-54.jpg\" alt=\"输出\"></p>\n<p>这时我们发现<strong>答案颇有规律</strong>：每个输出都是<strong>两段</strong><code>先一个5，然后n-1个0</code>！</p>\n<p>这样我们只需<strong>从最高位往最低位</strong>逐位打印即可,代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">printChar</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//版本一，逐位打印字符(串)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//再重复一段</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">printNum</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//版本二，逐位打印整型</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//再重复一段</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","cover_type":"img","excerpt":"","more":"<h2 id=\"整型家族\"><a href=\"#整型家族\" class=\"headerlink\" title=\"整型家族\"></a>整型家族</h2><p>在使用C语言写程序时，会储存各种长度的整型,而在整型家族中，长度的比较如下</p>\n<p><code>char &lt; short &lt;= int &lt;= long &lt;long long </code></p>\n<h2 id=\"整型是如何储存在内存中的\"><a href=\"#整型是如何储存在内存中的\" class=\"headerlink\" title=\"整型是如何储存在内存中的\"></a>整型是如何储存在内存中的</h2><p><em>以<code>char</code>为例</em><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-14_15-33-30.jpg\" alt=\"char\"></p>\n<p><code>char</code>的长度为1个<code>字节</code>，8个<code>比特位</code>,其中<strong>最高位</strong>是<strong>符号位</strong>,<code>0</code>表示正数，<code>1</code>表示负数，剩下的位数用于储存变量的<strong>绝对值</strong></p>\n<hr>\n<p>而当使用无符号整型(带前缀<code>unsigned</code>)时，只需把符号位也用于存值即可</p>\n<h2 id=\"能够储存的最大正整数\"><a href=\"#能够储存的最大正整数\" class=\"headerlink\" title=\"能够储存的最大正整数\"></a>能够储存的最大正整数</h2><p><code>int</code>长度为4<code>字节</code>,能够储存的最大值为<code>2的31次方-1</code>,即<strong>2,147,483,647</strong></p>\n<p><code>unsigned int</code>能够储存的最大值为<strong>4294967295</strong></p>\n<p><code>unsigned long long</code>长度为8<code>字节</code>,能够储存的最大值为<code>2的64次方-1</code>,即<strong>18,446,744,073,709,551,615</strong></p>\n<hr>\n<h2 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h2><p>虽然<code>unsigned long long</code>已经很大了，但当遇到<code>指数</code>,<code>阶乘</code>之类的运算时仍然可能<strong>存不下!</strong>(光<code>21!</code>就比<code>unsigned long long</code>长了)</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>过大的整数，可能出现在<strong>程序的过程</strong>中，也可能出现在<strong>输出</strong>中，对于过程，可以尝试<strong>改变实现思路</strong>，让过程中不出现过大的整数；对于输出，可以尝试<strong>改变输出的类型</strong>，采用输出<strong>字符或字符串</strong></p>\n<h1 id=\"以下皆为例题\"><a href=\"#以下皆为例题\" class=\"headerlink\" title=\"以下皆为例题\"></a>以下皆为例题</h1><h2 id=\"1-求n-的结尾有多少个0\"><a href=\"#1-求n-的结尾有多少个0\" class=\"headerlink\" title=\"1.求n!的结尾有多少个0\"></a>1.求n!的结尾有多少个0</h2><p>最直白的思路就是把<code>n!</code>算出来，然后用<code>%10</code>再<code>/=10</code>的方法统计末尾的<code>0</code>,想法很简单，“实现”起来也不难，<strong>但不幸的是</strong>，<code>21!</code>就已经储存不了了，所以不能暴力求解</p>\n<p>所以要<strong>改变思路</strong>，先从末尾0是怎么来的下手。末尾的n个0来自因式分解后10的n次方，而采用质因数分解的方法，可以发现<code>0</code>来自分解后<code>2的n次方</code>和<code>5的n次方</code>,而一个数分解后<code>2的n次方</code>必定比<code>5的n次方</code> 多，所以只需统计<code>5的n次方</code>。<strong>注意</strong>：就别再倒回去，想着先算出阶乘再求<code>5的n次方</code>了。</p>\n<p><strong>这里采用逐步计数的方法</strong>：结果中的<code>5的n次方</code>来自各个因数中<code>5的N次方</code>的累乘,所以只需要历遍每个因数，并统计其中<code>因数5</code>的次数。这样过程中就不会有过大的数字了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">count_num0</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> copy = i<span class=\"comment\">//防止改变循环变量</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(copy%<span class=\"number\">5</span> == <span class=\"number\">0</span>)<span class=\"comment\">//统计因数5的出现次数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(copy%<span class=\"number\">5</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            copy/=<span class=\"number\">5</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"快速输出1-2-……-10-n\"><a href=\"#快速输出1-2-……-10-n\" class=\"headerlink\" title=\"快速输出1+2+……+10^n\"></a>快速输出1+2+……+10^n</h2><p><em>如下图</em>：当我们试图算一算答案时，发现<code>n</code>到了<code>10</code>时就已经算不出答案了</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/gao_si.png\" alt=\"计算结果\"></p>\n<p>所以要<strong>改变输出答案答案的方式</strong>,观察一下<code>n</code>在<code>1~9</code>时的输出</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_07-26-54.jpg\" alt=\"输出\"></p>\n<p>这时我们发现<strong>答案颇有规律</strong>：每个输出都是<strong>两段</strong><code>先一个5，然后n-1个0</code>！</p>\n<p>这样我们只需<strong>从最高位往最低位</strong>逐位打印即可,代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">printChar</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//版本一，逐位打印字符(串)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//再重复一段</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">printNum</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//版本二，逐位打印整型</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//再重复一段</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"=C语言实践= 手把手教你做高端cmd简单扫雷","date":"2023-10-29T23:28:01.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-27-25.jpg","_content":"# 直接开始吧！\n\n## 多文件项目 #\n扫雷项目内容较多，需要调用的**函数**也较多，采用多文件的方式，可以使代码**条理清晰**，并且**易于管理和维护**。文件如下\n\n`game.h`用于宏定义，函数声明，引入头文件等\n\n`game.c`用于**函数的具体实现**\n\n`front.c`用于实现程序的**主干部分**\n\n`other.c`用于实现其他杂项函数，这里我用于实现`menu()`函数，~~主要内容太花了~~\n\n**注**  `.c`结尾的源文件均需加一句`#include \"game.h\"`\n\n## 头文件 #\n本次用到的头文件有`stdio.h` `stdlib.h` `time.h` `windows.h`\n和自己建的`game.h`\n\n**均在**文件`game.h`中`#include`\n\n\n## define宏定义 #\n为了便于**阅读和维护**代码,在`game.h`中的宏定义如下\n\n```C\n//显示行列\n#define ROW 9\n#define COL 9\n\n//实际数组大小\n#define ROWS ROW+2\n#define COLS COL + 2\n\n//地雷信息\n#define Bomb '*'\n#define Blank ' '\n\n//难度\n#define EZ_RANK 10\n#define HD_RANK 15\n\n//显示区\n#define UN '\u001f'\n#define Flag '!'\n\n```\n\n### 为什么实际数组要大一圈？ #\n\n如图，采用九宫格式访问时，大出来的一圈能有效**防止越界访问**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_11-23-51.jpg)\n\n\n## 构建main函数 #\n内容不多，主要是与菜单配合食用\n```C\nint main()\n{\n    //用time()获取时间戳，传给srand设置(随机值生成器的)种子\n\tsrand((unsigned int)time(NULL));\n\twhile (1)//循环游玩\n\t{\n\t\tint input = 0;\n\t\tMenu();//打印菜单\n\t\tprintf(\"请输入:>\");\n\t\tscanf(\"%d\", &input);//获取指令\n\t\tswitch (input)\n\t\t{\n\t\tcase 1:\n\t\t\tSleep(250);\n\t\t\tgame();//开始游戏,游戏具体在game()函数中实现\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"游戏结束\\n\");\n\t\t\treturn 0;//结束程序\n\t\tdefault:\n\t\t\tprintf(\"输入错误,请重试\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n\n## 打印菜单 #\n还在做静态菜单?~~弱爆了！~~来试试**动态出现**的菜单！\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/menu.gif)\n\n原理很**简单**，就是`打印空白数组`->`向内逐个替换两侧元素`->`清屏`->`再打印`->`再替换`->`...`\n\n*接下来的代码写在`other.c`中*\n\n```C\n//动态打印菜单\nvoid Menu()\n{\n\tchar cover[]  =  \"=======================\";\n\tchar option1[] = \"======  play (1) ======\";\n\tchar option2[] = \"======  exit (2) ======\"; \n\tchar empty_c[] = \"                       \";\n\tchar empty_1[] = \"                       \";\n\tchar empty_2[] = \"                       \";\n\n\tint left = 0;\n\tint right = 22;\n\twhile (left < right)\n\t{\n        //内容替换\n\t\tempty_c[left] = cover[left];\n\t\tempty_c[right] = cover[right];\n\t\tempty_1[left] = option1[left];\n\t\tempty_1[right] = option1[right];\n\t\tempty_2[left] = option2[left];\n\t\tempty_2[right] = option2[right];\n\n\t\tSleep(50);\n\t\tsystem(\"cls\");//清屏\n\t\tprintf(\"%s\\n%s\\n%s\\n%s\\n\",empty_c,empty_1,empty_2,empty_c);//打印菜单\n\n\t\tleft++;\n\t\tright--;\n\n\t}\n\tif (left == right)//打印最终菜单\n\t{\n\t\tSleep(50);\n\t\tsystem(\"cls\");\n\t\tempty_c[left] = cover[left];\n\t\tempty_1[left] = option1[left];\n\t\tempty_2[left] = option2[left];\n\t\tprintf(\"%s\\n%s\\n%s\\n%s\\n\", empty_c, empty_1, empty_2, empty_c);\n\t}\n}\n```\n\n## 实现game()函数 #\n*游戏的主要逻辑在game()中实现*\n\n```C\nvoid game()\n{\n\tchar mine[ROWS][COLS] = { 0 };\n\tchar show[ROWS][COLS] = { 0 };\n\tchar check[ROWS][COLS] = { 0 };\n\n    //初始化棋盘，其实就是用第二个形参填充二维数组\n\tInitBoard(mine, Blank);\n\tInitBoard(show, UN);\n\n\tInitCheck(check);//初始化check数组，逻辑与上面的初始化不同\n\n\tSetMine(mine,EZ_RANK);//设置地雷\n\tSetNum(mine);//设置雷周围的数字\n\n\t//DisplayBoard(mine); //用于开发时检查棋盘布局\n\t//DisplayBoard(show); //同上，不使用时注释掉\n\n    //以上是前期准备\n\tOPMine(mine,show, check);//开始排雷\n\n\tprintf(\"敲击enter以继续\\n\");\n\tgetchar();\n\tgetchar();\n\n}\n```\n\n### 为什么用三个二维数组？ #\n扫雷需要实现的功能较多，显然一个二维数组是不足以满足需求的，所以这里采用**三个**数组相叠加的方式，各自实现功能，并整合到一起。\n\n数组`mine`用于存放`雷`和雷周围的`计数数字`\n\n数组`show`用于储存给`用户`看到的内容，可以是`Unkown`,`空白`，`数字`，`旗帜`\n\n数组`check`用于记录棋盘的哪些地块被检查过了，防止后面用**递归**打开成片的空白区时，出现无限递归。\n\n**规定**：检查过的坐标储存`字符1`,没检查过的坐标储存`字符0`,大出来的**一圈**默认储存`字符1`\n\n## 实现游戏用的函数 #\n### 先看看有哪些要声明在`game.h`里的 #\n```C\nvoid Menu();//这个在上文实现过了\n\n//一下函数将在下文实现\n\n//初始化棋盘\nvoid InitBoard(char board[ROWS][COLS], char sign);\n//展示棋盘\nvoid DisplayBoard(char board[ROWS][COLS]);\n//初始化check棋盘\nvoid InitCheck(char check[ROWS][COLS]);\n//设置地雷/数字\nvoid SetMine(char board[ROWS][COLS],int rank);\nvoid SetNum(char board[ROWS][COLS]);\n//玩家排雷用的函数\nvoid OPMine(char mine[ROWS][COLS],char show[ROWS][COLS],char check[ROWS][COLS]);\n\n```\n*好，有了目标，接下来就去一个一个实现*\n\n**注**：以下代码均写在`game.c`文件里\n\n### InitBoard() #\n```C\nvoid InitBoard(char board[ROWS][COLS],char sign)\n{\n\tfor (int i = 0; i < ROWS; i++)\n\t{\n\t\tfor (int j = 0; j < COLS; j++)\n\t\t{\n\t\t\tboard[i][j] = sign;\n\t\t}\n\t}\n}\n```\n这里初始化的方式比较简单粗暴，就是用形参`sign`填充整个二维数组\n\n### DisplayBoard()函数 #\n这里采用的展示方式是带横纵坐标的\n```C\nvoid DisplayBoard(char board[ROWS][COLS])\n{\n\t//打印一排列坐标\n\tfor (int k = 0; k <= COL; k++)\n\t{\n\t\tprintf(\"%d \", k);\n\t}\n\tprintf(\"\\n\");\n\t//打印一排横分割线\n\tfor (int k = 0; k <= COL; k++)\n\t{\n\t\tprintf(\"--\");\n\t}\n\tprintf(\"\\n\");\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tprintf(\"%d|\", i);//这句话打印横排坐标和竖分割线\n\t\t//打印一排棋盘内容\n\t\tfor (int j = 1; j <= COL; j++)\n\t\t{\n\t\t\tprintf(\"%c \", board[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n```\n### InitCheck()函数 #\n这里复用了`InitBoard()`函数，是在其基础上增加了内容\n\n```C\nvoid InitCheck(char check[ROWS][COLS])\n{\n\tInitBoard(check, '0');\n\n\t//将边缘大出来的一圈改为'1'\n\tfor (int k = 0; k < COLS; k++)\n\t{\n\t\tcheck[0][k] = '1';\n\t\tcheck[ROWS - 1][k] = '1';\n\t}\n\tfor (int i = 1; i < ROWS -1; i++)\n\t{\n\t\tcheck[i][0] = '1';\n\t\tcheck[i][COLS - 1] = '1';\n\t}\n}\n\n```\n\n### SetMine()函数 #\n这里要使用`rand()`函数搭配`%`运算，来随机生成雷的坐标\n\n```C\nvoid SetMine(char board[ROWS][COLS],int rank)\n{\n\tint x = 0;\n\tint y = 0;\n\tfor (int count = 0;count < rank;)\n\t{\n\t\tx = rand() % ROW + 1;//x的范围是1~ROW\n\t\ty = rand() % COL + 1;\n\n\t\tif (board[x][y] == Blank)\n\t\t{\n\t\t\tcount++;\n\t\t\tboard[x][y] = Bomb;\n\t\t}\n\t}\n}\n\n```\n\n### SetNum()函数 #\n这里遍历一遍数组并采用`九宫格式`计数\n```C\n//该函数用于九宫格式计数，并在下个函数中被调用\nint CountMine(char board[ROWS][COLS], int x, int y)\n{\n\tint sum = 0;\n\tfor (int i = x - 1; i <= x + 1; i++)//上中下三行\n\t{\n\t\tfor (int j = y - 1; j <= y + 1; j++)//左中右三列\n\t\t{\n\t\t\tif (i != x || j != y)\n\t\t\t{\n\t\t\t\tif (board[i][j] == Bomb)\n\t\t\t\t{\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nvoid SetNum(char board[ROWS][COLS])\n{\n\t//遍历二维数组\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tfor (int j = 0; j <= COLS; j++)\n\t\t{\n\t\t\tif (board[i][j] == Blank)//仅操作非雷的格子\n\t\t\t{\n\t\t\t\tif (CountMine(board, i, j))\n\t\t\t\t{\n\t\t\t\t\tboard[i][j] = '0' + CountMine(board, i, j);//将返回的数字转化成字符\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### OPMine()函数--核心函数 #\n该函数为游戏的`核心函数`，有内置菜单，且多次调用其它函数，其中`函数`的具体实现见`四级标题`处\n\n```C\nvoid OPMine(char mine[ROWS][COLS],char show[ROWS][COLS],char check[ROWS][COLS])\n{\n\tint x = 0;//横纵坐标\n\tint y = 0;\n\tint flag = 1;//用于菜单选项\n\tint cont = 1;//cont为0时游戏结束\n\twhile (cont)\n\t{\n\t\tsystem(\"cls\");\n\t\tDisplayBoard(show);\n\t\tprintf(\"排雷(1)\\n插旗/拔旗(2)\\n请输入:>\");\n\t\tscanf(\"%d\", &flag);\n\t\t\n\t\tswitch (flag)\n\t\t{\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\t//排雷\n\t\t\t\tprintf(\"坐标格式,例>2(空格)2\\n\");\n\t\t\t\tprintf(\"请输入坐标:>\");\n\t\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\tif (show[x][y] == Flag)\n\t\t\t\t{\n\n\t\t\t\t\tprintf(\"此处为旗帜，不可排雷\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (show[x][y] != UN)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"不可重复排查\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//具体排雷操作\n\t\t\t\tcont = FindMine(mine,show,check, x, y);\n\t\t\t\tif (cont)\n\t\t\t\t{\n\t\t\t\t\t//检查是否赢得游戏\n\t\t\t\t\tcont = CheckWin(mine,show);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\t//插旗\n\t\t\t\tprintf(\"坐标格式,例>2(空格)2\\n\");\n\t\t\t\tprintf(\"请输入坐标:>\");\n\t\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\tSetFlag(show, x, y);//插旗函数\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n输入错误(恼\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n#### SetFlag()函数 #\n先捏软柿子，插旗函数比较简单\n\n```C\nvoid SetFlag(char show[ROWS][COLS], int x, int y)\n{\n\tif (show[x][y] == UN)//插旗\n\t{\n\t\tshow[x][y] = Flag;\n\t}\n\telse if (show[x][y] == Flag)//拔旗\n\t{\n\t\tshow[x][y] = UN;\n\t}\n\telse\n\t{\n\t\tprintf(\"报错\\n\");\n\t}\n}\n\n```\n#### ExpandBlank()函数 #\n这个函数用于打开成片的`空白区`,因为要从连着的空白连续开下去，所以要用到`函数递归`,此时`二维数组check`用于防止死递归\n\n**注**：这个函数一定要写在下一个函数(FindMine)前\n\n```C\nvoid ExpandBlank(char mine[ROWS][COLS], char show[ROWS][COLS], char check[ROWS][COLS],int x,int y)\n{\n\tshow[x][y] = mine[x][y];//将用户看到的格子改成mine中的格子,包括空白和数字格子\n\tcheck[x][y] = '1';//探测过的格子放`1`\n\tif (mine[x][y] == Blank)//仅空白格子会触发递归，数字格子不会\n\t{\n\t\t//九宫格式探测\n\t\tfor (int i = x - 1; i <= x + 1; i++)\n\t\t{\n\t\t\tfor (int j = y - 1; j <= y + 1; j++)\n\t\t\t{\n\t\t\t\tif (check[i][j] == '0' && mine[i][j] != Bomb && show[i][j] != Flag)\n\t\t\t\t{\n\t\t\t\t\t//含雷的格子不会执行ExpandBlank函数，就不会把雷放出来给用户看，但数字格子会\n\t\t\t\t\tExpandBlank(mine, show, check, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n#### FindMine()函数 #\n排雷用的函数\n\n```C\nint FindMine(char mine[ROWS][COLS], char show[ROW][COLS],char check[ROWS][COLS], int x, int y)\n{\n\tif (mine[x][y] == Bomb)\n\t{\n\t\tDisplayBoard(mine);\n\t\tprintf(\"炸死，游戏结束:)\\n\");\n\t\treturn 0;//返回0来结束游戏\n\t}\n\telse if (mine[x][y] != Blank)\n\t{\n\t\tshow[x][y] = mine[x][y];\n\t\treturn 1;//返回1来继续游戏\n\t}\n\telse\n\t{\n\t\t//这里有对上一个函数的调用\n\t\tExpandBlank(mine, show, check,x,y);\n\t\treturn 1;\n\t}\n}\n```\n#### CheckWin()函数 #\n用于检查玩家是否完全排雷，赢得游戏\n\n```C\nint CheckWin(char mine[ROWS][COLS], char show[ROWS][COLS])\n{\n\tint count = 0;//统计没排雷的格子数\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tfor (int j = 1; j <= COL; j++)\n\t\t{\n\t\t\tif (show[i][j] == UN || show[i][j] == Flag)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tif (count == EZ_RANK)//统计数==雷数\n\t{\n\t\tprintf(\"恭喜排雷成功!\\n\");\n\t\tDisplayBoard(mine);\n\t\treturn 0;//返回0，停止游戏\n\t}\n\telse\n\t{\n\t\treturn 1;\n\t}\n}\n```\n\n# 总结 #\n至此游戏所需的代码全部完成，已经可以编译出来玩耍啦。\n\n该实践项目主要练习了`二维数组`,`函数`,`函数递归`,`宏定义`等内容，代码量在入门学习中算较大的，本人在初次编写的时候也写出了不少bug，debug的过程是相当~~快乐~~\n\n建议多多画示意图，**耐下性子**写代码和debug,哪怕是实现这样的小游戏项目，也是颇有意义的","source":"_posts/mine-clearance.md","raw":"---\ntitle: =C语言实践= 手把手教你做高端cmd简单扫雷\ndate: 2023-10-30 07:28:01\ntags:\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-27-25.jpg\n---\n# 直接开始吧！\n\n## 多文件项目 #\n扫雷项目内容较多，需要调用的**函数**也较多，采用多文件的方式，可以使代码**条理清晰**，并且**易于管理和维护**。文件如下\n\n`game.h`用于宏定义，函数声明，引入头文件等\n\n`game.c`用于**函数的具体实现**\n\n`front.c`用于实现程序的**主干部分**\n\n`other.c`用于实现其他杂项函数，这里我用于实现`menu()`函数，~~主要内容太花了~~\n\n**注**  `.c`结尾的源文件均需加一句`#include \"game.h\"`\n\n## 头文件 #\n本次用到的头文件有`stdio.h` `stdlib.h` `time.h` `windows.h`\n和自己建的`game.h`\n\n**均在**文件`game.h`中`#include`\n\n\n## define宏定义 #\n为了便于**阅读和维护**代码,在`game.h`中的宏定义如下\n\n```C\n//显示行列\n#define ROW 9\n#define COL 9\n\n//实际数组大小\n#define ROWS ROW+2\n#define COLS COL + 2\n\n//地雷信息\n#define Bomb '*'\n#define Blank ' '\n\n//难度\n#define EZ_RANK 10\n#define HD_RANK 15\n\n//显示区\n#define UN '\u001f'\n#define Flag '!'\n\n```\n\n### 为什么实际数组要大一圈？ #\n\n如图，采用九宫格式访问时，大出来的一圈能有效**防止越界访问**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_11-23-51.jpg)\n\n\n## 构建main函数 #\n内容不多，主要是与菜单配合食用\n```C\nint main()\n{\n    //用time()获取时间戳，传给srand设置(随机值生成器的)种子\n\tsrand((unsigned int)time(NULL));\n\twhile (1)//循环游玩\n\t{\n\t\tint input = 0;\n\t\tMenu();//打印菜单\n\t\tprintf(\"请输入:>\");\n\t\tscanf(\"%d\", &input);//获取指令\n\t\tswitch (input)\n\t\t{\n\t\tcase 1:\n\t\t\tSleep(250);\n\t\t\tgame();//开始游戏,游戏具体在game()函数中实现\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"游戏结束\\n\");\n\t\t\treturn 0;//结束程序\n\t\tdefault:\n\t\t\tprintf(\"输入错误,请重试\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n\n## 打印菜单 #\n还在做静态菜单?~~弱爆了！~~来试试**动态出现**的菜单！\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/menu.gif)\n\n原理很**简单**，就是`打印空白数组`->`向内逐个替换两侧元素`->`清屏`->`再打印`->`再替换`->`...`\n\n*接下来的代码写在`other.c`中*\n\n```C\n//动态打印菜单\nvoid Menu()\n{\n\tchar cover[]  =  \"=======================\";\n\tchar option1[] = \"======  play (1) ======\";\n\tchar option2[] = \"======  exit (2) ======\"; \n\tchar empty_c[] = \"                       \";\n\tchar empty_1[] = \"                       \";\n\tchar empty_2[] = \"                       \";\n\n\tint left = 0;\n\tint right = 22;\n\twhile (left < right)\n\t{\n        //内容替换\n\t\tempty_c[left] = cover[left];\n\t\tempty_c[right] = cover[right];\n\t\tempty_1[left] = option1[left];\n\t\tempty_1[right] = option1[right];\n\t\tempty_2[left] = option2[left];\n\t\tempty_2[right] = option2[right];\n\n\t\tSleep(50);\n\t\tsystem(\"cls\");//清屏\n\t\tprintf(\"%s\\n%s\\n%s\\n%s\\n\",empty_c,empty_1,empty_2,empty_c);//打印菜单\n\n\t\tleft++;\n\t\tright--;\n\n\t}\n\tif (left == right)//打印最终菜单\n\t{\n\t\tSleep(50);\n\t\tsystem(\"cls\");\n\t\tempty_c[left] = cover[left];\n\t\tempty_1[left] = option1[left];\n\t\tempty_2[left] = option2[left];\n\t\tprintf(\"%s\\n%s\\n%s\\n%s\\n\", empty_c, empty_1, empty_2, empty_c);\n\t}\n}\n```\n\n## 实现game()函数 #\n*游戏的主要逻辑在game()中实现*\n\n```C\nvoid game()\n{\n\tchar mine[ROWS][COLS] = { 0 };\n\tchar show[ROWS][COLS] = { 0 };\n\tchar check[ROWS][COLS] = { 0 };\n\n    //初始化棋盘，其实就是用第二个形参填充二维数组\n\tInitBoard(mine, Blank);\n\tInitBoard(show, UN);\n\n\tInitCheck(check);//初始化check数组，逻辑与上面的初始化不同\n\n\tSetMine(mine,EZ_RANK);//设置地雷\n\tSetNum(mine);//设置雷周围的数字\n\n\t//DisplayBoard(mine); //用于开发时检查棋盘布局\n\t//DisplayBoard(show); //同上，不使用时注释掉\n\n    //以上是前期准备\n\tOPMine(mine,show, check);//开始排雷\n\n\tprintf(\"敲击enter以继续\\n\");\n\tgetchar();\n\tgetchar();\n\n}\n```\n\n### 为什么用三个二维数组？ #\n扫雷需要实现的功能较多，显然一个二维数组是不足以满足需求的，所以这里采用**三个**数组相叠加的方式，各自实现功能，并整合到一起。\n\n数组`mine`用于存放`雷`和雷周围的`计数数字`\n\n数组`show`用于储存给`用户`看到的内容，可以是`Unkown`,`空白`，`数字`，`旗帜`\n\n数组`check`用于记录棋盘的哪些地块被检查过了，防止后面用**递归**打开成片的空白区时，出现无限递归。\n\n**规定**：检查过的坐标储存`字符1`,没检查过的坐标储存`字符0`,大出来的**一圈**默认储存`字符1`\n\n## 实现游戏用的函数 #\n### 先看看有哪些要声明在`game.h`里的 #\n```C\nvoid Menu();//这个在上文实现过了\n\n//一下函数将在下文实现\n\n//初始化棋盘\nvoid InitBoard(char board[ROWS][COLS], char sign);\n//展示棋盘\nvoid DisplayBoard(char board[ROWS][COLS]);\n//初始化check棋盘\nvoid InitCheck(char check[ROWS][COLS]);\n//设置地雷/数字\nvoid SetMine(char board[ROWS][COLS],int rank);\nvoid SetNum(char board[ROWS][COLS]);\n//玩家排雷用的函数\nvoid OPMine(char mine[ROWS][COLS],char show[ROWS][COLS],char check[ROWS][COLS]);\n\n```\n*好，有了目标，接下来就去一个一个实现*\n\n**注**：以下代码均写在`game.c`文件里\n\n### InitBoard() #\n```C\nvoid InitBoard(char board[ROWS][COLS],char sign)\n{\n\tfor (int i = 0; i < ROWS; i++)\n\t{\n\t\tfor (int j = 0; j < COLS; j++)\n\t\t{\n\t\t\tboard[i][j] = sign;\n\t\t}\n\t}\n}\n```\n这里初始化的方式比较简单粗暴，就是用形参`sign`填充整个二维数组\n\n### DisplayBoard()函数 #\n这里采用的展示方式是带横纵坐标的\n```C\nvoid DisplayBoard(char board[ROWS][COLS])\n{\n\t//打印一排列坐标\n\tfor (int k = 0; k <= COL; k++)\n\t{\n\t\tprintf(\"%d \", k);\n\t}\n\tprintf(\"\\n\");\n\t//打印一排横分割线\n\tfor (int k = 0; k <= COL; k++)\n\t{\n\t\tprintf(\"--\");\n\t}\n\tprintf(\"\\n\");\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tprintf(\"%d|\", i);//这句话打印横排坐标和竖分割线\n\t\t//打印一排棋盘内容\n\t\tfor (int j = 1; j <= COL; j++)\n\t\t{\n\t\t\tprintf(\"%c \", board[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n```\n### InitCheck()函数 #\n这里复用了`InitBoard()`函数，是在其基础上增加了内容\n\n```C\nvoid InitCheck(char check[ROWS][COLS])\n{\n\tInitBoard(check, '0');\n\n\t//将边缘大出来的一圈改为'1'\n\tfor (int k = 0; k < COLS; k++)\n\t{\n\t\tcheck[0][k] = '1';\n\t\tcheck[ROWS - 1][k] = '1';\n\t}\n\tfor (int i = 1; i < ROWS -1; i++)\n\t{\n\t\tcheck[i][0] = '1';\n\t\tcheck[i][COLS - 1] = '1';\n\t}\n}\n\n```\n\n### SetMine()函数 #\n这里要使用`rand()`函数搭配`%`运算，来随机生成雷的坐标\n\n```C\nvoid SetMine(char board[ROWS][COLS],int rank)\n{\n\tint x = 0;\n\tint y = 0;\n\tfor (int count = 0;count < rank;)\n\t{\n\t\tx = rand() % ROW + 1;//x的范围是1~ROW\n\t\ty = rand() % COL + 1;\n\n\t\tif (board[x][y] == Blank)\n\t\t{\n\t\t\tcount++;\n\t\t\tboard[x][y] = Bomb;\n\t\t}\n\t}\n}\n\n```\n\n### SetNum()函数 #\n这里遍历一遍数组并采用`九宫格式`计数\n```C\n//该函数用于九宫格式计数，并在下个函数中被调用\nint CountMine(char board[ROWS][COLS], int x, int y)\n{\n\tint sum = 0;\n\tfor (int i = x - 1; i <= x + 1; i++)//上中下三行\n\t{\n\t\tfor (int j = y - 1; j <= y + 1; j++)//左中右三列\n\t\t{\n\t\t\tif (i != x || j != y)\n\t\t\t{\n\t\t\t\tif (board[i][j] == Bomb)\n\t\t\t\t{\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nvoid SetNum(char board[ROWS][COLS])\n{\n\t//遍历二维数组\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tfor (int j = 0; j <= COLS; j++)\n\t\t{\n\t\t\tif (board[i][j] == Blank)//仅操作非雷的格子\n\t\t\t{\n\t\t\t\tif (CountMine(board, i, j))\n\t\t\t\t{\n\t\t\t\t\tboard[i][j] = '0' + CountMine(board, i, j);//将返回的数字转化成字符\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### OPMine()函数--核心函数 #\n该函数为游戏的`核心函数`，有内置菜单，且多次调用其它函数，其中`函数`的具体实现见`四级标题`处\n\n```C\nvoid OPMine(char mine[ROWS][COLS],char show[ROWS][COLS],char check[ROWS][COLS])\n{\n\tint x = 0;//横纵坐标\n\tint y = 0;\n\tint flag = 1;//用于菜单选项\n\tint cont = 1;//cont为0时游戏结束\n\twhile (cont)\n\t{\n\t\tsystem(\"cls\");\n\t\tDisplayBoard(show);\n\t\tprintf(\"排雷(1)\\n插旗/拔旗(2)\\n请输入:>\");\n\t\tscanf(\"%d\", &flag);\n\t\t\n\t\tswitch (flag)\n\t\t{\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\t//排雷\n\t\t\t\tprintf(\"坐标格式,例>2(空格)2\\n\");\n\t\t\t\tprintf(\"请输入坐标:>\");\n\t\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\tif (show[x][y] == Flag)\n\t\t\t\t{\n\n\t\t\t\t\tprintf(\"此处为旗帜，不可排雷\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (show[x][y] != UN)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"不可重复排查\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//具体排雷操作\n\t\t\t\tcont = FindMine(mine,show,check, x, y);\n\t\t\t\tif (cont)\n\t\t\t\t{\n\t\t\t\t\t//检查是否赢得游戏\n\t\t\t\t\tcont = CheckWin(mine,show);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\t//插旗\n\t\t\t\tprintf(\"坐标格式,例>2(空格)2\\n\");\n\t\t\t\tprintf(\"请输入坐标:>\");\n\t\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\tSetFlag(show, x, y);//插旗函数\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n输入错误(恼\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n#### SetFlag()函数 #\n先捏软柿子，插旗函数比较简单\n\n```C\nvoid SetFlag(char show[ROWS][COLS], int x, int y)\n{\n\tif (show[x][y] == UN)//插旗\n\t{\n\t\tshow[x][y] = Flag;\n\t}\n\telse if (show[x][y] == Flag)//拔旗\n\t{\n\t\tshow[x][y] = UN;\n\t}\n\telse\n\t{\n\t\tprintf(\"报错\\n\");\n\t}\n}\n\n```\n#### ExpandBlank()函数 #\n这个函数用于打开成片的`空白区`,因为要从连着的空白连续开下去，所以要用到`函数递归`,此时`二维数组check`用于防止死递归\n\n**注**：这个函数一定要写在下一个函数(FindMine)前\n\n```C\nvoid ExpandBlank(char mine[ROWS][COLS], char show[ROWS][COLS], char check[ROWS][COLS],int x,int y)\n{\n\tshow[x][y] = mine[x][y];//将用户看到的格子改成mine中的格子,包括空白和数字格子\n\tcheck[x][y] = '1';//探测过的格子放`1`\n\tif (mine[x][y] == Blank)//仅空白格子会触发递归，数字格子不会\n\t{\n\t\t//九宫格式探测\n\t\tfor (int i = x - 1; i <= x + 1; i++)\n\t\t{\n\t\t\tfor (int j = y - 1; j <= y + 1; j++)\n\t\t\t{\n\t\t\t\tif (check[i][j] == '0' && mine[i][j] != Bomb && show[i][j] != Flag)\n\t\t\t\t{\n\t\t\t\t\t//含雷的格子不会执行ExpandBlank函数，就不会把雷放出来给用户看，但数字格子会\n\t\t\t\t\tExpandBlank(mine, show, check, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n#### FindMine()函数 #\n排雷用的函数\n\n```C\nint FindMine(char mine[ROWS][COLS], char show[ROW][COLS],char check[ROWS][COLS], int x, int y)\n{\n\tif (mine[x][y] == Bomb)\n\t{\n\t\tDisplayBoard(mine);\n\t\tprintf(\"炸死，游戏结束:)\\n\");\n\t\treturn 0;//返回0来结束游戏\n\t}\n\telse if (mine[x][y] != Blank)\n\t{\n\t\tshow[x][y] = mine[x][y];\n\t\treturn 1;//返回1来继续游戏\n\t}\n\telse\n\t{\n\t\t//这里有对上一个函数的调用\n\t\tExpandBlank(mine, show, check,x,y);\n\t\treturn 1;\n\t}\n}\n```\n#### CheckWin()函数 #\n用于检查玩家是否完全排雷，赢得游戏\n\n```C\nint CheckWin(char mine[ROWS][COLS], char show[ROWS][COLS])\n{\n\tint count = 0;//统计没排雷的格子数\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tfor (int j = 1; j <= COL; j++)\n\t\t{\n\t\t\tif (show[i][j] == UN || show[i][j] == Flag)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tif (count == EZ_RANK)//统计数==雷数\n\t{\n\t\tprintf(\"恭喜排雷成功!\\n\");\n\t\tDisplayBoard(mine);\n\t\treturn 0;//返回0，停止游戏\n\t}\n\telse\n\t{\n\t\treturn 1;\n\t}\n}\n```\n\n# 总结 #\n至此游戏所需的代码全部完成，已经可以编译出来玩耍啦。\n\n该实践项目主要练习了`二维数组`,`函数`,`函数递归`,`宏定义`等内容，代码量在入门学习中算较大的，本人在初次编写的时候也写出了不少bug，debug的过程是相当~~快乐~~\n\n建议多多画示意图，**耐下性子**写代码和debug,哪怕是实现这样的小游戏项目，也是颇有意义的","slug":"mine-clearance","published":1,"updated":"2023-11-06T03:19:27.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloutk93q0005kkg61vd053u4","content":"<h1 id=\"直接开始吧！\"><a href=\"#直接开始吧！\" class=\"headerlink\" title=\"直接开始吧！\"></a>直接开始吧！</h1><h2 id=\"多文件项目\"><a href=\"#多文件项目\" class=\"headerlink\" title=\"多文件项目\"></a>多文件项目</h2><p>扫雷项目内容较多，需要调用的<strong>函数</strong>也较多，采用多文件的方式，可以使代码<strong>条理清晰</strong>，并且<strong>易于管理和维护</strong>。文件如下</p>\n<p><code>game.h</code>用于宏定义，函数声明，引入头文件等</p>\n<p><code>game.c</code>用于<strong>函数的具体实现</strong></p>\n<p><code>front.c</code>用于实现程序的<strong>主干部分</strong></p>\n<p><code>other.c</code>用于实现其他杂项函数，这里我用于实现<code>menu()</code>函数，<del>主要内容太花了</del></p>\n<p><strong>注</strong>  <code>.c</code>结尾的源文件均需加一句<code>#include &quot;game.h&quot;</code></p>\n<h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><p>本次用到的头文件有<code>stdio.h</code> <code>stdlib.h</code> <code>time.h</code> <code>windows.h</code><br>和自己建的<code>game.h</code></p>\n<p><strong>均在</strong>文件<code>game.h</code>中<code>#include</code></p>\n<h2 id=\"define宏定义\"><a href=\"#define宏定义\" class=\"headerlink\" title=\"define宏定义\"></a>define宏定义</h2><p>为了便于<strong>阅读和维护</strong>代码,在<code>game.h</code>中的宏定义如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//显示行列</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ROW 9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COL 9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实际数组大小</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ROWS ROW+2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COLS COL + 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//地雷信息</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Bomb <span class=\"string\">&#x27;*&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Blank <span class=\"string\">&#x27; &#x27;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//难度</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EZ_RANK 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HD_RANK 15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示区</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UN <span class=\"string\">&#x27;\u001f&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Flag <span class=\"string\">&#x27;!&#x27;</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么实际数组要大一圈？\"><a href=\"#为什么实际数组要大一圈？\" class=\"headerlink\" title=\"为什么实际数组要大一圈？\"></a>为什么实际数组要大一圈？</h3><p>如图，采用九宫格式访问时，大出来的一圈能有效<strong>防止越界访问</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_11-23-51.jpg\"></p>\n<h2 id=\"构建main函数\"><a href=\"#构建main函数\" class=\"headerlink\" title=\"构建main函数\"></a>构建main函数</h2><p>内容不多，主要是与菜单配合食用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//用time()获取时间戳，传给srand设置(随机值生成器的)种子</span></span><br><span class=\"line\">\tsrand((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)<span class=\"comment\">//循环游玩</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> input = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tMenu();<span class=\"comment\">//打印菜单</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;input);<span class=\"comment\">//获取指令</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (input)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\tSleep(<span class=\"number\">250</span>);</span><br><span class=\"line\">\t\t\tgame();<span class=\"comment\">//开始游戏,游戏具体在game()函数中实现</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;游戏结束\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//结束程序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;输入错误,请重试\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"打印菜单\"><a href=\"#打印菜单\" class=\"headerlink\" title=\"打印菜单\"></a>打印菜单</h2><p>还在做静态菜单?<del>弱爆了！</del>来试试<strong>动态出现</strong>的菜单！</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/menu.gif\"></p>\n<p>原理很<strong>简单</strong>，就是<code>打印空白数组</code>-&gt;<code>向内逐个替换两侧元素</code>-&gt;<code>清屏</code>-&gt;<code>再打印</code>-&gt;<code>再替换</code>-&gt;<code>...</code></p>\n<p><em>接下来的代码写在<code>other.c</code>中</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态打印菜单</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Menu</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> cover[]  =  <span class=\"string\">&quot;=======================&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> option1[] = <span class=\"string\">&quot;======  play (1) ======&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> option2[] = <span class=\"string\">&quot;======  exit (2) ======&quot;</span>; </span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_c[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_1[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_2[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> right = <span class=\"number\">22</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"comment\">//内容替换</span></span><br><span class=\"line\">\t\tempty_c[left] = cover[left];</span><br><span class=\"line\">\t\tempty_c[right] = cover[right];</span><br><span class=\"line\">\t\tempty_1[left] = option1[left];</span><br><span class=\"line\">\t\tempty_1[right] = option1[right];</span><br><span class=\"line\">\t\tempty_2[left] = option2[left];</span><br><span class=\"line\">\t\tempty_2[right] = option2[right];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);<span class=\"comment\">//清屏</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n%s\\n%s\\n%s\\n&quot;</span>,empty_c,empty_1,empty_2,empty_c);<span class=\"comment\">//打印菜单</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tleft++;</span><br><span class=\"line\">\t\tright--;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left == right)<span class=\"comment\">//打印最终菜单</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\tempty_c[left] = cover[left];</span><br><span class=\"line\">\t\tempty_1[left] = option1[left];</span><br><span class=\"line\">\t\tempty_2[left] = option2[left];</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n%s\\n%s\\n%s\\n&quot;</span>, empty_c, empty_1, empty_2, empty_c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现game-函数\"><a href=\"#实现game-函数\" class=\"headerlink\" title=\"实现game()函数\"></a>实现game()函数</h2><p><em>游戏的主要逻辑在game()中实现</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">game</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> mine[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">char</span> show[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">char</span> check[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化棋盘，其实就是用第二个形参填充二维数组</span></span><br><span class=\"line\">\tInitBoard(mine, Blank);</span><br><span class=\"line\">\tInitBoard(show, UN);</span><br><span class=\"line\"></span><br><span class=\"line\">\tInitCheck(check);<span class=\"comment\">//初始化check数组，逻辑与上面的初始化不同</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tSetMine(mine,EZ_RANK);<span class=\"comment\">//设置地雷</span></span><br><span class=\"line\">\tSetNum(mine);<span class=\"comment\">//设置雷周围的数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//DisplayBoard(mine); //用于开发时检查棋盘布局</span></span><br><span class=\"line\">\t<span class=\"comment\">//DisplayBoard(show); //同上，不使用时注释掉</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//以上是前期准备</span></span><br><span class=\"line\">\tOPMine(mine,show, check);<span class=\"comment\">//开始排雷</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;敲击enter以继续\\n&quot;</span>);</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么用三个二维数组？\"><a href=\"#为什么用三个二维数组？\" class=\"headerlink\" title=\"为什么用三个二维数组？\"></a>为什么用三个二维数组？</h3><p>扫雷需要实现的功能较多，显然一个二维数组是不足以满足需求的，所以这里采用<strong>三个</strong>数组相叠加的方式，各自实现功能，并整合到一起。</p>\n<p>数组<code>mine</code>用于存放<code>雷</code>和雷周围的<code>计数数字</code></p>\n<p>数组<code>show</code>用于储存给<code>用户</code>看到的内容，可以是<code>Unkown</code>,<code>空白</code>，<code>数字</code>，<code>旗帜</code></p>\n<p>数组<code>check</code>用于记录棋盘的哪些地块被检查过了，防止后面用<strong>递归</strong>打开成片的空白区时，出现无限递归。</p>\n<p><strong>规定</strong>：检查过的坐标储存<code>字符1</code>,没检查过的坐标储存<code>字符0</code>,大出来的<strong>一圈</strong>默认储存<code>字符1</code></p>\n<h2 id=\"实现游戏用的函数\"><a href=\"#实现游戏用的函数\" class=\"headerlink\" title=\"实现游戏用的函数\"></a>实现游戏用的函数</h2><h3 id=\"先看看有哪些要声明在game-h里的\"><a href=\"#先看看有哪些要声明在game-h里的\" class=\"headerlink\" title=\"先看看有哪些要声明在game.h里的\"></a>先看看有哪些要声明在<code>game.h</code>里的</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Menu</span><span class=\"params\">()</span>;<span class=\"comment\">//这个在上文实现过了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一下函数将在下文实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS], <span class=\"type\">char</span> sign)</span>;</span><br><span class=\"line\"><span class=\"comment\">//展示棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DisplayBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//初始化check棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitCheck</span><span class=\"params\">(<span class=\"type\">char</span> check[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//设置地雷/数字</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">int</span> rank)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetNum</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//玩家排雷用的函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">OPMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS],<span class=\"type\">char</span> show[ROWS][COLS],<span class=\"type\">char</span> check[ROWS][COLS])</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em>好，有了目标，接下来就去一个一个实现</em></p>\n<p><strong>注</strong>：以下代码均写在<code>game.c</code>文件里</p>\n<h3 id=\"InitBoard\"><a href=\"#InitBoard\" class=\"headerlink\" title=\"InitBoard()\"></a>InitBoard()</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">char</span> sign)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; ROWS; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; COLS; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tboard[i][j] = sign;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里初始化的方式比较简单粗暴，就是用形参<code>sign</code>填充整个二维数组</p>\n<h3 id=\"DisplayBoard-函数\"><a href=\"#DisplayBoard-函数\" class=\"headerlink\" title=\"DisplayBoard()函数\"></a>DisplayBoard()函数</h3><p>这里采用的展示方式是带横纵坐标的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DisplayBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//打印一排列坐标</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= COL; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, k);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//打印一排横分割线</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= COL; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;--&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d|&quot;</span>, i);<span class=\"comment\">//这句话打印横排坐标和竖分割线</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//打印一排棋盘内容</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= COL; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c &quot;</span>, board[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"InitCheck-函数\"><a href=\"#InitCheck-函数\" class=\"headerlink\" title=\"InitCheck()函数\"></a>InitCheck()函数</h3><p>这里复用了<code>InitBoard()</code>函数，是在其基础上增加了内容</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitCheck</span><span class=\"params\">(<span class=\"type\">char</span> check[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tInitBoard(check, <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将边缘大出来的一圈改为&#x27;1&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; COLS; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcheck[<span class=\"number\">0</span>][k] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t\tcheck[ROWS - <span class=\"number\">1</span>][k] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; ROWS <span class=\"number\">-1</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcheck[i][<span class=\"number\">0</span>] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t\tcheck[i][COLS - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SetMine-函数\"><a href=\"#SetMine-函数\" class=\"headerlink\" title=\"SetMine()函数\"></a>SetMine()函数</h3><p>这里要使用<code>rand()</code>函数搭配<code>%</code>运算，来随机生成雷的坐标</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">int</span> rank)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> count = <span class=\"number\">0</span>;count &lt; rank;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx = rand() % ROW + <span class=\"number\">1</span>;<span class=\"comment\">//x的范围是1~ROW</span></span><br><span class=\"line\">\t\ty = rand() % COL + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (board[x][y] == Blank)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcount++;</span><br><span class=\"line\">\t\t\tboard[x][y] = Bomb;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SetNum-函数\"><a href=\"#SetNum-函数\" class=\"headerlink\" title=\"SetNum()函数\"></a>SetNum()函数</h3><p>这里遍历一遍数组并采用<code>九宫格式</code>计数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//该函数用于九宫格式计数，并在下个函数中被调用</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">CountMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = x - <span class=\"number\">1</span>; i &lt;= x + <span class=\"number\">1</span>; i++)<span class=\"comment\">//上中下三行</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = y - <span class=\"number\">1</span>; j &lt;= y + <span class=\"number\">1</span>; j++)<span class=\"comment\">//左中右三列</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i != x || j != y)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (board[i][j] == Bomb)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tsum++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetNum</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//遍历二维数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= COLS; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (board[i][j] == Blank)<span class=\"comment\">//仅操作非雷的格子</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (CountMine(board, i, j))</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tboard[i][j] = <span class=\"string\">&#x27;0&#x27;</span> + CountMine(board, i, j);<span class=\"comment\">//将返回的数字转化成字符</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"OPMine-函数–核心函数\"><a href=\"#OPMine-函数–核心函数\" class=\"headerlink\" title=\"OPMine()函数–核心函数\"></a>OPMine()函数–核心函数</h3><p>该函数为游戏的<code>核心函数</code>，有内置菜单，且多次调用其它函数，其中<code>函数</code>的具体实现见<code>四级标题</code>处</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">OPMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS],<span class=\"type\">char</span> show[ROWS][COLS],<span class=\"type\">char</span> check[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>;<span class=\"comment\">//横纵坐标</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">1</span>;<span class=\"comment\">//用于菜单选项</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> cont = <span class=\"number\">1</span>;<span class=\"comment\">//cont为0时游戏结束</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cont)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\tDisplayBoard(show);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;排雷(1)\\n插旗/拔旗(2)\\n请输入:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;flag);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (flag)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//排雷</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;坐标格式,例&gt;2(空格)2\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (show[x][y] == Flag)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;此处为旗帜，不可排雷\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (show[x][y] != UN)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;不可重复排查\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//具体排雷操作</span></span><br><span class=\"line\">\t\t\t\tcont = FindMine(mine,show,check, x, y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cont)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//检查是否赢得游戏</span></span><br><span class=\"line\">\t\t\t\t\tcont = CheckWin(mine,show);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//插旗</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;坐标格式,例&gt;2(空格)2\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\t\t\tSetFlag(show, x, y);<span class=\"comment\">//插旗函数</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n输入错误(恼\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SetFlag-函数\"><a href=\"#SetFlag-函数\" class=\"headerlink\" title=\"SetFlag()函数\"></a>SetFlag()函数</h4><p>先捏软柿子，插旗函数比较简单</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetFlag</span><span class=\"params\">(<span class=\"type\">char</span> show[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (show[x][y] == UN)<span class=\"comment\">//插旗</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = Flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (show[x][y] == Flag)<span class=\"comment\">//拔旗</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = UN;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;报错\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"ExpandBlank-函数\"><a href=\"#ExpandBlank-函数\" class=\"headerlink\" title=\"ExpandBlank()函数\"></a>ExpandBlank()函数</h4><p>这个函数用于打开成片的<code>空白区</code>,因为要从连着的空白连续开下去，所以要用到<code>函数递归</code>,此时<code>二维数组check</code>用于防止死递归</p>\n<p><strong>注</strong>：这个函数一定要写在下一个函数(FindMine)前</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ExpandBlank</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROWS][COLS], <span class=\"type\">char</span> check[ROWS][COLS],<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tshow[x][y] = mine[x][y];<span class=\"comment\">//将用户看到的格子改成mine中的格子,包括空白和数字格子</span></span><br><span class=\"line\">\tcheck[x][y] = <span class=\"string\">&#x27;1&#x27;</span>;<span class=\"comment\">//探测过的格子放`1`</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mine[x][y] == Blank)<span class=\"comment\">//仅空白格子会触发递归，数字格子不会</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//九宫格式探测</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = x - <span class=\"number\">1</span>; i &lt;= x + <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = y - <span class=\"number\">1</span>; j &lt;= y + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (check[i][j] == <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; mine[i][j] != Bomb &amp;&amp; show[i][j] != Flag)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//含雷的格子不会执行ExpandBlank函数，就不会把雷放出来给用户看，但数字格子会</span></span><br><span class=\"line\">\t\t\t\t\tExpandBlank(mine, show, check, i, j);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"FindMine-函数\"><a href=\"#FindMine-函数\" class=\"headerlink\" title=\"FindMine()函数\"></a>FindMine()函数</h4><p>排雷用的函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">FindMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROW][COLS],<span class=\"type\">char</span> check[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mine[x][y] == Bomb)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tDisplayBoard(mine);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;炸死，游戏结束:)\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//返回0来结束游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mine[x][y] != Blank)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = mine[x][y];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;<span class=\"comment\">//返回1来继续游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里有对上一个函数的调用</span></span><br><span class=\"line\">\t\tExpandBlank(mine, show, check,x,y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CheckWin-函数\"><a href=\"#CheckWin-函数\" class=\"headerlink\" title=\"CheckWin()函数\"></a>CheckWin()函数</h4><p>用于检查玩家是否完全排雷，赢得游戏</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">CheckWin</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//统计没排雷的格子数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= COL; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (show[i][j] == UN || show[i][j] == Flag)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcount++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (count == EZ_RANK)<span class=\"comment\">//统计数==雷数</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;恭喜排雷成功!\\n&quot;</span>);</span><br><span class=\"line\">\t\tDisplayBoard(mine);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//返回0，停止游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>至此游戏所需的代码全部完成，已经可以编译出来玩耍啦。</p>\n<p>该实践项目主要练习了<code>二维数组</code>,<code>函数</code>,<code>函数递归</code>,<code>宏定义</code>等内容，代码量在入门学习中算较大的，本人在初次编写的时候也写出了不少bug，debug的过程是相当<del>快乐</del></p>\n<p>建议多多画示意图，<strong>耐下性子</strong>写代码和debug,哪怕是实现这样的小游戏项目，也是颇有意义的</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"直接开始吧！\"><a href=\"#直接开始吧！\" class=\"headerlink\" title=\"直接开始吧！\"></a>直接开始吧！</h1><h2 id=\"多文件项目\"><a href=\"#多文件项目\" class=\"headerlink\" title=\"多文件项目\"></a>多文件项目</h2><p>扫雷项目内容较多，需要调用的<strong>函数</strong>也较多，采用多文件的方式，可以使代码<strong>条理清晰</strong>，并且<strong>易于管理和维护</strong>。文件如下</p>\n<p><code>game.h</code>用于宏定义，函数声明，引入头文件等</p>\n<p><code>game.c</code>用于<strong>函数的具体实现</strong></p>\n<p><code>front.c</code>用于实现程序的<strong>主干部分</strong></p>\n<p><code>other.c</code>用于实现其他杂项函数，这里我用于实现<code>menu()</code>函数，<del>主要内容太花了</del></p>\n<p><strong>注</strong>  <code>.c</code>结尾的源文件均需加一句<code>#include &quot;game.h&quot;</code></p>\n<h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><p>本次用到的头文件有<code>stdio.h</code> <code>stdlib.h</code> <code>time.h</code> <code>windows.h</code><br>和自己建的<code>game.h</code></p>\n<p><strong>均在</strong>文件<code>game.h</code>中<code>#include</code></p>\n<h2 id=\"define宏定义\"><a href=\"#define宏定义\" class=\"headerlink\" title=\"define宏定义\"></a>define宏定义</h2><p>为了便于<strong>阅读和维护</strong>代码,在<code>game.h</code>中的宏定义如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//显示行列</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ROW 9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COL 9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实际数组大小</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ROWS ROW+2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COLS COL + 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//地雷信息</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Bomb <span class=\"string\">&#x27;*&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Blank <span class=\"string\">&#x27; &#x27;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//难度</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EZ_RANK 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HD_RANK 15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示区</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UN <span class=\"string\">&#x27;\u001f&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Flag <span class=\"string\">&#x27;!&#x27;</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么实际数组要大一圈？\"><a href=\"#为什么实际数组要大一圈？\" class=\"headerlink\" title=\"为什么实际数组要大一圈？\"></a>为什么实际数组要大一圈？</h3><p>如图，采用九宫格式访问时，大出来的一圈能有效<strong>防止越界访问</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_11-23-51.jpg\"></p>\n<h2 id=\"构建main函数\"><a href=\"#构建main函数\" class=\"headerlink\" title=\"构建main函数\"></a>构建main函数</h2><p>内容不多，主要是与菜单配合食用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//用time()获取时间戳，传给srand设置(随机值生成器的)种子</span></span><br><span class=\"line\">\tsrand((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)<span class=\"comment\">//循环游玩</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> input = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tMenu();<span class=\"comment\">//打印菜单</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;input);<span class=\"comment\">//获取指令</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (input)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\tSleep(<span class=\"number\">250</span>);</span><br><span class=\"line\">\t\t\tgame();<span class=\"comment\">//开始游戏,游戏具体在game()函数中实现</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;游戏结束\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//结束程序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;输入错误,请重试\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"打印菜单\"><a href=\"#打印菜单\" class=\"headerlink\" title=\"打印菜单\"></a>打印菜单</h2><p>还在做静态菜单?<del>弱爆了！</del>来试试<strong>动态出现</strong>的菜单！</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/menu.gif\"></p>\n<p>原理很<strong>简单</strong>，就是<code>打印空白数组</code>-&gt;<code>向内逐个替换两侧元素</code>-&gt;<code>清屏</code>-&gt;<code>再打印</code>-&gt;<code>再替换</code>-&gt;<code>...</code></p>\n<p><em>接下来的代码写在<code>other.c</code>中</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态打印菜单</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Menu</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> cover[]  =  <span class=\"string\">&quot;=======================&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> option1[] = <span class=\"string\">&quot;======  play (1) ======&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> option2[] = <span class=\"string\">&quot;======  exit (2) ======&quot;</span>; </span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_c[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_1[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_2[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> right = <span class=\"number\">22</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"comment\">//内容替换</span></span><br><span class=\"line\">\t\tempty_c[left] = cover[left];</span><br><span class=\"line\">\t\tempty_c[right] = cover[right];</span><br><span class=\"line\">\t\tempty_1[left] = option1[left];</span><br><span class=\"line\">\t\tempty_1[right] = option1[right];</span><br><span class=\"line\">\t\tempty_2[left] = option2[left];</span><br><span class=\"line\">\t\tempty_2[right] = option2[right];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);<span class=\"comment\">//清屏</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n%s\\n%s\\n%s\\n&quot;</span>,empty_c,empty_1,empty_2,empty_c);<span class=\"comment\">//打印菜单</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tleft++;</span><br><span class=\"line\">\t\tright--;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left == right)<span class=\"comment\">//打印最终菜单</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\tempty_c[left] = cover[left];</span><br><span class=\"line\">\t\tempty_1[left] = option1[left];</span><br><span class=\"line\">\t\tempty_2[left] = option2[left];</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n%s\\n%s\\n%s\\n&quot;</span>, empty_c, empty_1, empty_2, empty_c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现game-函数\"><a href=\"#实现game-函数\" class=\"headerlink\" title=\"实现game()函数\"></a>实现game()函数</h2><p><em>游戏的主要逻辑在game()中实现</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">game</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> mine[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">char</span> show[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">char</span> check[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化棋盘，其实就是用第二个形参填充二维数组</span></span><br><span class=\"line\">\tInitBoard(mine, Blank);</span><br><span class=\"line\">\tInitBoard(show, UN);</span><br><span class=\"line\"></span><br><span class=\"line\">\tInitCheck(check);<span class=\"comment\">//初始化check数组，逻辑与上面的初始化不同</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tSetMine(mine,EZ_RANK);<span class=\"comment\">//设置地雷</span></span><br><span class=\"line\">\tSetNum(mine);<span class=\"comment\">//设置雷周围的数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//DisplayBoard(mine); //用于开发时检查棋盘布局</span></span><br><span class=\"line\">\t<span class=\"comment\">//DisplayBoard(show); //同上，不使用时注释掉</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//以上是前期准备</span></span><br><span class=\"line\">\tOPMine(mine,show, check);<span class=\"comment\">//开始排雷</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;敲击enter以继续\\n&quot;</span>);</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么用三个二维数组？\"><a href=\"#为什么用三个二维数组？\" class=\"headerlink\" title=\"为什么用三个二维数组？\"></a>为什么用三个二维数组？</h3><p>扫雷需要实现的功能较多，显然一个二维数组是不足以满足需求的，所以这里采用<strong>三个</strong>数组相叠加的方式，各自实现功能，并整合到一起。</p>\n<p>数组<code>mine</code>用于存放<code>雷</code>和雷周围的<code>计数数字</code></p>\n<p>数组<code>show</code>用于储存给<code>用户</code>看到的内容，可以是<code>Unkown</code>,<code>空白</code>，<code>数字</code>，<code>旗帜</code></p>\n<p>数组<code>check</code>用于记录棋盘的哪些地块被检查过了，防止后面用<strong>递归</strong>打开成片的空白区时，出现无限递归。</p>\n<p><strong>规定</strong>：检查过的坐标储存<code>字符1</code>,没检查过的坐标储存<code>字符0</code>,大出来的<strong>一圈</strong>默认储存<code>字符1</code></p>\n<h2 id=\"实现游戏用的函数\"><a href=\"#实现游戏用的函数\" class=\"headerlink\" title=\"实现游戏用的函数\"></a>实现游戏用的函数</h2><h3 id=\"先看看有哪些要声明在game-h里的\"><a href=\"#先看看有哪些要声明在game-h里的\" class=\"headerlink\" title=\"先看看有哪些要声明在game.h里的\"></a>先看看有哪些要声明在<code>game.h</code>里的</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Menu</span><span class=\"params\">()</span>;<span class=\"comment\">//这个在上文实现过了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一下函数将在下文实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS], <span class=\"type\">char</span> sign)</span>;</span><br><span class=\"line\"><span class=\"comment\">//展示棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DisplayBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//初始化check棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitCheck</span><span class=\"params\">(<span class=\"type\">char</span> check[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//设置地雷/数字</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">int</span> rank)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetNum</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//玩家排雷用的函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">OPMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS],<span class=\"type\">char</span> show[ROWS][COLS],<span class=\"type\">char</span> check[ROWS][COLS])</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em>好，有了目标，接下来就去一个一个实现</em></p>\n<p><strong>注</strong>：以下代码均写在<code>game.c</code>文件里</p>\n<h3 id=\"InitBoard\"><a href=\"#InitBoard\" class=\"headerlink\" title=\"InitBoard()\"></a>InitBoard()</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">char</span> sign)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; ROWS; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; COLS; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tboard[i][j] = sign;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里初始化的方式比较简单粗暴，就是用形参<code>sign</code>填充整个二维数组</p>\n<h3 id=\"DisplayBoard-函数\"><a href=\"#DisplayBoard-函数\" class=\"headerlink\" title=\"DisplayBoard()函数\"></a>DisplayBoard()函数</h3><p>这里采用的展示方式是带横纵坐标的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DisplayBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//打印一排列坐标</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= COL; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, k);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//打印一排横分割线</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= COL; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;--&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d|&quot;</span>, i);<span class=\"comment\">//这句话打印横排坐标和竖分割线</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//打印一排棋盘内容</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= COL; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c &quot;</span>, board[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"InitCheck-函数\"><a href=\"#InitCheck-函数\" class=\"headerlink\" title=\"InitCheck()函数\"></a>InitCheck()函数</h3><p>这里复用了<code>InitBoard()</code>函数，是在其基础上增加了内容</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitCheck</span><span class=\"params\">(<span class=\"type\">char</span> check[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tInitBoard(check, <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将边缘大出来的一圈改为&#x27;1&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; COLS; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcheck[<span class=\"number\">0</span>][k] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t\tcheck[ROWS - <span class=\"number\">1</span>][k] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; ROWS <span class=\"number\">-1</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcheck[i][<span class=\"number\">0</span>] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t\tcheck[i][COLS - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SetMine-函数\"><a href=\"#SetMine-函数\" class=\"headerlink\" title=\"SetMine()函数\"></a>SetMine()函数</h3><p>这里要使用<code>rand()</code>函数搭配<code>%</code>运算，来随机生成雷的坐标</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">int</span> rank)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> count = <span class=\"number\">0</span>;count &lt; rank;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx = rand() % ROW + <span class=\"number\">1</span>;<span class=\"comment\">//x的范围是1~ROW</span></span><br><span class=\"line\">\t\ty = rand() % COL + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (board[x][y] == Blank)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcount++;</span><br><span class=\"line\">\t\t\tboard[x][y] = Bomb;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SetNum-函数\"><a href=\"#SetNum-函数\" class=\"headerlink\" title=\"SetNum()函数\"></a>SetNum()函数</h3><p>这里遍历一遍数组并采用<code>九宫格式</code>计数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//该函数用于九宫格式计数，并在下个函数中被调用</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">CountMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = x - <span class=\"number\">1</span>; i &lt;= x + <span class=\"number\">1</span>; i++)<span class=\"comment\">//上中下三行</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = y - <span class=\"number\">1</span>; j &lt;= y + <span class=\"number\">1</span>; j++)<span class=\"comment\">//左中右三列</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i != x || j != y)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (board[i][j] == Bomb)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tsum++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetNum</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//遍历二维数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= COLS; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (board[i][j] == Blank)<span class=\"comment\">//仅操作非雷的格子</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (CountMine(board, i, j))</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tboard[i][j] = <span class=\"string\">&#x27;0&#x27;</span> + CountMine(board, i, j);<span class=\"comment\">//将返回的数字转化成字符</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"OPMine-函数–核心函数\"><a href=\"#OPMine-函数–核心函数\" class=\"headerlink\" title=\"OPMine()函数–核心函数\"></a>OPMine()函数–核心函数</h3><p>该函数为游戏的<code>核心函数</code>，有内置菜单，且多次调用其它函数，其中<code>函数</code>的具体实现见<code>四级标题</code>处</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">OPMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS],<span class=\"type\">char</span> show[ROWS][COLS],<span class=\"type\">char</span> check[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>;<span class=\"comment\">//横纵坐标</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">1</span>;<span class=\"comment\">//用于菜单选项</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> cont = <span class=\"number\">1</span>;<span class=\"comment\">//cont为0时游戏结束</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cont)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\tDisplayBoard(show);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;排雷(1)\\n插旗/拔旗(2)\\n请输入:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;flag);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (flag)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//排雷</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;坐标格式,例&gt;2(空格)2\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (show[x][y] == Flag)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;此处为旗帜，不可排雷\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (show[x][y] != UN)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;不可重复排查\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//具体排雷操作</span></span><br><span class=\"line\">\t\t\t\tcont = FindMine(mine,show,check, x, y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cont)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//检查是否赢得游戏</span></span><br><span class=\"line\">\t\t\t\t\tcont = CheckWin(mine,show);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//插旗</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;坐标格式,例&gt;2(空格)2\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\t\t\tSetFlag(show, x, y);<span class=\"comment\">//插旗函数</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n输入错误(恼\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SetFlag-函数\"><a href=\"#SetFlag-函数\" class=\"headerlink\" title=\"SetFlag()函数\"></a>SetFlag()函数</h4><p>先捏软柿子，插旗函数比较简单</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetFlag</span><span class=\"params\">(<span class=\"type\">char</span> show[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (show[x][y] == UN)<span class=\"comment\">//插旗</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = Flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (show[x][y] == Flag)<span class=\"comment\">//拔旗</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = UN;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;报错\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"ExpandBlank-函数\"><a href=\"#ExpandBlank-函数\" class=\"headerlink\" title=\"ExpandBlank()函数\"></a>ExpandBlank()函数</h4><p>这个函数用于打开成片的<code>空白区</code>,因为要从连着的空白连续开下去，所以要用到<code>函数递归</code>,此时<code>二维数组check</code>用于防止死递归</p>\n<p><strong>注</strong>：这个函数一定要写在下一个函数(FindMine)前</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ExpandBlank</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROWS][COLS], <span class=\"type\">char</span> check[ROWS][COLS],<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tshow[x][y] = mine[x][y];<span class=\"comment\">//将用户看到的格子改成mine中的格子,包括空白和数字格子</span></span><br><span class=\"line\">\tcheck[x][y] = <span class=\"string\">&#x27;1&#x27;</span>;<span class=\"comment\">//探测过的格子放`1`</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mine[x][y] == Blank)<span class=\"comment\">//仅空白格子会触发递归，数字格子不会</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//九宫格式探测</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = x - <span class=\"number\">1</span>; i &lt;= x + <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = y - <span class=\"number\">1</span>; j &lt;= y + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (check[i][j] == <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; mine[i][j] != Bomb &amp;&amp; show[i][j] != Flag)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//含雷的格子不会执行ExpandBlank函数，就不会把雷放出来给用户看，但数字格子会</span></span><br><span class=\"line\">\t\t\t\t\tExpandBlank(mine, show, check, i, j);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"FindMine-函数\"><a href=\"#FindMine-函数\" class=\"headerlink\" title=\"FindMine()函数\"></a>FindMine()函数</h4><p>排雷用的函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">FindMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROW][COLS],<span class=\"type\">char</span> check[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mine[x][y] == Bomb)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tDisplayBoard(mine);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;炸死，游戏结束:)\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//返回0来结束游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mine[x][y] != Blank)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = mine[x][y];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;<span class=\"comment\">//返回1来继续游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里有对上一个函数的调用</span></span><br><span class=\"line\">\t\tExpandBlank(mine, show, check,x,y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CheckWin-函数\"><a href=\"#CheckWin-函数\" class=\"headerlink\" title=\"CheckWin()函数\"></a>CheckWin()函数</h4><p>用于检查玩家是否完全排雷，赢得游戏</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">CheckWin</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//统计没排雷的格子数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= COL; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (show[i][j] == UN || show[i][j] == Flag)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcount++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (count == EZ_RANK)<span class=\"comment\">//统计数==雷数</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;恭喜排雷成功!\\n&quot;</span>);</span><br><span class=\"line\">\t\tDisplayBoard(mine);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//返回0，停止游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>至此游戏所需的代码全部完成，已经可以编译出来玩耍啦。</p>\n<p>该实践项目主要练习了<code>二维数组</code>,<code>函数</code>,<code>函数递归</code>,<code>宏定义</code>等内容，代码量在入门学习中算较大的，本人在初次编写的时候也写出了不少bug，debug的过程是相当<del>快乐</del></p>\n<p>建议多多画示意图，<strong>耐下性子</strong>写代码和debug,哪怕是实现这样的小游戏项目，也是颇有意义的</p>\n"},{"title":"=C语言=动态内存分配遇上函数-经典错误纠错","date":"2023-08-28T08:11:37.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-46-45.jpg","_content":"### 直接完整代码 #\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid GetMemory(char* p)   //申请内存\n{\n\tp = (char*)malloc(100);  \n}\n\nvoid Test()\n{\n\tchar* str = NULL;\n\tGetMemory(str);\n\tstrcpy(str, \"hello world\"); //复制字符串\n\tprintf(str);  //输出字符串\n}\n\nint main()\n{\n\tTest();\n\treturn 0;\n}\n```\n### 分析 #\n推测这段代码的的目的是通过``GetMemory``函数申请内存，然后把返回的地址存入指针变量``str``,再把字符串``\"hello world\"``复制到``str``所指向的内存中，最后``printf``输出\n\n#### 逐步纠错 #\n\n##### ``GetMemory`` #\n\n1. 首先是传参错误。若在函数内修改外部的一级指针，不能直接将外部一级指针作为**实参**传入：因为函数会将**实参**赋给**形参**，程序运行到大括号外面后，**形参**被销毁，**实参**没有变化。所以应该使用``char** p``二级指针作为**形参**,储存地址时使用``*p``\\\n2. 其次是内存泄漏。开辟的内存的地址并没有传递给实参，形参又最后销毁了，同时没有释放内存，函数运行完后申请的内存无法找到，导致最终无法释放，造成内存泄漏\n\n```C\n//更合适的代码\nvoid GetMenmory(char** p)\n{\n    *p = (char*)malloc(100);\n}\n\n```\n##### ``Test`` #\n1. NULL的大问题。假设``malloc``返回的地址已经存入``str``,但任然缺少对空指针的判断,导致``strcmp``中传入了空指针->报错;``printf``中传入空指针->报错\n2. 没有释放内存->内存泄漏。\n```C\n//更适合的代码\nvoid Test()\n{\n    char* str = NULL;\n    GetMemory(str);\n    if(str == MULL)\n    {\n        return;\n    }\n    strcpy(str,\"hello world\");\n    printf(\"%s\\n\",str);\n    free(str); //防止内存泄漏\n    str = NULL; //清除野指针\n}\n\n```\n","source":"_posts/mistake1.md","raw":"---\ntitle: =C语言=动态内存分配遇上函数-经典错误纠错\ndate: 2023-08-28 16:11:37\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-46-45.jpg\n---\n### 直接完整代码 #\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid GetMemory(char* p)   //申请内存\n{\n\tp = (char*)malloc(100);  \n}\n\nvoid Test()\n{\n\tchar* str = NULL;\n\tGetMemory(str);\n\tstrcpy(str, \"hello world\"); //复制字符串\n\tprintf(str);  //输出字符串\n}\n\nint main()\n{\n\tTest();\n\treturn 0;\n}\n```\n### 分析 #\n推测这段代码的的目的是通过``GetMemory``函数申请内存，然后把返回的地址存入指针变量``str``,再把字符串``\"hello world\"``复制到``str``所指向的内存中，最后``printf``输出\n\n#### 逐步纠错 #\n\n##### ``GetMemory`` #\n\n1. 首先是传参错误。若在函数内修改外部的一级指针，不能直接将外部一级指针作为**实参**传入：因为函数会将**实参**赋给**形参**，程序运行到大括号外面后，**形参**被销毁，**实参**没有变化。所以应该使用``char** p``二级指针作为**形参**,储存地址时使用``*p``\\\n2. 其次是内存泄漏。开辟的内存的地址并没有传递给实参，形参又最后销毁了，同时没有释放内存，函数运行完后申请的内存无法找到，导致最终无法释放，造成内存泄漏\n\n```C\n//更合适的代码\nvoid GetMenmory(char** p)\n{\n    *p = (char*)malloc(100);\n}\n\n```\n##### ``Test`` #\n1. NULL的大问题。假设``malloc``返回的地址已经存入``str``,但任然缺少对空指针的判断,导致``strcmp``中传入了空指针->报错;``printf``中传入空指针->报错\n2. 没有释放内存->内存泄漏。\n```C\n//更适合的代码\nvoid Test()\n{\n    char* str = NULL;\n    GetMemory(str);\n    if(str == MULL)\n    {\n        return;\n    }\n    strcpy(str,\"hello world\");\n    printf(\"%s\\n\",str);\n    free(str); //防止内存泄漏\n    str = NULL; //清除野指针\n}\n\n```\n","slug":"mistake1","published":1,"updated":"2023-11-02T02:56:16.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloutk93s0007kkg69w4ogz8u","content":"<h3 id=\"直接完整代码\"><a href=\"#直接完整代码\" class=\"headerlink\" title=\"直接完整代码\"></a>直接完整代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GetMemory</span><span class=\"params\">(<span class=\"type\">char</span>* p)</span>   <span class=\"comment\">//申请内存</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tp = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Test</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span>* str = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tGetMemory(str);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(str, <span class=\"string\">&quot;hello world&quot;</span>); <span class=\"comment\">//复制字符串</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(str);  <span class=\"comment\">//输出字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tTest();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>推测这段代码的的目的是通过<code>GetMemory</code>函数申请内存，然后把返回的地址存入指针变量<code>str</code>,再把字符串<code>&quot;hello world&quot;</code>复制到<code>str</code>所指向的内存中，最后<code>printf</code>输出</p>\n<h4 id=\"逐步纠错\"><a href=\"#逐步纠错\" class=\"headerlink\" title=\"逐步纠错\"></a>逐步纠错</h4><h5 id=\"GetMemory\"><a href=\"#GetMemory\" class=\"headerlink\" title=\"GetMemory\"></a><code>GetMemory</code></h5><ol>\n<li>首先是传参错误。若在函数内修改外部的一级指针，不能直接将外部一级指针作为<strong>实参</strong>传入：因为函数会将<strong>实参</strong>赋给<strong>形参</strong>，程序运行到大括号外面后，<strong>形参</strong>被销毁，<strong>实参</strong>没有变化。所以应该使用<code>char** p</code>二级指针作为<strong>形参</strong>,储存地址时使用<code>*p</code>\\</li>\n<li>其次是内存泄漏。开辟的内存的地址并没有传递给实参，形参又最后销毁了，同时没有释放内存，函数运行完后申请的内存无法找到，导致最终无法释放，造成内存泄漏</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//更合适的代码</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GetMenmory</span><span class=\"params\">(<span class=\"type\">char</span>** p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    *p = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a><code>Test</code></h5><ol>\n<li>NULL的大问题。假设<code>malloc</code>返回的地址已经存入<code>str</code>,但任然缺少对空指针的判断,导致<code>strcmp</code>中传入了空指针-&gt;报错;<code>printf</code>中传入空指针-&gt;报错</li>\n<li>没有释放内存-&gt;内存泄漏。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//更适合的代码</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Test</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* str = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    GetMemory(str);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str == MULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(str,<span class=\"string\">&quot;hello world&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,str);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(str); <span class=\"comment\">//防止内存泄漏</span></span><br><span class=\"line\">    str = <span class=\"literal\">NULL</span>; <span class=\"comment\">//清除野指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h3 id=\"直接完整代码\"><a href=\"#直接完整代码\" class=\"headerlink\" title=\"直接完整代码\"></a>直接完整代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GetMemory</span><span class=\"params\">(<span class=\"type\">char</span>* p)</span>   <span class=\"comment\">//申请内存</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tp = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Test</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span>* str = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tGetMemory(str);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(str, <span class=\"string\">&quot;hello world&quot;</span>); <span class=\"comment\">//复制字符串</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(str);  <span class=\"comment\">//输出字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tTest();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>推测这段代码的的目的是通过<code>GetMemory</code>函数申请内存，然后把返回的地址存入指针变量<code>str</code>,再把字符串<code>&quot;hello world&quot;</code>复制到<code>str</code>所指向的内存中，最后<code>printf</code>输出</p>\n<h4 id=\"逐步纠错\"><a href=\"#逐步纠错\" class=\"headerlink\" title=\"逐步纠错\"></a>逐步纠错</h4><h5 id=\"GetMemory\"><a href=\"#GetMemory\" class=\"headerlink\" title=\"GetMemory\"></a><code>GetMemory</code></h5><ol>\n<li>首先是传参错误。若在函数内修改外部的一级指针，不能直接将外部一级指针作为<strong>实参</strong>传入：因为函数会将<strong>实参</strong>赋给<strong>形参</strong>，程序运行到大括号外面后，<strong>形参</strong>被销毁，<strong>实参</strong>没有变化。所以应该使用<code>char** p</code>二级指针作为<strong>形参</strong>,储存地址时使用<code>*p</code>\\</li>\n<li>其次是内存泄漏。开辟的内存的地址并没有传递给实参，形参又最后销毁了，同时没有释放内存，函数运行完后申请的内存无法找到，导致最终无法释放，造成内存泄漏</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//更合适的代码</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GetMenmory</span><span class=\"params\">(<span class=\"type\">char</span>** p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    *p = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a><code>Test</code></h5><ol>\n<li>NULL的大问题。假设<code>malloc</code>返回的地址已经存入<code>str</code>,但任然缺少对空指针的判断,导致<code>strcmp</code>中传入了空指针-&gt;报错;<code>printf</code>中传入空指针-&gt;报错</li>\n<li>没有释放内存-&gt;内存泄漏。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//更适合的代码</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Test</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* str = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    GetMemory(str);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str == MULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(str,<span class=\"string\">&quot;hello world&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,str);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(str); <span class=\"comment\">//防止内存泄漏</span></span><br><span class=\"line\">    str = <span class=\"literal\">NULL</span>; <span class=\"comment\">//清除野指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"玩转N组输入和多组输入","date":"2023-10-18T14:39:57.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg","_content":"\n# 引入 #\n当我们在写IO型OJ时，`多组输入`便是我们绕过不开的话题了，但**不用担心**，可能初见多组输入会觉得难以理解，但用多了之后就会发现，`多组输入` 花样并不多，混熟了就**很简单了**\n\n## 先看看一组输入输出如何完成的 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_17-06-13.jpg)\n\n*如图*：一组输入时，用`scanf`获取一组输入，并在主体部分完成数据的处理，产生结果，最后用`printf`输出产生的一组结果。\n\n*以下用实现加法的程序做演示*\n\n```C\n#include <stdio.h>\n\nint main()\n{\n    int a,b;\n    scanf(\"%d %d\",&a,&b);//获取一组输入\n    int sum = a + b;//产生结果\n    printf(\"%d\\n\",sum);//输出结果\n    return 0;\n}\n```\n\n# 然后升级到N组输入\n有的OJ题在一个测试文件中会先输入一个`n`,告诉你接下来有`n`组输入，你就要产生`n`组输出,也就是说要将`一组输入输出`**重复性地**完成`n次`。难道我们要把代码重复`n次`吗？显然不现实。\n\n所以是时候使用**循环**了，具体用法如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg)\n\n如图，先用一个`scanf`获取循环次数`n`,然后创建一个循环，将`一组输入输出`放入循环体，一次一次循环处理即可\n\n## 变量的重置 #\n\n为防止前后两次循环产生干扰，有两种处理`变量`的方式\n\n1.(推荐)除了输入的变量，**其它所有变量**在循环体内声明，这些变量会在一次循环后*销毁*，下一次循环开始时**自动***重新声明*，从而完成**变量的自动重置**\n\n*以下面这个一次求和3个数的程序为例*\n```C\n#include <stdio.h>\n\nint main()\n{\n    int n = 0;\n    scanf(\"%d\",&n);//获取循环次数n\n    for(int i =0;i<n;i++)//创建循环\n    {\n        //以下完成一组输入输出\n        int sum = 0;//声明一个局部变量，下次循环时会自动重声明\n        int num = 0;//储存输入的数字\n        for(int j =0;j<3;j++)\n        {\n            scanf(\"%d\",&num);\n            sum+=num;\n        }\n        printf(\"%d\\n\",sum);//完成输出\n        //本次循环走完后变量sum被销毁，然后进入下一次循环,完成重置\n    }\n    return 0;\n}\n\n```\n\n2.在循环外部声明变量，然后在**循环末尾**手动重置变量\n\n*以下面这个一次求和3个数的程序为例*\n\n```C\n#include <stdio.h>\n\nint main()\n{\n    int sum = 0;//声明在循环外部\n    int n = 0;\n    scanf(\"%d\",&n);//获取循环次数n\n    for(int i =0;i<n;i++)//创建循环\n    {\n        //以下完成一组输入输出\n        int num = 0;//储存输入的数字\n        for(int j =0;j<3;j++)\n        {\n            scanf(\"%d\",&num);\n            sum+=num;\n        }\n        printf(\"%d\\n\",sum);//完成输出\n        sum = 0;//重置sum\n    }\n    return 0;\n}\n\n```\n\n\n## 要不要用数组储存输入，或储存结果再一次性输出？ #\n答案是：**可以，但没必要**。\n\n只需要像上图那么写即可，因为输入是一次性喂进去的 。存数组再输出，和每产生一个结果就输出一次，最终呈现出来是一样的（如下图）\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%A4%9A%E7%BB%84%E8%BE%93%E5%87%BA.gif)\n\n# 现在，勇士，来挑战多组输入吧 #\n\n## scanf的返回值 #\n多组输入时，究竟会输入多少组数据，也不告诉你了，**但是**，此时`scanf`的返回值就派上用场了。和我们在终端手打输入不同,OJ的输入是喂一个文件进去，所以当**输入结束时**，`scanf`的返回值是`EOF`*(意为文件结尾end of file)*,而当成功输入数据时，则会返回输入数据的个数(文档截图如下)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_20-46-54.jpg)\n\n## 结合循环 #\n那么就把`scanf`放入`while`循环吧,每次试图获取下一组输入时，检测是否返回值为`EOF`,若是，则跳出循环，结束程序；若否，则继续循环\n\n*以下面这个一次求和3个数的程序为例*\n\n```C\n#include <stdio.h>\nint main()\n{\n    int num = 0;//先声明至少一个待输入的变量\n    while(scanf(\"%d\",&n) != EOF)//创建循环，每次循环开始时scanf一次，并检测是否返回EOF\n    {\n        //开始构建循坏体\n        int sum = 0;\n        sum+=n;\n        //完成剩下的两次输入\n        for(int i =0; i < 3 - 1;i++)\n        {\n            scanf(\"%d\",&n);\n            sum+=n\n        }\n        printf(\"%d\\n\",sum);//完成一次输出\n    }\n    //scanf返回EOF后跳出循环\n    return 0;\n}\n```\n## 基本架构 #\n以后再要写`多组输入`，基本就像上面那个程序一样\n\n1.先声明至少一个待输入的变量\n\n2.创建循环，每次循环开始时scanf一次，并检测是否返回EOF\n\n3.开始构建循坏体(包括完成剩下的输入,完成一组输出)**别忘了回车！！！**\n\n4.直至scanf返回EOF后跳出循环\n\n# 想模拟一下多组输入看看？ #\n像下图一样每组数据间加个`空格`就行，什么？题目的样例输入有`回车`？不用管它，放心大胆地`换成空格`就行。自己`测试`程序，只需要**输出**一样就行，至于怎么输入，**没必要**和题目一模一样\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/mutiInpuut.gif)\n\n# 注意！！！不要试图在终端停止程序 #\n因为和OJ不同，在本地运行程序时，不是文件输入，而是终端输入,没法让`scanf`返回`EOF`,~~炫迈，根本停不来~~\n\n你要是想立即`中断`程序，那就按`ctrl+c`","source":"_posts/mutiInput.md","raw":"---\ntitle: 玩转N组输入和多组输入\ndate: 2023-10-18 22:39:57\ntags:\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg\n---\n\n# 引入 #\n当我们在写IO型OJ时，`多组输入`便是我们绕过不开的话题了，但**不用担心**，可能初见多组输入会觉得难以理解，但用多了之后就会发现，`多组输入` 花样并不多，混熟了就**很简单了**\n\n## 先看看一组输入输出如何完成的 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_17-06-13.jpg)\n\n*如图*：一组输入时，用`scanf`获取一组输入，并在主体部分完成数据的处理，产生结果，最后用`printf`输出产生的一组结果。\n\n*以下用实现加法的程序做演示*\n\n```C\n#include <stdio.h>\n\nint main()\n{\n    int a,b;\n    scanf(\"%d %d\",&a,&b);//获取一组输入\n    int sum = a + b;//产生结果\n    printf(\"%d\\n\",sum);//输出结果\n    return 0;\n}\n```\n\n# 然后升级到N组输入\n有的OJ题在一个测试文件中会先输入一个`n`,告诉你接下来有`n`组输入，你就要产生`n`组输出,也就是说要将`一组输入输出`**重复性地**完成`n次`。难道我们要把代码重复`n次`吗？显然不现实。\n\n所以是时候使用**循环**了，具体用法如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg)\n\n如图，先用一个`scanf`获取循环次数`n`,然后创建一个循环，将`一组输入输出`放入循环体，一次一次循环处理即可\n\n## 变量的重置 #\n\n为防止前后两次循环产生干扰，有两种处理`变量`的方式\n\n1.(推荐)除了输入的变量，**其它所有变量**在循环体内声明，这些变量会在一次循环后*销毁*，下一次循环开始时**自动***重新声明*，从而完成**变量的自动重置**\n\n*以下面这个一次求和3个数的程序为例*\n```C\n#include <stdio.h>\n\nint main()\n{\n    int n = 0;\n    scanf(\"%d\",&n);//获取循环次数n\n    for(int i =0;i<n;i++)//创建循环\n    {\n        //以下完成一组输入输出\n        int sum = 0;//声明一个局部变量，下次循环时会自动重声明\n        int num = 0;//储存输入的数字\n        for(int j =0;j<3;j++)\n        {\n            scanf(\"%d\",&num);\n            sum+=num;\n        }\n        printf(\"%d\\n\",sum);//完成输出\n        //本次循环走完后变量sum被销毁，然后进入下一次循环,完成重置\n    }\n    return 0;\n}\n\n```\n\n2.在循环外部声明变量，然后在**循环末尾**手动重置变量\n\n*以下面这个一次求和3个数的程序为例*\n\n```C\n#include <stdio.h>\n\nint main()\n{\n    int sum = 0;//声明在循环外部\n    int n = 0;\n    scanf(\"%d\",&n);//获取循环次数n\n    for(int i =0;i<n;i++)//创建循环\n    {\n        //以下完成一组输入输出\n        int num = 0;//储存输入的数字\n        for(int j =0;j<3;j++)\n        {\n            scanf(\"%d\",&num);\n            sum+=num;\n        }\n        printf(\"%d\\n\",sum);//完成输出\n        sum = 0;//重置sum\n    }\n    return 0;\n}\n\n```\n\n\n## 要不要用数组储存输入，或储存结果再一次性输出？ #\n答案是：**可以，但没必要**。\n\n只需要像上图那么写即可，因为输入是一次性喂进去的 。存数组再输出，和每产生一个结果就输出一次，最终呈现出来是一样的（如下图）\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%A4%9A%E7%BB%84%E8%BE%93%E5%87%BA.gif)\n\n# 现在，勇士，来挑战多组输入吧 #\n\n## scanf的返回值 #\n多组输入时，究竟会输入多少组数据，也不告诉你了，**但是**，此时`scanf`的返回值就派上用场了。和我们在终端手打输入不同,OJ的输入是喂一个文件进去，所以当**输入结束时**，`scanf`的返回值是`EOF`*(意为文件结尾end of file)*,而当成功输入数据时，则会返回输入数据的个数(文档截图如下)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_20-46-54.jpg)\n\n## 结合循环 #\n那么就把`scanf`放入`while`循环吧,每次试图获取下一组输入时，检测是否返回值为`EOF`,若是，则跳出循环，结束程序；若否，则继续循环\n\n*以下面这个一次求和3个数的程序为例*\n\n```C\n#include <stdio.h>\nint main()\n{\n    int num = 0;//先声明至少一个待输入的变量\n    while(scanf(\"%d\",&n) != EOF)//创建循环，每次循环开始时scanf一次，并检测是否返回EOF\n    {\n        //开始构建循坏体\n        int sum = 0;\n        sum+=n;\n        //完成剩下的两次输入\n        for(int i =0; i < 3 - 1;i++)\n        {\n            scanf(\"%d\",&n);\n            sum+=n\n        }\n        printf(\"%d\\n\",sum);//完成一次输出\n    }\n    //scanf返回EOF后跳出循环\n    return 0;\n}\n```\n## 基本架构 #\n以后再要写`多组输入`，基本就像上面那个程序一样\n\n1.先声明至少一个待输入的变量\n\n2.创建循环，每次循环开始时scanf一次，并检测是否返回EOF\n\n3.开始构建循坏体(包括完成剩下的输入,完成一组输出)**别忘了回车！！！**\n\n4.直至scanf返回EOF后跳出循环\n\n# 想模拟一下多组输入看看？ #\n像下图一样每组数据间加个`空格`就行，什么？题目的样例输入有`回车`？不用管它，放心大胆地`换成空格`就行。自己`测试`程序，只需要**输出**一样就行，至于怎么输入，**没必要**和题目一模一样\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/mutiInpuut.gif)\n\n# 注意！！！不要试图在终端停止程序 #\n因为和OJ不同，在本地运行程序时，不是文件输入，而是终端输入,没法让`scanf`返回`EOF`,~~炫迈，根本停不来~~\n\n你要是想立即`中断`程序，那就按`ctrl+c`","slug":"mutiInput","published":1,"updated":"2023-11-02T02:38:14.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloutk947000bkkg68b6r1lgp","content":"<h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><p>当我们在写IO型OJ时，<code>多组输入</code>便是我们绕过不开的话题了，但<strong>不用担心</strong>，可能初见多组输入会觉得难以理解，但用多了之后就会发现，<code>多组输入</code> 花样并不多，混熟了就<strong>很简单了</strong></p>\n<h2 id=\"先看看一组输入输出如何完成的\"><a href=\"#先看看一组输入输出如何完成的\" class=\"headerlink\" title=\"先看看一组输入输出如何完成的\"></a>先看看一组输入输出如何完成的</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_17-06-13.jpg\"></p>\n<p><em>如图</em>：一组输入时，用<code>scanf</code>获取一组输入，并在主体部分完成数据的处理，产生结果，最后用<code>printf</code>输出产生的一组结果。</p>\n<p><em>以下用实现加法的程序做演示</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<span class=\"comment\">//获取一组输入</span></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = a + b;<span class=\"comment\">//产生结果</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//输出结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"然后升级到N组输入\"><a href=\"#然后升级到N组输入\" class=\"headerlink\" title=\"然后升级到N组输入\"></a>然后升级到N组输入</h1><p>有的OJ题在一个测试文件中会先输入一个<code>n</code>,告诉你接下来有<code>n</code>组输入，你就要产生<code>n</code>组输出,也就是说要将<code>一组输入输出</code><strong>重复性地</strong>完成<code>n次</code>。难道我们要把代码重复<code>n次</code>吗？显然不现实。</p>\n<p>所以是时候使用<strong>循环</strong>了，具体用法如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg\"></p>\n<p>如图，先用一个<code>scanf</code>获取循环次数<code>n</code>,然后创建一个循环，将<code>一组输入输出</code>放入循环体，一次一次循环处理即可</p>\n<h2 id=\"变量的重置\"><a href=\"#变量的重置\" class=\"headerlink\" title=\"变量的重置\"></a>变量的重置</h2><p>为防止前后两次循环产生干扰，有两种处理<code>变量</code>的方式</p>\n<p>1.(推荐)除了输入的变量，<strong>其它所有变量</strong>在循环体内声明，这些变量会在一次循环后<em>销毁</em>，下一次循环开始时<strong>自动</strong><em>重新声明</em>，从而完成<strong>变量的自动重置</strong></p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);<span class=\"comment\">//获取循环次数n</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"comment\">//创建循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以下完成一组输入输出</span></span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;<span class=\"comment\">//声明一个局部变量，下次循环时会自动重声明</span></span><br><span class=\"line\">        <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//储存输入的数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">0</span>;j&lt;<span class=\"number\">3</span>;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num);</span><br><span class=\"line\">            sum+=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成输出</span></span><br><span class=\"line\">        <span class=\"comment\">//本次循环走完后变量sum被销毁，然后进入下一次循环,完成重置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>2.在循环外部声明变量，然后在<strong>循环末尾</strong>手动重置变量</p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;<span class=\"comment\">//声明在循环外部</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);<span class=\"comment\">//获取循环次数n</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"comment\">//创建循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以下完成一组输入输出</span></span><br><span class=\"line\">        <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//储存输入的数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">0</span>;j&lt;<span class=\"number\">3</span>;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num);</span><br><span class=\"line\">            sum+=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成输出</span></span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;<span class=\"comment\">//重置sum</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"要不要用数组储存输入，或储存结果再一次性输出？\"><a href=\"#要不要用数组储存输入，或储存结果再一次性输出？\" class=\"headerlink\" title=\"要不要用数组储存输入，或储存结果再一次性输出？\"></a>要不要用数组储存输入，或储存结果再一次性输出？</h2><p>答案是：<strong>可以，但没必要</strong>。</p>\n<p>只需要像上图那么写即可，因为输入是一次性喂进去的 。存数组再输出，和每产生一个结果就输出一次，最终呈现出来是一样的（如下图）</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%A4%9A%E7%BB%84%E8%BE%93%E5%87%BA.gif\"></p>\n<h1 id=\"现在，勇士，来挑战多组输入吧\"><a href=\"#现在，勇士，来挑战多组输入吧\" class=\"headerlink\" title=\"现在，勇士，来挑战多组输入吧\"></a>现在，勇士，来挑战多组输入吧</h1><h2 id=\"scanf的返回值\"><a href=\"#scanf的返回值\" class=\"headerlink\" title=\"scanf的返回值\"></a>scanf的返回值</h2><p>多组输入时，究竟会输入多少组数据，也不告诉你了，<strong>但是</strong>，此时<code>scanf</code>的返回值就派上用场了。和我们在终端手打输入不同,OJ的输入是喂一个文件进去，所以当<strong>输入结束时</strong>，<code>scanf</code>的返回值是<code>EOF</code><em>(意为文件结尾end of file)</em>,而当成功输入数据时，则会返回输入数据的个数(文档截图如下)</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_20-46-54.jpg\"></p>\n<h2 id=\"结合循环\"><a href=\"#结合循环\" class=\"headerlink\" title=\"结合循环\"></a>结合循环</h2><p>那么就把<code>scanf</code>放入<code>while</code>循环吧,每次试图获取下一组输入时，检测是否返回值为<code>EOF</code>,若是，则跳出循环，结束程序；若否，则继续循环</p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//先声明至少一个待输入的变量</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n) != EOF)<span class=\"comment\">//创建循环，每次循环开始时scanf一次，并检测是否返回EOF</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//开始构建循坏体</span></span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        sum+=n;</span><br><span class=\"line\">        <span class=\"comment\">//完成剩下的两次输入</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span> - <span class=\"number\">1</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">            sum+=n</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成一次输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//scanf返回EOF后跳出循环</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h2><p>以后再要写<code>多组输入</code>，基本就像上面那个程序一样</p>\n<p>1.先声明至少一个待输入的变量</p>\n<p>2.创建循环，每次循环开始时scanf一次，并检测是否返回EOF</p>\n<p>3.开始构建循坏体(包括完成剩下的输入,完成一组输出)<strong>别忘了回车！！！</strong></p>\n<p>4.直至scanf返回EOF后跳出循环</p>\n<h1 id=\"想模拟一下多组输入看看？\"><a href=\"#想模拟一下多组输入看看？\" class=\"headerlink\" title=\"想模拟一下多组输入看看？\"></a>想模拟一下多组输入看看？</h1><p>像下图一样每组数据间加个<code>空格</code>就行，什么？题目的样例输入有<code>回车</code>？不用管它，放心大胆地<code>换成空格</code>就行。自己<code>测试</code>程序，只需要<strong>输出</strong>一样就行，至于怎么输入，<strong>没必要</strong>和题目一模一样</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/mutiInpuut.gif\"></p>\n<h1 id=\"注意！！！不要试图在终端停止程序\"><a href=\"#注意！！！不要试图在终端停止程序\" class=\"headerlink\" title=\"注意！！！不要试图在终端停止程序\"></a>注意！！！不要试图在终端停止程序</h1><p>因为和OJ不同，在本地运行程序时，不是文件输入，而是终端输入,没法让<code>scanf</code>返回<code>EOF</code>,<del>炫迈，根本停不来</del></p>\n<p>你要是想立即<code>中断</code>程序，那就按<code>ctrl+c</code></p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><p>当我们在写IO型OJ时，<code>多组输入</code>便是我们绕过不开的话题了，但<strong>不用担心</strong>，可能初见多组输入会觉得难以理解，但用多了之后就会发现，<code>多组输入</code> 花样并不多，混熟了就<strong>很简单了</strong></p>\n<h2 id=\"先看看一组输入输出如何完成的\"><a href=\"#先看看一组输入输出如何完成的\" class=\"headerlink\" title=\"先看看一组输入输出如何完成的\"></a>先看看一组输入输出如何完成的</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_17-06-13.jpg\"></p>\n<p><em>如图</em>：一组输入时，用<code>scanf</code>获取一组输入，并在主体部分完成数据的处理，产生结果，最后用<code>printf</code>输出产生的一组结果。</p>\n<p><em>以下用实现加法的程序做演示</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<span class=\"comment\">//获取一组输入</span></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = a + b;<span class=\"comment\">//产生结果</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//输出结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"然后升级到N组输入\"><a href=\"#然后升级到N组输入\" class=\"headerlink\" title=\"然后升级到N组输入\"></a>然后升级到N组输入</h1><p>有的OJ题在一个测试文件中会先输入一个<code>n</code>,告诉你接下来有<code>n</code>组输入，你就要产生<code>n</code>组输出,也就是说要将<code>一组输入输出</code><strong>重复性地</strong>完成<code>n次</code>。难道我们要把代码重复<code>n次</code>吗？显然不现实。</p>\n<p>所以是时候使用<strong>循环</strong>了，具体用法如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg\"></p>\n<p>如图，先用一个<code>scanf</code>获取循环次数<code>n</code>,然后创建一个循环，将<code>一组输入输出</code>放入循环体，一次一次循环处理即可</p>\n<h2 id=\"变量的重置\"><a href=\"#变量的重置\" class=\"headerlink\" title=\"变量的重置\"></a>变量的重置</h2><p>为防止前后两次循环产生干扰，有两种处理<code>变量</code>的方式</p>\n<p>1.(推荐)除了输入的变量，<strong>其它所有变量</strong>在循环体内声明，这些变量会在一次循环后<em>销毁</em>，下一次循环开始时<strong>自动</strong><em>重新声明</em>，从而完成<strong>变量的自动重置</strong></p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);<span class=\"comment\">//获取循环次数n</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"comment\">//创建循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以下完成一组输入输出</span></span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;<span class=\"comment\">//声明一个局部变量，下次循环时会自动重声明</span></span><br><span class=\"line\">        <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//储存输入的数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">0</span>;j&lt;<span class=\"number\">3</span>;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num);</span><br><span class=\"line\">            sum+=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成输出</span></span><br><span class=\"line\">        <span class=\"comment\">//本次循环走完后变量sum被销毁，然后进入下一次循环,完成重置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>2.在循环外部声明变量，然后在<strong>循环末尾</strong>手动重置变量</p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;<span class=\"comment\">//声明在循环外部</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);<span class=\"comment\">//获取循环次数n</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"comment\">//创建循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以下完成一组输入输出</span></span><br><span class=\"line\">        <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//储存输入的数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">0</span>;j&lt;<span class=\"number\">3</span>;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num);</span><br><span class=\"line\">            sum+=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成输出</span></span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;<span class=\"comment\">//重置sum</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"要不要用数组储存输入，或储存结果再一次性输出？\"><a href=\"#要不要用数组储存输入，或储存结果再一次性输出？\" class=\"headerlink\" title=\"要不要用数组储存输入，或储存结果再一次性输出？\"></a>要不要用数组储存输入，或储存结果再一次性输出？</h2><p>答案是：<strong>可以，但没必要</strong>。</p>\n<p>只需要像上图那么写即可，因为输入是一次性喂进去的 。存数组再输出，和每产生一个结果就输出一次，最终呈现出来是一样的（如下图）</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%A4%9A%E7%BB%84%E8%BE%93%E5%87%BA.gif\"></p>\n<h1 id=\"现在，勇士，来挑战多组输入吧\"><a href=\"#现在，勇士，来挑战多组输入吧\" class=\"headerlink\" title=\"现在，勇士，来挑战多组输入吧\"></a>现在，勇士，来挑战多组输入吧</h1><h2 id=\"scanf的返回值\"><a href=\"#scanf的返回值\" class=\"headerlink\" title=\"scanf的返回值\"></a>scanf的返回值</h2><p>多组输入时，究竟会输入多少组数据，也不告诉你了，<strong>但是</strong>，此时<code>scanf</code>的返回值就派上用场了。和我们在终端手打输入不同,OJ的输入是喂一个文件进去，所以当<strong>输入结束时</strong>，<code>scanf</code>的返回值是<code>EOF</code><em>(意为文件结尾end of file)</em>,而当成功输入数据时，则会返回输入数据的个数(文档截图如下)</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_20-46-54.jpg\"></p>\n<h2 id=\"结合循环\"><a href=\"#结合循环\" class=\"headerlink\" title=\"结合循环\"></a>结合循环</h2><p>那么就把<code>scanf</code>放入<code>while</code>循环吧,每次试图获取下一组输入时，检测是否返回值为<code>EOF</code>,若是，则跳出循环，结束程序；若否，则继续循环</p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//先声明至少一个待输入的变量</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n) != EOF)<span class=\"comment\">//创建循环，每次循环开始时scanf一次，并检测是否返回EOF</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//开始构建循坏体</span></span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        sum+=n;</span><br><span class=\"line\">        <span class=\"comment\">//完成剩下的两次输入</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span> - <span class=\"number\">1</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">            sum+=n</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成一次输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//scanf返回EOF后跳出循环</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h2><p>以后再要写<code>多组输入</code>，基本就像上面那个程序一样</p>\n<p>1.先声明至少一个待输入的变量</p>\n<p>2.创建循环，每次循环开始时scanf一次，并检测是否返回EOF</p>\n<p>3.开始构建循坏体(包括完成剩下的输入,完成一组输出)<strong>别忘了回车！！！</strong></p>\n<p>4.直至scanf返回EOF后跳出循环</p>\n<h1 id=\"想模拟一下多组输入看看？\"><a href=\"#想模拟一下多组输入看看？\" class=\"headerlink\" title=\"想模拟一下多组输入看看？\"></a>想模拟一下多组输入看看？</h1><p>像下图一样每组数据间加个<code>空格</code>就行，什么？题目的样例输入有<code>回车</code>？不用管它，放心大胆地<code>换成空格</code>就行。自己<code>测试</code>程序，只需要<strong>输出</strong>一样就行，至于怎么输入，<strong>没必要</strong>和题目一模一样</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/mutiInpuut.gif\"></p>\n<h1 id=\"注意！！！不要试图在终端停止程序\"><a href=\"#注意！！！不要试图在终端停止程序\" class=\"headerlink\" title=\"注意！！！不要试图在终端停止程序\"></a>注意！！！不要试图在终端停止程序</h1><p>因为和OJ不同，在本地运行程序时，不是文件输入，而是终端输入,没法让<code>scanf</code>返回<code>EOF</code>,<del>炫迈，根本停不来</del></p>\n<p>你要是想立即<code>中断</code>程序，那就按<code>ctrl+c</code></p>\n"},{"title":"如何在VS里使用scanf","date":"2023-10-05T14:37:32.000Z","_content":"# VS里怎么连scanf都用不了？ #\n不少刚接触[Visual Studio](https://visualstudio.microsoft.com/zh-hans/free-developer-offers/)的可能发现使用scanf会报错(如下)\n\n![报错图片](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/VS_scanf.jpg)\n\nvs告诉你说`scanf`不安全，然后你会发现vs给你提供了`scanf_s`去代替`scanf`,**但是**,只有vs能编译`scanf_s`,**可移植性**太差了，所以我们要用回`scanf`,所以要怎么不让它报错呢？**可以在源文件开头添加一行宏定义(如下)**\n\n`#define  _CRT_SECURE_NO_WARNINGS 1`\n\n这样就能**关闭报错**了,但请先**别急着走**,每次都要复制粘贴一句宏定义太麻烦了，想**一劳永逸**的请往下看。\n\n# 修改newc++file.cpp来自动添加宏定义 #\n**先来看怎么做：**首先搜索找到电脑中叫做`newc++file.cpp`的文件。（这里推荐使用[everything](https://www.voidtools.com/zh-cn/downloads/)）\n\n---\n\n*后半段路径应与图片一致，注意不是快捷方式*\n\n![c++文件的位置](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/newcppfile.jpg)\n\n---\n\n**注意**：由于权限原因，**无法**直接修改此文件\n\n所以先将这个文件复制粘贴到别处，例如桌面，下文用`副本`代称。\n\n用记事本类软件(记事本就行)打开`副本`,在第一行输入上文提到的宏定义代码`#define  _CRT_SECURE_NO_WARNINGS 1`,然后`ctrl+s`保存。\n\n**关闭编辑窗口**，将该`副本`移动到原始文件所在文件夹，弹出如下窗口，然后选择**替换文件**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-18.jpg)\n\n接着弹出下一个提示，点**接续**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-33.jpg)\n\n等待它替换完成，然后**大功告成！**。之后新建的每一个`.c`或`.cpp` 文件都会自带那段宏定义，于是`scanf`从此任君使用。~~当然平时删代码的时候记得别把那段宏定义删了~~\n\n## 原理 #\nVS所新建的`.c`和`.cpp`文件都源自于对上文`newc++file.cpp`文件的拷贝，通过修改它就能改变`VS新建文件`的初始内容","source":"_posts/useScanf.md","raw":"---\ntitle: 如何在VS里使用scanf\ndate: 2023-10-05 22:37:32\ntags:\n---\n# VS里怎么连scanf都用不了？ #\n不少刚接触[Visual Studio](https://visualstudio.microsoft.com/zh-hans/free-developer-offers/)的可能发现使用scanf会报错(如下)\n\n![报错图片](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/VS_scanf.jpg)\n\nvs告诉你说`scanf`不安全，然后你会发现vs给你提供了`scanf_s`去代替`scanf`,**但是**,只有vs能编译`scanf_s`,**可移植性**太差了，所以我们要用回`scanf`,所以要怎么不让它报错呢？**可以在源文件开头添加一行宏定义(如下)**\n\n`#define  _CRT_SECURE_NO_WARNINGS 1`\n\n这样就能**关闭报错**了,但请先**别急着走**,每次都要复制粘贴一句宏定义太麻烦了，想**一劳永逸**的请往下看。\n\n# 修改newc++file.cpp来自动添加宏定义 #\n**先来看怎么做：**首先搜索找到电脑中叫做`newc++file.cpp`的文件。（这里推荐使用[everything](https://www.voidtools.com/zh-cn/downloads/)）\n\n---\n\n*后半段路径应与图片一致，注意不是快捷方式*\n\n![c++文件的位置](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/newcppfile.jpg)\n\n---\n\n**注意**：由于权限原因，**无法**直接修改此文件\n\n所以先将这个文件复制粘贴到别处，例如桌面，下文用`副本`代称。\n\n用记事本类软件(记事本就行)打开`副本`,在第一行输入上文提到的宏定义代码`#define  _CRT_SECURE_NO_WARNINGS 1`,然后`ctrl+s`保存。\n\n**关闭编辑窗口**，将该`副本`移动到原始文件所在文件夹，弹出如下窗口，然后选择**替换文件**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-18.jpg)\n\n接着弹出下一个提示，点**接续**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-33.jpg)\n\n等待它替换完成，然后**大功告成！**。之后新建的每一个`.c`或`.cpp` 文件都会自带那段宏定义，于是`scanf`从此任君使用。~~当然平时删代码的时候记得别把那段宏定义删了~~\n\n## 原理 #\nVS所新建的`.c`和`.cpp`文件都源自于对上文`newc++file.cpp`文件的拷贝，通过修改它就能改变`VS新建文件`的初始内容","slug":"useScanf","published":1,"updated":"2023-10-19T04:10:39.080Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloutk947000ckkg60a3s5q0j","content":"<h1 id=\"VS里怎么连scanf都用不了？\"><a href=\"#VS里怎么连scanf都用不了？\" class=\"headerlink\" title=\"VS里怎么连scanf都用不了？\"></a>VS里怎么连scanf都用不了？</h1><p>不少刚接触<a href=\"https://visualstudio.microsoft.com/zh-hans/free-developer-offers/\">Visual Studio</a>的可能发现使用scanf会报错(如下)</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/VS_scanf.jpg\" alt=\"报错图片\"></p>\n<p>vs告诉你说<code>scanf</code>不安全，然后你会发现vs给你提供了<code>scanf_s</code>去代替<code>scanf</code>,<strong>但是</strong>,只有vs能编译<code>scanf_s</code>,<strong>可移植性</strong>太差了，所以我们要用回<code>scanf</code>,所以要怎么不让它报错呢？<strong>可以在源文件开头添加一行宏定义(如下)</strong></p>\n<p><code>#define  _CRT_SECURE_NO_WARNINGS 1</code></p>\n<p>这样就能<strong>关闭报错</strong>了,但请先<strong>别急着走</strong>,每次都要复制粘贴一句宏定义太麻烦了，想<strong>一劳永逸</strong>的请往下看。</p>\n<h1 id=\"修改newc-file-cpp来自动添加宏定义\"><a href=\"#修改newc-file-cpp来自动添加宏定义\" class=\"headerlink\" title=\"修改newc++file.cpp来自动添加宏定义\"></a>修改newc++file.cpp来自动添加宏定义</h1><p><strong>先来看怎么做：</strong>首先搜索找到电脑中叫做<code>newc++file.cpp</code>的文件。（这里推荐使用<a href=\"https://www.voidtools.com/zh-cn/downloads/\">everything</a>）</p>\n<hr>\n<p><em>后半段路径应与图片一致，注意不是快捷方式</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/newcppfile.jpg\" alt=\"c++文件的位置\"></p>\n<hr>\n<p><strong>注意</strong>：由于权限原因，<strong>无法</strong>直接修改此文件</p>\n<p>所以先将这个文件复制粘贴到别处，例如桌面，下文用<code>副本</code>代称。</p>\n<p>用记事本类软件(记事本就行)打开<code>副本</code>,在第一行输入上文提到的宏定义代码<code>#define  _CRT_SECURE_NO_WARNINGS 1</code>,然后<code>ctrl+s</code>保存。</p>\n<p><strong>关闭编辑窗口</strong>，将该<code>副本</code>移动到原始文件所在文件夹，弹出如下窗口，然后选择<strong>替换文件</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-18.jpg\"></p>\n<p>接着弹出下一个提示，点<strong>接续</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-33.jpg\"></p>\n<p>等待它替换完成，然后<strong>大功告成！</strong>。之后新建的每一个<code>.c</code>或<code>.cpp</code> 文件都会自带那段宏定义，于是<code>scanf</code>从此任君使用。<del>当然平时删代码的时候记得别把那段宏定义删了</del></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>VS所新建的<code>.c</code>和<code>.cpp</code>文件都源自于对上文<code>newc++file.cpp</code>文件的拷贝，通过修改它就能改变<code>VS新建文件</code>的初始内容</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed.supdriver.top/img/avatar.png","cover_type":"img","excerpt":"","more":"<h1 id=\"VS里怎么连scanf都用不了？\"><a href=\"#VS里怎么连scanf都用不了？\" class=\"headerlink\" title=\"VS里怎么连scanf都用不了？\"></a>VS里怎么连scanf都用不了？</h1><p>不少刚接触<a href=\"https://visualstudio.microsoft.com/zh-hans/free-developer-offers/\">Visual Studio</a>的可能发现使用scanf会报错(如下)</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/VS_scanf.jpg\" alt=\"报错图片\"></p>\n<p>vs告诉你说<code>scanf</code>不安全，然后你会发现vs给你提供了<code>scanf_s</code>去代替<code>scanf</code>,<strong>但是</strong>,只有vs能编译<code>scanf_s</code>,<strong>可移植性</strong>太差了，所以我们要用回<code>scanf</code>,所以要怎么不让它报错呢？<strong>可以在源文件开头添加一行宏定义(如下)</strong></p>\n<p><code>#define  _CRT_SECURE_NO_WARNINGS 1</code></p>\n<p>这样就能<strong>关闭报错</strong>了,但请先<strong>别急着走</strong>,每次都要复制粘贴一句宏定义太麻烦了，想<strong>一劳永逸</strong>的请往下看。</p>\n<h1 id=\"修改newc-file-cpp来自动添加宏定义\"><a href=\"#修改newc-file-cpp来自动添加宏定义\" class=\"headerlink\" title=\"修改newc++file.cpp来自动添加宏定义\"></a>修改newc++file.cpp来自动添加宏定义</h1><p><strong>先来看怎么做：</strong>首先搜索找到电脑中叫做<code>newc++file.cpp</code>的文件。（这里推荐使用<a href=\"https://www.voidtools.com/zh-cn/downloads/\">everything</a>）</p>\n<hr>\n<p><em>后半段路径应与图片一致，注意不是快捷方式</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/newcppfile.jpg\" alt=\"c++文件的位置\"></p>\n<hr>\n<p><strong>注意</strong>：由于权限原因，<strong>无法</strong>直接修改此文件</p>\n<p>所以先将这个文件复制粘贴到别处，例如桌面，下文用<code>副本</code>代称。</p>\n<p>用记事本类软件(记事本就行)打开<code>副本</code>,在第一行输入上文提到的宏定义代码<code>#define  _CRT_SECURE_NO_WARNINGS 1</code>,然后<code>ctrl+s</code>保存。</p>\n<p><strong>关闭编辑窗口</strong>，将该<code>副本</code>移动到原始文件所在文件夹，弹出如下窗口，然后选择<strong>替换文件</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-18.jpg\"></p>\n<p>接着弹出下一个提示，点<strong>接续</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-33.jpg\"></p>\n<p>等待它替换完成，然后<strong>大功告成！</strong>。之后新建的每一个<code>.c</code>或<code>.cpp</code> 文件都会自带那段宏定义，于是<code>scanf</code>从此任君使用。<del>当然平时删代码的时候记得别把那段宏定义删了</del></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>VS所新建的<code>.c</code>和<code>.cpp</code>文件都源自于对上文<code>newc++file.cpp</code>文件的拷贝，通过修改它就能改变<code>VS新建文件</code>的初始内容</p>\n"},{"title":"=回顾-前端=从简陋的html到单网页再到全栈开发","date":"2023-09-23T01:58:24.000Z","_content":"[👉点我去作业一](https://picbed.supdriver.top/html/prj_basis++/index.html)\n\n[👉点我去作业二](https://picbed.supdriver.top/html/adc_v2/index.html)\n\n[👉点我去作业三](http://localhost:5173/)(抱歉，还没部署到服务器里，这个只能在我自己的电脑里用)\n\n[👉点我去作业四](https://picbed.supdriver.top/video/never.mp4)\n\n~~其实这依然是个博客~~\n\n---\n# 粗糙的作业一 #\n当时只学过html,css,js的快速入门，对盒子`<div>`的玩法还不太熟，还只会用浮动盒子`float`和绝对定位,结局就是写两句html就得清除浮动~~233~~,甚至`<lenged>`也不认识，结果手动用css给实现了。总之就挺简陋的\n\n# 精致~~(并不)~~作业二 #\n用vscode写作业二的时候，写一半发现鼠标悬停在`tag`时，它会给出去往[*MDN*](https://developer.mozilla.org/zh-CN/)对应参考页的连接,然后就开始一边写一边阅读MDN,结果一发不可收拾，开始读的时间比写的时间还长。最后成功学到神器~~bushi~~`flex`**弹性盒子模型。**。\n\n但还没完，除了参阅文档，我还多次在B站首页和MC百度百科首页打开`F12`,查看，学习他们是如何布局盒子的，别说，学成品也挺有用的，对盒子的排版，嵌套的想法成熟多了\n\n结合二者，照着图片做一个网页便没什么问题了。那个作业二我甚至直接弃掉了初版（已经把顶部做好了）version2基本完全采用`flex盒子`。比较遗憾的是，虽然每个菜单按钮都加了超链接，但是对应的网页并没有做出来（创作力有限）。但至少是个合格的花瓶，嘿嘿\n\n# 速成作业三 #\n因为作业三没部署到服务器上，只能文字描述了（悲）\n\n作业三我选的是用`vue`搭建个人博客，我先是自学了几天vue,结果发现光学vue就做不了个人博客，于是在B站上找了个时长6小时的全栈开发，用`js`写的服务端，数据库用`sqlite`,前端框架是`vue`.\n\n好家伙，5天爆肝项目（包括但不限于*抄代码*,*找bug*,*找bug*,*找bug*），成功把博客的基本功能写完了。除了`Naive UI`的代码是复制**组件库**里的，剩下的代码基本都是我**手打**的，可以说忙得不亦乐乎，而且当时我并不太懂`js语法`，体验可以说是相当刺激了。\n\n但**回报不小**，就算不能说入门吧，到时候自己加功能，照葫芦画瓢，自己写`js`的能力还是有了滴。而且这也是我首次**接触数据库**,混个脸熟，嘿嘿。而且**最重要**的一点，我成功增加了一个**高自由度的个人博客**，~~讲真hexo的各自魔改我不太玩的懂~~。\n\n## 尾声 #\n作业三部曲之后，我大概就不太去碰前端了，至少一周爆肝一个全栈开发项目这种疯狂的行为不会再有了，权当是一次挑战罢，一次冒险，一次对边界的探索罢。重心很明确，对前端顶多写写像这篇博客一样的感悟，技术博客主要还是在后端语言，算法，数据结构之类\n","source":"_posts/vueTheRoad.md","raw":"---\ntitle: =回顾-前端=从简陋的html到单网页再到全栈开发\ndate: 2023-09-23 09:58:24\ntags:\n---\n[👉点我去作业一](https://picbed.supdriver.top/html/prj_basis++/index.html)\n\n[👉点我去作业二](https://picbed.supdriver.top/html/adc_v2/index.html)\n\n[👉点我去作业三](http://localhost:5173/)(抱歉，还没部署到服务器里，这个只能在我自己的电脑里用)\n\n[👉点我去作业四](https://picbed.supdriver.top/video/never.mp4)\n\n~~其实这依然是个博客~~\n\n---\n# 粗糙的作业一 #\n当时只学过html,css,js的快速入门，对盒子`<div>`的玩法还不太熟，还只会用浮动盒子`float`和绝对定位,结局就是写两句html就得清除浮动~~233~~,甚至`<lenged>`也不认识，结果手动用css给实现了。总之就挺简陋的\n\n# 精致~~(并不)~~作业二 #\n用vscode写作业二的时候，写一半发现鼠标悬停在`tag`时，它会给出去往[*MDN*](https://developer.mozilla.org/zh-CN/)对应参考页的连接,然后就开始一边写一边阅读MDN,结果一发不可收拾，开始读的时间比写的时间还长。最后成功学到神器~~bushi~~`flex`**弹性盒子模型。**。\n\n但还没完，除了参阅文档，我还多次在B站首页和MC百度百科首页打开`F12`,查看，学习他们是如何布局盒子的，别说，学成品也挺有用的，对盒子的排版，嵌套的想法成熟多了\n\n结合二者，照着图片做一个网页便没什么问题了。那个作业二我甚至直接弃掉了初版（已经把顶部做好了）version2基本完全采用`flex盒子`。比较遗憾的是，虽然每个菜单按钮都加了超链接，但是对应的网页并没有做出来（创作力有限）。但至少是个合格的花瓶，嘿嘿\n\n# 速成作业三 #\n因为作业三没部署到服务器上，只能文字描述了（悲）\n\n作业三我选的是用`vue`搭建个人博客，我先是自学了几天vue,结果发现光学vue就做不了个人博客，于是在B站上找了个时长6小时的全栈开发，用`js`写的服务端，数据库用`sqlite`,前端框架是`vue`.\n\n好家伙，5天爆肝项目（包括但不限于*抄代码*,*找bug*,*找bug*,*找bug*），成功把博客的基本功能写完了。除了`Naive UI`的代码是复制**组件库**里的，剩下的代码基本都是我**手打**的，可以说忙得不亦乐乎，而且当时我并不太懂`js语法`，体验可以说是相当刺激了。\n\n但**回报不小**，就算不能说入门吧，到时候自己加功能，照葫芦画瓢，自己写`js`的能力还是有了滴。而且这也是我首次**接触数据库**,混个脸熟，嘿嘿。而且**最重要**的一点，我成功增加了一个**高自由度的个人博客**，~~讲真hexo的各自魔改我不太玩的懂~~。\n\n## 尾声 #\n作业三部曲之后，我大概就不太去碰前端了，至少一周爆肝一个全栈开发项目这种疯狂的行为不会再有了，权当是一次挑战罢，一次冒险，一次对边界的探索罢。重心很明确，对前端顶多写写像这篇博客一样的感悟，技术博客主要还是在后端语言，算法，数据结构之类\n","slug":"vueTheRoad","published":1,"updated":"2023-10-03T12:12:18.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloutk948000dkkg65fu4ds6j","content":"<p><a href=\"https://picbed.supdriver.top/html/prj_basis++/index.html\">👉点我去作业一</a></p>\n<p><a href=\"https://picbed.supdriver.top/html/adc_v2/index.html\">👉点我去作业二</a></p>\n<p><a href=\"http://localhost:5173/\">👉点我去作业三</a>(抱歉，还没部署到服务器里，这个只能在我自己的电脑里用)</p>\n<p><a href=\"https://picbed.supdriver.top/video/never.mp4\">👉点我去作业四</a></p>\n<p><del>其实这依然是个博客</del></p>\n<hr>\n<h1 id=\"粗糙的作业一\"><a href=\"#粗糙的作业一\" class=\"headerlink\" title=\"粗糙的作业一\"></a>粗糙的作业一</h1><p>当时只学过html,css,js的快速入门，对盒子<code>&lt;div&gt;</code>的玩法还不太熟，还只会用浮动盒子<code>float</code>和绝对定位,结局就是写两句html就得清除浮动<del>233</del>,甚至<code>&lt;lenged&gt;</code>也不认识，结果手动用css给实现了。总之就挺简陋的</p>\n<h1 id=\"精致-并不-作业二\"><a href=\"#精致-并不-作业二\" class=\"headerlink\" title=\"精致(并不)作业二\"></a>精致<del>(并不)</del>作业二</h1><p>用vscode写作业二的时候，写一半发现鼠标悬停在<code>tag</code>时，它会给出去往<a href=\"https://developer.mozilla.org/zh-CN/\"><em>MDN</em></a>对应参考页的连接,然后就开始一边写一边阅读MDN,结果一发不可收拾，开始读的时间比写的时间还长。最后成功学到神器<del>bushi</del><code>flex</code><strong>弹性盒子模型。</strong>。</p>\n<p>但还没完，除了参阅文档，我还多次在B站首页和MC百度百科首页打开<code>F12</code>,查看，学习他们是如何布局盒子的，别说，学成品也挺有用的，对盒子的排版，嵌套的想法成熟多了</p>\n<p>结合二者，照着图片做一个网页便没什么问题了。那个作业二我甚至直接弃掉了初版（已经把顶部做好了）version2基本完全采用<code>flex盒子</code>。比较遗憾的是，虽然每个菜单按钮都加了超链接，但是对应的网页并没有做出来（创作力有限）。但至少是个合格的花瓶，嘿嘿</p>\n<h1 id=\"速成作业三\"><a href=\"#速成作业三\" class=\"headerlink\" title=\"速成作业三\"></a>速成作业三</h1><p>因为作业三没部署到服务器上，只能文字描述了（悲）</p>\n<p>作业三我选的是用<code>vue</code>搭建个人博客，我先是自学了几天vue,结果发现光学vue就做不了个人博客，于是在B站上找了个时长6小时的全栈开发，用<code>js</code>写的服务端，数据库用<code>sqlite</code>,前端框架是<code>vue</code>.</p>\n<p>好家伙，5天爆肝项目（包括但不限于<em>抄代码</em>,<em>找bug</em>,<em>找bug</em>,<em>找bug</em>），成功把博客的基本功能写完了。除了<code>Naive UI</code>的代码是复制<strong>组件库</strong>里的，剩下的代码基本都是我<strong>手打</strong>的，可以说忙得不亦乐乎，而且当时我并不太懂<code>js语法</code>，体验可以说是相当刺激了。</p>\n<p>但<strong>回报不小</strong>，就算不能说入门吧，到时候自己加功能，照葫芦画瓢，自己写<code>js</code>的能力还是有了滴。而且这也是我首次<strong>接触数据库</strong>,混个脸熟，嘿嘿。而且<strong>最重要</strong>的一点，我成功增加了一个<strong>高自由度的个人博客</strong>，<del>讲真hexo的各自魔改我不太玩的懂</del>。</p>\n<h2 id=\"尾声\"><a href=\"#尾声\" class=\"headerlink\" title=\"尾声\"></a>尾声</h2><p>作业三部曲之后，我大概就不太去碰前端了，至少一周爆肝一个全栈开发项目这种疯狂的行为不会再有了，权当是一次挑战罢，一次冒险，一次对边界的探索罢。重心很明确，对前端顶多写写像这篇博客一样的感悟，技术博客主要还是在后端语言，算法，数据结构之类</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed.supdriver.top/img/avatar.png","cover_type":"img","excerpt":"","more":"<p><a href=\"https://picbed.supdriver.top/html/prj_basis++/index.html\">👉点我去作业一</a></p>\n<p><a href=\"https://picbed.supdriver.top/html/adc_v2/index.html\">👉点我去作业二</a></p>\n<p><a href=\"http://localhost:5173/\">👉点我去作业三</a>(抱歉，还没部署到服务器里，这个只能在我自己的电脑里用)</p>\n<p><a href=\"https://picbed.supdriver.top/video/never.mp4\">👉点我去作业四</a></p>\n<p><del>其实这依然是个博客</del></p>\n<hr>\n<h1 id=\"粗糙的作业一\"><a href=\"#粗糙的作业一\" class=\"headerlink\" title=\"粗糙的作业一\"></a>粗糙的作业一</h1><p>当时只学过html,css,js的快速入门，对盒子<code>&lt;div&gt;</code>的玩法还不太熟，还只会用浮动盒子<code>float</code>和绝对定位,结局就是写两句html就得清除浮动<del>233</del>,甚至<code>&lt;lenged&gt;</code>也不认识，结果手动用css给实现了。总之就挺简陋的</p>\n<h1 id=\"精致-并不-作业二\"><a href=\"#精致-并不-作业二\" class=\"headerlink\" title=\"精致(并不)作业二\"></a>精致<del>(并不)</del>作业二</h1><p>用vscode写作业二的时候，写一半发现鼠标悬停在<code>tag</code>时，它会给出去往<a href=\"https://developer.mozilla.org/zh-CN/\"><em>MDN</em></a>对应参考页的连接,然后就开始一边写一边阅读MDN,结果一发不可收拾，开始读的时间比写的时间还长。最后成功学到神器<del>bushi</del><code>flex</code><strong>弹性盒子模型。</strong>。</p>\n<p>但还没完，除了参阅文档，我还多次在B站首页和MC百度百科首页打开<code>F12</code>,查看，学习他们是如何布局盒子的，别说，学成品也挺有用的，对盒子的排版，嵌套的想法成熟多了</p>\n<p>结合二者，照着图片做一个网页便没什么问题了。那个作业二我甚至直接弃掉了初版（已经把顶部做好了）version2基本完全采用<code>flex盒子</code>。比较遗憾的是，虽然每个菜单按钮都加了超链接，但是对应的网页并没有做出来（创作力有限）。但至少是个合格的花瓶，嘿嘿</p>\n<h1 id=\"速成作业三\"><a href=\"#速成作业三\" class=\"headerlink\" title=\"速成作业三\"></a>速成作业三</h1><p>因为作业三没部署到服务器上，只能文字描述了（悲）</p>\n<p>作业三我选的是用<code>vue</code>搭建个人博客，我先是自学了几天vue,结果发现光学vue就做不了个人博客，于是在B站上找了个时长6小时的全栈开发，用<code>js</code>写的服务端，数据库用<code>sqlite</code>,前端框架是<code>vue</code>.</p>\n<p>好家伙，5天爆肝项目（包括但不限于<em>抄代码</em>,<em>找bug</em>,<em>找bug</em>,<em>找bug</em>），成功把博客的基本功能写完了。除了<code>Naive UI</code>的代码是复制<strong>组件库</strong>里的，剩下的代码基本都是我<strong>手打</strong>的，可以说忙得不亦乐乎，而且当时我并不太懂<code>js语法</code>，体验可以说是相当刺激了。</p>\n<p>但<strong>回报不小</strong>，就算不能说入门吧，到时候自己加功能，照葫芦画瓢，自己写<code>js</code>的能力还是有了滴。而且这也是我首次<strong>接触数据库</strong>,混个脸熟，嘿嘿。而且<strong>最重要</strong>的一点，我成功增加了一个<strong>高自由度的个人博客</strong>，<del>讲真hexo的各自魔改我不太玩的懂</del>。</p>\n<h2 id=\"尾声\"><a href=\"#尾声\" class=\"headerlink\" title=\"尾声\"></a>尾声</h2><p>作业三部曲之后，我大概就不太去碰前端了，至少一周爆肝一个全栈开发项目这种疯狂的行为不会再有了，权当是一次挑战罢，一次冒险，一次对边界的探索罢。重心很明确，对前端顶多写写像这篇博客一样的感悟，技术博客主要还是在后端语言，算法，数据结构之类</p>\n"},{"title":"=C入门=深入研究 字符串与字符数组","date":"2023-11-08T13:11:51.000Z","_content":"# 什么是字符串 #\n## 初见字符串 #\n我们最先遇到的字符串,一般是`hello_world`程序中用到的`\"hello world\"`,也就是**两个双引号括起来的一串字符**,输出时的占位符是`%s`,可以直接拿去传值，代码如下\n```C\nprintf(\"%s\",\"hello world\");\n```\n## 声明字符串变量 #\n有时我们想要先把字符串存起来，再进行操作，那么就使用**字符数组**，并在**初始化**的时候把字符串传给它,这样在**创建数组**时会编译器会自动分配内存给它，代码如下\n\n```C\nchar str[] = \"abcdef\";\n```\n\n此时我们也可以开启VS的**调试**，并打开**内存**和**监视**窗口观察字符串是如何在内存中储存的,如下图\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_10-06-06.jpg)\n\n通过观察可以发现，C语⾔字符串的字符串有个`规定`(特点)，就是以字符`\\0`结尾，无论是初始化数组时，还是在分配内存时，都有`\\0`的位置。\n\n### strlen()函数 #\n依据以`\\0`为字符串结尾的规则，`strlen`函数就可以计算字符串的长度，它会从字符串的第一个字符向后扫描，直到遇到`\\0`结束,且`\\0`不进入计数，最后返回字符串的长度,代码如下\n```C\n#include <string.h> //需要引对应的头文件\n\nint len = strlen(\"abcdef\");//len的值为6\nint sz = sizeof(\"abcdef\");//sz的大小为7(\\0被计入总数)\n```\n\n### 验证字符串的结尾 #\n\n#### 正向验证 #\n我们做在字符数组里插入一个`\\0`,来看看函数`printf`和`strlen`找到的结尾在哪里,如下图\n\n```C\nchar str[] = {'a','b','c','\\0','d','e','f','\\0'};\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_11-01-35.jpg)\n\n可以看到字符数组似乎被“截断”了，`printf`只输出了`\\0`前面的内容, `strlen`算出来的长度也只有`3`,可见插入的`\\0`被作为了**字符串**的结尾，字符串提前中指,而没到达**字符数组**的结尾\n\n\n\n#### 反向验证 #\n\n我们来**反向**验证一下，`\\0`是字符串结尾的标志,如下图，我们声明一个**没有**`\\0`结尾的字符数组，看看函数`printf`和`strlen`还找不找得到我们“认为”的结尾\n```C\nchar str[] = {'a','b','c','d','e','f'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-02-07.jpg)\n\n可以看到函数对字符串的判断出现了严重**失误**，所以**字符数组**里没有`\\0`标记结尾是非常严重的问题，不光是找不到字符串的结尾，而且会**越界访问**！危险操作，写代码的时候一定要注意\n\n---\n\n## 从字符串到字符数组 #\n虽然上面已经用到了字符数组，但主要还是为了方便讨论**字符串**,接下来着重研究字符数组。\n\n### 先整清楚几个概念 #\n`什么是数组`：数组是⼀组相同类型元素的集合,会在内存中开辟一段连续的空间，将元素储存在那段内存中\n\n`什么是数组元素`：存放在数组的值被称为数组的元素，数组在创建的时候可以指定数组的⼤⼩和数组的元素类型。\n\n所以`字符数组`是一组`字符`的集合，字符数组里的`元素`都是`字符`!,访问到的字符数组里的**元素**都是**字符**，像`'a'`,`'b'`,`'c'`这种的单个的字符,别和`字符串`混为一谈！\n\n```C\nchar str = \"abc\";\nint sz = sizeof(str);//这里str代表了整个数组,所以包括\\0\n,sz的值为4\n\n```\n\n### 字符数组的声明 #\n字符数组的声明和其他类型的数组差不多，有**初始化**，**不完全初始化**，**声明长度**，**不声明长度**\n\n*正确的声明代码如下*\n```C\nchar str1[] = \"abc\";//初始化,不声明长度\n\nchar str2[] = {'a','b','c','\\0'};//这也是初始化，且不声明长度\n\nchar str3[10] = { 0 };//初始化，用值0(等价于`\\0`)填充\n\nchar str4[10] = \"abc\";//不完全初始化，存入字符串\"abc\",后面都用'\\0'填充\n\nchar str5[10] = {'a','b','c','d'};//不完全初始化,从下标为0开始，依次往后填充字符 a,b,c,\\0\n\n```\n*错误的声明代码*\n```C\nchar str1[3] = \"abc\";//数组声明短了，放不下结尾的\\0,编译过不了\n\nchar str2[3] = {'a','b','c','d'};//同上,放不下\n\nchar str3[] = { 0 };//能声明，但是字符数组长度为1，这个数组大概率是用不了的/会被拿去错误使用的\n\n```\n### 来看看这些声明方式在内存中的表现 #\n\n#### 不初始化的声明(极度不推荐) #\n```C\nchar str[];//这个不加长度，直接编译失败（如下图）\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-39-10.jpg)\n\n```C\nchar str[10];//语法没有问题，来看看此时数组里存了什么\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-46-49.jpg)\n可以看到全都存了`-52`,对应的中文字符是`烫`，这样**不好**，请在声明字符数组的时候**初始化数组**\n#### 不声明长度的数组声明\n```C\nchar str1[] = \"abc\";\n\nchar str2[] = {'a','b','c','\\0'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-59-34.jpg)\n\n如上图，不声明长度时，编译器自动给字符数组分配内存，既不给多，也不给少，初始化给的`字符串`或者`{...}`多长，创建的数组就多长。\n\n**注意红框**，再强调一遍，字符串以`\\0`结尾,看到双引号括起来的字符串，要记得最后隐藏了一个`\\0`,用字符数组储存的时候一定要留足空间\n\n#### 声明长度的数组声明 #\n```C\nchar str3[10] = { 0 };\n\nchar str4[10] = \"abc\";\n\nchar str5[10] = {'a','b','c','d'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_15-25-54.jpg)\n\n可以看到，在声明的长度**足够长**时，你初始化的时候给它多少字符，它就从`下标0`处开始**按顺序**存进去多少,剩下的部分**自动**用`'\\0'`填充,\n\n所以实际上上面代码中的`str5`因为长度`10`>初始化给的`4`个字符，后面六个元素用`\\0`填充了，所以`str5`里存了有**结尾**的完整字符串\n\n#### 错误声明 #\n```C\nchar str1[3] = \"abc\";\nchar str2[3] = { 'a','b','c','d' };\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-44-57.jpg)\n\n可以看到上面两种错误的声明方式，甚至直接**编译失败**,所以声明字符数组的时候一定要**留足空间**\n\n```C\nchar str3[] = { 0 };\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-51-55.jpg)\n\n如上图，可以看到这样写还是编译成功了，但是在监视查看**数组长度**的时候，发现长度为`1`,里面存了一个`\\0`,这么**短**的数组能用吗？只能**用一点点**，甚至还不如直接声明一个`char`类型的字符变量\n\n## 当字符数组加上const #\n```C\nconst char str[5] = \"abc\";\n```\n### 一些性质 #\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_18-55-52.jpg)\n\n可以看到，声明时加了`const`之后，字符数组`str`在声明时的**初始化**之后便不可更改了，只能**访问**其元素,而**不能通过访问元素来改变数组内容**\n\n那么`scanf`还能写入内容吗？答案是**可以**!*(如下图)*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-10-43.jpg)\n\n那它能拿来初始化别的数组吗？很遗憾，**不能**\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-05-15.jpg)\n\n### 对应的指针类型 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-15-32.jpg)\n\n可以看到，这里得用`const char*`来储存字符数组的地址，而使用`char*`就会报错\n\n那么用`双引号括起来的字符串`，是否也有地址，能用指针储存它的地址呢？\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-21-10.jpg)\n\n如图，可以看到,字符串`\"abc\"`是属于`const char`类型的数组，对应的指针是`const char*`,不能通过访问元素来改变内部的值，也不能用`char*`来储存地址\n\n#### 在内存中的表现 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_str.gif)\n\n可以看到哪怕是字符串`\"abc\"`,也是在内存中开辟了一段空间，并把字符**储存在内存中**了的\n\n但是，**不要**试图用`scanf`去改变字符串的值\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_strrrr.gif)\n\n---\n\n## 如何向字符数组里添加内容 #\n添加的方法多种多样，搞不好可能还会出错，所以把字符数组**学明白**很重要！\n\n以下使用的数组样例声明如下\n```C\nchar str[10] = { 0 };\n```\n\n### 初始化 #\n在初始化的时候就把值传进去，有哪些初始化方式**上面**已经介绍过了，这里不多赘述\n\n### 访问数组元素 #\n通过`[]`可以访问数组元素，并对没有`const`修饰的数组，修改其元素,例如:\n\n```C\nstr[0] = 'A';//将数组的第一个元素改成字符A\n```\n\n我们也可以通过循环的方式，将数组的所有元素填充为某个字符\n\n```C\nchar place_holder = 'A';\nfor(int i = 0; i < 10 ; i++)//这里使用左闭右开区间，10为数组的大小\n{\n    str[i] = place_holder;\n}\n```\n\n### 使用`scanf`函数 #\n由上面的探究已知：对于已声明的字符数组，**无论**有没有`const`修饰，都可已用`scanf`修改内容,那么`scanf`怎么用，又具体怎么工作的，我们接着往下探究\n\n#### 使用示例 #\n```C\nchar str[10] = { 0 };\nscanf(\"%s\",str);//占位符是 %s ,右边的参数是 str ,也就是数组名\n//或者 scanf(\"%s\",&str)\n```\n**注意**！这边的数组名`str`储存的是**数组首元素的地址**，而`&str`储存的是`整个数组的地址`，值是一样的，两者皆可用于传参，但**指针类型不一样**，要做好区分\n\n#### `scanf`都做了什么 #\n先来看看它分别对用`{ 0 }`**初始化**和**不初始化**的数组做了什么\n```C\nchar str1[10] = { 0 };\nscanf(\"%s\",str1);\nchar str2[10];\nscanf(\"%s\",str2);\n```\n*两个数组的输入均为abc*\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-11_19-09-50.jpg)\n\n可以看到，对`str1`,字符非常正常地填充进去了，因为整个数组原本是用`\\0`填充的,看不出什么端倪\n\n而对于`str2`,观察发现，除了输入进去的字符`a`,`b`,`c`,它还自动在结尾补了一个`\\0`,使`str2`里储存了一个完整的字符串。**但是**，剩下的部分还是用**值**`-52`填充，即未初始化的状态，所以依然**不提倡**声明的时候没有初始化\n\n然后是在字符数组内已有内容的情况下，再次使用`scanf`的情况\n```C\nchar str1[5] = \"abc\";\nchar str2[5] = \"abc\";\n\nscanf(\"%s %s\",str1,str2);\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-33-02.jpg)\n\n如图，`scanf`做的是把输入的字符串`覆盖`式存入字符数组，比原来长，就完全覆盖，比原来短，就部分覆盖，未覆盖的部分无改动\n\n#### 关于`scanf`的危险操作 #\n由于`scanf`无法预测**字符数组**能否存下输入的**字符串**，如果**字符数组**声明的长度不够，就可能出现**越界访问**,随之而来的便是奇奇怪怪的`bug`\n\n```C\nchar str[4] = { 0 };//先声明一个长度为4的数组\nscanf(\"%s\",str);//这次输入abcdef试试\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-47-00.jpg)\n\n可以看到，确实**越界访问**了，所以声明字符数组的时候，建议比预计最大输入，在多些长度，防止越界访问。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/str-arr.md","raw":"---\ntitle: =C入门=深入研究 字符串与字符数组\ndate: 2023-11-08 21:11:51\ntags:\n---\n# 什么是字符串 #\n## 初见字符串 #\n我们最先遇到的字符串,一般是`hello_world`程序中用到的`\"hello world\"`,也就是**两个双引号括起来的一串字符**,输出时的占位符是`%s`,可以直接拿去传值，代码如下\n```C\nprintf(\"%s\",\"hello world\");\n```\n## 声明字符串变量 #\n有时我们想要先把字符串存起来，再进行操作，那么就使用**字符数组**，并在**初始化**的时候把字符串传给它,这样在**创建数组**时会编译器会自动分配内存给它，代码如下\n\n```C\nchar str[] = \"abcdef\";\n```\n\n此时我们也可以开启VS的**调试**，并打开**内存**和**监视**窗口观察字符串是如何在内存中储存的,如下图\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_10-06-06.jpg)\n\n通过观察可以发现，C语⾔字符串的字符串有个`规定`(特点)，就是以字符`\\0`结尾，无论是初始化数组时，还是在分配内存时，都有`\\0`的位置。\n\n### strlen()函数 #\n依据以`\\0`为字符串结尾的规则，`strlen`函数就可以计算字符串的长度，它会从字符串的第一个字符向后扫描，直到遇到`\\0`结束,且`\\0`不进入计数，最后返回字符串的长度,代码如下\n```C\n#include <string.h> //需要引对应的头文件\n\nint len = strlen(\"abcdef\");//len的值为6\nint sz = sizeof(\"abcdef\");//sz的大小为7(\\0被计入总数)\n```\n\n### 验证字符串的结尾 #\n\n#### 正向验证 #\n我们做在字符数组里插入一个`\\0`,来看看函数`printf`和`strlen`找到的结尾在哪里,如下图\n\n```C\nchar str[] = {'a','b','c','\\0','d','e','f','\\0'};\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_11-01-35.jpg)\n\n可以看到字符数组似乎被“截断”了，`printf`只输出了`\\0`前面的内容, `strlen`算出来的长度也只有`3`,可见插入的`\\0`被作为了**字符串**的结尾，字符串提前中指,而没到达**字符数组**的结尾\n\n\n\n#### 反向验证 #\n\n我们来**反向**验证一下，`\\0`是字符串结尾的标志,如下图，我们声明一个**没有**`\\0`结尾的字符数组，看看函数`printf`和`strlen`还找不找得到我们“认为”的结尾\n```C\nchar str[] = {'a','b','c','d','e','f'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-02-07.jpg)\n\n可以看到函数对字符串的判断出现了严重**失误**，所以**字符数组**里没有`\\0`标记结尾是非常严重的问题，不光是找不到字符串的结尾，而且会**越界访问**！危险操作，写代码的时候一定要注意\n\n---\n\n## 从字符串到字符数组 #\n虽然上面已经用到了字符数组，但主要还是为了方便讨论**字符串**,接下来着重研究字符数组。\n\n### 先整清楚几个概念 #\n`什么是数组`：数组是⼀组相同类型元素的集合,会在内存中开辟一段连续的空间，将元素储存在那段内存中\n\n`什么是数组元素`：存放在数组的值被称为数组的元素，数组在创建的时候可以指定数组的⼤⼩和数组的元素类型。\n\n所以`字符数组`是一组`字符`的集合，字符数组里的`元素`都是`字符`!,访问到的字符数组里的**元素**都是**字符**，像`'a'`,`'b'`,`'c'`这种的单个的字符,别和`字符串`混为一谈！\n\n```C\nchar str = \"abc\";\nint sz = sizeof(str);//这里str代表了整个数组,所以包括\\0\n,sz的值为4\n\n```\n\n### 字符数组的声明 #\n字符数组的声明和其他类型的数组差不多，有**初始化**，**不完全初始化**，**声明长度**，**不声明长度**\n\n*正确的声明代码如下*\n```C\nchar str1[] = \"abc\";//初始化,不声明长度\n\nchar str2[] = {'a','b','c','\\0'};//这也是初始化，且不声明长度\n\nchar str3[10] = { 0 };//初始化，用值0(等价于`\\0`)填充\n\nchar str4[10] = \"abc\";//不完全初始化，存入字符串\"abc\",后面都用'\\0'填充\n\nchar str5[10] = {'a','b','c','d'};//不完全初始化,从下标为0开始，依次往后填充字符 a,b,c,\\0\n\n```\n*错误的声明代码*\n```C\nchar str1[3] = \"abc\";//数组声明短了，放不下结尾的\\0,编译过不了\n\nchar str2[3] = {'a','b','c','d'};//同上,放不下\n\nchar str3[] = { 0 };//能声明，但是字符数组长度为1，这个数组大概率是用不了的/会被拿去错误使用的\n\n```\n### 来看看这些声明方式在内存中的表现 #\n\n#### 不初始化的声明(极度不推荐) #\n```C\nchar str[];//这个不加长度，直接编译失败（如下图）\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-39-10.jpg)\n\n```C\nchar str[10];//语法没有问题，来看看此时数组里存了什么\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-46-49.jpg)\n可以看到全都存了`-52`,对应的中文字符是`烫`，这样**不好**，请在声明字符数组的时候**初始化数组**\n#### 不声明长度的数组声明\n```C\nchar str1[] = \"abc\";\n\nchar str2[] = {'a','b','c','\\0'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-59-34.jpg)\n\n如上图，不声明长度时，编译器自动给字符数组分配内存，既不给多，也不给少，初始化给的`字符串`或者`{...}`多长，创建的数组就多长。\n\n**注意红框**，再强调一遍，字符串以`\\0`结尾,看到双引号括起来的字符串，要记得最后隐藏了一个`\\0`,用字符数组储存的时候一定要留足空间\n\n#### 声明长度的数组声明 #\n```C\nchar str3[10] = { 0 };\n\nchar str4[10] = \"abc\";\n\nchar str5[10] = {'a','b','c','d'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_15-25-54.jpg)\n\n可以看到，在声明的长度**足够长**时，你初始化的时候给它多少字符，它就从`下标0`处开始**按顺序**存进去多少,剩下的部分**自动**用`'\\0'`填充,\n\n所以实际上上面代码中的`str5`因为长度`10`>初始化给的`4`个字符，后面六个元素用`\\0`填充了，所以`str5`里存了有**结尾**的完整字符串\n\n#### 错误声明 #\n```C\nchar str1[3] = \"abc\";\nchar str2[3] = { 'a','b','c','d' };\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-44-57.jpg)\n\n可以看到上面两种错误的声明方式，甚至直接**编译失败**,所以声明字符数组的时候一定要**留足空间**\n\n```C\nchar str3[] = { 0 };\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-51-55.jpg)\n\n如上图，可以看到这样写还是编译成功了，但是在监视查看**数组长度**的时候，发现长度为`1`,里面存了一个`\\0`,这么**短**的数组能用吗？只能**用一点点**，甚至还不如直接声明一个`char`类型的字符变量\n\n## 当字符数组加上const #\n```C\nconst char str[5] = \"abc\";\n```\n### 一些性质 #\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_18-55-52.jpg)\n\n可以看到，声明时加了`const`之后，字符数组`str`在声明时的**初始化**之后便不可更改了，只能**访问**其元素,而**不能通过访问元素来改变数组内容**\n\n那么`scanf`还能写入内容吗？答案是**可以**!*(如下图)*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-10-43.jpg)\n\n那它能拿来初始化别的数组吗？很遗憾，**不能**\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-05-15.jpg)\n\n### 对应的指针类型 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-15-32.jpg)\n\n可以看到，这里得用`const char*`来储存字符数组的地址，而使用`char*`就会报错\n\n那么用`双引号括起来的字符串`，是否也有地址，能用指针储存它的地址呢？\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-21-10.jpg)\n\n如图，可以看到,字符串`\"abc\"`是属于`const char`类型的数组，对应的指针是`const char*`,不能通过访问元素来改变内部的值，也不能用`char*`来储存地址\n\n#### 在内存中的表现 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_str.gif)\n\n可以看到哪怕是字符串`\"abc\"`,也是在内存中开辟了一段空间，并把字符**储存在内存中**了的\n\n但是，**不要**试图用`scanf`去改变字符串的值\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_strrrr.gif)\n\n---\n\n## 如何向字符数组里添加内容 #\n添加的方法多种多样，搞不好可能还会出错，所以把字符数组**学明白**很重要！\n\n以下使用的数组样例声明如下\n```C\nchar str[10] = { 0 };\n```\n\n### 初始化 #\n在初始化的时候就把值传进去，有哪些初始化方式**上面**已经介绍过了，这里不多赘述\n\n### 访问数组元素 #\n通过`[]`可以访问数组元素，并对没有`const`修饰的数组，修改其元素,例如:\n\n```C\nstr[0] = 'A';//将数组的第一个元素改成字符A\n```\n\n我们也可以通过循环的方式，将数组的所有元素填充为某个字符\n\n```C\nchar place_holder = 'A';\nfor(int i = 0; i < 10 ; i++)//这里使用左闭右开区间，10为数组的大小\n{\n    str[i] = place_holder;\n}\n```\n\n### 使用`scanf`函数 #\n由上面的探究已知：对于已声明的字符数组，**无论**有没有`const`修饰，都可已用`scanf`修改内容,那么`scanf`怎么用，又具体怎么工作的，我们接着往下探究\n\n#### 使用示例 #\n```C\nchar str[10] = { 0 };\nscanf(\"%s\",str);//占位符是 %s ,右边的参数是 str ,也就是数组名\n//或者 scanf(\"%s\",&str)\n```\n**注意**！这边的数组名`str`储存的是**数组首元素的地址**，而`&str`储存的是`整个数组的地址`，值是一样的，两者皆可用于传参，但**指针类型不一样**，要做好区分\n\n#### `scanf`都做了什么 #\n先来看看它分别对用`{ 0 }`**初始化**和**不初始化**的数组做了什么\n```C\nchar str1[10] = { 0 };\nscanf(\"%s\",str1);\nchar str2[10];\nscanf(\"%s\",str2);\n```\n*两个数组的输入均为abc*\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-11_19-09-50.jpg)\n\n可以看到，对`str1`,字符非常正常地填充进去了，因为整个数组原本是用`\\0`填充的,看不出什么端倪\n\n而对于`str2`,观察发现，除了输入进去的字符`a`,`b`,`c`,它还自动在结尾补了一个`\\0`,使`str2`里储存了一个完整的字符串。**但是**，剩下的部分还是用**值**`-52`填充，即未初始化的状态，所以依然**不提倡**声明的时候没有初始化\n\n然后是在字符数组内已有内容的情况下，再次使用`scanf`的情况\n```C\nchar str1[5] = \"abc\";\nchar str2[5] = \"abc\";\n\nscanf(\"%s %s\",str1,str2);\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-33-02.jpg)\n\n如图，`scanf`做的是把输入的字符串`覆盖`式存入字符数组，比原来长，就完全覆盖，比原来短，就部分覆盖，未覆盖的部分无改动\n\n#### 关于`scanf`的危险操作 #\n由于`scanf`无法预测**字符数组**能否存下输入的**字符串**，如果**字符数组**声明的长度不够，就可能出现**越界访问**,随之而来的便是奇奇怪怪的`bug`\n\n```C\nchar str[4] = { 0 };//先声明一个长度为4的数组\nscanf(\"%s\",str);//这次输入abcdef试试\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-47-00.jpg)\n\n可以看到，确实**越界访问**了，所以声明字符数组的时候，建议比预计最大输入，在多些长度，防止越界访问。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"str-arr","published":1,"updated":"2023-11-12T01:50:53.558Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloutk948000ekkg6huoedcbh","content":"<h1 id=\"什么是字符串\"><a href=\"#什么是字符串\" class=\"headerlink\" title=\"什么是字符串\"></a>什么是字符串</h1><h2 id=\"初见字符串\"><a href=\"#初见字符串\" class=\"headerlink\" title=\"初见字符串\"></a>初见字符串</h2><p>我们最先遇到的字符串,一般是<code>hello_world</code>程序中用到的<code>&quot;hello world&quot;</code>,也就是<strong>两个双引号括起来的一串字符</strong>,输出时的占位符是<code>%s</code>,可以直接拿去传值，代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>,<span class=\"string\">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明字符串变量\"><a href=\"#声明字符串变量\" class=\"headerlink\" title=\"声明字符串变量\"></a>声明字符串变量</h2><p>有时我们想要先把字符串存起来，再进行操作，那么就使用<strong>字符数组</strong>，并在<strong>初始化</strong>的时候把字符串传给它,这样在<strong>创建数组</strong>时会编译器会自动分配内存给它，代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = <span class=\"string\">&quot;abcdef&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们也可以开启VS的<strong>调试</strong>，并打开<strong>内存</strong>和<strong>监视</strong>窗口观察字符串是如何在内存中储存的,如下图</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_10-06-06.jpg\"></p>\n<p>通过观察可以发现，C语⾔字符串的字符串有个<code>规定</code>(特点)，就是以字符<code>\\0</code>结尾，无论是初始化数组时，还是在分配内存时，都有<code>\\0</code>的位置。</p>\n<h3 id=\"strlen-函数\"><a href=\"#strlen-函数\" class=\"headerlink\" title=\"strlen()函数\"></a>strlen()函数</h3><p>依据以<code>\\0</code>为字符串结尾的规则，<code>strlen</code>函数就可以计算字符串的长度，它会从字符串的第一个字符向后扫描，直到遇到<code>\\0</code>结束,且<code>\\0</code>不进入计数，最后返回字符串的长度,代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span> <span class=\"comment\">//需要引对应的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(<span class=\"string\">&quot;abcdef&quot;</span>);<span class=\"comment\">//len的值为6</span></span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(<span class=\"string\">&quot;abcdef&quot;</span>);<span class=\"comment\">//sz的大小为7(\\0被计入总数)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"验证字符串的结尾\"><a href=\"#验证字符串的结尾\" class=\"headerlink\" title=\"验证字符串的结尾\"></a>验证字符串的结尾</h3><h4 id=\"正向验证\"><a href=\"#正向验证\" class=\"headerlink\" title=\"正向验证\"></a>正向验证</h4><p>我们做在字符数组里插入一个<code>\\0</code>,来看看函数<code>printf</code>和<code>strlen</code>找到的结尾在哪里,如下图</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;f&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_11-01-35.jpg\"></p>\n<p>可以看到字符数组似乎被“截断”了，<code>printf</code>只输出了<code>\\0</code>前面的内容, <code>strlen</code>算出来的长度也只有<code>3</code>,可见插入的<code>\\0</code>被作为了<strong>字符串</strong>的结尾，字符串提前中指,而没到达<strong>字符数组</strong>的结尾</p>\n<h4 id=\"反向验证\"><a href=\"#反向验证\" class=\"headerlink\" title=\"反向验证\"></a>反向验证</h4><p>我们来<strong>反向</strong>验证一下，<code>\\0</code>是字符串结尾的标志,如下图，我们声明一个<strong>没有</strong><code>\\0</code>结尾的字符数组，看看函数<code>printf</code>和<code>strlen</code>还找不找得到我们“认为”的结尾</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;f&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-02-07.jpg\"></p>\n<p>可以看到函数对字符串的判断出现了严重<strong>失误</strong>，所以<strong>字符数组</strong>里没有<code>\\0</code>标记结尾是非常严重的问题，不光是找不到字符串的结尾，而且会<strong>越界访问</strong>！危险操作，写代码的时候一定要注意</p>\n<hr>\n<h2 id=\"从字符串到字符数组\"><a href=\"#从字符串到字符数组\" class=\"headerlink\" title=\"从字符串到字符数组\"></a>从字符串到字符数组</h2><p>虽然上面已经用到了字符数组，但主要还是为了方便讨论<strong>字符串</strong>,接下来着重研究字符数组。</p>\n<h3 id=\"先整清楚几个概念\"><a href=\"#先整清楚几个概念\" class=\"headerlink\" title=\"先整清楚几个概念\"></a>先整清楚几个概念</h3><p><code>什么是数组</code>：数组是⼀组相同类型元素的集合,会在内存中开辟一段连续的空间，将元素储存在那段内存中</p>\n<p><code>什么是数组元素</code>：存放在数组的值被称为数组的元素，数组在创建的时候可以指定数组的⼤⼩和数组的元素类型。</p>\n<p>所以<code>字符数组</code>是一组<code>字符</code>的集合，字符数组里的<code>元素</code>都是<code>字符</code>!,访问到的字符数组里的<strong>元素</strong>都是<strong>字符</strong>，像<code>&#39;a&#39;</code>,<code>&#39;b&#39;</code>,<code>&#39;c&#39;</code>这种的单个的字符,别和<code>字符串</code>混为一谈！</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(str);<span class=\"comment\">//这里str代表了整个数组,所以包括\\0</span></span><br><span class=\"line\">,sz的值为<span class=\"number\">4</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符数组的声明\"><a href=\"#字符数组的声明\" class=\"headerlink\" title=\"字符数组的声明\"></a>字符数组的声明</h3><p>字符数组的声明和其他类型的数组差不多，有<strong>初始化</strong>，<strong>不完全初始化</strong>，<strong>声明长度</strong>，<strong>不声明长度</strong></p>\n<p><em>正确的声明代码如下</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//初始化,不声明长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;<span class=\"comment\">//这也是初始化，且不声明长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str3[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//初始化，用值0(等价于`\\0`)填充</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str4[<span class=\"number\">10</span>] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//不完全初始化，存入字符串&quot;abc&quot;,后面都用&#x27;\\0&#x27;填充</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str5[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;<span class=\"comment\">//不完全初始化,从下标为0开始，依次往后填充字符 a,b,c,\\0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em>错误的声明代码</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">3</span>] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//数组声明短了，放不下结尾的\\0,编译过不了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">3</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;<span class=\"comment\">//同上,放不下</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str3[] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//能声明，但是字符数组长度为1，这个数组大概率是用不了的/会被拿去错误使用的</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"来看看这些声明方式在内存中的表现\"><a href=\"#来看看这些声明方式在内存中的表现\" class=\"headerlink\" title=\"来看看这些声明方式在内存中的表现\"></a>来看看这些声明方式在内存中的表现</h3><h4 id=\"不初始化的声明-极度不推荐\"><a href=\"#不初始化的声明-极度不推荐\" class=\"headerlink\" title=\"不初始化的声明(极度不推荐)\"></a>不初始化的声明(极度不推荐)</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[];<span class=\"comment\">//这个不加长度，直接编译失败（如下图）</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-39-10.jpg\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>];<span class=\"comment\">//语法没有问题，来看看此时数组里存了什么</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-46-49.jpg\"><br>可以看到全都存了<code>-52</code>,对应的中文字符是<code>烫</code>，这样<strong>不好</strong>，请在声明字符数组的时候<strong>初始化数组</strong></p>\n<h4 id=\"不声明长度的数组声明\"><a href=\"#不声明长度的数组声明\" class=\"headerlink\" title=\"不声明长度的数组声明\"></a>不声明长度的数组声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-59-34.jpg\"></p>\n<p>如上图，不声明长度时，编译器自动给字符数组分配内存，既不给多，也不给少，初始化给的<code>字符串</code>或者<code>&#123;...&#125;</code>多长，创建的数组就多长。</p>\n<p><strong>注意红框</strong>，再强调一遍，字符串以<code>\\0</code>结尾,看到双引号括起来的字符串，要记得最后隐藏了一个<code>\\0</code>,用字符数组储存的时候一定要留足空间</p>\n<h4 id=\"声明长度的数组声明\"><a href=\"#声明长度的数组声明\" class=\"headerlink\" title=\"声明长度的数组声明\"></a>声明长度的数组声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str3[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str4[<span class=\"number\">10</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str5[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_15-25-54.jpg\"></p>\n<p>可以看到，在声明的长度<strong>足够长</strong>时，你初始化的时候给它多少字符，它就从<code>下标0</code>处开始<strong>按顺序</strong>存进去多少,剩下的部分<strong>自动</strong>用<code>&#39;\\0&#39;</code>填充,</p>\n<p>所以实际上上面代码中的<code>str5</code>因为长度<code>10</code>&gt;初始化给的<code>4</code>个字符，后面六个元素用<code>\\0</code>填充了，所以<code>str5</code>里存了有<strong>结尾</strong>的完整字符串</p>\n<h4 id=\"错误声明\"><a href=\"#错误声明\" class=\"headerlink\" title=\"错误声明\"></a>错误声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">3</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">3</span>] = &#123; <span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-44-57.jpg\"></p>\n<p>可以看到上面两种错误的声明方式，甚至直接<strong>编译失败</strong>,所以声明字符数组的时候一定要<strong>留足空间</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str3[] = &#123; <span class=\"number\">0</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-51-55.jpg\"></p>\n<p>如上图，可以看到这样写还是编译成功了，但是在监视查看<strong>数组长度</strong>的时候，发现长度为<code>1</code>,里面存了一个<code>\\0</code>,这么<strong>短</strong>的数组能用吗？只能<strong>用一点点</strong>，甚至还不如直接声明一个<code>char</code>类型的字符变量</p>\n<h2 id=\"当字符数组加上const\"><a href=\"#当字符数组加上const\" class=\"headerlink\" title=\"当字符数组加上const\"></a>当字符数组加上const</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> str[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"一些性质\"><a href=\"#一些性质\" class=\"headerlink\" title=\"一些性质\"></a>一些性质</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_18-55-52.jpg\"></p>\n<p>可以看到，声明时加了<code>const</code>之后，字符数组<code>str</code>在声明时的<strong>初始化</strong>之后便不可更改了，只能<strong>访问</strong>其元素,而<strong>不能通过访问元素来改变数组内容</strong></p>\n<p>那么<code>scanf</code>还能写入内容吗？答案是<strong>可以</strong>!<em>(如下图)</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-10-43.jpg\"></p>\n<p>那它能拿来初始化别的数组吗？很遗憾，<strong>不能</strong><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-05-15.jpg\"></p>\n<h3 id=\"对应的指针类型\"><a href=\"#对应的指针类型\" class=\"headerlink\" title=\"对应的指针类型\"></a>对应的指针类型</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-15-32.jpg\"></p>\n<p>可以看到，这里得用<code>const char*</code>来储存字符数组的地址，而使用<code>char*</code>就会报错</p>\n<p>那么用<code>双引号括起来的字符串</code>，是否也有地址，能用指针储存它的地址呢？</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-21-10.jpg\"></p>\n<p>如图，可以看到,字符串<code>&quot;abc&quot;</code>是属于<code>const char</code>类型的数组，对应的指针是<code>const char*</code>,不能通过访问元素来改变内部的值，也不能用<code>char*</code>来储存地址</p>\n<h4 id=\"在内存中的表现\"><a href=\"#在内存中的表现\" class=\"headerlink\" title=\"在内存中的表现\"></a>在内存中的表现</h4><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_str.gif\"></p>\n<p>可以看到哪怕是字符串<code>&quot;abc&quot;</code>,也是在内存中开辟了一段空间，并把字符<strong>储存在内存中</strong>了的</p>\n<p>但是，<strong>不要</strong>试图用<code>scanf</code>去改变字符串的值<br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_strrrr.gif\"></p>\n<hr>\n<h2 id=\"如何向字符数组里添加内容\"><a href=\"#如何向字符数组里添加内容\" class=\"headerlink\" title=\"如何向字符数组里添加内容\"></a>如何向字符数组里添加内容</h2><p>添加的方法多种多样，搞不好可能还会出错，所以把字符数组<strong>学明白</strong>很重要！</p>\n<p>以下使用的数组样例声明如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>在初始化的时候就把值传进去，有哪些初始化方式<strong>上面</strong>已经介绍过了，这里不多赘述</p>\n<h3 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h3><p>通过<code>[]</code>可以访问数组元素，并对没有<code>const</code>修饰的数组，修改其元素,例如:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;A&#x27;</span>;<span class=\"comment\">//将数组的第一个元素改成字符A</span></span><br></pre></td></tr></table></figure>\n\n<p>我们也可以通过循环的方式，将数组的所有元素填充为某个字符</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> place_holder = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++)<span class=\"comment\">//这里使用左闭右开区间，10为数组的大小</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    str[i] = place_holder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用scanf函数\"><a href=\"#使用scanf函数\" class=\"headerlink\" title=\"使用scanf函数\"></a>使用<code>scanf</code>函数</h3><p>由上面的探究已知：对于已声明的字符数组，<strong>无论</strong>有没有<code>const</code>修饰，都可已用<code>scanf</code>修改内容,那么<code>scanf</code>怎么用，又具体怎么工作的，我们接着往下探究</p>\n<h4 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str);<span class=\"comment\">//占位符是 %s ,右边的参数是 str ,也就是数组名</span></span><br><span class=\"line\"><span class=\"comment\">//或者 scanf(&quot;%s&quot;,&amp;str)</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>！这边的数组名<code>str</code>储存的是<strong>数组首元素的地址</strong>，而<code>&amp;str</code>储存的是<code>整个数组的地址</code>，值是一样的，两者皆可用于传参，但<strong>指针类型不一样</strong>，要做好区分</p>\n<h4 id=\"scanf都做了什么\"><a href=\"#scanf都做了什么\" class=\"headerlink\" title=\"scanf都做了什么\"></a><code>scanf</code>都做了什么</h4><p>先来看看它分别对用<code>&#123; 0 &#125;</code><strong>初始化</strong>和<strong>不初始化</strong>的数组做了什么</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str1);</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str2);</span><br></pre></td></tr></table></figure>\n<p><em>两个数组的输入均为abc</em><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-11_19-09-50.jpg\"></p>\n<p>可以看到，对<code>str1</code>,字符非常正常地填充进去了，因为整个数组原本是用<code>\\0</code>填充的,看不出什么端倪</p>\n<p>而对于<code>str2</code>,观察发现，除了输入进去的字符<code>a</code>,<code>b</code>,<code>c</code>,它还自动在结尾补了一个<code>\\0</code>,使<code>str2</code>里储存了一个完整的字符串。<strong>但是</strong>，剩下的部分还是用<strong>值</strong><code>-52</code>填充，即未初始化的状态，所以依然<strong>不提倡</strong>声明的时候没有初始化</p>\n<p>然后是在字符数组内已有内容的情况下，再次使用<code>scanf</code>的情况</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s %s&quot;</span>,str1,str2);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-33-02.jpg\"></p>\n<p>如图，<code>scanf</code>做的是把输入的字符串<code>覆盖</code>式存入字符数组，比原来长，就完全覆盖，比原来短，就部分覆盖，未覆盖的部分无改动</p>\n<h4 id=\"关于scanf的危险操作\"><a href=\"#关于scanf的危险操作\" class=\"headerlink\" title=\"关于scanf的危险操作\"></a>关于<code>scanf</code>的危险操作</h4><p>由于<code>scanf</code>无法预测<strong>字符数组</strong>能否存下输入的<strong>字符串</strong>，如果<strong>字符数组</strong>声明的长度不够，就可能出现<strong>越界访问</strong>,随之而来的便是奇奇怪怪的<code>bug</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">4</span>] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//先声明一个长度为4的数组</span></span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str);<span class=\"comment\">//这次输入abcdef试试</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-47-00.jpg\"></p>\n<p>可以看到，确实<strong>越界访问</strong>了，所以声明字符数组的时候，建议比预计最大输入，在多些长度，防止越界访问。</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"什么是字符串\"><a href=\"#什么是字符串\" class=\"headerlink\" title=\"什么是字符串\"></a>什么是字符串</h1><h2 id=\"初见字符串\"><a href=\"#初见字符串\" class=\"headerlink\" title=\"初见字符串\"></a>初见字符串</h2><p>我们最先遇到的字符串,一般是<code>hello_world</code>程序中用到的<code>&quot;hello world&quot;</code>,也就是<strong>两个双引号括起来的一串字符</strong>,输出时的占位符是<code>%s</code>,可以直接拿去传值，代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>,<span class=\"string\">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明字符串变量\"><a href=\"#声明字符串变量\" class=\"headerlink\" title=\"声明字符串变量\"></a>声明字符串变量</h2><p>有时我们想要先把字符串存起来，再进行操作，那么就使用<strong>字符数组</strong>，并在<strong>初始化</strong>的时候把字符串传给它,这样在<strong>创建数组</strong>时会编译器会自动分配内存给它，代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = <span class=\"string\">&quot;abcdef&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们也可以开启VS的<strong>调试</strong>，并打开<strong>内存</strong>和<strong>监视</strong>窗口观察字符串是如何在内存中储存的,如下图</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_10-06-06.jpg\"></p>\n<p>通过观察可以发现，C语⾔字符串的字符串有个<code>规定</code>(特点)，就是以字符<code>\\0</code>结尾，无论是初始化数组时，还是在分配内存时，都有<code>\\0</code>的位置。</p>\n<h3 id=\"strlen-函数\"><a href=\"#strlen-函数\" class=\"headerlink\" title=\"strlen()函数\"></a>strlen()函数</h3><p>依据以<code>\\0</code>为字符串结尾的规则，<code>strlen</code>函数就可以计算字符串的长度，它会从字符串的第一个字符向后扫描，直到遇到<code>\\0</code>结束,且<code>\\0</code>不进入计数，最后返回字符串的长度,代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span> <span class=\"comment\">//需要引对应的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(<span class=\"string\">&quot;abcdef&quot;</span>);<span class=\"comment\">//len的值为6</span></span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(<span class=\"string\">&quot;abcdef&quot;</span>);<span class=\"comment\">//sz的大小为7(\\0被计入总数)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"验证字符串的结尾\"><a href=\"#验证字符串的结尾\" class=\"headerlink\" title=\"验证字符串的结尾\"></a>验证字符串的结尾</h3><h4 id=\"正向验证\"><a href=\"#正向验证\" class=\"headerlink\" title=\"正向验证\"></a>正向验证</h4><p>我们做在字符数组里插入一个<code>\\0</code>,来看看函数<code>printf</code>和<code>strlen</code>找到的结尾在哪里,如下图</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;f&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_11-01-35.jpg\"></p>\n<p>可以看到字符数组似乎被“截断”了，<code>printf</code>只输出了<code>\\0</code>前面的内容, <code>strlen</code>算出来的长度也只有<code>3</code>,可见插入的<code>\\0</code>被作为了<strong>字符串</strong>的结尾，字符串提前中指,而没到达<strong>字符数组</strong>的结尾</p>\n<h4 id=\"反向验证\"><a href=\"#反向验证\" class=\"headerlink\" title=\"反向验证\"></a>反向验证</h4><p>我们来<strong>反向</strong>验证一下，<code>\\0</code>是字符串结尾的标志,如下图，我们声明一个<strong>没有</strong><code>\\0</code>结尾的字符数组，看看函数<code>printf</code>和<code>strlen</code>还找不找得到我们“认为”的结尾</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;f&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-02-07.jpg\"></p>\n<p>可以看到函数对字符串的判断出现了严重<strong>失误</strong>，所以<strong>字符数组</strong>里没有<code>\\0</code>标记结尾是非常严重的问题，不光是找不到字符串的结尾，而且会<strong>越界访问</strong>！危险操作，写代码的时候一定要注意</p>\n<hr>\n<h2 id=\"从字符串到字符数组\"><a href=\"#从字符串到字符数组\" class=\"headerlink\" title=\"从字符串到字符数组\"></a>从字符串到字符数组</h2><p>虽然上面已经用到了字符数组，但主要还是为了方便讨论<strong>字符串</strong>,接下来着重研究字符数组。</p>\n<h3 id=\"先整清楚几个概念\"><a href=\"#先整清楚几个概念\" class=\"headerlink\" title=\"先整清楚几个概念\"></a>先整清楚几个概念</h3><p><code>什么是数组</code>：数组是⼀组相同类型元素的集合,会在内存中开辟一段连续的空间，将元素储存在那段内存中</p>\n<p><code>什么是数组元素</code>：存放在数组的值被称为数组的元素，数组在创建的时候可以指定数组的⼤⼩和数组的元素类型。</p>\n<p>所以<code>字符数组</code>是一组<code>字符</code>的集合，字符数组里的<code>元素</code>都是<code>字符</code>!,访问到的字符数组里的<strong>元素</strong>都是<strong>字符</strong>，像<code>&#39;a&#39;</code>,<code>&#39;b&#39;</code>,<code>&#39;c&#39;</code>这种的单个的字符,别和<code>字符串</code>混为一谈！</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(str);<span class=\"comment\">//这里str代表了整个数组,所以包括\\0</span></span><br><span class=\"line\">,sz的值为<span class=\"number\">4</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符数组的声明\"><a href=\"#字符数组的声明\" class=\"headerlink\" title=\"字符数组的声明\"></a>字符数组的声明</h3><p>字符数组的声明和其他类型的数组差不多，有<strong>初始化</strong>，<strong>不完全初始化</strong>，<strong>声明长度</strong>，<strong>不声明长度</strong></p>\n<p><em>正确的声明代码如下</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//初始化,不声明长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;<span class=\"comment\">//这也是初始化，且不声明长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str3[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//初始化，用值0(等价于`\\0`)填充</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str4[<span class=\"number\">10</span>] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//不完全初始化，存入字符串&quot;abc&quot;,后面都用&#x27;\\0&#x27;填充</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str5[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;<span class=\"comment\">//不完全初始化,从下标为0开始，依次往后填充字符 a,b,c,\\0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em>错误的声明代码</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">3</span>] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//数组声明短了，放不下结尾的\\0,编译过不了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">3</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;<span class=\"comment\">//同上,放不下</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str3[] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//能声明，但是字符数组长度为1，这个数组大概率是用不了的/会被拿去错误使用的</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"来看看这些声明方式在内存中的表现\"><a href=\"#来看看这些声明方式在内存中的表现\" class=\"headerlink\" title=\"来看看这些声明方式在内存中的表现\"></a>来看看这些声明方式在内存中的表现</h3><h4 id=\"不初始化的声明-极度不推荐\"><a href=\"#不初始化的声明-极度不推荐\" class=\"headerlink\" title=\"不初始化的声明(极度不推荐)\"></a>不初始化的声明(极度不推荐)</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[];<span class=\"comment\">//这个不加长度，直接编译失败（如下图）</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-39-10.jpg\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>];<span class=\"comment\">//语法没有问题，来看看此时数组里存了什么</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-46-49.jpg\"><br>可以看到全都存了<code>-52</code>,对应的中文字符是<code>烫</code>，这样<strong>不好</strong>，请在声明字符数组的时候<strong>初始化数组</strong></p>\n<h4 id=\"不声明长度的数组声明\"><a href=\"#不声明长度的数组声明\" class=\"headerlink\" title=\"不声明长度的数组声明\"></a>不声明长度的数组声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-59-34.jpg\"></p>\n<p>如上图，不声明长度时，编译器自动给字符数组分配内存，既不给多，也不给少，初始化给的<code>字符串</code>或者<code>&#123;...&#125;</code>多长，创建的数组就多长。</p>\n<p><strong>注意红框</strong>，再强调一遍，字符串以<code>\\0</code>结尾,看到双引号括起来的字符串，要记得最后隐藏了一个<code>\\0</code>,用字符数组储存的时候一定要留足空间</p>\n<h4 id=\"声明长度的数组声明\"><a href=\"#声明长度的数组声明\" class=\"headerlink\" title=\"声明长度的数组声明\"></a>声明长度的数组声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str3[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str4[<span class=\"number\">10</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str5[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_15-25-54.jpg\"></p>\n<p>可以看到，在声明的长度<strong>足够长</strong>时，你初始化的时候给它多少字符，它就从<code>下标0</code>处开始<strong>按顺序</strong>存进去多少,剩下的部分<strong>自动</strong>用<code>&#39;\\0&#39;</code>填充,</p>\n<p>所以实际上上面代码中的<code>str5</code>因为长度<code>10</code>&gt;初始化给的<code>4</code>个字符，后面六个元素用<code>\\0</code>填充了，所以<code>str5</code>里存了有<strong>结尾</strong>的完整字符串</p>\n<h4 id=\"错误声明\"><a href=\"#错误声明\" class=\"headerlink\" title=\"错误声明\"></a>错误声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">3</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">3</span>] = &#123; <span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-44-57.jpg\"></p>\n<p>可以看到上面两种错误的声明方式，甚至直接<strong>编译失败</strong>,所以声明字符数组的时候一定要<strong>留足空间</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str3[] = &#123; <span class=\"number\">0</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-51-55.jpg\"></p>\n<p>如上图，可以看到这样写还是编译成功了，但是在监视查看<strong>数组长度</strong>的时候，发现长度为<code>1</code>,里面存了一个<code>\\0</code>,这么<strong>短</strong>的数组能用吗？只能<strong>用一点点</strong>，甚至还不如直接声明一个<code>char</code>类型的字符变量</p>\n<h2 id=\"当字符数组加上const\"><a href=\"#当字符数组加上const\" class=\"headerlink\" title=\"当字符数组加上const\"></a>当字符数组加上const</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> str[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"一些性质\"><a href=\"#一些性质\" class=\"headerlink\" title=\"一些性质\"></a>一些性质</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_18-55-52.jpg\"></p>\n<p>可以看到，声明时加了<code>const</code>之后，字符数组<code>str</code>在声明时的<strong>初始化</strong>之后便不可更改了，只能<strong>访问</strong>其元素,而<strong>不能通过访问元素来改变数组内容</strong></p>\n<p>那么<code>scanf</code>还能写入内容吗？答案是<strong>可以</strong>!<em>(如下图)</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-10-43.jpg\"></p>\n<p>那它能拿来初始化别的数组吗？很遗憾，<strong>不能</strong><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-05-15.jpg\"></p>\n<h3 id=\"对应的指针类型\"><a href=\"#对应的指针类型\" class=\"headerlink\" title=\"对应的指针类型\"></a>对应的指针类型</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-15-32.jpg\"></p>\n<p>可以看到，这里得用<code>const char*</code>来储存字符数组的地址，而使用<code>char*</code>就会报错</p>\n<p>那么用<code>双引号括起来的字符串</code>，是否也有地址，能用指针储存它的地址呢？</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-21-10.jpg\"></p>\n<p>如图，可以看到,字符串<code>&quot;abc&quot;</code>是属于<code>const char</code>类型的数组，对应的指针是<code>const char*</code>,不能通过访问元素来改变内部的值，也不能用<code>char*</code>来储存地址</p>\n<h4 id=\"在内存中的表现\"><a href=\"#在内存中的表现\" class=\"headerlink\" title=\"在内存中的表现\"></a>在内存中的表现</h4><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_str.gif\"></p>\n<p>可以看到哪怕是字符串<code>&quot;abc&quot;</code>,也是在内存中开辟了一段空间，并把字符<strong>储存在内存中</strong>了的</p>\n<p>但是，<strong>不要</strong>试图用<code>scanf</code>去改变字符串的值<br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_strrrr.gif\"></p>\n<hr>\n<h2 id=\"如何向字符数组里添加内容\"><a href=\"#如何向字符数组里添加内容\" class=\"headerlink\" title=\"如何向字符数组里添加内容\"></a>如何向字符数组里添加内容</h2><p>添加的方法多种多样，搞不好可能还会出错，所以把字符数组<strong>学明白</strong>很重要！</p>\n<p>以下使用的数组样例声明如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>在初始化的时候就把值传进去，有哪些初始化方式<strong>上面</strong>已经介绍过了，这里不多赘述</p>\n<h3 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h3><p>通过<code>[]</code>可以访问数组元素，并对没有<code>const</code>修饰的数组，修改其元素,例如:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;A&#x27;</span>;<span class=\"comment\">//将数组的第一个元素改成字符A</span></span><br></pre></td></tr></table></figure>\n\n<p>我们也可以通过循环的方式，将数组的所有元素填充为某个字符</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> place_holder = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++)<span class=\"comment\">//这里使用左闭右开区间，10为数组的大小</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    str[i] = place_holder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用scanf函数\"><a href=\"#使用scanf函数\" class=\"headerlink\" title=\"使用scanf函数\"></a>使用<code>scanf</code>函数</h3><p>由上面的探究已知：对于已声明的字符数组，<strong>无论</strong>有没有<code>const</code>修饰，都可已用<code>scanf</code>修改内容,那么<code>scanf</code>怎么用，又具体怎么工作的，我们接着往下探究</p>\n<h4 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str);<span class=\"comment\">//占位符是 %s ,右边的参数是 str ,也就是数组名</span></span><br><span class=\"line\"><span class=\"comment\">//或者 scanf(&quot;%s&quot;,&amp;str)</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>！这边的数组名<code>str</code>储存的是<strong>数组首元素的地址</strong>，而<code>&amp;str</code>储存的是<code>整个数组的地址</code>，值是一样的，两者皆可用于传参，但<strong>指针类型不一样</strong>，要做好区分</p>\n<h4 id=\"scanf都做了什么\"><a href=\"#scanf都做了什么\" class=\"headerlink\" title=\"scanf都做了什么\"></a><code>scanf</code>都做了什么</h4><p>先来看看它分别对用<code>&#123; 0 &#125;</code><strong>初始化</strong>和<strong>不初始化</strong>的数组做了什么</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str1);</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str2);</span><br></pre></td></tr></table></figure>\n<p><em>两个数组的输入均为abc</em><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-11_19-09-50.jpg\"></p>\n<p>可以看到，对<code>str1</code>,字符非常正常地填充进去了，因为整个数组原本是用<code>\\0</code>填充的,看不出什么端倪</p>\n<p>而对于<code>str2</code>,观察发现，除了输入进去的字符<code>a</code>,<code>b</code>,<code>c</code>,它还自动在结尾补了一个<code>\\0</code>,使<code>str2</code>里储存了一个完整的字符串。<strong>但是</strong>，剩下的部分还是用<strong>值</strong><code>-52</code>填充，即未初始化的状态，所以依然<strong>不提倡</strong>声明的时候没有初始化</p>\n<p>然后是在字符数组内已有内容的情况下，再次使用<code>scanf</code>的情况</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s %s&quot;</span>,str1,str2);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-33-02.jpg\"></p>\n<p>如图，<code>scanf</code>做的是把输入的字符串<code>覆盖</code>式存入字符数组，比原来长，就完全覆盖，比原来短，就部分覆盖，未覆盖的部分无改动</p>\n<h4 id=\"关于scanf的危险操作\"><a href=\"#关于scanf的危险操作\" class=\"headerlink\" title=\"关于scanf的危险操作\"></a>关于<code>scanf</code>的危险操作</h4><p>由于<code>scanf</code>无法预测<strong>字符数组</strong>能否存下输入的<strong>字符串</strong>，如果<strong>字符数组</strong>声明的长度不够，就可能出现<strong>越界访问</strong>,随之而来的便是奇奇怪怪的<code>bug</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">4</span>] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//先声明一个长度为4的数组</span></span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str);<span class=\"comment\">//这次输入abcdef试试</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-47-00.jpg\"></p>\n<p>可以看到，确实<strong>越界访问</strong>了，所以声明字符数组的时候，建议比预计最大输入，在多些长度，防止越界访问。</p>\n"},{"title":"=算法=双指针的种种应用(更新中)","date":"2023-09-12T10:40:44.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-34-45.jpg","_content":"\n*本文章将涉及C语言数组至数据结构的链表*\n\n## Q:为什么要用双指针? #\nA:因为\n通过使用双指针可以使算法的**时间复杂度降低**(或者降低遍历次数),有时也能**降低空间复杂度**\n\n## 分类 #\n根据双指针的用法，可分为**前后双指针**,**头尾双指针**,**快慢双指针**.....\n\n---\n# 以下为各种双指针的应用及介绍 #\n## 前后双指针 #\n\n#### 应用一 删除排序数组中的重复项 #\n**要求**:原地删除,并返回新数组的长度，不需要考虑数组中超出新长度后面的元素。\n\n**思路**:通过创建一前一后两个指针，**前指针**指向**上一个元素**，**后指针**向后历遍,一旦**找到**不同的元素,前指针指向**下一个位置，并视为空位**，通过**后指针**找到目标元素,并存入前指针目前所指向的**空位**。然后**后指针**接着遍历，直至遍历整个数组.\n\n```C\n//代码实现\nint removeDuplicates(int* nums, int numsSize){\n    int* left = nums;\n    int*right = nums+1;\n    int ret = 1;\n    //遍历数组\n    for (int i=0;i<numsSize-1;i++)\n    {\n        if(*left != *right)\n        {\n            left++;\n            *left = *right;\n            right++;\n            ret++;\n        }\n        else\n        {\n            right++;\n        }\n    }\n    return ret;\n}\n```\n**分析**:这个函数只遍历的一遍数组，没有复制数组,所以**时间复杂度**为``O(n)``,**空间复杂度**为``O(1)``;\n\n---\n## 头尾双指针 #\n#### 应用一 翻转数组/字符串 #\n关于翻转，首先想到的应该是创建一个**等长的空数组**，再同时顺序遍历**原数组**和逆序遍历**空数组**，逐位储存到空数组，然后再同时顺序遍历两个数组，将**已逆序**的数组拷贝至原数组\n\n**缺点**：需要**多次**遍历，且**空间复杂度**为O(n)\n\n**使用双指针优化**：整个数组的翻转可逐步拆解为：第一个和最后一个互换、第二个和倒数第二个互换、、、第N个数和倒数第N个数互换，直至中间。此处便可使用**双指针**，头尾指针各自一边**交换**所指向的内容，一边**向中间靠近**\n```C\n//代码实现-这里是翻转字符串\nvoid reverseString(char* s, int sSize){\n    int *left = s;//头指针\n    int *right = s + sSize-1;//尾指针\n    while(left<right)//尚未到达中间时\n    {\n        char tmp = *left;\n        *left = *right;\n        *right = tmp;\n        left++;\n        right--;\n    }\n}\n```\n\n---\n## 快慢双指针 #\n#### 应用一 删除链表倒数第K个节点  #\n**一般解法**：先遍历一遍链表获得链表总数N,再二次遍历到N-K处的节点，并执行删除\n\n**如何优化**：使用快慢双指针，仅需遍历一次，就能用慢指针定位目标节点\n\n```C\n//代码实现\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\n    //创建哨兵位解决头删问题\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n    dummy->val = 0;\n    dummy->next = head;\n\n    struct ListNode* slow = dummy;\n    struct ListNode* fast = dummy;\n    while (int i = 0;i<n+1;n++)//移动fast\n    {\n        fast = fast->next;\n    }\n    \n    while(fast != NULL)//同时遍历\n    {\n        fast= fast->next;\n        slow= slow->next;\n    }\n    //此时slow指向目标节点的前一个节点\n    struct ListNode* tmp = slow->next;\n    slow->next = slow->next->next;\n    free(tmp);\n    return dummy->next;\n}\n```\n\n\n#### 应用二 找出并返回链表中间的节点 #\n\n**注**:偶数个节点时删除**前一个**中间节点\n\n**一般解法**：依然是先遍历一遍链表，然后定位中间的节点,二次遍历\n\n**如何优化**：使用**慢指针**(一步走一个节点)和**快指针**(一步走两个节点)，二者同时遍历，直至**快指针**指向`NULL`或快指针指向`尾节点`\n\n当遍历结束时，慢指针指向目标中间节点\n\n```C\n//代码实现\nstruct ListNode* middleNode(struct ListNode* head){\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n    while(fast && fast->next)\n    {\n        slow = slow->next;\n        fast = fast->next->next; \n    }\n\n    return slow;\n}\n```\n\n## 应用三 循环链表问题 #\n","source":"_posts/双指针.md","raw":"---\ntitle: =算法=双指针的种种应用(更新中)\ndate: 2023-09-12 18:40:44\ntags: 算法\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-34-45.jpg\n---\n\n*本文章将涉及C语言数组至数据结构的链表*\n\n## Q:为什么要用双指针? #\nA:因为\n通过使用双指针可以使算法的**时间复杂度降低**(或者降低遍历次数),有时也能**降低空间复杂度**\n\n## 分类 #\n根据双指针的用法，可分为**前后双指针**,**头尾双指针**,**快慢双指针**.....\n\n---\n# 以下为各种双指针的应用及介绍 #\n## 前后双指针 #\n\n#### 应用一 删除排序数组中的重复项 #\n**要求**:原地删除,并返回新数组的长度，不需要考虑数组中超出新长度后面的元素。\n\n**思路**:通过创建一前一后两个指针，**前指针**指向**上一个元素**，**后指针**向后历遍,一旦**找到**不同的元素,前指针指向**下一个位置，并视为空位**，通过**后指针**找到目标元素,并存入前指针目前所指向的**空位**。然后**后指针**接着遍历，直至遍历整个数组.\n\n```C\n//代码实现\nint removeDuplicates(int* nums, int numsSize){\n    int* left = nums;\n    int*right = nums+1;\n    int ret = 1;\n    //遍历数组\n    for (int i=0;i<numsSize-1;i++)\n    {\n        if(*left != *right)\n        {\n            left++;\n            *left = *right;\n            right++;\n            ret++;\n        }\n        else\n        {\n            right++;\n        }\n    }\n    return ret;\n}\n```\n**分析**:这个函数只遍历的一遍数组，没有复制数组,所以**时间复杂度**为``O(n)``,**空间复杂度**为``O(1)``;\n\n---\n## 头尾双指针 #\n#### 应用一 翻转数组/字符串 #\n关于翻转，首先想到的应该是创建一个**等长的空数组**，再同时顺序遍历**原数组**和逆序遍历**空数组**，逐位储存到空数组，然后再同时顺序遍历两个数组，将**已逆序**的数组拷贝至原数组\n\n**缺点**：需要**多次**遍历，且**空间复杂度**为O(n)\n\n**使用双指针优化**：整个数组的翻转可逐步拆解为：第一个和最后一个互换、第二个和倒数第二个互换、、、第N个数和倒数第N个数互换，直至中间。此处便可使用**双指针**，头尾指针各自一边**交换**所指向的内容，一边**向中间靠近**\n```C\n//代码实现-这里是翻转字符串\nvoid reverseString(char* s, int sSize){\n    int *left = s;//头指针\n    int *right = s + sSize-1;//尾指针\n    while(left<right)//尚未到达中间时\n    {\n        char tmp = *left;\n        *left = *right;\n        *right = tmp;\n        left++;\n        right--;\n    }\n}\n```\n\n---\n## 快慢双指针 #\n#### 应用一 删除链表倒数第K个节点  #\n**一般解法**：先遍历一遍链表获得链表总数N,再二次遍历到N-K处的节点，并执行删除\n\n**如何优化**：使用快慢双指针，仅需遍历一次，就能用慢指针定位目标节点\n\n```C\n//代码实现\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\n    //创建哨兵位解决头删问题\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n    dummy->val = 0;\n    dummy->next = head;\n\n    struct ListNode* slow = dummy;\n    struct ListNode* fast = dummy;\n    while (int i = 0;i<n+1;n++)//移动fast\n    {\n        fast = fast->next;\n    }\n    \n    while(fast != NULL)//同时遍历\n    {\n        fast= fast->next;\n        slow= slow->next;\n    }\n    //此时slow指向目标节点的前一个节点\n    struct ListNode* tmp = slow->next;\n    slow->next = slow->next->next;\n    free(tmp);\n    return dummy->next;\n}\n```\n\n\n#### 应用二 找出并返回链表中间的节点 #\n\n**注**:偶数个节点时删除**前一个**中间节点\n\n**一般解法**：依然是先遍历一遍链表，然后定位中间的节点,二次遍历\n\n**如何优化**：使用**慢指针**(一步走一个节点)和**快指针**(一步走两个节点)，二者同时遍历，直至**快指针**指向`NULL`或快指针指向`尾节点`\n\n当遍历结束时，慢指针指向目标中间节点\n\n```C\n//代码实现\nstruct ListNode* middleNode(struct ListNode* head){\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n    while(fast && fast->next)\n    {\n        slow = slow->next;\n        fast = fast->next->next; \n    }\n\n    return slow;\n}\n```\n\n## 应用三 循环链表问题 #\n","slug":"双指针","published":1,"updated":"2023-11-02T02:35:41.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloutk949000fkkg6aqscet69","content":"<p><em>本文章将涉及C语言数组至数据结构的链表</em></p>\n<h2 id=\"Q-为什么要用双指针\"><a href=\"#Q-为什么要用双指针\" class=\"headerlink\" title=\"Q:为什么要用双指针?\"></a>Q:为什么要用双指针?</h2><p>A:因为<br>通过使用双指针可以使算法的<strong>时间复杂度降低</strong>(或者降低遍历次数),有时也能<strong>降低空间复杂度</strong></p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>根据双指针的用法，可分为<strong>前后双指针</strong>,<strong>头尾双指针</strong>,<strong>快慢双指针</strong>…..</p>\n<hr>\n<h1 id=\"以下为各种双指针的应用及介绍\"><a href=\"#以下为各种双指针的应用及介绍\" class=\"headerlink\" title=\"以下为各种双指针的应用及介绍\"></a>以下为各种双指针的应用及介绍</h1><h2 id=\"前后双指针\"><a href=\"#前后双指针\" class=\"headerlink\" title=\"前后双指针\"></a>前后双指针</h2><h4 id=\"应用一-删除排序数组中的重复项\"><a href=\"#应用一-删除排序数组中的重复项\" class=\"headerlink\" title=\"应用一 删除排序数组中的重复项\"></a>应用一 删除排序数组中的重复项</h4><p><strong>要求</strong>:原地删除,并返回新数组的长度，不需要考虑数组中超出新长度后面的元素。</p>\n<p><strong>思路</strong>:通过创建一前一后两个指针，<strong>前指针</strong>指向<strong>上一个元素</strong>，<strong>后指针</strong>向后历遍,一旦<strong>找到</strong>不同的元素,前指针指向<strong>下一个位置，并视为空位</strong>，通过<strong>后指针</strong>找到目标元素,并存入前指针目前所指向的<strong>空位</strong>。然后<strong>后指针</strong>接着遍历，直至遍历整个数组.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">removeDuplicates</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>* left = nums;</span><br><span class=\"line\">    <span class=\"type\">int</span>*right = nums+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//遍历数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*left != *right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            *left = *right;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">            ret++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析</strong>:这个函数只遍历的一遍数组，没有复制数组,所以<strong>时间复杂度</strong>为<code>O(n)</code>,<strong>空间复杂度</strong>为<code>O(1)</code>;</p>\n<hr>\n<h2 id=\"头尾双指针\"><a href=\"#头尾双指针\" class=\"headerlink\" title=\"头尾双指针\"></a>头尾双指针</h2><h4 id=\"应用一-翻转数组-字符串\"><a href=\"#应用一-翻转数组-字符串\" class=\"headerlink\" title=\"应用一 翻转数组&#x2F;字符串\"></a>应用一 翻转数组&#x2F;字符串</h4><p>关于翻转，首先想到的应该是创建一个<strong>等长的空数组</strong>，再同时顺序遍历<strong>原数组</strong>和逆序遍历<strong>空数组</strong>，逐位储存到空数组，然后再同时顺序遍历两个数组，将<strong>已逆序</strong>的数组拷贝至原数组</p>\n<p><strong>缺点</strong>：需要<strong>多次</strong>遍历，且<strong>空间复杂度</strong>为O(n)</p>\n<p><strong>使用双指针优化</strong>：整个数组的翻转可逐步拆解为：第一个和最后一个互换、第二个和倒数第二个互换、、、第N个数和倒数第N个数互换，直至中间。此处便可使用<strong>双指针</strong>，头尾指针各自一边<strong>交换</strong>所指向的内容，一边<strong>向中间靠近</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现-这里是翻转字符串</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">reverseString</span><span class=\"params\">(<span class=\"type\">char</span>* s, <span class=\"type\">int</span> sSize)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *left = s;<span class=\"comment\">//头指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *right = s + sSize<span class=\"number\">-1</span>;<span class=\"comment\">//尾指针</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left&lt;right)<span class=\"comment\">//尚未到达中间时</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> tmp = *left;</span><br><span class=\"line\">        *left = *right;</span><br><span class=\"line\">        *right = tmp;</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"快慢双指针\"><a href=\"#快慢双指针\" class=\"headerlink\" title=\"快慢双指针\"></a>快慢双指针</h2><h4 id=\"应用一-删除链表倒数第K个节点\"><a href=\"#应用一-删除链表倒数第K个节点\" class=\"headerlink\" title=\"应用一 删除链表倒数第K个节点\"></a>应用一 删除链表倒数第K个节点</h4><p><strong>一般解法</strong>：先遍历一遍链表获得链表总数N,再二次遍历到N-K处的节点，并执行删除</p>\n<p><strong>如何优化</strong>：使用快慢双指针，仅需遍历一次，就能用慢指针定位目标节点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">removeNthFromEnd</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head, <span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建哨兵位解决头删问题</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">dummy</span> =</span> (<span class=\"keyword\">struct</span> ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> ListNode));</span><br><span class=\"line\">    dummy-&gt;val = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dummy-&gt;next = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">slow</span> =</span> dummy;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">fast</span> =</span> dummy;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n+<span class=\"number\">1</span>;n++)<span class=\"comment\">//移动fast</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast != <span class=\"literal\">NULL</span>)<span class=\"comment\">//同时遍历</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fast= fast-&gt;next;</span><br><span class=\"line\">        slow= slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//此时slow指向目标节点的前一个节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">tmp</span> =</span> slow-&gt;next;</span><br><span class=\"line\">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"应用二-找出并返回链表中间的节点\"><a href=\"#应用二-找出并返回链表中间的节点\" class=\"headerlink\" title=\"应用二 找出并返回链表中间的节点\"></a>应用二 找出并返回链表中间的节点</h4><p><strong>注</strong>:偶数个节点时删除<strong>前一个</strong>中间节点</p>\n<p><strong>一般解法</strong>：依然是先遍历一遍链表，然后定位中间的节点,二次遍历</p>\n<p><strong>如何优化</strong>：使用<strong>慢指针</strong>(一步走一个节点)和<strong>快指针</strong>(一步走两个节点)，二者同时遍历，直至<strong>快指针</strong>指向<code>NULL</code>或快指针指向<code>尾节点</code></p>\n<p>当遍历结束时，慢指针指向目标中间节点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">middleNode</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head)</span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">slow</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">fast</span> =</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用三-循环链表问题\"><a href=\"#应用三-循环链表问题\" class=\"headerlink\" title=\"应用三 循环链表问题\"></a>应用三 循环链表问题</h2>","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<p><em>本文章将涉及C语言数组至数据结构的链表</em></p>\n<h2 id=\"Q-为什么要用双指针\"><a href=\"#Q-为什么要用双指针\" class=\"headerlink\" title=\"Q:为什么要用双指针?\"></a>Q:为什么要用双指针?</h2><p>A:因为<br>通过使用双指针可以使算法的<strong>时间复杂度降低</strong>(或者降低遍历次数),有时也能<strong>降低空间复杂度</strong></p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>根据双指针的用法，可分为<strong>前后双指针</strong>,<strong>头尾双指针</strong>,<strong>快慢双指针</strong>…..</p>\n<hr>\n<h1 id=\"以下为各种双指针的应用及介绍\"><a href=\"#以下为各种双指针的应用及介绍\" class=\"headerlink\" title=\"以下为各种双指针的应用及介绍\"></a>以下为各种双指针的应用及介绍</h1><h2 id=\"前后双指针\"><a href=\"#前后双指针\" class=\"headerlink\" title=\"前后双指针\"></a>前后双指针</h2><h4 id=\"应用一-删除排序数组中的重复项\"><a href=\"#应用一-删除排序数组中的重复项\" class=\"headerlink\" title=\"应用一 删除排序数组中的重复项\"></a>应用一 删除排序数组中的重复项</h4><p><strong>要求</strong>:原地删除,并返回新数组的长度，不需要考虑数组中超出新长度后面的元素。</p>\n<p><strong>思路</strong>:通过创建一前一后两个指针，<strong>前指针</strong>指向<strong>上一个元素</strong>，<strong>后指针</strong>向后历遍,一旦<strong>找到</strong>不同的元素,前指针指向<strong>下一个位置，并视为空位</strong>，通过<strong>后指针</strong>找到目标元素,并存入前指针目前所指向的<strong>空位</strong>。然后<strong>后指针</strong>接着遍历，直至遍历整个数组.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">removeDuplicates</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>* left = nums;</span><br><span class=\"line\">    <span class=\"type\">int</span>*right = nums+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//遍历数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*left != *right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            *left = *right;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">            ret++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析</strong>:这个函数只遍历的一遍数组，没有复制数组,所以<strong>时间复杂度</strong>为<code>O(n)</code>,<strong>空间复杂度</strong>为<code>O(1)</code>;</p>\n<hr>\n<h2 id=\"头尾双指针\"><a href=\"#头尾双指针\" class=\"headerlink\" title=\"头尾双指针\"></a>头尾双指针</h2><h4 id=\"应用一-翻转数组-字符串\"><a href=\"#应用一-翻转数组-字符串\" class=\"headerlink\" title=\"应用一 翻转数组&#x2F;字符串\"></a>应用一 翻转数组&#x2F;字符串</h4><p>关于翻转，首先想到的应该是创建一个<strong>等长的空数组</strong>，再同时顺序遍历<strong>原数组</strong>和逆序遍历<strong>空数组</strong>，逐位储存到空数组，然后再同时顺序遍历两个数组，将<strong>已逆序</strong>的数组拷贝至原数组</p>\n<p><strong>缺点</strong>：需要<strong>多次</strong>遍历，且<strong>空间复杂度</strong>为O(n)</p>\n<p><strong>使用双指针优化</strong>：整个数组的翻转可逐步拆解为：第一个和最后一个互换、第二个和倒数第二个互换、、、第N个数和倒数第N个数互换，直至中间。此处便可使用<strong>双指针</strong>，头尾指针各自一边<strong>交换</strong>所指向的内容，一边<strong>向中间靠近</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现-这里是翻转字符串</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">reverseString</span><span class=\"params\">(<span class=\"type\">char</span>* s, <span class=\"type\">int</span> sSize)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *left = s;<span class=\"comment\">//头指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *right = s + sSize<span class=\"number\">-1</span>;<span class=\"comment\">//尾指针</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left&lt;right)<span class=\"comment\">//尚未到达中间时</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> tmp = *left;</span><br><span class=\"line\">        *left = *right;</span><br><span class=\"line\">        *right = tmp;</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"快慢双指针\"><a href=\"#快慢双指针\" class=\"headerlink\" title=\"快慢双指针\"></a>快慢双指针</h2><h4 id=\"应用一-删除链表倒数第K个节点\"><a href=\"#应用一-删除链表倒数第K个节点\" class=\"headerlink\" title=\"应用一 删除链表倒数第K个节点\"></a>应用一 删除链表倒数第K个节点</h4><p><strong>一般解法</strong>：先遍历一遍链表获得链表总数N,再二次遍历到N-K处的节点，并执行删除</p>\n<p><strong>如何优化</strong>：使用快慢双指针，仅需遍历一次，就能用慢指针定位目标节点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">removeNthFromEnd</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head, <span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建哨兵位解决头删问题</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">dummy</span> =</span> (<span class=\"keyword\">struct</span> ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> ListNode));</span><br><span class=\"line\">    dummy-&gt;val = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dummy-&gt;next = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">slow</span> =</span> dummy;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">fast</span> =</span> dummy;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n+<span class=\"number\">1</span>;n++)<span class=\"comment\">//移动fast</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast != <span class=\"literal\">NULL</span>)<span class=\"comment\">//同时遍历</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fast= fast-&gt;next;</span><br><span class=\"line\">        slow= slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//此时slow指向目标节点的前一个节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">tmp</span> =</span> slow-&gt;next;</span><br><span class=\"line\">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"应用二-找出并返回链表中间的节点\"><a href=\"#应用二-找出并返回链表中间的节点\" class=\"headerlink\" title=\"应用二 找出并返回链表中间的节点\"></a>应用二 找出并返回链表中间的节点</h4><p><strong>注</strong>:偶数个节点时删除<strong>前一个</strong>中间节点</p>\n<p><strong>一般解法</strong>：依然是先遍历一遍链表，然后定位中间的节点,二次遍历</p>\n<p><strong>如何优化</strong>：使用<strong>慢指针</strong>(一步走一个节点)和<strong>快指针</strong>(一步走两个节点)，二者同时遍历，直至<strong>快指针</strong>指向<code>NULL</code>或快指针指向<code>尾节点</code></p>\n<p>当遍历结束时，慢指针指向目标中间节点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">middleNode</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head)</span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">slow</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">fast</span> =</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用三-循环链表问题\"><a href=\"#应用三-循环链表问题\" class=\"headerlink\" title=\"应用三 循环链表问题\"></a>应用三 循环链表问题</h2>"},{"title":"=算法=按位异或^的种种玩法","date":"2023-09-03T23:05:48.000Z","_content":"## 什么是按位异或``^`` #\n首先将不同数制的数写成**二进制**,例如``9->0b1001``.\\\n然后最末位对齐，依次**按位异或**.\\\n规则:``0 ^ 0= 0 ; 1 ^ 1 = 0; 1 ^ 0 = 1``\\\n推论:任意整数``x``,都有``0^x = x``  ;   ``x ^ x = 0``\\\n***\n**来看看应用**\n## 寻找一个单身狗数 #\n像``[1,3,2,2,3]``这样除了某一个数``1``,剩下的数字都是成对的,也就是说遍历一次数组，把所有的元素**按位异或**在一起，结果便是落单的那个``1``\n```C\n//代码实现\nint arr[] = {1,3,2,2,3};\nint sz = sizeof(arr)/sizeof(arr[0]);//求数组大小\nint ret  = 0;\nfor (int i =0;i<sz;i++)\n{\n    ret^=arr[i];\n}\n\nreturn ret; //此时ret即为落单的那个数\n```\n**_变形_**\n## 消失的数 #\n已知一个由0\\~n(缺失一个数)填充的数组，例``[0,6,4,2,3,1]``,例中的数组少了一个``5``,而我们已知数组包含0\\~6中的5个数，就可以将数组元素与0~6**按位异或**到一起，将问题*消失的数*转化为问题*寻找单身狗*,消失的数变成剩下的那个单身狗\n```C\n//代码实现\nint missingNumber(int* nums, int numsSize)\n{\n    int ret = 0;\n    for(int i = 0;i<numsSize;i++>)\n    {\n        ret^=nums[i];//历遍nums的所有元素\n        ret^=i;//历遍0~numsSize-1\n    }\n    ret^=numsSize;//补上numsSize;\n    return ret;\n}\n```\n**_进阶_**\n## 找到两个单身狗 #\n数组再升级，单身狗变成了**两个**，导致不能粗暴地把所有元素按位异或来求出两个数,但我们仍可以将问题简化：能否将两个单身狗分到两个数组，使之转化为两个独立的*求单个单身狗问题*。于是难点来到了如何**分组**\n\n### 方案之一便是运用**按位异或**和**右移运算符** #\n因为两个不同的数，在二进制上作比较，就至少有一位是不同的，以那一位为``0``或``1``分成两组，便可将两个单身狗分开.而若要查找具体是哪一位，将列表中**所有元素**（就包括了两数）**按位异或**后再用**右移运算符**逐位检验是否为``1``,之后便可轻松分组，并直接**按位异或**得出结果\n\n```C\n//代码实现\nint* singleNumber(int* nums, int numsSize, int ret[2]){\n    int ret1 = 0;\n    int ret2 = 0;\n    int n = 0;//用于记录\"1\"在哪一位\n    int tmp = 0;\n    for(int i =0;i<numsSize;i++)\n    {\n        tmp^=nums[i];\n    }\n    while((tmp>>n) !=1 )\n    {\n        n++;\n    }\n    for(int i = 0; i<nums;i++>)//再次历遍\n    {\n        if((nums[i]>>n ==1))//分组1\n        {\n            ret1^=nums[i];\n        }\n        else  //分组2\n        {\n            ret2^=nums[i];\n        }\n    }\n    ret[0] = ret1;\n    ret[1] = ret2;\n    return ret;\n}\n\n```\n\n思考:3个，4个....N个单身狗时呢？","source":"_posts/算法_按位异或.md","raw":"---\ntitle: =算法=按位异或^的种种玩法\ndate: 2023-09-04 07:05:48\ntags: 算法\n---\n## 什么是按位异或``^`` #\n首先将不同数制的数写成**二进制**,例如``9->0b1001``.\\\n然后最末位对齐，依次**按位异或**.\\\n规则:``0 ^ 0= 0 ; 1 ^ 1 = 0; 1 ^ 0 = 1``\\\n推论:任意整数``x``,都有``0^x = x``  ;   ``x ^ x = 0``\\\n***\n**来看看应用**\n## 寻找一个单身狗数 #\n像``[1,3,2,2,3]``这样除了某一个数``1``,剩下的数字都是成对的,也就是说遍历一次数组，把所有的元素**按位异或**在一起，结果便是落单的那个``1``\n```C\n//代码实现\nint arr[] = {1,3,2,2,3};\nint sz = sizeof(arr)/sizeof(arr[0]);//求数组大小\nint ret  = 0;\nfor (int i =0;i<sz;i++)\n{\n    ret^=arr[i];\n}\n\nreturn ret; //此时ret即为落单的那个数\n```\n**_变形_**\n## 消失的数 #\n已知一个由0\\~n(缺失一个数)填充的数组，例``[0,6,4,2,3,1]``,例中的数组少了一个``5``,而我们已知数组包含0\\~6中的5个数，就可以将数组元素与0~6**按位异或**到一起，将问题*消失的数*转化为问题*寻找单身狗*,消失的数变成剩下的那个单身狗\n```C\n//代码实现\nint missingNumber(int* nums, int numsSize)\n{\n    int ret = 0;\n    for(int i = 0;i<numsSize;i++>)\n    {\n        ret^=nums[i];//历遍nums的所有元素\n        ret^=i;//历遍0~numsSize-1\n    }\n    ret^=numsSize;//补上numsSize;\n    return ret;\n}\n```\n**_进阶_**\n## 找到两个单身狗 #\n数组再升级，单身狗变成了**两个**，导致不能粗暴地把所有元素按位异或来求出两个数,但我们仍可以将问题简化：能否将两个单身狗分到两个数组，使之转化为两个独立的*求单个单身狗问题*。于是难点来到了如何**分组**\n\n### 方案之一便是运用**按位异或**和**右移运算符** #\n因为两个不同的数，在二进制上作比较，就至少有一位是不同的，以那一位为``0``或``1``分成两组，便可将两个单身狗分开.而若要查找具体是哪一位，将列表中**所有元素**（就包括了两数）**按位异或**后再用**右移运算符**逐位检验是否为``1``,之后便可轻松分组，并直接**按位异或**得出结果\n\n```C\n//代码实现\nint* singleNumber(int* nums, int numsSize, int ret[2]){\n    int ret1 = 0;\n    int ret2 = 0;\n    int n = 0;//用于记录\"1\"在哪一位\n    int tmp = 0;\n    for(int i =0;i<numsSize;i++)\n    {\n        tmp^=nums[i];\n    }\n    while((tmp>>n) !=1 )\n    {\n        n++;\n    }\n    for(int i = 0; i<nums;i++>)//再次历遍\n    {\n        if((nums[i]>>n ==1))//分组1\n        {\n            ret1^=nums[i];\n        }\n        else  //分组2\n        {\n            ret2^=nums[i];\n        }\n    }\n    ret[0] = ret1;\n    ret[1] = ret2;\n    return ret;\n}\n\n```\n\n思考:3个，4个....N个单身狗时呢？","slug":"算法_按位异或","published":1,"updated":"2023-09-04T13:05:39.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloutk949000gkkg62dl1eswl","content":"<h2 id=\"什么是按位异或\"><a href=\"#什么是按位异或\" class=\"headerlink\" title=\"什么是按位异或^\"></a>什么是按位异或<code>^</code></h2><p>首先将不同数制的数写成<strong>二进制</strong>,例如<code>9-&gt;0b1001</code>.<br>然后最末位对齐，依次<strong>按位异或</strong>.<br>规则:<code>0 ^ 0= 0 ; 1 ^ 1 = 0; 1 ^ 0 = 1</code><br>推论:任意整数<code>x</code>,都有<code>0^x = x</code>  ;   <code>x ^ x = 0</code>\\</p>\n<hr>\n<p><strong>来看看应用</strong></p>\n<h2 id=\"寻找一个单身狗数\"><a href=\"#寻找一个单身狗数\" class=\"headerlink\" title=\"寻找一个单身狗数\"></a>寻找一个单身狗数</h2><p>像<code>[1,3,2,2,3]</code>这样除了某一个数<code>1</code>,剩下的数字都是成对的,也就是说遍历一次数组，把所有的元素<strong>按位异或</strong>在一起，结果便是落单的那个<code>1</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>]);<span class=\"comment\">//求数组大小</span></span><br><span class=\"line\"><span class=\"type\">int</span> ret  = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;sz;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ret^=arr[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> ret; <span class=\"comment\">//此时ret即为落单的那个数</span></span><br></pre></td></tr></table></figure>\n<p><strong><em>变形</em></strong></p>\n<h2 id=\"消失的数\"><a href=\"#消失的数\" class=\"headerlink\" title=\"消失的数\"></a>消失的数</h2><p>已知一个由0~n(缺失一个数)填充的数组，例<code>[0,6,4,2,3,1]</code>,例中的数组少了一个<code>5</code>,而我们已知数组包含0~6中的5个数，就可以将数组元素与0~6<strong>按位异或</strong>到一起，将问题<em>消失的数</em>转化为问题<em>寻找单身狗</em>,消失的数变成剩下的那个单身狗</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">missingNumber</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;numsSize;i++&gt;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret^=nums[i];<span class=\"comment\">//历遍nums的所有元素</span></span><br><span class=\"line\">        ret^=i;<span class=\"comment\">//历遍0~numsSize-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret^=numsSize;<span class=\"comment\">//补上numsSize;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><em>进阶</em></strong></p>\n<h2 id=\"找到两个单身狗\"><a href=\"#找到两个单身狗\" class=\"headerlink\" title=\"找到两个单身狗\"></a>找到两个单身狗</h2><p>数组再升级，单身狗变成了<strong>两个</strong>，导致不能粗暴地把所有元素按位异或来求出两个数,但我们仍可以将问题简化：能否将两个单身狗分到两个数组，使之转化为两个独立的<em>求单个单身狗问题</em>。于是难点来到了如何<strong>分组</strong></p>\n<h3 id=\"方案之一便是运用按位异或和右移运算符\"><a href=\"#方案之一便是运用按位异或和右移运算符\" class=\"headerlink\" title=\"方案之一便是运用按位异或和右移运算符\"></a>方案之一便是运用<strong>按位异或</strong>和<strong>右移运算符</strong></h3><p>因为两个不同的数，在二进制上作比较，就至少有一位是不同的，以那一位为<code>0</code>或<code>1</code>分成两组，便可将两个单身狗分开.而若要查找具体是哪一位，将列表中<strong>所有元素</strong>（就包括了两数）<strong>按位异或</strong>后再用<strong>右移运算符</strong>逐位检验是否为<code>1</code>,之后便可轻松分组，并直接<strong>按位异或</strong>得出结果</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span>* <span class=\"title function_\">singleNumber</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize, <span class=\"type\">int</span> ret[<span class=\"number\">2</span>])</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;<span class=\"comment\">//用于记录&quot;1&quot;在哪一位</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;numsSize;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp^=nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((tmp&gt;&gt;n) !=<span class=\"number\">1</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;nums;i++&gt;)<span class=\"comment\">//再次历遍</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((nums[i]&gt;&gt;n ==<span class=\"number\">1</span>))<span class=\"comment\">//分组1</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ret1^=nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"comment\">//分组2</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ret2^=nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret[<span class=\"number\">0</span>] = ret1;</span><br><span class=\"line\">    ret[<span class=\"number\">1</span>] = ret2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>思考:3个，4个….N个单身狗时呢？</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg","cover_type":"img","excerpt":"","more":"<h2 id=\"什么是按位异或\"><a href=\"#什么是按位异或\" class=\"headerlink\" title=\"什么是按位异或^\"></a>什么是按位异或<code>^</code></h2><p>首先将不同数制的数写成<strong>二进制</strong>,例如<code>9-&gt;0b1001</code>.<br>然后最末位对齐，依次<strong>按位异或</strong>.<br>规则:<code>0 ^ 0= 0 ; 1 ^ 1 = 0; 1 ^ 0 = 1</code><br>推论:任意整数<code>x</code>,都有<code>0^x = x</code>  ;   <code>x ^ x = 0</code>\\</p>\n<hr>\n<p><strong>来看看应用</strong></p>\n<h2 id=\"寻找一个单身狗数\"><a href=\"#寻找一个单身狗数\" class=\"headerlink\" title=\"寻找一个单身狗数\"></a>寻找一个单身狗数</h2><p>像<code>[1,3,2,2,3]</code>这样除了某一个数<code>1</code>,剩下的数字都是成对的,也就是说遍历一次数组，把所有的元素<strong>按位异或</strong>在一起，结果便是落单的那个<code>1</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>]);<span class=\"comment\">//求数组大小</span></span><br><span class=\"line\"><span class=\"type\">int</span> ret  = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;sz;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ret^=arr[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> ret; <span class=\"comment\">//此时ret即为落单的那个数</span></span><br></pre></td></tr></table></figure>\n<p><strong><em>变形</em></strong></p>\n<h2 id=\"消失的数\"><a href=\"#消失的数\" class=\"headerlink\" title=\"消失的数\"></a>消失的数</h2><p>已知一个由0~n(缺失一个数)填充的数组，例<code>[0,6,4,2,3,1]</code>,例中的数组少了一个<code>5</code>,而我们已知数组包含0~6中的5个数，就可以将数组元素与0~6<strong>按位异或</strong>到一起，将问题<em>消失的数</em>转化为问题<em>寻找单身狗</em>,消失的数变成剩下的那个单身狗</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">missingNumber</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;numsSize;i++&gt;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret^=nums[i];<span class=\"comment\">//历遍nums的所有元素</span></span><br><span class=\"line\">        ret^=i;<span class=\"comment\">//历遍0~numsSize-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret^=numsSize;<span class=\"comment\">//补上numsSize;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><em>进阶</em></strong></p>\n<h2 id=\"找到两个单身狗\"><a href=\"#找到两个单身狗\" class=\"headerlink\" title=\"找到两个单身狗\"></a>找到两个单身狗</h2><p>数组再升级，单身狗变成了<strong>两个</strong>，导致不能粗暴地把所有元素按位异或来求出两个数,但我们仍可以将问题简化：能否将两个单身狗分到两个数组，使之转化为两个独立的<em>求单个单身狗问题</em>。于是难点来到了如何<strong>分组</strong></p>\n<h3 id=\"方案之一便是运用按位异或和右移运算符\"><a href=\"#方案之一便是运用按位异或和右移运算符\" class=\"headerlink\" title=\"方案之一便是运用按位异或和右移运算符\"></a>方案之一便是运用<strong>按位异或</strong>和<strong>右移运算符</strong></h3><p>因为两个不同的数，在二进制上作比较，就至少有一位是不同的，以那一位为<code>0</code>或<code>1</code>分成两组，便可将两个单身狗分开.而若要查找具体是哪一位，将列表中<strong>所有元素</strong>（就包括了两数）<strong>按位异或</strong>后再用<strong>右移运算符</strong>逐位检验是否为<code>1</code>,之后便可轻松分组，并直接<strong>按位异或</strong>得出结果</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span>* <span class=\"title function_\">singleNumber</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize, <span class=\"type\">int</span> ret[<span class=\"number\">2</span>])</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;<span class=\"comment\">//用于记录&quot;1&quot;在哪一位</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;numsSize;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp^=nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((tmp&gt;&gt;n) !=<span class=\"number\">1</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;nums;i++&gt;)<span class=\"comment\">//再次历遍</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((nums[i]&gt;&gt;n ==<span class=\"number\">1</span>))<span class=\"comment\">//分组1</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ret1^=nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"comment\">//分组2</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ret2^=nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret[<span class=\"number\">0</span>] = ret1;</span><br><span class=\"line\">    ret[<span class=\"number\">1</span>] = ret2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>思考:3个，4个….N个单身狗时呢？</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cloutk949000fkkg6aqscet69","tag_id":"cloutk94a000hkkg67csphp54","_id":"cloutk94d000jkkg68ebudc26"},{"post_id":"cloutk949000gkkg62dl1eswl","tag_id":"cloutk94a000hkkg67csphp54","_id":"cloutk94e000kkkg61oax67hh"}],"Tag":[{"name":"算法","_id":"cloutk94a000hkkg67csphp54"}]}}