{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":0},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/ACVA.md","hash":"2d763a4b6ee1cb6af19b3835fdfb8415e75c63be","modified":1725552296344},{"_id":"source/_posts/AVLTree.md","hash":"16bec392dc5d155c0b62b28f61279c5eaa3caaa5","modified":1725496014411},{"_id":"source/_posts/BiiigInt.md","hash":"715ee0c6bf5405f19eb92e58811158d801583fb1","modified":1715212576551},{"_id":"source/_posts/BSTree.md","hash":"60183fd87e91ef40726e03370e3597dd9cbb4655","modified":1722417456018},{"_id":"source/_posts/OLSIC.md","hash":"99cd0316e2eecc2c774d9870ab20bd400c7620ba","modified":1726406887405},{"_id":"source/_posts/RBTree.md","hash":"ef946b6d1125e533d7722c28e54c94702dcec128","modified":1726470973952},{"_id":"source/_posts/compier.md","hash":"65ddebf3a19f570aa999710988d004a5dbf5a3b0","modified":1725323392506},{"_id":"source/_posts/CppInherit.md","hash":"bf02cfcbff4bfd35923f27ba2d2956c6a1d7e895","modified":1725612946135},{"_id":"source/_posts/c-file-cache.md","hash":"4705e190a9acaec97d7dd8b064a3e5b95d7322b7","modified":1722912127026},{"_id":"source/_posts/cfileop.md","hash":"861b53bb46ac53dd6922d4c29aba0f4530f1be69","modified":1722001456479},{"_id":"source/_posts/basicIO.md","hash":"db8bdac1fe882c2fe4f6e9b229fa1eb6c0b118b4","modified":1721883194416},{"_id":"source/_posts/cppsizeof.md","hash":"c0b730e8c01d34f2c66dae2078e1cd2455c63698","modified":1720685162500},{"_id":"source/_posts/create-mylist.md","hash":"fc807a91d09964502df0bcf0842783d7b013241c","modified":1715653226438},{"_id":"source/_posts/cpp-file-op.md","hash":"e8be16321b5e98ef442b6a8e03c311fa33720bd7","modified":1716350953093},{"_id":"source/_posts/evn.md","hash":"5ba5f76a05bc075c0c6a0c4c1aa44f64898d3aaf","modified":1721918324455},{"_id":"source/_posts/cpp-class.md","hash":"7a4e8f2a74943a59a236030ef2bf9931256664fe","modified":1715653247676},{"_id":"source/_posts/fork.md","hash":"d163f52434e0d1377f7fb70e6028529961365a8d","modified":1721917651970},{"_id":"source/_posts/heap-sort.md","hash":"9f7f483e46097ce0154eb8ce37b9148d5769219a","modified":1716304892748},{"_id":"source/_posts/filesys.md","hash":"cbe94338f941a5cea04187d1eb9648475514b754","modified":1722955019310},{"_id":"source/_posts/mergesort.md","hash":"35d2c34af3cdf3dcb5e5168232992dae90add52b","modified":1719990792497},{"_id":"source/_posts/libs.md","hash":"5b36dc3162fd9fa86d616c52ccdaadbb6f33a227","modified":1723264875793},{"_id":"source/_posts/mine-clearance.md","hash":"6dc2d64453d83deddd4d24bfe4abb2a4a0a815c9","modified":1715653268155},{"_id":"source/_posts/mutiInput.md","hash":"247cb73adc72b6733957c28f810264ebc61babab","modified":1715653295221},{"_id":"source/_posts/logSystem.md","hash":"585691b81d8426d0eef94763fd3e3bf0f18683ea","modified":1723624283362},{"_id":"source/_posts/myshell.md","hash":"09586da26379747684d29c2b84d8d45dd75393aa","modified":1718721501118},{"_id":"source/_posts/mistake1.md","hash":"822e5c6fc40110a8513faf0fc92c3ffd04d8edab","modified":1699921923958},{"_id":"source/_posts/pipe.md","hash":"0d458e914f47ab740f178798389e17a98aba2199","modified":1723540367501},{"_id":"source/_posts/processPool.md","hash":"4b5bf3cee44204f96d8b0ded2c5567f970587a1f","modified":1723520070248},{"_id":"source/_posts/spclass.md","hash":"2a807181883d91338db4272ab5be053880d05151","modified":1723431333498},{"_id":"source/_posts/progress.md","hash":"063df9ded20ede09c5b2b9e2a8d2500b937d6466","modified":1720366977386},{"_id":"source/_posts/pointer.md","hash":"003fcc6e68cd79c79ade4cb441548caed998a222","modified":1716390823399},{"_id":"source/_posts/shmd.md","hash":"d01db57729eabe9f5c65ddc6cf313949e0c68693","modified":1724726802632},{"_id":"source/_posts/progressMSG.md","hash":"eda0c817f71f0616949522c9dfb272864ec2ea3d","modified":1724636478595},{"_id":"source/_posts/thread.md","hash":"907af61e04c17cfff6110a895fb599ec5deee381","modified":1725867301246},{"_id":"source/_posts/算法_按位异或.md","hash":"99cc40b971ce541f575004db09cccaa400c17ae3","modified":1699921923959},{"_id":"source/_posts/usestatic.md","hash":"df62edaaa1dfd11bf4056988c30ebb469a64df66","modified":1719993665162},{"_id":"source/_posts/useScanf.md","hash":"f0f53909512bdf9121b0f35aaf78c141ff019d3d","modified":1715653305184},{"_id":"source/_posts/str-arr.md","hash":"7c1bff097e8250d6076623964beb3fc6a627ea74","modified":1715653316898},{"_id":"source/coss/custom.css","hash":"2fc60914d6e055b13d217d1db06ec681349fb125","modified":1699921923960},{"_id":"source/_posts/vim-cmd.md","hash":"b722350cf6688e4d88ff6beb06799e97bb4905e9","modified":1720001033185},{"_id":"source/categories/index.md","hash":"7f3a092a9a6047f93cfd3a0e0f0d513bdff30e26","modified":1699921923960},{"_id":"source/_posts/vueTheRoad.md","hash":"25c26bc360276733b794c2eb53711a598af5eec0","modified":1715653332821},{"_id":"source/about/indext.md","hash":"b62bfe0aaa1cc14a88cf6fa10fdaee7dbaa470fc","modified":1715079336157},{"_id":"source/_posts/双指针.md","hash":"1973e284c2890022207d6c1929c58a3f93d6945b","modified":1715212006059},{"_id":"source/tags/index.md","hash":"4571b54f250e173f7f4c5446a987a5239d2a1cd1","modified":1699921923962},{"_id":"source/link/index.md","hash":"5e32c142f4cfa8afa7410a6396542369a68c38d0","modified":1699921923961},{"_id":"source/img/favicon.png","hash":"904181e69465f5d510898b39eeb942886241fade","modified":1715078534656},{"_id":"source/_data/link.yml","hash":"58f368035b02bf3025c359e09957f4ec9e3282b7","modified":1699921923957},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"f6ae7f38d016135340fd25c5fd1be65452b6773d","modified":1699921921411},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"b684e7cc1100d22a59a13ec48d09b1eef0610e34","modified":1699921921412},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"d5de86b2fe60bae4eaf5aa8735fb681b10d29232","modified":1699921921513},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"5ca893c78f8971f512da55c785b8ccbfa9d37cfc","modified":1699921921411},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1699921921413},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1699921921439},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"115fa5ee8864e5c97549eff91a17c66101d724ab","modified":1699921921413},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1699921921411},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1699921921439},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1699921921440},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"6d68dab3b79accb1bceb4710c8aaab724a45053a","modified":1699921921513},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1699921921439},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"cc8672dc0c2762b694f689cbeb6e34810f1c194e","modified":1699921921412},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"d444cbb5c5456aaf27f3fb1b4308634689c7bb53","modified":1699921921412},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"4957fd976c99745d3aa24000a85b2955e8d1cf81","modified":1699921921412},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1699921921410},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"145ec301db185c8a06de1f34a77ca391e1d2729b","modified":1699921921413},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1699921921411},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"d9ff4bad9c9664e12729c7a531169a05698a3fd1","modified":1699921921410},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1699921921413},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1699921921410},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1699921921414},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1699921921413},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"b50b0afdc41c54279587410c3f82c8cb3c5ff46d","modified":1699921921414},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1699921921418},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"92683cb785a29e5a73701b33dba73d3afac268c3","modified":1699921921410},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1699921921514},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1699921921421},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1699921921514},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1699921921514},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1699921921514},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1699921921420},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1699921921515},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1699921921515},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"a3323fcb11cfd3f3e21230737341beb5d76b40aa","modified":1699921921516},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"c55f05400eb27ab051f47396ec8d4249ce6f71ec","modified":1699921921421},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1699921921516},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1699921921516},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1699921921515},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/findArchiveLength.js","hash":"8ff03b35385f9162e1eb54dceb5fa7f781306caf","modified":1699921921517},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"7222102f9919f8e961d4f1688425845fb7775ada","modified":1699921921517},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1699921921538},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"6005907245dd74b153f03afdccfae1abb66bb482","modified":1699921921517},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1699921921518},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1699921921518},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"b8d95ac1851c37f1dce4b1dd4a1d3ffdff501a03","modified":1699921921519},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1699921921519},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1699921921520},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1699921921520},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"e01a3967e5884881bab858b11635457df412de80","modified":1699921921519},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1699921921520},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1699921921521},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/score.js","hash":"fc5a80707cf522378be3cf8638ef78bccc88c510","modified":1699921921521},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1699921921522},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1699921921539},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"e1e37a2e932163886789b72624c7348545003f1d","modified":1699921921539},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1699921921521},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1699921921539},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"a102a6cacf7b20183946a54580867a964f3674c4","modified":1699921921543},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"4fd1cd7a02dedcb686caf6149c35fd8e1fbcafc9","modified":1699921921541},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1699921921540},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1699921921414},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"13b2b02118a0f4ec2e9e0bb1b90f5b1a30a70f44","modified":1699921921543},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1699921921415},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"f5207840c96df6b26ad227433babca4f8c362624","modified":1699921921415},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1699921921414},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1699921921415},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1699921921415},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1699921921415},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"fd55f0e09827ef40c53c48d184a553464aac3e03","modified":1699921921415},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1699921921417},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1699921921417},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1699921921417},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1699921921417},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1699921921418},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1699921921418},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"50b4b9c7f6a4771910be4198639cfcfc6d7b8925","modified":1699921921418},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1699921921419},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1699921921418},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1699921921420},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1699921921419},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1699921921419},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"3adb731465a4ab14529277fd7867889e0800ad16","modified":1699921921419},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1699921921420},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1699921921421},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1699921921422},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"cc1f7ae8a7ce5445277215821092e712ec8cc296","modified":1699921921420},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1699921921433},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1699921921420},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1699921921429},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1699921921433},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1699921921436},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"82bb447a5d045980789cf3f9de9d49cc32011b13","modified":1699921921433},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1699921921437},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1699921921436},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1699921921436},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1699921921437},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1699921921437},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1699921921438},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1699921921438},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1699921921437},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1699921921437},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1699921921438},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1699921921438},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1699921921438},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"e43017dbc73e0ce95dcfcb9dfb4fcce0c1715dd4","modified":1699921921523},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"ba94ceb40d7c81372a76103d958dcc2cc6a84f00","modified":1699921921439},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"431b4a252443e224872bd6b4f6aa76ed1679a82c","modified":1699921921523},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1699921921526},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"9893656128c347d1c09c90784627c84c979b326f","modified":1699921921523},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1699921921526},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"5e27f7842af82ff7498d4b59787ce9ca90fa9e6f","modified":1699921921527},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1699921921527},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"3969f599e8657adf8c3ce287d83f5d0a23f276a9","modified":1699921921526},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1699921921528},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1699921921528},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"20303c0dad28e5c5335ce2fa6582f1fafae5b628","modified":1699921921527},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"fc029f5e00d7904c0878efd20dd4e09fc55e1d03","modified":1699921921528},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1699921921530},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1699921921530},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"9066a62e442affce3a923a06a90486bf9d364e0e","modified":1699921921531},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"7e9b65dcae7ac54e0183bc841fea0f4bd4d78e5c","modified":1699921921530},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"824b2b2d2ee72583b9e009c0bb13e29e806534cc","modified":1699921921530},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1699921921531},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1699921921533},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"4c86c10f8ec0c8fb60b400a5a2f14699d3155be4","modified":1699921921532},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1699921921532},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1699921921532},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1699921921533},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1699921921533},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"57d333ef47bfb8fd22da31f600527c9d91e8e322","modified":1699921921534},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1699921921534},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1699921921534},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"cf90ea339fbb7f345212319627fcd68964024e40","modified":1699921921535},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"7c463ba25b3b54f0f46dfd75971d792816e942a8","modified":1699921921535},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1699921921535},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1699921921535},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1699921921536},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1699921921536},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1699921921536},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1699921921536},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"331c89ecfb79fab68466944a43e9e3d0ff49c646","modified":1699921921537},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1699921921537},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1699921921538},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1699921921537},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1699921921422},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"40e76d6da538cb3c1ef6b79ffc0adfa64fe6b8ba","modified":1699921921542},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"bbe930d8425bdaee2a5ba3cade42b617cee42934","modified":1699921921542},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"0010c7a10d265c4329f0fd4db85b4a9ea7ba06b5","modified":1699921921421},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"19b5cfa1f77781246e02967cefe149f19170e45f","modified":1699921921422},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1699921921422},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1699921921423},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"c42bbce31fcd8846cf3360f4c383dec9368daeba","modified":1699921921423},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1699921921423},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1699921921423},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1699921921422},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1699921921423},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1699921921424},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1699921921425},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1699921921424},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1699921921424},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1699921921424},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1699921921425},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f8b73bc63ec1b45d86aa3891d8c81ef4d5980943","modified":1699921921425},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"b19b123df682b23491b17dcca386d79062cd8f6e","modified":1699921921426},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"1a20b11fa0e6b1943e9b4d81e197a25ca36af66d","modified":1699921921426},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"b47698e153c73cb29286b19bec5ddd920cb7ffba","modified":1699921921425},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a56edeb1ce2f1b1fb0e866a30543f274b9f7d69e","modified":1699921921426},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"7c7fbe27d82becc9ee509765f1195c69f5864a0b","modified":1699921921426},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"c5e131d65a7ad30f3cb98ac3b94cd2f6a94c22e9","modified":1699921921426},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1699921921426},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1699921921428},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f618457d62ef35d78a31e7fb1e375a462f64b228","modified":1699921921428},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"386a2b371644c2682560733617561ba6e6bf9ab2","modified":1699921921428},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"6b0d28671afd5ed286a714f25ba16256a2e7d880","modified":1699921921429},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1699921921430},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1699921921430},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4bb4cf58e219dfb8787273c931b1ea978b2ab88f","modified":1699921921428},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"cba55cbbd0962bf84b8956195e686b0e158ed247","modified":1699921921429},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"a6be932d1f64c6190f5d03b5b77fba09fa0fd6b8","modified":1699921921431},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"da94966a9650ef3e4c69f3ee93758b30fa42cb78","modified":1699921921430},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1699921921430},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"cfcfaed3a52fa47fff4cc65a053a2f025fb3b7b6","modified":1699921921431},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"edd4ebf76a79fb74cfae03a286fab90f74324dbd","modified":1699921921432},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1699921921431},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"4f8bd22c5c32d5430cbe08ab4e861b6f8b86f820","modified":1699921921431},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"4fb998a05e51ef2302775945883307ee3039a544","modified":1699921921432},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ce4ab79c85df9f77395269eb01e9a023d7f96376","modified":1699921921432},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"2f3af113713563e34b10bbe998cc15008f81c85a","modified":1699921921433},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1699921921434},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"4b9c35375e0eb9cf99ad246d5ca838eca64a635d","modified":1699921921434},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1699921921434},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1699921921435},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1699921921435},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"ba04174d977da988a1d49c06641262c413352346","modified":1699921921434},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1699921921435},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1699921921435},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1699921921525},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1699921921524},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1699921921525},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1699921921525},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1699921921524},{"_id":"public/coss/custom.css","hash":"30a41bf8495adcb1d4a1bc1f8d7f5e16657e5643","modified":1726500287288},{"_id":"public/search.xml","hash":"68c1f4df4a226f368e7d713b94937d27cf31dead","modified":1726500287288},{"_id":"public/404.html","hash":"419e805675362df20549d438c1a2a849211b630f","modified":1726500287288},{"_id":"public/about/indext.html","hash":"b0282d8bc70e34872a713d2dbbfa7b0574ed2ad9","modified":1726500287288},{"_id":"public/categories/index.html","hash":"508c27660a6c3a932a0dbf9aef6bb23c98c5216c","modified":1726500287288},{"_id":"public/link/index.html","hash":"065165c0dfba531454a25f959bb5ad49de9d5d4d","modified":1726500287288},{"_id":"public/tags/index.html","hash":"9bda4dcf660cc6cba5141dd1e4b857478a1f4582","modified":1726500287288},{"_id":"public/2024/09/15/OLSIC/index.html","hash":"e78fd37ceda75d678308dc8015e4399e06914166","modified":1726500287288},{"_id":"public/2024/09/03/ACVA/index.html","hash":"b6fa76e88e4f084149c8b575e9ce8bd40083093a","modified":1726500287288},{"_id":"public/2024/09/03/RBTree/index.html","hash":"581fe4626a746025b9dbbff36faa18fc67b37839","modified":1726500287288},{"_id":"public/2024/09/02/compier/index.html","hash":"1e442452894424ac34191a7d3e41a6cba91b848c","modified":1726500287288},{"_id":"public/2024/09/02/CppInherit/index.html","hash":"b70fbb622902c4e4897346f87282af68bb997e90","modified":1726500287288},{"_id":"public/2024/08/14/thread/index.html","hash":"dd983bc2928ffba26c7a692efe96a7f9cc53efa8","modified":1726500287288},{"_id":"public/2024/08/14/shmd/index.html","hash":"3069827a70a02a010488b226f875d7688421189f","modified":1726500287288},{"_id":"public/2024/08/13/logSystem/index.html","hash":"51dd9413019d01085c8b524e3510a6200e785aa3","modified":1726500287288},{"_id":"public/2024/08/12/AVLTree/index.html","hash":"7f7e0c563e13c0992f69ea9f6d6fc1a0e109254b","modified":1726500287288},{"_id":"public/2024/08/12/spclass/index.html","hash":"a0a4a8b49074bcc6336623a6d80dc3e6c00ef232","modified":1726500287288},{"_id":"public/2024/08/02/pipe/index.html","hash":"73fb04b3ed59f28ed08b5d8af65d3704c4e660d5","modified":1726500287288},{"_id":"public/2024/08/02/progressMSG/index.html","hash":"dcb081796986f5fe85b6cf712703d8cf74838e9d","modified":1726500287288},{"_id":"public/2024/08/02/processPool/index.html","hash":"26651f3234cc5cc65ee32b4dbd7ba722e6004ac2","modified":1726500287288},{"_id":"public/2024/07/27/BSTree/index.html","hash":"3b82b72bfdfc7692420ea19c4d868dc03155fad3","modified":1726500287288},{"_id":"public/2024/07/26/c-file-cache/index.html","hash":"ef508c971270febe8039484709dd9e92937f43c1","modified":1726500287288},{"_id":"public/2024/07/26/filesys/index.html","hash":"dec264ac40d1083ce8804422e717d99aeaac4a8a","modified":1726500287288},{"_id":"public/2024/07/15/cfileop/index.html","hash":"b730514bfcd22d8068ea575d0954bc2ec7fe85b4","modified":1726500287288},{"_id":"public/2024/07/10/cppsizeof/index.html","hash":"41c9595082a9b0df572d578275a76d2a3d464612","modified":1726500287288},{"_id":"public/2024/07/10/basicIO/index.html","hash":"53cc3c3991b30c28c61b81b8752aadf17b6f8b83","modified":1726500287288},{"_id":"public/2024/07/08/libs/index.html","hash":"fa01dce8d9461c79b60349273ae96da8f7bad271","modified":1726500287288},{"_id":"public/2024/07/07/fork/index.html","hash":"d3e12c4ad776fb96a2eab1922e306cbe639b4255","modified":1726500287288},{"_id":"public/2024/07/06/evn/index.html","hash":"bd7f376fac37e75a11d9d95e05a879d3f177294b","modified":1726500287288},{"_id":"public/2024/07/04/progress/index.html","hash":"d378f87b9e8294fc80cfe908b67648202354bdb0","modified":1726500287288},{"_id":"public/2024/06/30/usestatic/index.html","hash":"9fd032f8353ebc00eb224189133fbc061ecb8ca5","modified":1726500287288},{"_id":"public/2024/06/28/mergesort/index.html","hash":"c2863fe6a5177bd6808377079acfdd866aad5164","modified":1726500287288},{"_id":"public/2024/05/21/heap-sort/index.html","hash":"de709f3593e0b61f33ff49305af78b08f14e3319","modified":1726500287288},{"_id":"public/2024/06/04/myshell/index.html","hash":"a7a13fe5b017bad72b8ccdfd77f6041008655d78","modified":1726500287288},{"_id":"public/2024/05/14/cpp-file-op/index.html","hash":"c3e1be145b0e22a74d040620dacd583b7ae6ef53","modified":1726500287288},{"_id":"public/2024/04/26/create-mylist/index.html","hash":"1781a9a43534246416209fe0abf6ef9dd7300be3","modified":1726500287288},{"_id":"public/2023/12/11/vim-cmd/index.html","hash":"d749142391af16990428c39e0805dc7531698731","modified":1726500287288},{"_id":"public/2023/12/07/cpp-class/index.html","hash":"91af4bbbb1cc5103e854ed2a32ec8094bda105bf","modified":1726500287288},{"_id":"public/2023/11/23/pointer/index.html","hash":"cb0d06a6d831e25190d7d4f061c8a98f088f1617","modified":1726500287288},{"_id":"public/2023/11/08/str-arr/index.html","hash":"e38b17e7599dd98d088b86f7412b6518edc33312","modified":1726500287288},{"_id":"public/2023/10/30/mine-clearance/index.html","hash":"04897e054bb79d974fa9ccb8860d1a5bccc1b5e4","modified":1726500287288},{"_id":"public/2023/10/18/mutiInput/index.html","hash":"7b1c35c425684df07f8061c144f84ea513cedd90","modified":1726500287288},{"_id":"public/2023/10/14/BiiigInt/index.html","hash":"eff0f7423ae0695fb5c9bf225137f5b92ce61fa1","modified":1726500287288},{"_id":"public/2023/10/05/useScanf/index.html","hash":"a782306a789a8393be8f9e24044dcbbee9894292","modified":1726500287288},{"_id":"public/2023/09/23/vueTheRoad/index.html","hash":"573c13b871f874a672127cae1a3f09911d10b9ed","modified":1726500287288},{"_id":"public/2023/09/12/双指针/index.html","hash":"429d5d5492948b772e221b32e9e2515a41347a84","modified":1726500287288},{"_id":"public/2023/09/04/算法_按位异或/index.html","hash":"cbc349fcf0f3cce09fc7344c5d186db37bc0f9e9","modified":1726500287288},{"_id":"public/2023/08/28/mistake1/index.html","hash":"ba302a55a980a3041c280ed1bcef688110871a18","modified":1726500287288},{"_id":"public/archives/index.html","hash":"c36e4b61d47ba5069fba824d1e62d699e87de29f","modified":1726500287288},{"_id":"public/archives/page/2/index.html","hash":"976f3ac69fbc32337689e405e3c25a876437db67","modified":1726500287288},{"_id":"public/archives/page/3/index.html","hash":"bc08a38d876f6af4cf8d63baa2921d6831efaf37","modified":1726500287288},{"_id":"public/archives/page/4/index.html","hash":"a8bdf3984e937f5ba0259c36f339cbfc885a1f04","modified":1726500287288},{"_id":"public/archives/page/5/index.html","hash":"de7734657180318575884a67a7ef7f3511f98f2b","modified":1726500287288},{"_id":"public/archives/2023/index.html","hash":"98428039d29fdd7a53d31b18368a8023a87c7930","modified":1726500287288},{"_id":"public/archives/2023/page/2/index.html","hash":"e22f01cc609e5b69b920ad05f06688a5839458c3","modified":1726500287288},{"_id":"public/archives/2023/08/index.html","hash":"6240eee7893dd5b554a8ddbbc4905722bc3afb34","modified":1726500287288},{"_id":"public/archives/2023/09/index.html","hash":"badbb6d1cabb74b3c095caa4154d88b8f50c5bcb","modified":1726500287288},{"_id":"public/archives/2023/10/index.html","hash":"701c01833029936942a926afbbfd0788f1260629","modified":1726500287288},{"_id":"public/archives/2023/11/index.html","hash":"b0e0cdfc3657a347f656821fdfd0bc9e66548438","modified":1726500287288},{"_id":"public/archives/2023/12/index.html","hash":"5f85caf358301b490e7d1ee38e08726568694eb8","modified":1726500287288},{"_id":"public/archives/2024/index.html","hash":"040a1493bede89b84a8a397799944f94a70a9f79","modified":1726500287288},{"_id":"public/archives/2024/page/2/index.html","hash":"e67c68931e1d0f6ab2652bbd669baed106115e95","modified":1726500287288},{"_id":"public/archives/2024/page/3/index.html","hash":"6192d4c846a2ac7748fbb19e2f8aaee94574b330","modified":1726500287288},{"_id":"public/archives/2024/04/index.html","hash":"b26f351fafcf124d5b069c55a7a6a815df6bc886","modified":1726500287288},{"_id":"public/archives/2024/05/index.html","hash":"879ff66ce6960f21e51427b6439f8032732c2f30","modified":1726500287288},{"_id":"public/archives/2024/06/index.html","hash":"39f152817c5685bd94adb606051ae340567355c2","modified":1726500287288},{"_id":"public/archives/2024/07/index.html","hash":"e51d010a4a6b6753eb22e1ef200edbfadef13703","modified":1726500287288},{"_id":"public/archives/2024/08/index.html","hash":"235276a80742e16855c69dc61eed78a897e80084","modified":1726500287288},{"_id":"public/archives/2024/09/index.html","hash":"00065205ed9ace07b41c3b0ae1a705fb6b9a53a9","modified":1726500287288},{"_id":"public/tags/数据结构-二叉树-搜索树/index.html","hash":"dea85344a4bf1d29279586dce72bf56db0d21dcd","modified":1726500287288},{"_id":"public/tags/C语言/index.html","hash":"cc9ac6ff6d4a55d538f911fb8feba1410fa21ab0","modified":1726500287288},{"_id":"public/tags/C-继承/index.html","hash":"550ff0e2a36b79f9548740a431478a208e7dcc9c","modified":1726500287288},{"_id":"public/tags/Linux/index.html","hash":"853630a939e28ea11ddd37d2bdf38e151e453400","modified":1726500287288},{"_id":"public/tags/C-类和对象/index.html","hash":"3872eb4ec605eb957c67b3235f4cb57d5ce8b0b2","modified":1726500287288},{"_id":"public/tags/C-文件/index.html","hash":"2078e3b88e22c92b33e4dded2082f85b564bf09d","modified":1726500287288},{"_id":"public/tags/环境变量/index.html","hash":"1dc095ab04d750687c13d2368881b8250daa5b79","modified":1726500287288},{"_id":"public/tags/fork-Linux/index.html","hash":"1205d623a8db1b2e7f228ed5de7599cdd039d427","modified":1726500287288},{"_id":"public/tags/七大排序-堆排序-排序/index.html","hash":"c7d2100198e476071a64d248d991f9bc5f37e247","modified":1726500287288},{"_id":"public/tags/排序-算法/index.html","hash":"1b96fd6e23c48507484b9edc90b43aecdc33b441","modified":1726500287288},{"_id":"public/tags/动态库-静态库/index.html","hash":"98a8274969bc121c7ea55c1342430fa47f08a812","modified":1726500287288},{"_id":"public/tags/C语言-实践项目/index.html","hash":"fcc181404c768cd65fce604e64d433df7aa6c321","modified":1726500287288},{"_id":"public/tags/Linux-C-日志/index.html","hash":"78699bcb60f29ad411642cb0a5a84307f403165b","modified":1726500287288},{"_id":"public/tags/C语言-多组输入/index.html","hash":"d3e10c5089c173e8fff20b3e2c9fef80a63518a8","modified":1726500287288},{"_id":"public/tags/Linux-C/index.html","hash":"cd8bd04e477aaff6cfe9ce1c00322d44d51ddf40","modified":1726500287288},{"_id":"public/tags/进程-Linux/index.html","hash":"377436777a808977b542deeb53176ee70eac9648","modified":1726500287288},{"_id":"public/tags/Linux-vim/index.html","hash":"8f1f8ce7de2abd310796ee297c47a89295b3d4b4","modified":1726500287288},{"_id":"public/tags/C语言-字符串-数组/index.html","hash":"d91475f54b9a78a5170c14d1e154075a306ffd8b","modified":1726500287288},{"_id":"public/tags/回顾/index.html","hash":"0f106dcc02afda306418e00a86de7531ef7bf26a","modified":1726500287288},{"_id":"public/tags/算法/index.html","hash":"87e3e623935ab4b21aeb437044a5b29feb0cc15a","modified":1726500287288},{"_id":"public/index.html","hash":"e6f8996fcc145e13a547cc3f2bae3e83cb7462c0","modified":1726500287288},{"_id":"public/page/2/index.html","hash":"25b692fc9d6c691adf8e582240174e5eae23a59c","modified":1726500287288},{"_id":"public/page/4/index.html","hash":"9c0651211cfc340a14dc317221050bc8419d2ac6","modified":1726500287288},{"_id":"public/page/3/index.html","hash":"3423f33b673be8ab6710e587e169e6b9cd3c2d6d","modified":1726500287288},{"_id":"public/page/5/index.html","hash":"3b0bad8f8ad9bcf8dcfa6987c27db753cdcb96f9","modified":1726500287288},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1726500287288},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1726500287288},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1726500287288},{"_id":"public/css/index.css","hash":"3db711ba85c6ee09832da7cc10b118fbe1a257d5","modified":1726500287288},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1726500287288},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1726500287288},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1726500287288},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1726500287288},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1726500287288},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1726500287288}],"Category":[],"Data":[{"_id":"link","data":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}],"Page":[{"_content":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }","source":"coss/custom.css","raw":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }","date":"2023-11-14T00:32:03.960Z","updated":"2023-11-14T00:32:03.960Z","path":"coss/custom.css","layout":"false","title":"","comments":1,"_id":"cm155p07w00004sp5e87x82xa","content":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/fbd897def1737d82803bc185dc431920.jpg","cover_type":"img","excerpt":"","more":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }"},{"title":"关于","date":"2023-08-23T04:00:00.000Z","type":"about","_content":"\n这是个about","source":"about/indext.md","raw":"---\ntitle: 关于\ndate: 2023-08-23 12:00:00\ntype: \"about\"\n---\n\n这是个about","updated":"2024-05-07T10:55:36.157Z","path":"about/indext.html","comments":1,"layout":"page","_id":"cm155p08000024sp5gtmt6i81","content":"<p>这是个about</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/12a4cf6640ed132e210ab645ff95c1e2.jpg","cover_type":"img","excerpt":"","more":"<p>这是个about</p>\n"},{"title":"categories","date":"2023-09-03T03:23:20.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-09-03 11:23:20\ntype: \"categories\"\n---\n","updated":"2023-11-14T00:32:03.960Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cm155p08100044sp5cc6a3ks6","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/7be4e5cabc1892f13a8ce4d55cbd787c.jpg","cover_type":"img","excerpt":"","more":""},{"title":"link","date":"2023-08-22T01:56:32.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2023-08-22 09:56:32\ntype: \"link\"\n---\n","updated":"2023-11-14T00:32:03.961Z","path":"link/index.html","comments":1,"layout":"page","_id":"cm155p08200064sp5f53y5afw","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/12a4cf6640ed132e210ab645ff95c1e2.jpg","cover_type":"img","excerpt":"","more":""},{"title":"tags","date":"2023-08-22T01:54:41.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-08-22 09:54:41\ntype: \"tags\"\n---\n","updated":"2023-11-14T00:32:03.962Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cm155p08300094sp51grk855d","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409052348435.jpg","cover_type":"img","excerpt":"","more":""}],"Post":[{"title":"【python项目实践】ACVA航空公司客户价值分析","date":"2024-09-03T01:38:54.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_COVER.png","_content":"# 背景分析\n\n## 航空公司现状\n\n#### 行业内竞争\n民航的竞争除了三大航空公司之间的竞争外，还将加入新崛起的各类小型航空公司、民营航空公司，甚至国外航空巨头。航空产品**生产过剩,产品同质化**特征愈加明显，于是航空公司从**价格、服务**间的竞争逐渐转向对**客户**的竞争\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/airliness.png)\n\n## 行业外竞争\n随着**高铁**、动车等铁路运输的兴建，航空公司受到巨大冲击\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/transportalrad.png)\n\n*如上图所示，经过2010到2015年的发展，铁路运输对航空运输的冲击越发明显*\n\n## 航空公司数据特征说明\n+ 目前航空公司已经积累了大量的会员档案信息和其乘坐航班记录\n+ 就本项目已获取的数据，以2014-03-31为结束时间，选取宽度为**两年**的时间段作为分析观测窗口，抽取观测窗口内有乘机记录的所有客户的详细数据形成的历史数据，44个特征，总共62988条记录。\n \n数据特征记录说明如下表所示:\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE1.png)\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE2.png)\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE3.png)\n\n## 结合数据的项目目标\n结合目前航空公司的数据情况，可以实现以下目标\n\n+ 借助航空公司客户数据，对客户进行分类\n+ 对不同的客户类别`进行特征分析`，比较不同类别客户的`客户价值`\n+ 对不同价值的客户类别提供`个性化服务`,制定相应的`营销策略`\n\n## 了解客户价值分析\n客户营销战略倡导者*Jay* & *Adam Curry* 从国外数百家公司进行了客户营销实施的经验中提炼了如下经验\n\n+ 公司**收入**的`80%`来自顶端的`20%`客户\n+ `20%`的客户其利`润率100%`\n+ `90%`以上的收入来自**现有**客户\n+ **大部分的营销预算**经常被用在非现有客户上\n+ `5%`至`30%`的客户在客户金字塔中具有**升级潜力**\n+ 客户金字塔中客户升级`2%`，意味着营销收入增加`10%`,利润增加`50%`\n\n也许这些经验并不完全准确，但是它解释了新时代`客户分化`的趋势，也说明了对客户价值分析的**迫切性**和**必要性**\n\n## 项目流程图\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_flow_char.png)\n\n# 代码实现业务功能\n\n## 系统架构\n\n### 文件结构\n这里主要用三个文件夹，分别储存`代码`，`原始数据`,`临时文件`\n\n+ `codes`       代码文件夹\n+ `data_raw`    原始数据文件夹\n+ `tmp`         临时文件文件夹\n\n## 代码结构\n\n本业务系统采用一个`main.py`执行主要业务逻辑，封装多个模块和类实现具体业务，以达到主要业务逻辑清晰，代码封装性强，易于维护和复用的优点\n\n主要的代码文件有:\n\n+ main.py       执行主要逻辑\n+ log.py        提供日志器\n+ data_cleaner  实现清洗数据\n+ LEDNX.py      构建和提取五大特征\n+ radar_char.py 绘制结果雷达图\n\n## 实现一个简单的日志器\n一般日志器有`日志等级`，`日志时间`，和`日志内容`三大部分，不过本次业务与时间关联性不大，就只打印两个部分\n\n> log.py\n```Python\n###### 实现日志系统 ########\n\n# 定义日志等级\nLOG_INFO = \"Info\"\nLOG_ERROR = \"Error\"\nLOG_WANING = \"Warning\"\nLOG_FATAL = \"Fatal\"\n\nclass Log:\n    def __init__(self):\n        return\n\n    def __call__(self,level,*msgs): # 重载()运算符\n        print(\"[\", level, \"]\",end='')\n        for msg in msgs:\n            print(msg)\n        # 本项目与时间关系不大，日志系统不打印时间\n```\n\n这里使用了`__call__`对`()`操作符的`重载`，和`*mgs`达到了`传递任意数量参数`的语法特性\n\n这样以后打印日志可以方便地把对象当函数用\n\n## 程序入口 & 从数据源提取数据\n我们将`main.py`作为项目的程序入口\n\n> main.py\n```Python\n######### 主程序入口 #############\nimport numpy as np\nimport pandas as pd\nfrom sklearn.cluster import KMeans\nimport time\n\nfrom log import *\nfrom data_clean import *\nfrom LRFMC import *\n\nif __name__ == '__main__':\n\n    log = Log()  # 实例化一个日志器\n    data_cleaner = DataCleaner() #实例化数据清洗器\n    LRFMCobj = LRFMC()  # 实例化模型处理器\n```\n\n这里的数据源为`.csv`文件，所以我们要用到`pandas`模块读取文件到表格中\n\n这里代码不多，就直接写在`main.py`里了\n\n```Python\n    # ...上略...\n    #data_cleaner = DataCleaner() #实例化数据清洗器\n\n    # 从数据源获取数据\n    airline_data = pd.read_csv(\"../data_raw/air_data.csv\",\n        encoding=\"gb18030\")  # 导入航空数据\n    log(LOG_INFO,'原始数据的形状为：', airline_data.shape)\n\n```\n\n## 预处理航空公司数据\n航空公司客户原始数据存在少量的`缺失值`和`异常值`，需要清洗后才能用于分析。\n\n### 缺失值处理\n通过对数据观察发现原始数据中存在票价为空值，票价最小值为0，折扣率最小值为0，总飞行公里数大于0的记录。票价为空值的数据可能是客户不存在乘机记录造成。\n\n处理方法：丢弃票价为空的记录\n\n具体实现： 考虑到与票价有关的特征有`SUM_YR_1`和`SUM_YR_2`两条，逻辑上两条特征数据都为`0`才算`缺失值`,所以分别提取两条对应的`布尔值列表`，并用`逻辑与`合并，用于数据表格的切片\n\n*我们先定义好成员函数，最后封装到DataCleaner类中*\n> data_cleaner.py\n```Python\n    def notNull(self,airline_data):  # 缺失值处理：去除票价为空的记录\n        exp1 = airline_data[\"SUM_YR_1\"].notnull()\n        exp2 = airline_data[\"SUM_YR_2\"].notnull()\n        exp = exp1 & exp2  # 按位逻辑与,获取所需的布尔值列表\n        # airline_notnull = airline_data.loc[exp, :]  # exp提供布尔值竖列表， ':'默认无参时，切片所有行,完成去除操作\n        airline_notnull = airline_data[exp] #  这是上一句的简化写法（使用更多的缺省参数\n\n        return airline_notnull\n```\n\n### 异常值\n\n其他的数据可能是客户乘坐`0折机票`或者`积分兑换`造成。由于原始数据量大，这类数据所占比例较小，对于问题影响不大，因此对其进行丢弃处理。\n\n处理方法：丢弃**票价为0，平均折扣率为0，总飞行公里数大于0的记录。**\n\n具体处理：采用`index1`和`index2`先保留总票价不为`0`的记录,然后用`index3`筛选出总里程`SEG_KM_SUM``>0`且平均折扣率`avg_discount``!=0`的记录,使用布尔值列表`(index1 | index2) & index3`进行筛选，保留所需数据\n\n```Python\n    def notOutlier(self,airline_data):\n        index1 = airline_data[\"SUM_YR_1\"].notnull()\n        index2 = airline_data[\"SUM_YR_2\"] != 0  # 效果和上一句的notnull()一样,都是生成bool array\n        index3 = (airline_data[\"SEG_KM_SUM\"] > 0) & \\\n                 (airline_data[\"avg_discount\"] != 0)  # 折扣且总里程不为0的机票\n        airline = airline_data[(index1 | index2) & index3]  # 丢弃票价为0，或折扣率为0，且总里程>0的异常值\n        return airline\n```\n\n### 封装DataCleaner类\n将用于清理数据的函数整合到一个类中，方便维护，添加或修改新的清理规则也很可以很方便地找到`DataCleaner`类，在里面集中维护s\n\n> data_cleaner.py\n```Python\nclass DataCleaner:\n    def __init__(self):\n        return\n    def notNull(self,airline_data):  # 缺失值处理：去除票价为空的记录\n        exp1 = airline_data[\"SUM_YR_1\"].notnull()\n        exp2 = airline_data[\"SUM_YR_2\"].notnull()\n        exp = exp1 & exp2  # 按位逻辑与,获取所需的布尔值列表\n        #airline_notnull = airline_data.loc[exp, :]  # exp提供布尔值竖列表， ':'默认无参时，切片所有行,完成去除操作\n        airline_notnull = airline_data[exp] #  这是上一句的简化写法（使用更多的缺省参数\n        return airline_notnull\n\n    def notOutlier(self,airline_data):\n        index1 = airline_data[\"SUM_YR_1\"].notnull()\n        index2 = airline_data[\"SUM_YR_2\"] != 0  # 效果和上一句的notnull()一样,都是生成bool array\n        index3 = (airline_data[\"SEG_KM_SUM\"] > 0) & \\\n                 (airline_data[\"avg_discount\"] != 0)  # 折扣且总里程不为0的机票\n        airline = airline_data[(index1 | index2) & index3]  # 丢弃票价为0，或折扣率为0，且总里程>0的异常值\n        return airline\n\n```\n\n## RFM到LFRMC模型的介绍\n\n### RFM模型介绍\n本项目的目标是客户价值分析，即通过航空公司客户数据识别不同价值的客户，识别客户价值应用最广泛的模型是RFM模型。\n\n> + **R**（`Recency`）指的是最近一次消费时间与截止时间的间隔。通常情况下，最近一次消费时间与截止时间的间隔越短，对即时提供的商品或是服务也最有可能感兴趣。\n> + **F**（`Frequency`）指顾客在某段时间内所消费的次数。可以说消费频率越高的顾客，也是满意度越高的顾客，其忠诚度也就越高，顾客价值也就越大。\n> + **M**（`Monetary`）指顾客在某段时间内所消费的金额。消费金额越大的顾客，他们的消费能力自然也就越大，这就是所谓“20%的顾客贡献了80%的销售额”的二八法则。\n\n### RFM模型结果解读\n\nRFM模型包括三个特征，使用**三维坐标系**进行展示，如图所示。X轴表示`Recency`，Y轴表示`Frequency`，Z轴表示`Monetary`，每个轴一般会分成5级表示程度，1为最小，5为最大\n\n*如图，不同的区域有有不同的营销策略*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RFM_model_res.png)\n\n### 传统RFM模型在航空行业的缺陷\n\n在RFM模型中，消费金额表示在一段时间内，客户购买该企业产品金额的总和，由于航空票价受到运输距离，舱位等级等多种因素影响，同样消费金额的不同旅客对航空公司的价值是不同的，因此这个特征并不适合用于航空公司的客户价值分析。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_RFM_LOw.png)\n\n### 航空客户价值分析的LRFMC模型\n为了弥补传统RFM模型在实际应用中的缺陷，本次项目使用了适用于航空客户价值分析的`LRFMC模型`\n\n本项目选择客户在一定时间内累积的飞行里程M和客户在一定时间内乘坐舱位所对应的折扣系数的平均值C两个特征代替消费金额。此外，航空公司会员入会时间的长短在一定程度上能够影响客户价值，所以在模型中增加客户关系长度L，作为区分客户的另一特征。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_LRFMC.png)\n\n## 构建航空客户价值分析的关键特征\n\n这里依然使用模块封装和类封装，在`LRFMC.py`中封装`LRFMC`类来完成模型相关的数据处理\n\n### 选取关键特征 和 构建L特征\n我们首先选取上图相关特征的列到`airline_selection`中，用于构建`L`特征和后面选取后四列与`L`列合并\n\n> LRFMC.py\n```Python\n######## 构建 LRFMC模型 ########\nimport pandas as pd\nfrom log import *\n\nclass LRFMC:\n    def __init__(self):\n        self.log = Log()\n        return\n    def getFeatures(self,airline):\n        # 选取需求特征\n        airline_selection = airline[[\"FFP_DATE\",\"LOAD_TIME\",\n                                     \"FLIGHT_COUNT\",\"LAST_TO_END\",\n                                     \"avg_discount\",\"SEG_KM_SUM\"]]\n        # 构建L特征\n        L = pd.to_datetime(airline_selection[\"LOAD_TIME\"]) \\\n            - pd.to_datetime(airline_selection[\"FFP_DATE\"])\n        self.log(LOG_DEBUG,\"\\n\",L[:5])  #测试前五行\n        # 转成月份\n        L = L.astype(\"str\").str.split().str[0]\n        L = L.astype(\"int\")/30\n\n        #合并特征\n        airline_features = pd.concat([L,\n                airline_selection.iloc[:,2:]],axis = 1)  #axis=1使函数按列合并,[:,2:]舍弃了原本的前两列\n        airline_features =airline_features.rename(columns={0:\"L\"}) # 重命名没有名字的列\n        self.log(LOG_DEBUG,\"\\n\",airline_features.head())  #缺省参数为5，打印前五行\n        return airline_features\n```\n\n### 标准化\n完成五个特征的构建以后，对每个特征数据分布情况进行分析，其数据的取值范围如下表所示。从表中数据可以发现，**五个特征的取值范围数据差异较大**，为了消除数量级数据带来的影响，需要对数据做`标准化处理`。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_Stadert_table.png)\n\n这里使用 `sklearn`模块中的 `StandardScaler`类来自动标准化数据，然后我们将标准化后的数据再转成`pandas`表格，最后储存到临时文件`airline_scale.xlsx`中\n\n> LRFMC.py\n```Python\n    def storeStandData(self,airline_features):\n        data = StandardScaler().fit_transform(airline_features)\n        SDF = pd.DataFrame(data);  #获取 standardDataFrame(SDF)\n        SDF = SDF.rename(columns={0:\"L\",1:\"F\",2:\"R\",3:\"C\",4:\"M\"})\n        self.log(LOG_INFO,\"标准化后的前五行的LRFMC五个特征为\\n\",SDF.head())\n        SDF.to_excel(\"../tmp/airline_scale.xlsx\")  ##储存值tmp文件夹\n```\n\n前五行标准化前后的结果如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/acva_sta_raw.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_STA.png)\n\n## 了解和使用`K-Means`聚类算法\n即使经过了一系列预处理和模型建模，我们手上的数据依然还是比较原始，只有经过分类过的数据才更有分析价值，而自然数据一般都难以直接分类，需要用聚类算法进行分类，这里就用到了`K-Means`聚类算法\n\n### 基本概念\nK-Means聚类算法是一种基于质心的划分方法，输入聚类个数k，以及包含n个数据对象的数据库，输出满足误差平方和最小标准的k个聚类。算法步骤如下:\n\n+ 从n个样本数据中随机选取k个对象作为初始的聚类中心。\n+ 分别计算每个样本到各个聚类质心的距离，将样本分配到距离最近的那个聚类中心类别中。\n+ 所有样本分配完成后，重新计算k个聚类的中心。\n+ 与前一次计算得到的k个聚类中心比较，如果聚类中心发生变化，转(2)，否则转(5)。\n+ 当质心不发生变化时停止并输出聚类结果。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_KMEANS.png)\n\n### 数据类型\nK-Means聚类算法是在数值类型数据的基础上进行研究，然而数据分析的样本复杂多样，因此要求不仅能够对特征为数值类型的数据进行分析，还要适应数据类型的变化，对不同特征做不同变换，以满足算法的要求。\n\n### 获取KMeans对象\nsklearn的cluster模块提供了KMeans函数构建K-Means聚类模型\n\n翻阅其源代码(下图)，可以看到`KMeans`是一个**类**，且构造函数有大量缺省参数，因此实例化`KMeans`对象时，只需提供无缺省的参数，和调整关键缺省参数即可\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/K-Means_org.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_Kmeans_para.png)\n\n这里我们只显式传参`n_clusters`和`random_state`,其中后一个参数用时间戳\n\n因为本身`KMeans`就封装地很好，这部分代码就写在`main.py`的主逻辑中\n\n> main.py\n```Python\n    ## 对象实例化\n    k = 5 ## 确定聚类中心数，这里我们预期聚类5类客户\n    kmeans_model = KMeans(n_clusters=k,random_state=int(time.time()))  # 实例化对象\n    kmeans_model = kmeans_model.fit(airline_scale)  # 用准备好的数据训练模型\n    centers = kmeans_model.cluster_centers_\n    log(LOG_INFO,\"五个聚类中心为\\n\",centers)\n\n    ## 统计不同类别样本的数目\n    r1 = pd.Series(kmeans_model.labels_).value_counts()\n    log(LOG_INFO,\"最终每个类别的数目为\\n\",r1)\n```\n\n最后聚类的结果类似下表\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_CLUSTER_RES.png)\n\n至此数据的分析，建模和聚类已经完成，数据处理部分告一段落，接下来是可视化处理\n\n## 可视化雷达图\n\n这里使用`matplotlib.pyplot`模块作图，`numpy`二次处理数据,封装代码到`RadarDrawer`类中并用`__call__`重载`()`操作符\n\n值得注意的是:\n\n+ 因为这里使用了雷达图，所以绘制图形时使用`极坐标`会更方便\n+ 因为这里使用了中文文字，而默认字体不支持中文，会报错，所以要**提前设置中文字体**\n\n> radar_chart.py\n```Python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nclass RadarDrawer():\n    def __init__(self):\n        return\n\n    def __call__(self, kmeans_moudel, n_clusters):\n        # 设置支持中文的字体\n        plt.rc(\"font\",family=\"Microsoft YaHei\")\n        # 标签\n        labels = np.array([u'ZL',u'ZR',u'ZF',u'ZM',u'ZC'])\n\n        plot_data = kmeans_moudel.cluster_centers_\n        # 指定颜色\n        color = ['b','g','r','c','y']\n        # 计算雷达图的角度\n        angles = np.linspace(0,2*np.pi,n_clusters,endpoint=False)\n\n        # 闭合(首尾列相同) 并用np把pandas的DataFrame转成原生数组\n        plot_data = np.concatenate((plot_data,plot_data[:,[0]]),axis = 1)\n        angles_org = angles\n        angles = np.concatenate((angles,[angles[0]]))\n\n        fig = plt.figure(figsize=(6,6),dpi = 160)\n        #polar参数\n        ax = fig.add_subplot(111, polar=True)  # 设置坐标为极坐标\n        # 画若干个五边形\n        floor = np.floor(plot_data.min())   # 大于最小值的最大整数\n        ceil = np.ceil(plot_data.max())     # 小于最小值的最小整数\n        n = len(labels)\n        for i in np.arange(floor,ceil+0.5, 0.5):\n            ax.plot(angles,[i] *(n+1),'-.',lw=0.5,color='black')\n        # 话不同客户群的分割线\n        for i in range(len(plot_data)):\n            ax.plot(angles,plot_data[i],color = color[i],\n                    label='客户群'+str(i+1),linewidth=2, linestyle='-.')\n        ax.set_rgrids(np.arange(0,2.5, 0.5))  # 画出每层的权重\n        ax.set_thetagrids(angles_org* 180/np.pi,labels)  # 设置显示的角度为度数制\n        plt.legend(loc='lower right',bbox_to_anchor=(1.1, -0.1))  #设置图例位置在画布外\n        #plt.legend()\n\n        #ax.set_theta_zero_location('N')         # 设置极坐标的起点（即0°）在正北方向\n        ax.spines['polar'].set_visible(False)   # 不显示极坐标最外面的圈\n        ax.grid(False)                          # 不显示默认分割线\n        plt.savefig(\"../tmp/ACVA_img.png\")      # 储存图像的临时文件\n        plt.show()\n```\n\n## 重新组织main.py\n\n至此所有的功能已经实现，并封装到了各个模块和类中，所以我们再重新组织一次`main.py`，并最终定档其中的代码\n\n> main.py\n```Python\n######### 主程序入口 #############\nimport pandas as pd\nfrom sklearn.cluster import KMeans\nimport time\n\nfrom log import *\nfrom data_clean import *\nfrom LRFMC import *\nfrom radar_chart import  *\n\nif __name__ == '__main__':\n\n    log = Log()  # 实例化一个日志器\n    data_cleaner = DataCleaner() #实例化数据清洗器\n    LRFMCobj = LRFMC() # 实例化模型处理器\n\n    # 从数据源获取数据\n    airline_data = pd.read_csv(\"../data_raw/air_data.csv\",\n        encoding=\"gb18030\")  # 导入航空数据\n    log(LOG_INFO,'原始数据的形状为：', airline_data.shape)\n\n    #数据预处理\n    ## 缺失值处理：去除票价为空的记录\n    airline_notnull = data_cleaner.notNull(airline_data)\n    log(LOG_INFO,'删除缺失记录后数据的形状为：', airline_notnull.shape)\n\n    ## 异常值处理: 只保留票价非零的，或者平均折扣率不为0且总飞行公里数大于0的记录。\n    airline = data_cleaner.notOutlier(airline_notnull)\n    log(LOG_INFO,'删除异常记录后数据的形状为：', airline.shape)\n\n    # 构建LRFMC五大特征\n    airline_features = LRFMCobj.getFeatures(airline)\n    LRFMCobj.storeStandData(airline_features)\n\n    # 获取KMeans对象\n    ## 准备数据\n    airline_scale = pd.read_excel(\"../tmp/airline_scale.xlsx\")\n    airline_scale = airline_scale.iloc[:,1:]  # 切掉第一列的作为行数标志的数字\n\n    ## 对象实例化\n    k = 5 ## 确定聚类中心数，这里我们预期聚类5类客户\n    kmeans_model = KMeans(n_clusters=k,random_state=int(time.time()))  # 实例化对象\n    kmeans_model = kmeans_model.fit(airline_scale)  # 用准备好的数据训练模型\n    centers = kmeans_model.cluster_centers_\n    log(LOG_INFO,\"五个聚类中心为\\n\",centers)\n\n    ## 统计不同类别样本的数目\n    r1 = pd.Series(kmeans_model.labels_).value_counts()\n    log(LOG_INFO,\"最终每个类别的数目为\\n\",r1)\n\n    # 作出图样\n    RadarDrawer()(kmeans_model,n_clusters=k)\n    log(LOG_INFO,\"完成作图\")\n```\n\n可以看到，经过一系列封装，`main.py`只有寥寥50多行，确已经体现了主要的 业务逻辑\n\n# 分析聚类结果\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_output.png)\n\n基于特征描述，本项目定义五个等级的客户类别：重要保持客户，重要发展客户，重要挽留客户，一般客户，低价值客户\n\n# 模型应用\n根据对各个客户群进行特征分析，采取下面的一些营销手段和策略，为航空公司的价值客户群管理提供参考\n\n+ `会员的升级与保级`：航空公司可以在对会员升级或保级进行评价的时间点之前，对那些接近但尚未达到要求的较高消费客户进行适当提醒甚至采取一些促销活动，刺激他们通过消费达到相应标准。这样既可以获得收益，同时也提高了客户的满意度，增加了公司的精英会员。\n+ `首次兑换`：采取的措施是从数据库中提取出接近但尚未达到首次兑换标准的会员，对他们进行提醒或促销，使他们通过消费达到标准。一旦实现了首次兑换，客户在本公司进行再次消费兑换就比在其他公司进行兑换要容易许多，在一定程度上等于提高了转移的成本。\n+ `交叉销售`：通过发行联名卡等与非航空类企业的合作，使客户在其他企业的消费过程中获得本公司的积分，增强与公司的联系，提高他们的忠诚度。\n\n# 小结\n本项目结合航空公司客户价值分析的案例，重点介绍了数据分析算法中K-Means聚类算法在客户价值分析中的应用。针对RFM客户价值分析模型的不足，使用K-Means算法构建了航空客户价值分析LRFMC模型，详细描述了数据分析的整个过程。\n\n# github项目文件 和 相关外部链接\n[戳我去github仓库🔗](https://github.com/sis-shen/ACVA)\n\n[戳我去KMeans源码🔗](https://github.com/scikit-learn/scikit-learn/blob/fd237278e/sklearn/cluster/_kmeans.py#L745)\n\n[戳我去pandas文档下载🔗](https://pandas.pydata.org/docs/)\n\n[戳我去matplotlib的API文档🔗](https://matplotlib.org/stable/api/index)\n\n[戳我去numpy文档🔗](https://numpy.org/doc/stable/)","source":"_posts/ACVA.md","raw":"---\ntitle: 【python项目实践】ACVA航空公司客户价值分析\ndate: 2024-09-03 09:38:54\ntags:\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_COVER.png\n---\n# 背景分析\n\n## 航空公司现状\n\n#### 行业内竞争\n民航的竞争除了三大航空公司之间的竞争外，还将加入新崛起的各类小型航空公司、民营航空公司，甚至国外航空巨头。航空产品**生产过剩,产品同质化**特征愈加明显，于是航空公司从**价格、服务**间的竞争逐渐转向对**客户**的竞争\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/airliness.png)\n\n## 行业外竞争\n随着**高铁**、动车等铁路运输的兴建，航空公司受到巨大冲击\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/transportalrad.png)\n\n*如上图所示，经过2010到2015年的发展，铁路运输对航空运输的冲击越发明显*\n\n## 航空公司数据特征说明\n+ 目前航空公司已经积累了大量的会员档案信息和其乘坐航班记录\n+ 就本项目已获取的数据，以2014-03-31为结束时间，选取宽度为**两年**的时间段作为分析观测窗口，抽取观测窗口内有乘机记录的所有客户的详细数据形成的历史数据，44个特征，总共62988条记录。\n \n数据特征记录说明如下表所示:\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE1.png)\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE2.png)\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE3.png)\n\n## 结合数据的项目目标\n结合目前航空公司的数据情况，可以实现以下目标\n\n+ 借助航空公司客户数据，对客户进行分类\n+ 对不同的客户类别`进行特征分析`，比较不同类别客户的`客户价值`\n+ 对不同价值的客户类别提供`个性化服务`,制定相应的`营销策略`\n\n## 了解客户价值分析\n客户营销战略倡导者*Jay* & *Adam Curry* 从国外数百家公司进行了客户营销实施的经验中提炼了如下经验\n\n+ 公司**收入**的`80%`来自顶端的`20%`客户\n+ `20%`的客户其利`润率100%`\n+ `90%`以上的收入来自**现有**客户\n+ **大部分的营销预算**经常被用在非现有客户上\n+ `5%`至`30%`的客户在客户金字塔中具有**升级潜力**\n+ 客户金字塔中客户升级`2%`，意味着营销收入增加`10%`,利润增加`50%`\n\n也许这些经验并不完全准确，但是它解释了新时代`客户分化`的趋势，也说明了对客户价值分析的**迫切性**和**必要性**\n\n## 项目流程图\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_flow_char.png)\n\n# 代码实现业务功能\n\n## 系统架构\n\n### 文件结构\n这里主要用三个文件夹，分别储存`代码`，`原始数据`,`临时文件`\n\n+ `codes`       代码文件夹\n+ `data_raw`    原始数据文件夹\n+ `tmp`         临时文件文件夹\n\n## 代码结构\n\n本业务系统采用一个`main.py`执行主要业务逻辑，封装多个模块和类实现具体业务，以达到主要业务逻辑清晰，代码封装性强，易于维护和复用的优点\n\n主要的代码文件有:\n\n+ main.py       执行主要逻辑\n+ log.py        提供日志器\n+ data_cleaner  实现清洗数据\n+ LEDNX.py      构建和提取五大特征\n+ radar_char.py 绘制结果雷达图\n\n## 实现一个简单的日志器\n一般日志器有`日志等级`，`日志时间`，和`日志内容`三大部分，不过本次业务与时间关联性不大，就只打印两个部分\n\n> log.py\n```Python\n###### 实现日志系统 ########\n\n# 定义日志等级\nLOG_INFO = \"Info\"\nLOG_ERROR = \"Error\"\nLOG_WANING = \"Warning\"\nLOG_FATAL = \"Fatal\"\n\nclass Log:\n    def __init__(self):\n        return\n\n    def __call__(self,level,*msgs): # 重载()运算符\n        print(\"[\", level, \"]\",end='')\n        for msg in msgs:\n            print(msg)\n        # 本项目与时间关系不大，日志系统不打印时间\n```\n\n这里使用了`__call__`对`()`操作符的`重载`，和`*mgs`达到了`传递任意数量参数`的语法特性\n\n这样以后打印日志可以方便地把对象当函数用\n\n## 程序入口 & 从数据源提取数据\n我们将`main.py`作为项目的程序入口\n\n> main.py\n```Python\n######### 主程序入口 #############\nimport numpy as np\nimport pandas as pd\nfrom sklearn.cluster import KMeans\nimport time\n\nfrom log import *\nfrom data_clean import *\nfrom LRFMC import *\n\nif __name__ == '__main__':\n\n    log = Log()  # 实例化一个日志器\n    data_cleaner = DataCleaner() #实例化数据清洗器\n    LRFMCobj = LRFMC()  # 实例化模型处理器\n```\n\n这里的数据源为`.csv`文件，所以我们要用到`pandas`模块读取文件到表格中\n\n这里代码不多，就直接写在`main.py`里了\n\n```Python\n    # ...上略...\n    #data_cleaner = DataCleaner() #实例化数据清洗器\n\n    # 从数据源获取数据\n    airline_data = pd.read_csv(\"../data_raw/air_data.csv\",\n        encoding=\"gb18030\")  # 导入航空数据\n    log(LOG_INFO,'原始数据的形状为：', airline_data.shape)\n\n```\n\n## 预处理航空公司数据\n航空公司客户原始数据存在少量的`缺失值`和`异常值`，需要清洗后才能用于分析。\n\n### 缺失值处理\n通过对数据观察发现原始数据中存在票价为空值，票价最小值为0，折扣率最小值为0，总飞行公里数大于0的记录。票价为空值的数据可能是客户不存在乘机记录造成。\n\n处理方法：丢弃票价为空的记录\n\n具体实现： 考虑到与票价有关的特征有`SUM_YR_1`和`SUM_YR_2`两条，逻辑上两条特征数据都为`0`才算`缺失值`,所以分别提取两条对应的`布尔值列表`，并用`逻辑与`合并，用于数据表格的切片\n\n*我们先定义好成员函数，最后封装到DataCleaner类中*\n> data_cleaner.py\n```Python\n    def notNull(self,airline_data):  # 缺失值处理：去除票价为空的记录\n        exp1 = airline_data[\"SUM_YR_1\"].notnull()\n        exp2 = airline_data[\"SUM_YR_2\"].notnull()\n        exp = exp1 & exp2  # 按位逻辑与,获取所需的布尔值列表\n        # airline_notnull = airline_data.loc[exp, :]  # exp提供布尔值竖列表， ':'默认无参时，切片所有行,完成去除操作\n        airline_notnull = airline_data[exp] #  这是上一句的简化写法（使用更多的缺省参数\n\n        return airline_notnull\n```\n\n### 异常值\n\n其他的数据可能是客户乘坐`0折机票`或者`积分兑换`造成。由于原始数据量大，这类数据所占比例较小，对于问题影响不大，因此对其进行丢弃处理。\n\n处理方法：丢弃**票价为0，平均折扣率为0，总飞行公里数大于0的记录。**\n\n具体处理：采用`index1`和`index2`先保留总票价不为`0`的记录,然后用`index3`筛选出总里程`SEG_KM_SUM``>0`且平均折扣率`avg_discount``!=0`的记录,使用布尔值列表`(index1 | index2) & index3`进行筛选，保留所需数据\n\n```Python\n    def notOutlier(self,airline_data):\n        index1 = airline_data[\"SUM_YR_1\"].notnull()\n        index2 = airline_data[\"SUM_YR_2\"] != 0  # 效果和上一句的notnull()一样,都是生成bool array\n        index3 = (airline_data[\"SEG_KM_SUM\"] > 0) & \\\n                 (airline_data[\"avg_discount\"] != 0)  # 折扣且总里程不为0的机票\n        airline = airline_data[(index1 | index2) & index3]  # 丢弃票价为0，或折扣率为0，且总里程>0的异常值\n        return airline\n```\n\n### 封装DataCleaner类\n将用于清理数据的函数整合到一个类中，方便维护，添加或修改新的清理规则也很可以很方便地找到`DataCleaner`类，在里面集中维护s\n\n> data_cleaner.py\n```Python\nclass DataCleaner:\n    def __init__(self):\n        return\n    def notNull(self,airline_data):  # 缺失值处理：去除票价为空的记录\n        exp1 = airline_data[\"SUM_YR_1\"].notnull()\n        exp2 = airline_data[\"SUM_YR_2\"].notnull()\n        exp = exp1 & exp2  # 按位逻辑与,获取所需的布尔值列表\n        #airline_notnull = airline_data.loc[exp, :]  # exp提供布尔值竖列表， ':'默认无参时，切片所有行,完成去除操作\n        airline_notnull = airline_data[exp] #  这是上一句的简化写法（使用更多的缺省参数\n        return airline_notnull\n\n    def notOutlier(self,airline_data):\n        index1 = airline_data[\"SUM_YR_1\"].notnull()\n        index2 = airline_data[\"SUM_YR_2\"] != 0  # 效果和上一句的notnull()一样,都是生成bool array\n        index3 = (airline_data[\"SEG_KM_SUM\"] > 0) & \\\n                 (airline_data[\"avg_discount\"] != 0)  # 折扣且总里程不为0的机票\n        airline = airline_data[(index1 | index2) & index3]  # 丢弃票价为0，或折扣率为0，且总里程>0的异常值\n        return airline\n\n```\n\n## RFM到LFRMC模型的介绍\n\n### RFM模型介绍\n本项目的目标是客户价值分析，即通过航空公司客户数据识别不同价值的客户，识别客户价值应用最广泛的模型是RFM模型。\n\n> + **R**（`Recency`）指的是最近一次消费时间与截止时间的间隔。通常情况下，最近一次消费时间与截止时间的间隔越短，对即时提供的商品或是服务也最有可能感兴趣。\n> + **F**（`Frequency`）指顾客在某段时间内所消费的次数。可以说消费频率越高的顾客，也是满意度越高的顾客，其忠诚度也就越高，顾客价值也就越大。\n> + **M**（`Monetary`）指顾客在某段时间内所消费的金额。消费金额越大的顾客，他们的消费能力自然也就越大，这就是所谓“20%的顾客贡献了80%的销售额”的二八法则。\n\n### RFM模型结果解读\n\nRFM模型包括三个特征，使用**三维坐标系**进行展示，如图所示。X轴表示`Recency`，Y轴表示`Frequency`，Z轴表示`Monetary`，每个轴一般会分成5级表示程度，1为最小，5为最大\n\n*如图，不同的区域有有不同的营销策略*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RFM_model_res.png)\n\n### 传统RFM模型在航空行业的缺陷\n\n在RFM模型中，消费金额表示在一段时间内，客户购买该企业产品金额的总和，由于航空票价受到运输距离，舱位等级等多种因素影响，同样消费金额的不同旅客对航空公司的价值是不同的，因此这个特征并不适合用于航空公司的客户价值分析。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_RFM_LOw.png)\n\n### 航空客户价值分析的LRFMC模型\n为了弥补传统RFM模型在实际应用中的缺陷，本次项目使用了适用于航空客户价值分析的`LRFMC模型`\n\n本项目选择客户在一定时间内累积的飞行里程M和客户在一定时间内乘坐舱位所对应的折扣系数的平均值C两个特征代替消费金额。此外，航空公司会员入会时间的长短在一定程度上能够影响客户价值，所以在模型中增加客户关系长度L，作为区分客户的另一特征。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_LRFMC.png)\n\n## 构建航空客户价值分析的关键特征\n\n这里依然使用模块封装和类封装，在`LRFMC.py`中封装`LRFMC`类来完成模型相关的数据处理\n\n### 选取关键特征 和 构建L特征\n我们首先选取上图相关特征的列到`airline_selection`中，用于构建`L`特征和后面选取后四列与`L`列合并\n\n> LRFMC.py\n```Python\n######## 构建 LRFMC模型 ########\nimport pandas as pd\nfrom log import *\n\nclass LRFMC:\n    def __init__(self):\n        self.log = Log()\n        return\n    def getFeatures(self,airline):\n        # 选取需求特征\n        airline_selection = airline[[\"FFP_DATE\",\"LOAD_TIME\",\n                                     \"FLIGHT_COUNT\",\"LAST_TO_END\",\n                                     \"avg_discount\",\"SEG_KM_SUM\"]]\n        # 构建L特征\n        L = pd.to_datetime(airline_selection[\"LOAD_TIME\"]) \\\n            - pd.to_datetime(airline_selection[\"FFP_DATE\"])\n        self.log(LOG_DEBUG,\"\\n\",L[:5])  #测试前五行\n        # 转成月份\n        L = L.astype(\"str\").str.split().str[0]\n        L = L.astype(\"int\")/30\n\n        #合并特征\n        airline_features = pd.concat([L,\n                airline_selection.iloc[:,2:]],axis = 1)  #axis=1使函数按列合并,[:,2:]舍弃了原本的前两列\n        airline_features =airline_features.rename(columns={0:\"L\"}) # 重命名没有名字的列\n        self.log(LOG_DEBUG,\"\\n\",airline_features.head())  #缺省参数为5，打印前五行\n        return airline_features\n```\n\n### 标准化\n完成五个特征的构建以后，对每个特征数据分布情况进行分析，其数据的取值范围如下表所示。从表中数据可以发现，**五个特征的取值范围数据差异较大**，为了消除数量级数据带来的影响，需要对数据做`标准化处理`。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_Stadert_table.png)\n\n这里使用 `sklearn`模块中的 `StandardScaler`类来自动标准化数据，然后我们将标准化后的数据再转成`pandas`表格，最后储存到临时文件`airline_scale.xlsx`中\n\n> LRFMC.py\n```Python\n    def storeStandData(self,airline_features):\n        data = StandardScaler().fit_transform(airline_features)\n        SDF = pd.DataFrame(data);  #获取 standardDataFrame(SDF)\n        SDF = SDF.rename(columns={0:\"L\",1:\"F\",2:\"R\",3:\"C\",4:\"M\"})\n        self.log(LOG_INFO,\"标准化后的前五行的LRFMC五个特征为\\n\",SDF.head())\n        SDF.to_excel(\"../tmp/airline_scale.xlsx\")  ##储存值tmp文件夹\n```\n\n前五行标准化前后的结果如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/acva_sta_raw.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_STA.png)\n\n## 了解和使用`K-Means`聚类算法\n即使经过了一系列预处理和模型建模，我们手上的数据依然还是比较原始，只有经过分类过的数据才更有分析价值，而自然数据一般都难以直接分类，需要用聚类算法进行分类，这里就用到了`K-Means`聚类算法\n\n### 基本概念\nK-Means聚类算法是一种基于质心的划分方法，输入聚类个数k，以及包含n个数据对象的数据库，输出满足误差平方和最小标准的k个聚类。算法步骤如下:\n\n+ 从n个样本数据中随机选取k个对象作为初始的聚类中心。\n+ 分别计算每个样本到各个聚类质心的距离，将样本分配到距离最近的那个聚类中心类别中。\n+ 所有样本分配完成后，重新计算k个聚类的中心。\n+ 与前一次计算得到的k个聚类中心比较，如果聚类中心发生变化，转(2)，否则转(5)。\n+ 当质心不发生变化时停止并输出聚类结果。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_KMEANS.png)\n\n### 数据类型\nK-Means聚类算法是在数值类型数据的基础上进行研究，然而数据分析的样本复杂多样，因此要求不仅能够对特征为数值类型的数据进行分析，还要适应数据类型的变化，对不同特征做不同变换，以满足算法的要求。\n\n### 获取KMeans对象\nsklearn的cluster模块提供了KMeans函数构建K-Means聚类模型\n\n翻阅其源代码(下图)，可以看到`KMeans`是一个**类**，且构造函数有大量缺省参数，因此实例化`KMeans`对象时，只需提供无缺省的参数，和调整关键缺省参数即可\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/K-Means_org.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_Kmeans_para.png)\n\n这里我们只显式传参`n_clusters`和`random_state`,其中后一个参数用时间戳\n\n因为本身`KMeans`就封装地很好，这部分代码就写在`main.py`的主逻辑中\n\n> main.py\n```Python\n    ## 对象实例化\n    k = 5 ## 确定聚类中心数，这里我们预期聚类5类客户\n    kmeans_model = KMeans(n_clusters=k,random_state=int(time.time()))  # 实例化对象\n    kmeans_model = kmeans_model.fit(airline_scale)  # 用准备好的数据训练模型\n    centers = kmeans_model.cluster_centers_\n    log(LOG_INFO,\"五个聚类中心为\\n\",centers)\n\n    ## 统计不同类别样本的数目\n    r1 = pd.Series(kmeans_model.labels_).value_counts()\n    log(LOG_INFO,\"最终每个类别的数目为\\n\",r1)\n```\n\n最后聚类的结果类似下表\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_CLUSTER_RES.png)\n\n至此数据的分析，建模和聚类已经完成，数据处理部分告一段落，接下来是可视化处理\n\n## 可视化雷达图\n\n这里使用`matplotlib.pyplot`模块作图，`numpy`二次处理数据,封装代码到`RadarDrawer`类中并用`__call__`重载`()`操作符\n\n值得注意的是:\n\n+ 因为这里使用了雷达图，所以绘制图形时使用`极坐标`会更方便\n+ 因为这里使用了中文文字，而默认字体不支持中文，会报错，所以要**提前设置中文字体**\n\n> radar_chart.py\n```Python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nclass RadarDrawer():\n    def __init__(self):\n        return\n\n    def __call__(self, kmeans_moudel, n_clusters):\n        # 设置支持中文的字体\n        plt.rc(\"font\",family=\"Microsoft YaHei\")\n        # 标签\n        labels = np.array([u'ZL',u'ZR',u'ZF',u'ZM',u'ZC'])\n\n        plot_data = kmeans_moudel.cluster_centers_\n        # 指定颜色\n        color = ['b','g','r','c','y']\n        # 计算雷达图的角度\n        angles = np.linspace(0,2*np.pi,n_clusters,endpoint=False)\n\n        # 闭合(首尾列相同) 并用np把pandas的DataFrame转成原生数组\n        plot_data = np.concatenate((plot_data,plot_data[:,[0]]),axis = 1)\n        angles_org = angles\n        angles = np.concatenate((angles,[angles[0]]))\n\n        fig = plt.figure(figsize=(6,6),dpi = 160)\n        #polar参数\n        ax = fig.add_subplot(111, polar=True)  # 设置坐标为极坐标\n        # 画若干个五边形\n        floor = np.floor(plot_data.min())   # 大于最小值的最大整数\n        ceil = np.ceil(plot_data.max())     # 小于最小值的最小整数\n        n = len(labels)\n        for i in np.arange(floor,ceil+0.5, 0.5):\n            ax.plot(angles,[i] *(n+1),'-.',lw=0.5,color='black')\n        # 话不同客户群的分割线\n        for i in range(len(plot_data)):\n            ax.plot(angles,plot_data[i],color = color[i],\n                    label='客户群'+str(i+1),linewidth=2, linestyle='-.')\n        ax.set_rgrids(np.arange(0,2.5, 0.5))  # 画出每层的权重\n        ax.set_thetagrids(angles_org* 180/np.pi,labels)  # 设置显示的角度为度数制\n        plt.legend(loc='lower right',bbox_to_anchor=(1.1, -0.1))  #设置图例位置在画布外\n        #plt.legend()\n\n        #ax.set_theta_zero_location('N')         # 设置极坐标的起点（即0°）在正北方向\n        ax.spines['polar'].set_visible(False)   # 不显示极坐标最外面的圈\n        ax.grid(False)                          # 不显示默认分割线\n        plt.savefig(\"../tmp/ACVA_img.png\")      # 储存图像的临时文件\n        plt.show()\n```\n\n## 重新组织main.py\n\n至此所有的功能已经实现，并封装到了各个模块和类中，所以我们再重新组织一次`main.py`，并最终定档其中的代码\n\n> main.py\n```Python\n######### 主程序入口 #############\nimport pandas as pd\nfrom sklearn.cluster import KMeans\nimport time\n\nfrom log import *\nfrom data_clean import *\nfrom LRFMC import *\nfrom radar_chart import  *\n\nif __name__ == '__main__':\n\n    log = Log()  # 实例化一个日志器\n    data_cleaner = DataCleaner() #实例化数据清洗器\n    LRFMCobj = LRFMC() # 实例化模型处理器\n\n    # 从数据源获取数据\n    airline_data = pd.read_csv(\"../data_raw/air_data.csv\",\n        encoding=\"gb18030\")  # 导入航空数据\n    log(LOG_INFO,'原始数据的形状为：', airline_data.shape)\n\n    #数据预处理\n    ## 缺失值处理：去除票价为空的记录\n    airline_notnull = data_cleaner.notNull(airline_data)\n    log(LOG_INFO,'删除缺失记录后数据的形状为：', airline_notnull.shape)\n\n    ## 异常值处理: 只保留票价非零的，或者平均折扣率不为0且总飞行公里数大于0的记录。\n    airline = data_cleaner.notOutlier(airline_notnull)\n    log(LOG_INFO,'删除异常记录后数据的形状为：', airline.shape)\n\n    # 构建LRFMC五大特征\n    airline_features = LRFMCobj.getFeatures(airline)\n    LRFMCobj.storeStandData(airline_features)\n\n    # 获取KMeans对象\n    ## 准备数据\n    airline_scale = pd.read_excel(\"../tmp/airline_scale.xlsx\")\n    airline_scale = airline_scale.iloc[:,1:]  # 切掉第一列的作为行数标志的数字\n\n    ## 对象实例化\n    k = 5 ## 确定聚类中心数，这里我们预期聚类5类客户\n    kmeans_model = KMeans(n_clusters=k,random_state=int(time.time()))  # 实例化对象\n    kmeans_model = kmeans_model.fit(airline_scale)  # 用准备好的数据训练模型\n    centers = kmeans_model.cluster_centers_\n    log(LOG_INFO,\"五个聚类中心为\\n\",centers)\n\n    ## 统计不同类别样本的数目\n    r1 = pd.Series(kmeans_model.labels_).value_counts()\n    log(LOG_INFO,\"最终每个类别的数目为\\n\",r1)\n\n    # 作出图样\n    RadarDrawer()(kmeans_model,n_clusters=k)\n    log(LOG_INFO,\"完成作图\")\n```\n\n可以看到，经过一系列封装，`main.py`只有寥寥50多行，确已经体现了主要的 业务逻辑\n\n# 分析聚类结果\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_output.png)\n\n基于特征描述，本项目定义五个等级的客户类别：重要保持客户，重要发展客户，重要挽留客户，一般客户，低价值客户\n\n# 模型应用\n根据对各个客户群进行特征分析，采取下面的一些营销手段和策略，为航空公司的价值客户群管理提供参考\n\n+ `会员的升级与保级`：航空公司可以在对会员升级或保级进行评价的时间点之前，对那些接近但尚未达到要求的较高消费客户进行适当提醒甚至采取一些促销活动，刺激他们通过消费达到相应标准。这样既可以获得收益，同时也提高了客户的满意度，增加了公司的精英会员。\n+ `首次兑换`：采取的措施是从数据库中提取出接近但尚未达到首次兑换标准的会员，对他们进行提醒或促销，使他们通过消费达到标准。一旦实现了首次兑换，客户在本公司进行再次消费兑换就比在其他公司进行兑换要容易许多，在一定程度上等于提高了转移的成本。\n+ `交叉销售`：通过发行联名卡等与非航空类企业的合作，使客户在其他企业的消费过程中获得本公司的积分，增强与公司的联系，提高他们的忠诚度。\n\n# 小结\n本项目结合航空公司客户价值分析的案例，重点介绍了数据分析算法中K-Means聚类算法在客户价值分析中的应用。针对RFM客户价值分析模型的不足，使用K-Means算法构建了航空客户价值分析LRFMC模型，详细描述了数据分析的整个过程。\n\n# github项目文件 和 相关外部链接\n[戳我去github仓库🔗](https://github.com/sis-shen/ACVA)\n\n[戳我去KMeans源码🔗](https://github.com/scikit-learn/scikit-learn/blob/fd237278e/sklearn/cluster/_kmeans.py#L745)\n\n[戳我去pandas文档下载🔗](https://pandas.pydata.org/docs/)\n\n[戳我去matplotlib的API文档🔗](https://matplotlib.org/stable/api/index)\n\n[戳我去numpy文档🔗](https://numpy.org/doc/stable/)","slug":"ACVA","published":1,"updated":"2024-09-05T16:04:56.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p07x00014sp59e2w4bbt","content":"<h1 id=\"背景分析\"><a href=\"#背景分析\" class=\"headerlink\" title=\"背景分析\"></a>背景分析</h1><h2 id=\"航空公司现状\"><a href=\"#航空公司现状\" class=\"headerlink\" title=\"航空公司现状\"></a>航空公司现状</h2><h4 id=\"行业内竞争\"><a href=\"#行业内竞争\" class=\"headerlink\" title=\"行业内竞争\"></a>行业内竞争</h4><p>民航的竞争除了三大航空公司之间的竞争外，还将加入新崛起的各类小型航空公司、民营航空公司，甚至国外航空巨头。航空产品<strong>生产过剩,产品同质化</strong>特征愈加明显，于是航空公司从<strong>价格、服务</strong>间的竞争逐渐转向对<strong>客户</strong>的竞争</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/airliness.png\"></p>\n<h2 id=\"行业外竞争\"><a href=\"#行业外竞争\" class=\"headerlink\" title=\"行业外竞争\"></a>行业外竞争</h2><p>随着<strong>高铁</strong>、动车等铁路运输的兴建，航空公司受到巨大冲击</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/transportalrad.png\"></p>\n<p><em>如上图所示，经过2010到2015年的发展，铁路运输对航空运输的冲击越发明显</em></p>\n<h2 id=\"航空公司数据特征说明\"><a href=\"#航空公司数据特征说明\" class=\"headerlink\" title=\"航空公司数据特征说明\"></a>航空公司数据特征说明</h2><ul>\n<li>目前航空公司已经积累了大量的会员档案信息和其乘坐航班记录</li>\n<li>就本项目已获取的数据，以2014-03-31为结束时间，选取宽度为<strong>两年</strong>的时间段作为分析观测窗口，抽取观测窗口内有乘机记录的所有客户的详细数据形成的历史数据，44个特征，总共62988条记录。</li>\n</ul>\n<p>数据特征记录说明如下表所示:</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE1.png\"><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE2.png\"><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE3.png\"></p>\n<h2 id=\"结合数据的项目目标\"><a href=\"#结合数据的项目目标\" class=\"headerlink\" title=\"结合数据的项目目标\"></a>结合数据的项目目标</h2><p>结合目前航空公司的数据情况，可以实现以下目标</p>\n<ul>\n<li>借助航空公司客户数据，对客户进行分类</li>\n<li>对不同的客户类别<code>进行特征分析</code>，比较不同类别客户的<code>客户价值</code></li>\n<li>对不同价值的客户类别提供<code>个性化服务</code>,制定相应的<code>营销策略</code></li>\n</ul>\n<h2 id=\"了解客户价值分析\"><a href=\"#了解客户价值分析\" class=\"headerlink\" title=\"了解客户价值分析\"></a>了解客户价值分析</h2><p>客户营销战略倡导者<em>Jay</em> &amp; <em>Adam Curry</em> 从国外数百家公司进行了客户营销实施的经验中提炼了如下经验</p>\n<ul>\n<li>公司<strong>收入</strong>的<code>80%</code>来自顶端的<code>20%</code>客户</li>\n<li><code>20%</code>的客户其利<code>润率100%</code></li>\n<li><code>90%</code>以上的收入来自<strong>现有</strong>客户</li>\n<li><strong>大部分的营销预算</strong>经常被用在非现有客户上</li>\n<li><code>5%</code>至<code>30%</code>的客户在客户金字塔中具有<strong>升级潜力</strong></li>\n<li>客户金字塔中客户升级<code>2%</code>，意味着营销收入增加<code>10%</code>,利润增加<code>50%</code></li>\n</ul>\n<p>也许这些经验并不完全准确，但是它解释了新时代<code>客户分化</code>的趋势，也说明了对客户价值分析的<strong>迫切性</strong>和<strong>必要性</strong></p>\n<h2 id=\"项目流程图\"><a href=\"#项目流程图\" class=\"headerlink\" title=\"项目流程图\"></a>项目流程图</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_flow_char.png\"></p>\n<h1 id=\"代码实现业务功能\"><a href=\"#代码实现业务功能\" class=\"headerlink\" title=\"代码实现业务功能\"></a>代码实现业务功能</h1><h2 id=\"系统架构\"><a href=\"#系统架构\" class=\"headerlink\" title=\"系统架构\"></a>系统架构</h2><h3 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h3><p>这里主要用三个文件夹，分别储存<code>代码</code>，<code>原始数据</code>,<code>临时文件</code></p>\n<ul>\n<li><code>codes</code>       代码文件夹</li>\n<li><code>data_raw</code>    原始数据文件夹</li>\n<li><code>tmp</code>         临时文件文件夹</li>\n</ul>\n<h2 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h2><p>本业务系统采用一个<code>main.py</code>执行主要业务逻辑，封装多个模块和类实现具体业务，以达到主要业务逻辑清晰，代码封装性强，易于维护和复用的优点</p>\n<p>主要的代码文件有:</p>\n<ul>\n<li>main.py       执行主要逻辑</li>\n<li>log.py        提供日志器</li>\n<li>data_cleaner  实现清洗数据</li>\n<li>LEDNX.py      构建和提取五大特征</li>\n<li>radar_char.py 绘制结果雷达图</li>\n</ul>\n<h2 id=\"实现一个简单的日志器\"><a href=\"#实现一个简单的日志器\" class=\"headerlink\" title=\"实现一个简单的日志器\"></a>实现一个简单的日志器</h2><p>一般日志器有<code>日志等级</code>，<code>日志时间</code>，和<code>日志内容</code>三大部分，不过本次业务与时间关联性不大，就只打印两个部分</p>\n<blockquote>\n<p>log.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">###### 实现日志系统 ########</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义日志等级</span></span><br><span class=\"line\">LOG_INFO = <span class=\"string\">&quot;Info&quot;</span></span><br><span class=\"line\">LOG_ERROR = <span class=\"string\">&quot;Error&quot;</span></span><br><span class=\"line\">LOG_WANING = <span class=\"string\">&quot;Warning&quot;</span></span><br><span class=\"line\">LOG_FATAL = <span class=\"string\">&quot;Fatal&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Log</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">self,level,*msgs</span>): <span class=\"comment\"># 重载()运算符</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[&quot;</span>, level, <span class=\"string\">&quot;]&quot;</span>,end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> msg <span class=\"keyword\">in</span> msgs:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(msg)</span><br><span class=\"line\">        <span class=\"comment\"># 本项目与时间关系不大，日志系统不打印时间</span></span><br></pre></td></tr></table></figure>\n\n<p>这里使用了<code>__call__</code>对<code>()</code>操作符的<code>重载</code>，和<code>*mgs</code>达到了<code>传递任意数量参数</code>的语法特性</p>\n<p>这样以后打印日志可以方便地把对象当函数用</p>\n<h2 id=\"程序入口-从数据源提取数据\"><a href=\"#程序入口-从数据源提取数据\" class=\"headerlink\" title=\"程序入口 &amp; 从数据源提取数据\"></a>程序入口 &amp; 从数据源提取数据</h2><p>我们将<code>main.py</code>作为项目的程序入口</p>\n<blockquote>\n<p>main.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">######### 主程序入口 #############</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.cluster <span class=\"keyword\">import</span> KMeans</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> log <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> data_clean <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LRFMC <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    log = Log()  <span class=\"comment\"># 实例化一个日志器</span></span><br><span class=\"line\">    data_cleaner = DataCleaner() <span class=\"comment\">#实例化数据清洗器</span></span><br><span class=\"line\">    LRFMCobj = LRFMC()  <span class=\"comment\"># 实例化模型处理器</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的数据源为<code>.csv</code>文件，所以我们要用到<code>pandas</code>模块读取文件到表格中</p>\n<p>这里代码不多，就直接写在<code>main.py</code>里了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ...上略...</span></span><br><span class=\"line\"><span class=\"comment\">#data_cleaner = DataCleaner() #实例化数据清洗器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从数据源获取数据</span></span><br><span class=\"line\">airline_data = pd.read_csv(<span class=\"string\">&quot;../data_raw/air_data.csv&quot;</span>,</span><br><span class=\"line\">    encoding=<span class=\"string\">&quot;gb18030&quot;</span>)  <span class=\"comment\"># 导入航空数据</span></span><br><span class=\"line\">log(LOG_INFO,<span class=\"string\">&#x27;原始数据的形状为：&#x27;</span>, airline_data.shape)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"预处理航空公司数据\"><a href=\"#预处理航空公司数据\" class=\"headerlink\" title=\"预处理航空公司数据\"></a>预处理航空公司数据</h2><p>航空公司客户原始数据存在少量的<code>缺失值</code>和<code>异常值</code>，需要清洗后才能用于分析。</p>\n<h3 id=\"缺失值处理\"><a href=\"#缺失值处理\" class=\"headerlink\" title=\"缺失值处理\"></a>缺失值处理</h3><p>通过对数据观察发现原始数据中存在票价为空值，票价最小值为0，折扣率最小值为0，总飞行公里数大于0的记录。票价为空值的数据可能是客户不存在乘机记录造成。</p>\n<p>处理方法：丢弃票价为空的记录</p>\n<p>具体实现： 考虑到与票价有关的特征有<code>SUM_YR_1</code>和<code>SUM_YR_2</code>两条，逻辑上两条特征数据都为<code>0</code>才算<code>缺失值</code>,所以分别提取两条对应的<code>布尔值列表</code>，并用<code>逻辑与</code>合并，用于数据表格的切片</p>\n<p><em>我们先定义好成员函数，最后封装到DataCleaner类中</em></p>\n<blockquote>\n<p>data_cleaner.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">notNull</span>(<span class=\"params\">self,airline_data</span>):  <span class=\"comment\"># 缺失值处理：去除票价为空的记录</span></span><br><span class=\"line\">    exp1 = airline_data[<span class=\"string\">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class=\"line\">    exp2 = airline_data[<span class=\"string\">&quot;SUM_YR_2&quot;</span>].notnull()</span><br><span class=\"line\">    exp = exp1 &amp; exp2  <span class=\"comment\"># 按位逻辑与,获取所需的布尔值列表</span></span><br><span class=\"line\">    <span class=\"comment\"># airline_notnull = airline_data.loc[exp, :]  # exp提供布尔值竖列表， &#x27;:&#x27;默认无参时，切片所有行,完成去除操作</span></span><br><span class=\"line\">    airline_notnull = airline_data[exp] <span class=\"comment\">#  这是上一句的简化写法（使用更多的缺省参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> airline_notnull</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异常值\"><a href=\"#异常值\" class=\"headerlink\" title=\"异常值\"></a>异常值</h3><p>其他的数据可能是客户乘坐<code>0折机票</code>或者<code>积分兑换</code>造成。由于原始数据量大，这类数据所占比例较小，对于问题影响不大，因此对其进行丢弃处理。</p>\n<p>处理方法：丢弃<strong>票价为0，平均折扣率为0，总飞行公里数大于0的记录。</strong></p>\n<p>具体处理：采用<code>index1</code>和<code>index2</code>先保留总票价不为<code>0</code>的记录,然后用<code>index3</code>筛选出总里程<code>SEG_KM_SUM``&gt;0</code>且平均折扣率<code>avg_discount``!=0</code>的记录,使用布尔值列表<code>(index1 | index2) &amp; index3</code>进行筛选，保留所需数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">notOutlier</span>(<span class=\"params\">self,airline_data</span>):</span><br><span class=\"line\">    index1 = airline_data[<span class=\"string\">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class=\"line\">    index2 = airline_data[<span class=\"string\">&quot;SUM_YR_2&quot;</span>] != <span class=\"number\">0</span>  <span class=\"comment\"># 效果和上一句的notnull()一样,都是生成bool array</span></span><br><span class=\"line\">    index3 = (airline_data[<span class=\"string\">&quot;SEG_KM_SUM&quot;</span>] &gt; <span class=\"number\">0</span>) &amp; \\</span><br><span class=\"line\">             (airline_data[<span class=\"string\">&quot;avg_discount&quot;</span>] != <span class=\"number\">0</span>)  <span class=\"comment\"># 折扣且总里程不为0的机票</span></span><br><span class=\"line\">    airline = airline_data[(index1 | index2) &amp; index3]  <span class=\"comment\"># 丢弃票价为0，或折扣率为0，且总里程&gt;0的异常值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> airline</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"封装DataCleaner类\"><a href=\"#封装DataCleaner类\" class=\"headerlink\" title=\"封装DataCleaner类\"></a>封装DataCleaner类</h3><p>将用于清理数据的函数整合到一个类中，方便维护，添加或修改新的清理规则也很可以很方便地找到<code>DataCleaner</code>类，在里面集中维护s</p>\n<blockquote>\n<p>data_cleaner.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataCleaner</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">notNull</span>(<span class=\"params\">self,airline_data</span>):  <span class=\"comment\"># 缺失值处理：去除票价为空的记录</span></span><br><span class=\"line\">        exp1 = airline_data[<span class=\"string\">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class=\"line\">        exp2 = airline_data[<span class=\"string\">&quot;SUM_YR_2&quot;</span>].notnull()</span><br><span class=\"line\">        exp = exp1 &amp; exp2  <span class=\"comment\"># 按位逻辑与,获取所需的布尔值列表</span></span><br><span class=\"line\">        <span class=\"comment\">#airline_notnull = airline_data.loc[exp, :]  # exp提供布尔值竖列表， &#x27;:&#x27;默认无参时，切片所有行,完成去除操作</span></span><br><span class=\"line\">        airline_notnull = airline_data[exp] <span class=\"comment\">#  这是上一句的简化写法（使用更多的缺省参数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> airline_notnull</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">notOutlier</span>(<span class=\"params\">self,airline_data</span>):</span><br><span class=\"line\">        index1 = airline_data[<span class=\"string\">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class=\"line\">        index2 = airline_data[<span class=\"string\">&quot;SUM_YR_2&quot;</span>] != <span class=\"number\">0</span>  <span class=\"comment\"># 效果和上一句的notnull()一样,都是生成bool array</span></span><br><span class=\"line\">        index3 = (airline_data[<span class=\"string\">&quot;SEG_KM_SUM&quot;</span>] &gt; <span class=\"number\">0</span>) &amp; \\</span><br><span class=\"line\">                 (airline_data[<span class=\"string\">&quot;avg_discount&quot;</span>] != <span class=\"number\">0</span>)  <span class=\"comment\"># 折扣且总里程不为0的机票</span></span><br><span class=\"line\">        airline = airline_data[(index1 | index2) &amp; index3]  <span class=\"comment\"># 丢弃票价为0，或折扣率为0，且总里程&gt;0的异常值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> airline</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RFM到LFRMC模型的介绍\"><a href=\"#RFM到LFRMC模型的介绍\" class=\"headerlink\" title=\"RFM到LFRMC模型的介绍\"></a>RFM到LFRMC模型的介绍</h2><h3 id=\"RFM模型介绍\"><a href=\"#RFM模型介绍\" class=\"headerlink\" title=\"RFM模型介绍\"></a>RFM模型介绍</h3><p>本项目的目标是客户价值分析，即通过航空公司客户数据识别不同价值的客户，识别客户价值应用最广泛的模型是RFM模型。</p>\n<blockquote>\n<ul>\n<li><strong>R</strong>（<code>Recency</code>）指的是最近一次消费时间与截止时间的间隔。通常情况下，最近一次消费时间与截止时间的间隔越短，对即时提供的商品或是服务也最有可能感兴趣。</li>\n<li><strong>F</strong>（<code>Frequency</code>）指顾客在某段时间内所消费的次数。可以说消费频率越高的顾客，也是满意度越高的顾客，其忠诚度也就越高，顾客价值也就越大。</li>\n<li><strong>M</strong>（<code>Monetary</code>）指顾客在某段时间内所消费的金额。消费金额越大的顾客，他们的消费能力自然也就越大，这就是所谓“20%的顾客贡献了80%的销售额”的二八法则。</li>\n</ul>\n</blockquote>\n<h3 id=\"RFM模型结果解读\"><a href=\"#RFM模型结果解读\" class=\"headerlink\" title=\"RFM模型结果解读\"></a>RFM模型结果解读</h3><p>RFM模型包括三个特征，使用<strong>三维坐标系</strong>进行展示，如图所示。X轴表示<code>Recency</code>，Y轴表示<code>Frequency</code>，Z轴表示<code>Monetary</code>，每个轴一般会分成5级表示程度，1为最小，5为最大</p>\n<p><em>如图，不同的区域有有不同的营销策略</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RFM_model_res.png\"></p>\n<h3 id=\"传统RFM模型在航空行业的缺陷\"><a href=\"#传统RFM模型在航空行业的缺陷\" class=\"headerlink\" title=\"传统RFM模型在航空行业的缺陷\"></a>传统RFM模型在航空行业的缺陷</h3><p>在RFM模型中，消费金额表示在一段时间内，客户购买该企业产品金额的总和，由于航空票价受到运输距离，舱位等级等多种因素影响，同样消费金额的不同旅客对航空公司的价值是不同的，因此这个特征并不适合用于航空公司的客户价值分析。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_RFM_LOw.png\"></p>\n<h3 id=\"航空客户价值分析的LRFMC模型\"><a href=\"#航空客户价值分析的LRFMC模型\" class=\"headerlink\" title=\"航空客户价值分析的LRFMC模型\"></a>航空客户价值分析的LRFMC模型</h3><p>为了弥补传统RFM模型在实际应用中的缺陷，本次项目使用了适用于航空客户价值分析的<code>LRFMC模型</code></p>\n<p>本项目选择客户在一定时间内累积的飞行里程M和客户在一定时间内乘坐舱位所对应的折扣系数的平均值C两个特征代替消费金额。此外，航空公司会员入会时间的长短在一定程度上能够影响客户价值，所以在模型中增加客户关系长度L，作为区分客户的另一特征。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_LRFMC.png\"></p>\n<h2 id=\"构建航空客户价值分析的关键特征\"><a href=\"#构建航空客户价值分析的关键特征\" class=\"headerlink\" title=\"构建航空客户价值分析的关键特征\"></a>构建航空客户价值分析的关键特征</h2><p>这里依然使用模块封装和类封装，在<code>LRFMC.py</code>中封装<code>LRFMC</code>类来完成模型相关的数据处理</p>\n<h3 id=\"选取关键特征-和-构建L特征\"><a href=\"#选取关键特征-和-构建L特征\" class=\"headerlink\" title=\"选取关键特征 和 构建L特征\"></a>选取关键特征 和 构建L特征</h3><p>我们首先选取上图相关特征的列到<code>airline_selection</code>中，用于构建<code>L</code>特征和后面选取后四列与<code>L</code>列合并</p>\n<blockquote>\n<p>LRFMC.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">######## 构建 LRFMC模型 ########</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> log <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRFMC</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.log = Log()</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">getFeatures</span>(<span class=\"params\">self,airline</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 选取需求特征</span></span><br><span class=\"line\">        airline_selection = airline[[<span class=\"string\">&quot;FFP_DATE&quot;</span>,<span class=\"string\">&quot;LOAD_TIME&quot;</span>,</span><br><span class=\"line\">                                     <span class=\"string\">&quot;FLIGHT_COUNT&quot;</span>,<span class=\"string\">&quot;LAST_TO_END&quot;</span>,</span><br><span class=\"line\">                                     <span class=\"string\">&quot;avg_discount&quot;</span>,<span class=\"string\">&quot;SEG_KM_SUM&quot;</span>]]</span><br><span class=\"line\">        <span class=\"comment\"># 构建L特征</span></span><br><span class=\"line\">        L = pd.to_datetime(airline_selection[<span class=\"string\">&quot;LOAD_TIME&quot;</span>]) \\</span><br><span class=\"line\">            - pd.to_datetime(airline_selection[<span class=\"string\">&quot;FFP_DATE&quot;</span>])</span><br><span class=\"line\">        self.log(LOG_DEBUG,<span class=\"string\">&quot;\\n&quot;</span>,L[:<span class=\"number\">5</span>])  <span class=\"comment\">#测试前五行</span></span><br><span class=\"line\">        <span class=\"comment\"># 转成月份</span></span><br><span class=\"line\">        L = L.astype(<span class=\"string\">&quot;str&quot;</span>).<span class=\"built_in\">str</span>.split().<span class=\"built_in\">str</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">        L = L.astype(<span class=\"string\">&quot;int&quot;</span>)/<span class=\"number\">30</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#合并特征</span></span><br><span class=\"line\">        airline_features = pd.concat([L,</span><br><span class=\"line\">                airline_selection.iloc[:,<span class=\"number\">2</span>:]],axis = <span class=\"number\">1</span>)  <span class=\"comment\">#axis=1使函数按列合并,[:,2:]舍弃了原本的前两列</span></span><br><span class=\"line\">        airline_features =airline_features.rename(columns=&#123;<span class=\"number\">0</span>:<span class=\"string\">&quot;L&quot;</span>&#125;) <span class=\"comment\"># 重命名没有名字的列</span></span><br><span class=\"line\">        self.log(LOG_DEBUG,<span class=\"string\">&quot;\\n&quot;</span>,airline_features.head())  <span class=\"comment\">#缺省参数为5，打印前五行</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> airline_features</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"标准化\"><a href=\"#标准化\" class=\"headerlink\" title=\"标准化\"></a>标准化</h3><p>完成五个特征的构建以后，对每个特征数据分布情况进行分析，其数据的取值范围如下表所示。从表中数据可以发现，<strong>五个特征的取值范围数据差异较大</strong>，为了消除数量级数据带来的影响，需要对数据做<code>标准化处理</code>。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_Stadert_table.png\"></p>\n<p>这里使用 <code>sklearn</code>模块中的 <code>StandardScaler</code>类来自动标准化数据，然后我们将标准化后的数据再转成<code>pandas</code>表格，最后储存到临时文件<code>airline_scale.xlsx</code>中</p>\n<blockquote>\n<p>LRFMC.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">storeStandData</span>(<span class=\"params\">self,airline_features</span>):</span><br><span class=\"line\">    data = StandardScaler().fit_transform(airline_features)</span><br><span class=\"line\">    SDF = pd.DataFrame(data);  <span class=\"comment\">#获取 standardDataFrame(SDF)</span></span><br><span class=\"line\">    SDF = SDF.rename(columns=&#123;<span class=\"number\">0</span>:<span class=\"string\">&quot;L&quot;</span>,<span class=\"number\">1</span>:<span class=\"string\">&quot;F&quot;</span>,<span class=\"number\">2</span>:<span class=\"string\">&quot;R&quot;</span>,<span class=\"number\">3</span>:<span class=\"string\">&quot;C&quot;</span>,<span class=\"number\">4</span>:<span class=\"string\">&quot;M&quot;</span>&#125;)</span><br><span class=\"line\">    self.log(LOG_INFO,<span class=\"string\">&quot;标准化后的前五行的LRFMC五个特征为\\n&quot;</span>,SDF.head())</span><br><span class=\"line\">    SDF.to_excel(<span class=\"string\">&quot;../tmp/airline_scale.xlsx&quot;</span>)  <span class=\"comment\">##储存值tmp文件夹</span></span><br></pre></td></tr></table></figure>\n\n<p>前五行标准化前后的结果如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/acva_sta_raw.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_STA.png\"></p>\n<h2 id=\"了解和使用K-Means聚类算法\"><a href=\"#了解和使用K-Means聚类算法\" class=\"headerlink\" title=\"了解和使用K-Means聚类算法\"></a>了解和使用<code>K-Means</code>聚类算法</h2><p>即使经过了一系列预处理和模型建模，我们手上的数据依然还是比较原始，只有经过分类过的数据才更有分析价值，而自然数据一般都难以直接分类，需要用聚类算法进行分类，这里就用到了<code>K-Means</code>聚类算法</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>K-Means聚类算法是一种基于质心的划分方法，输入聚类个数k，以及包含n个数据对象的数据库，输出满足误差平方和最小标准的k个聚类。算法步骤如下:</p>\n<ul>\n<li>从n个样本数据中随机选取k个对象作为初始的聚类中心。</li>\n<li>分别计算每个样本到各个聚类质心的距离，将样本分配到距离最近的那个聚类中心类别中。</li>\n<li>所有样本分配完成后，重新计算k个聚类的中心。</li>\n<li>与前一次计算得到的k个聚类中心比较，如果聚类中心发生变化，转(2)，否则转(5)。</li>\n<li>当质心不发生变化时停止并输出聚类结果。</li>\n</ul>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_KMEANS.png\"></p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>K-Means聚类算法是在数值类型数据的基础上进行研究，然而数据分析的样本复杂多样，因此要求不仅能够对特征为数值类型的数据进行分析，还要适应数据类型的变化，对不同特征做不同变换，以满足算法的要求。</p>\n<h3 id=\"获取KMeans对象\"><a href=\"#获取KMeans对象\" class=\"headerlink\" title=\"获取KMeans对象\"></a>获取KMeans对象</h3><p>sklearn的cluster模块提供了KMeans函数构建K-Means聚类模型</p>\n<p>翻阅其源代码(下图)，可以看到<code>KMeans</code>是一个<strong>类</strong>，且构造函数有大量缺省参数，因此实例化<code>KMeans</code>对象时，只需提供无缺省的参数，和调整关键缺省参数即可</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/K-Means_org.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_Kmeans_para.png\"></p>\n<p>这里我们只显式传参<code>n_clusters</code>和<code>random_state</code>,其中后一个参数用时间戳</p>\n<p>因为本身<code>KMeans</code>就封装地很好，这部分代码就写在<code>main.py</code>的主逻辑中</p>\n<blockquote>\n<p>main.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 对象实例化</span></span><br><span class=\"line\">k = <span class=\"number\">5</span> <span class=\"comment\">## 确定聚类中心数，这里我们预期聚类5类客户</span></span><br><span class=\"line\">kmeans_model = KMeans(n_clusters=k,random_state=<span class=\"built_in\">int</span>(time.time()))  <span class=\"comment\"># 实例化对象</span></span><br><span class=\"line\">kmeans_model = kmeans_model.fit(airline_scale)  <span class=\"comment\"># 用准备好的数据训练模型</span></span><br><span class=\"line\">centers = kmeans_model.cluster_centers_</span><br><span class=\"line\">log(LOG_INFO,<span class=\"string\">&quot;五个聚类中心为\\n&quot;</span>,centers)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 统计不同类别样本的数目</span></span><br><span class=\"line\">r1 = pd.Series(kmeans_model.labels_).value_counts()</span><br><span class=\"line\">log(LOG_INFO,<span class=\"string\">&quot;最终每个类别的数目为\\n&quot;</span>,r1)</span><br></pre></td></tr></table></figure>\n\n<p>最后聚类的结果类似下表</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_CLUSTER_RES.png\"></p>\n<p>至此数据的分析，建模和聚类已经完成，数据处理部分告一段落，接下来是可视化处理</p>\n<h2 id=\"可视化雷达图\"><a href=\"#可视化雷达图\" class=\"headerlink\" title=\"可视化雷达图\"></a>可视化雷达图</h2><p>这里使用<code>matplotlib.pyplot</code>模块作图，<code>numpy</code>二次处理数据,封装代码到<code>RadarDrawer</code>类中并用<code>__call__</code>重载<code>()</code>操作符</p>\n<p>值得注意的是:</p>\n<ul>\n<li>因为这里使用了雷达图，所以绘制图形时使用<code>极坐标</code>会更方便</li>\n<li>因为这里使用了中文文字，而默认字体不支持中文，会报错，所以要<strong>提前设置中文字体</strong></li>\n</ul>\n<blockquote>\n<p>radar_chart.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RadarDrawer</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">self, kmeans_moudel, n_clusters</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 设置支持中文的字体</span></span><br><span class=\"line\">        plt.rc(<span class=\"string\">&quot;font&quot;</span>,family=<span class=\"string\">&quot;Microsoft YaHei&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 标签</span></span><br><span class=\"line\">        labels = np.array([<span class=\"string\">u&#x27;ZL&#x27;</span>,<span class=\"string\">u&#x27;ZR&#x27;</span>,<span class=\"string\">u&#x27;ZF&#x27;</span>,<span class=\"string\">u&#x27;ZM&#x27;</span>,<span class=\"string\">u&#x27;ZC&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        plot_data = kmeans_moudel.cluster_centers_</span><br><span class=\"line\">        <span class=\"comment\"># 指定颜色</span></span><br><span class=\"line\">        color = [<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;g&#x27;</span>,<span class=\"string\">&#x27;r&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;y&#x27;</span>]</span><br><span class=\"line\">        <span class=\"comment\"># 计算雷达图的角度</span></span><br><span class=\"line\">        angles = np.linspace(<span class=\"number\">0</span>,<span class=\"number\">2</span>*np.pi,n_clusters,endpoint=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 闭合(首尾列相同) 并用np把pandas的DataFrame转成原生数组</span></span><br><span class=\"line\">        plot_data = np.concatenate((plot_data,plot_data[:,[<span class=\"number\">0</span>]]),axis = <span class=\"number\">1</span>)</span><br><span class=\"line\">        angles_org = angles</span><br><span class=\"line\">        angles = np.concatenate((angles,[angles[<span class=\"number\">0</span>]]))</span><br><span class=\"line\"></span><br><span class=\"line\">        fig = plt.figure(figsize=(<span class=\"number\">6</span>,<span class=\"number\">6</span>),dpi = <span class=\"number\">160</span>)</span><br><span class=\"line\">        <span class=\"comment\">#polar参数</span></span><br><span class=\"line\">        ax = fig.add_subplot(<span class=\"number\">111</span>, polar=<span class=\"literal\">True</span>)  <span class=\"comment\"># 设置坐标为极坐标</span></span><br><span class=\"line\">        <span class=\"comment\"># 画若干个五边形</span></span><br><span class=\"line\">        floor = np.floor(plot_data.<span class=\"built_in\">min</span>())   <span class=\"comment\"># 大于最小值的最大整数</span></span><br><span class=\"line\">        ceil = np.ceil(plot_data.<span class=\"built_in\">max</span>())     <span class=\"comment\"># 小于最小值的最小整数</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(labels)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> np.arange(floor,ceil+<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>):</span><br><span class=\"line\">            ax.plot(angles,[i] *(n+<span class=\"number\">1</span>),<span class=\"string\">&#x27;-.&#x27;</span>,lw=<span class=\"number\">0.5</span>,color=<span class=\"string\">&#x27;black&#x27;</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 话不同客户群的分割线</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(plot_data)):</span><br><span class=\"line\">            ax.plot(angles,plot_data[i],color = color[i],</span><br><span class=\"line\">                    label=<span class=\"string\">&#x27;客户群&#x27;</span>+<span class=\"built_in\">str</span>(i+<span class=\"number\">1</span>),linewidth=<span class=\"number\">2</span>, linestyle=<span class=\"string\">&#x27;-.&#x27;</span>)</span><br><span class=\"line\">        ax.set_rgrids(np.arange(<span class=\"number\">0</span>,<span class=\"number\">2.5</span>, <span class=\"number\">0.5</span>))  <span class=\"comment\"># 画出每层的权重</span></span><br><span class=\"line\">        ax.set_thetagrids(angles_org* <span class=\"number\">180</span>/np.pi,labels)  <span class=\"comment\"># 设置显示的角度为度数制</span></span><br><span class=\"line\">        plt.legend(loc=<span class=\"string\">&#x27;lower right&#x27;</span>,bbox_to_anchor=(<span class=\"number\">1.1</span>, -<span class=\"number\">0.1</span>))  <span class=\"comment\">#设置图例位置在画布外</span></span><br><span class=\"line\">        <span class=\"comment\">#plt.legend()</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#ax.set_theta_zero_location(&#x27;N&#x27;)         # 设置极坐标的起点（即0°）在正北方向</span></span><br><span class=\"line\">        ax.spines[<span class=\"string\">&#x27;polar&#x27;</span>].set_visible(<span class=\"literal\">False</span>)   <span class=\"comment\"># 不显示极坐标最外面的圈</span></span><br><span class=\"line\">        ax.grid(<span class=\"literal\">False</span>)                          <span class=\"comment\"># 不显示默认分割线</span></span><br><span class=\"line\">        plt.savefig(<span class=\"string\">&quot;../tmp/ACVA_img.png&quot;</span>)      <span class=\"comment\"># 储存图像的临时文件</span></span><br><span class=\"line\">        plt.show()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重新组织main-py\"><a href=\"#重新组织main-py\" class=\"headerlink\" title=\"重新组织main.py\"></a>重新组织main.py</h2><p>至此所有的功能已经实现，并封装到了各个模块和类中，所以我们再重新组织一次<code>main.py</code>，并最终定档其中的代码</p>\n<blockquote>\n<p>main.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">######### 主程序入口 #############</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.cluster <span class=\"keyword\">import</span> KMeans</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> log <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> data_clean <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LRFMC <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> radar_chart <span class=\"keyword\">import</span>  *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    log = Log()  <span class=\"comment\"># 实例化一个日志器</span></span><br><span class=\"line\">    data_cleaner = DataCleaner() <span class=\"comment\">#实例化数据清洗器</span></span><br><span class=\"line\">    LRFMCobj = LRFMC() <span class=\"comment\"># 实例化模型处理器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 从数据源获取数据</span></span><br><span class=\"line\">    airline_data = pd.read_csv(<span class=\"string\">&quot;../data_raw/air_data.csv&quot;</span>,</span><br><span class=\"line\">        encoding=<span class=\"string\">&quot;gb18030&quot;</span>)  <span class=\"comment\"># 导入航空数据</span></span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&#x27;原始数据的形状为：&#x27;</span>, airline_data.shape)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#数据预处理</span></span><br><span class=\"line\">    <span class=\"comment\">## 缺失值处理：去除票价为空的记录</span></span><br><span class=\"line\">    airline_notnull = data_cleaner.notNull(airline_data)</span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&#x27;删除缺失记录后数据的形状为：&#x27;</span>, airline_notnull.shape)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">## 异常值处理: 只保留票价非零的，或者平均折扣率不为0且总飞行公里数大于0的记录。</span></span><br><span class=\"line\">    airline = data_cleaner.notOutlier(airline_notnull)</span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&#x27;删除异常记录后数据的形状为：&#x27;</span>, airline.shape)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 构建LRFMC五大特征</span></span><br><span class=\"line\">    airline_features = LRFMCobj.getFeatures(airline)</span><br><span class=\"line\">    LRFMCobj.storeStandData(airline_features)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取KMeans对象</span></span><br><span class=\"line\">    <span class=\"comment\">## 准备数据</span></span><br><span class=\"line\">    airline_scale = pd.read_excel(<span class=\"string\">&quot;../tmp/airline_scale.xlsx&quot;</span>)</span><br><span class=\"line\">    airline_scale = airline_scale.iloc[:,<span class=\"number\">1</span>:]  <span class=\"comment\"># 切掉第一列的作为行数标志的数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">## 对象实例化</span></span><br><span class=\"line\">    k = <span class=\"number\">5</span> <span class=\"comment\">## 确定聚类中心数，这里我们预期聚类5类客户</span></span><br><span class=\"line\">    kmeans_model = KMeans(n_clusters=k,random_state=<span class=\"built_in\">int</span>(time.time()))  <span class=\"comment\"># 实例化对象</span></span><br><span class=\"line\">    kmeans_model = kmeans_model.fit(airline_scale)  <span class=\"comment\"># 用准备好的数据训练模型</span></span><br><span class=\"line\">    centers = kmeans_model.cluster_centers_</span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&quot;五个聚类中心为\\n&quot;</span>,centers)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">## 统计不同类别样本的数目</span></span><br><span class=\"line\">    r1 = pd.Series(kmeans_model.labels_).value_counts()</span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&quot;最终每个类别的数目为\\n&quot;</span>,r1)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 作出图样</span></span><br><span class=\"line\">    RadarDrawer()(kmeans_model,n_clusters=k)</span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&quot;完成作图&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，经过一系列封装，<code>main.py</code>只有寥寥50多行，确已经体现了主要的 业务逻辑</p>\n<h1 id=\"分析聚类结果\"><a href=\"#分析聚类结果\" class=\"headerlink\" title=\"分析聚类结果\"></a>分析聚类结果</h1><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_output.png\"></p>\n<p>基于特征描述，本项目定义五个等级的客户类别：重要保持客户，重要发展客户，重要挽留客户，一般客户，低价值客户</p>\n<h1 id=\"模型应用\"><a href=\"#模型应用\" class=\"headerlink\" title=\"模型应用\"></a>模型应用</h1><p>根据对各个客户群进行特征分析，采取下面的一些营销手段和策略，为航空公司的价值客户群管理提供参考</p>\n<ul>\n<li><code>会员的升级与保级</code>：航空公司可以在对会员升级或保级进行评价的时间点之前，对那些接近但尚未达到要求的较高消费客户进行适当提醒甚至采取一些促销活动，刺激他们通过消费达到相应标准。这样既可以获得收益，同时也提高了客户的满意度，增加了公司的精英会员。</li>\n<li><code>首次兑换</code>：采取的措施是从数据库中提取出接近但尚未达到首次兑换标准的会员，对他们进行提醒或促销，使他们通过消费达到标准。一旦实现了首次兑换，客户在本公司进行再次消费兑换就比在其他公司进行兑换要容易许多，在一定程度上等于提高了转移的成本。</li>\n<li><code>交叉销售</code>：通过发行联名卡等与非航空类企业的合作，使客户在其他企业的消费过程中获得本公司的积分，增强与公司的联系，提高他们的忠诚度。</li>\n</ul>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本项目结合航空公司客户价值分析的案例，重点介绍了数据分析算法中K-Means聚类算法在客户价值分析中的应用。针对RFM客户价值分析模型的不足，使用K-Means算法构建了航空客户价值分析LRFMC模型，详细描述了数据分析的整个过程。</p>\n<h1 id=\"github项目文件-和-相关外部链接\"><a href=\"#github项目文件-和-相关外部链接\" class=\"headerlink\" title=\"github项目文件 和 相关外部链接\"></a>github项目文件 和 相关外部链接</h1><p><a href=\"https://github.com/sis-shen/ACVA\">戳我去github仓库🔗</a></p>\n<p><a href=\"https://github.com/scikit-learn/scikit-learn/blob/fd237278e/sklearn/cluster/_kmeans.py#L745\">戳我去KMeans源码🔗</a></p>\n<p><a href=\"https://pandas.pydata.org/docs/\">戳我去pandas文档下载🔗</a></p>\n<p><a href=\"https://matplotlib.org/stable/api/index\">戳我去matplotlib的API文档🔗</a></p>\n<p><a href=\"https://numpy.org/doc/stable/\">戳我去numpy文档🔗</a></p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"背景分析\"><a href=\"#背景分析\" class=\"headerlink\" title=\"背景分析\"></a>背景分析</h1><h2 id=\"航空公司现状\"><a href=\"#航空公司现状\" class=\"headerlink\" title=\"航空公司现状\"></a>航空公司现状</h2><h4 id=\"行业内竞争\"><a href=\"#行业内竞争\" class=\"headerlink\" title=\"行业内竞争\"></a>行业内竞争</h4><p>民航的竞争除了三大航空公司之间的竞争外，还将加入新崛起的各类小型航空公司、民营航空公司，甚至国外航空巨头。航空产品<strong>生产过剩,产品同质化</strong>特征愈加明显，于是航空公司从<strong>价格、服务</strong>间的竞争逐渐转向对<strong>客户</strong>的竞争</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/airliness.png\"></p>\n<h2 id=\"行业外竞争\"><a href=\"#行业外竞争\" class=\"headerlink\" title=\"行业外竞争\"></a>行业外竞争</h2><p>随着<strong>高铁</strong>、动车等铁路运输的兴建，航空公司受到巨大冲击</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/transportalrad.png\"></p>\n<p><em>如上图所示，经过2010到2015年的发展，铁路运输对航空运输的冲击越发明显</em></p>\n<h2 id=\"航空公司数据特征说明\"><a href=\"#航空公司数据特征说明\" class=\"headerlink\" title=\"航空公司数据特征说明\"></a>航空公司数据特征说明</h2><ul>\n<li>目前航空公司已经积累了大量的会员档案信息和其乘坐航班记录</li>\n<li>就本项目已获取的数据，以2014-03-31为结束时间，选取宽度为<strong>两年</strong>的时间段作为分析观测窗口，抽取观测窗口内有乘机记录的所有客户的详细数据形成的历史数据，44个特征，总共62988条记录。</li>\n</ul>\n<p>数据特征记录说明如下表所示:</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE1.png\"><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE2.png\"><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_TABLE3.png\"></p>\n<h2 id=\"结合数据的项目目标\"><a href=\"#结合数据的项目目标\" class=\"headerlink\" title=\"结合数据的项目目标\"></a>结合数据的项目目标</h2><p>结合目前航空公司的数据情况，可以实现以下目标</p>\n<ul>\n<li>借助航空公司客户数据，对客户进行分类</li>\n<li>对不同的客户类别<code>进行特征分析</code>，比较不同类别客户的<code>客户价值</code></li>\n<li>对不同价值的客户类别提供<code>个性化服务</code>,制定相应的<code>营销策略</code></li>\n</ul>\n<h2 id=\"了解客户价值分析\"><a href=\"#了解客户价值分析\" class=\"headerlink\" title=\"了解客户价值分析\"></a>了解客户价值分析</h2><p>客户营销战略倡导者<em>Jay</em> &amp; <em>Adam Curry</em> 从国外数百家公司进行了客户营销实施的经验中提炼了如下经验</p>\n<ul>\n<li>公司<strong>收入</strong>的<code>80%</code>来自顶端的<code>20%</code>客户</li>\n<li><code>20%</code>的客户其利<code>润率100%</code></li>\n<li><code>90%</code>以上的收入来自<strong>现有</strong>客户</li>\n<li><strong>大部分的营销预算</strong>经常被用在非现有客户上</li>\n<li><code>5%</code>至<code>30%</code>的客户在客户金字塔中具有<strong>升级潜力</strong></li>\n<li>客户金字塔中客户升级<code>2%</code>，意味着营销收入增加<code>10%</code>,利润增加<code>50%</code></li>\n</ul>\n<p>也许这些经验并不完全准确，但是它解释了新时代<code>客户分化</code>的趋势，也说明了对客户价值分析的<strong>迫切性</strong>和<strong>必要性</strong></p>\n<h2 id=\"项目流程图\"><a href=\"#项目流程图\" class=\"headerlink\" title=\"项目流程图\"></a>项目流程图</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_flow_char.png\"></p>\n<h1 id=\"代码实现业务功能\"><a href=\"#代码实现业务功能\" class=\"headerlink\" title=\"代码实现业务功能\"></a>代码实现业务功能</h1><h2 id=\"系统架构\"><a href=\"#系统架构\" class=\"headerlink\" title=\"系统架构\"></a>系统架构</h2><h3 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h3><p>这里主要用三个文件夹，分别储存<code>代码</code>，<code>原始数据</code>,<code>临时文件</code></p>\n<ul>\n<li><code>codes</code>       代码文件夹</li>\n<li><code>data_raw</code>    原始数据文件夹</li>\n<li><code>tmp</code>         临时文件文件夹</li>\n</ul>\n<h2 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h2><p>本业务系统采用一个<code>main.py</code>执行主要业务逻辑，封装多个模块和类实现具体业务，以达到主要业务逻辑清晰，代码封装性强，易于维护和复用的优点</p>\n<p>主要的代码文件有:</p>\n<ul>\n<li>main.py       执行主要逻辑</li>\n<li>log.py        提供日志器</li>\n<li>data_cleaner  实现清洗数据</li>\n<li>LEDNX.py      构建和提取五大特征</li>\n<li>radar_char.py 绘制结果雷达图</li>\n</ul>\n<h2 id=\"实现一个简单的日志器\"><a href=\"#实现一个简单的日志器\" class=\"headerlink\" title=\"实现一个简单的日志器\"></a>实现一个简单的日志器</h2><p>一般日志器有<code>日志等级</code>，<code>日志时间</code>，和<code>日志内容</code>三大部分，不过本次业务与时间关联性不大，就只打印两个部分</p>\n<blockquote>\n<p>log.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">###### 实现日志系统 ########</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义日志等级</span></span><br><span class=\"line\">LOG_INFO = <span class=\"string\">&quot;Info&quot;</span></span><br><span class=\"line\">LOG_ERROR = <span class=\"string\">&quot;Error&quot;</span></span><br><span class=\"line\">LOG_WANING = <span class=\"string\">&quot;Warning&quot;</span></span><br><span class=\"line\">LOG_FATAL = <span class=\"string\">&quot;Fatal&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Log</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">self,level,*msgs</span>): <span class=\"comment\"># 重载()运算符</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[&quot;</span>, level, <span class=\"string\">&quot;]&quot;</span>,end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> msg <span class=\"keyword\">in</span> msgs:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(msg)</span><br><span class=\"line\">        <span class=\"comment\"># 本项目与时间关系不大，日志系统不打印时间</span></span><br></pre></td></tr></table></figure>\n\n<p>这里使用了<code>__call__</code>对<code>()</code>操作符的<code>重载</code>，和<code>*mgs</code>达到了<code>传递任意数量参数</code>的语法特性</p>\n<p>这样以后打印日志可以方便地把对象当函数用</p>\n<h2 id=\"程序入口-从数据源提取数据\"><a href=\"#程序入口-从数据源提取数据\" class=\"headerlink\" title=\"程序入口 &amp; 从数据源提取数据\"></a>程序入口 &amp; 从数据源提取数据</h2><p>我们将<code>main.py</code>作为项目的程序入口</p>\n<blockquote>\n<p>main.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">######### 主程序入口 #############</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.cluster <span class=\"keyword\">import</span> KMeans</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> log <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> data_clean <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LRFMC <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    log = Log()  <span class=\"comment\"># 实例化一个日志器</span></span><br><span class=\"line\">    data_cleaner = DataCleaner() <span class=\"comment\">#实例化数据清洗器</span></span><br><span class=\"line\">    LRFMCobj = LRFMC()  <span class=\"comment\"># 实例化模型处理器</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的数据源为<code>.csv</code>文件，所以我们要用到<code>pandas</code>模块读取文件到表格中</p>\n<p>这里代码不多，就直接写在<code>main.py</code>里了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ...上略...</span></span><br><span class=\"line\"><span class=\"comment\">#data_cleaner = DataCleaner() #实例化数据清洗器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从数据源获取数据</span></span><br><span class=\"line\">airline_data = pd.read_csv(<span class=\"string\">&quot;../data_raw/air_data.csv&quot;</span>,</span><br><span class=\"line\">    encoding=<span class=\"string\">&quot;gb18030&quot;</span>)  <span class=\"comment\"># 导入航空数据</span></span><br><span class=\"line\">log(LOG_INFO,<span class=\"string\">&#x27;原始数据的形状为：&#x27;</span>, airline_data.shape)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"预处理航空公司数据\"><a href=\"#预处理航空公司数据\" class=\"headerlink\" title=\"预处理航空公司数据\"></a>预处理航空公司数据</h2><p>航空公司客户原始数据存在少量的<code>缺失值</code>和<code>异常值</code>，需要清洗后才能用于分析。</p>\n<h3 id=\"缺失值处理\"><a href=\"#缺失值处理\" class=\"headerlink\" title=\"缺失值处理\"></a>缺失值处理</h3><p>通过对数据观察发现原始数据中存在票价为空值，票价最小值为0，折扣率最小值为0，总飞行公里数大于0的记录。票价为空值的数据可能是客户不存在乘机记录造成。</p>\n<p>处理方法：丢弃票价为空的记录</p>\n<p>具体实现： 考虑到与票价有关的特征有<code>SUM_YR_1</code>和<code>SUM_YR_2</code>两条，逻辑上两条特征数据都为<code>0</code>才算<code>缺失值</code>,所以分别提取两条对应的<code>布尔值列表</code>，并用<code>逻辑与</code>合并，用于数据表格的切片</p>\n<p><em>我们先定义好成员函数，最后封装到DataCleaner类中</em></p>\n<blockquote>\n<p>data_cleaner.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">notNull</span>(<span class=\"params\">self,airline_data</span>):  <span class=\"comment\"># 缺失值处理：去除票价为空的记录</span></span><br><span class=\"line\">    exp1 = airline_data[<span class=\"string\">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class=\"line\">    exp2 = airline_data[<span class=\"string\">&quot;SUM_YR_2&quot;</span>].notnull()</span><br><span class=\"line\">    exp = exp1 &amp; exp2  <span class=\"comment\"># 按位逻辑与,获取所需的布尔值列表</span></span><br><span class=\"line\">    <span class=\"comment\"># airline_notnull = airline_data.loc[exp, :]  # exp提供布尔值竖列表， &#x27;:&#x27;默认无参时，切片所有行,完成去除操作</span></span><br><span class=\"line\">    airline_notnull = airline_data[exp] <span class=\"comment\">#  这是上一句的简化写法（使用更多的缺省参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> airline_notnull</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异常值\"><a href=\"#异常值\" class=\"headerlink\" title=\"异常值\"></a>异常值</h3><p>其他的数据可能是客户乘坐<code>0折机票</code>或者<code>积分兑换</code>造成。由于原始数据量大，这类数据所占比例较小，对于问题影响不大，因此对其进行丢弃处理。</p>\n<p>处理方法：丢弃<strong>票价为0，平均折扣率为0，总飞行公里数大于0的记录。</strong></p>\n<p>具体处理：采用<code>index1</code>和<code>index2</code>先保留总票价不为<code>0</code>的记录,然后用<code>index3</code>筛选出总里程<code>SEG_KM_SUM``&gt;0</code>且平均折扣率<code>avg_discount``!=0</code>的记录,使用布尔值列表<code>(index1 | index2) &amp; index3</code>进行筛选，保留所需数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">notOutlier</span>(<span class=\"params\">self,airline_data</span>):</span><br><span class=\"line\">    index1 = airline_data[<span class=\"string\">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class=\"line\">    index2 = airline_data[<span class=\"string\">&quot;SUM_YR_2&quot;</span>] != <span class=\"number\">0</span>  <span class=\"comment\"># 效果和上一句的notnull()一样,都是生成bool array</span></span><br><span class=\"line\">    index3 = (airline_data[<span class=\"string\">&quot;SEG_KM_SUM&quot;</span>] &gt; <span class=\"number\">0</span>) &amp; \\</span><br><span class=\"line\">             (airline_data[<span class=\"string\">&quot;avg_discount&quot;</span>] != <span class=\"number\">0</span>)  <span class=\"comment\"># 折扣且总里程不为0的机票</span></span><br><span class=\"line\">    airline = airline_data[(index1 | index2) &amp; index3]  <span class=\"comment\"># 丢弃票价为0，或折扣率为0，且总里程&gt;0的异常值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> airline</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"封装DataCleaner类\"><a href=\"#封装DataCleaner类\" class=\"headerlink\" title=\"封装DataCleaner类\"></a>封装DataCleaner类</h3><p>将用于清理数据的函数整合到一个类中，方便维护，添加或修改新的清理规则也很可以很方便地找到<code>DataCleaner</code>类，在里面集中维护s</p>\n<blockquote>\n<p>data_cleaner.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataCleaner</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">notNull</span>(<span class=\"params\">self,airline_data</span>):  <span class=\"comment\"># 缺失值处理：去除票价为空的记录</span></span><br><span class=\"line\">        exp1 = airline_data[<span class=\"string\">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class=\"line\">        exp2 = airline_data[<span class=\"string\">&quot;SUM_YR_2&quot;</span>].notnull()</span><br><span class=\"line\">        exp = exp1 &amp; exp2  <span class=\"comment\"># 按位逻辑与,获取所需的布尔值列表</span></span><br><span class=\"line\">        <span class=\"comment\">#airline_notnull = airline_data.loc[exp, :]  # exp提供布尔值竖列表， &#x27;:&#x27;默认无参时，切片所有行,完成去除操作</span></span><br><span class=\"line\">        airline_notnull = airline_data[exp] <span class=\"comment\">#  这是上一句的简化写法（使用更多的缺省参数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> airline_notnull</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">notOutlier</span>(<span class=\"params\">self,airline_data</span>):</span><br><span class=\"line\">        index1 = airline_data[<span class=\"string\">&quot;SUM_YR_1&quot;</span>].notnull()</span><br><span class=\"line\">        index2 = airline_data[<span class=\"string\">&quot;SUM_YR_2&quot;</span>] != <span class=\"number\">0</span>  <span class=\"comment\"># 效果和上一句的notnull()一样,都是生成bool array</span></span><br><span class=\"line\">        index3 = (airline_data[<span class=\"string\">&quot;SEG_KM_SUM&quot;</span>] &gt; <span class=\"number\">0</span>) &amp; \\</span><br><span class=\"line\">                 (airline_data[<span class=\"string\">&quot;avg_discount&quot;</span>] != <span class=\"number\">0</span>)  <span class=\"comment\"># 折扣且总里程不为0的机票</span></span><br><span class=\"line\">        airline = airline_data[(index1 | index2) &amp; index3]  <span class=\"comment\"># 丢弃票价为0，或折扣率为0，且总里程&gt;0的异常值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> airline</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RFM到LFRMC模型的介绍\"><a href=\"#RFM到LFRMC模型的介绍\" class=\"headerlink\" title=\"RFM到LFRMC模型的介绍\"></a>RFM到LFRMC模型的介绍</h2><h3 id=\"RFM模型介绍\"><a href=\"#RFM模型介绍\" class=\"headerlink\" title=\"RFM模型介绍\"></a>RFM模型介绍</h3><p>本项目的目标是客户价值分析，即通过航空公司客户数据识别不同价值的客户，识别客户价值应用最广泛的模型是RFM模型。</p>\n<blockquote>\n<ul>\n<li><strong>R</strong>（<code>Recency</code>）指的是最近一次消费时间与截止时间的间隔。通常情况下，最近一次消费时间与截止时间的间隔越短，对即时提供的商品或是服务也最有可能感兴趣。</li>\n<li><strong>F</strong>（<code>Frequency</code>）指顾客在某段时间内所消费的次数。可以说消费频率越高的顾客，也是满意度越高的顾客，其忠诚度也就越高，顾客价值也就越大。</li>\n<li><strong>M</strong>（<code>Monetary</code>）指顾客在某段时间内所消费的金额。消费金额越大的顾客，他们的消费能力自然也就越大，这就是所谓“20%的顾客贡献了80%的销售额”的二八法则。</li>\n</ul>\n</blockquote>\n<h3 id=\"RFM模型结果解读\"><a href=\"#RFM模型结果解读\" class=\"headerlink\" title=\"RFM模型结果解读\"></a>RFM模型结果解读</h3><p>RFM模型包括三个特征，使用<strong>三维坐标系</strong>进行展示，如图所示。X轴表示<code>Recency</code>，Y轴表示<code>Frequency</code>，Z轴表示<code>Monetary</code>，每个轴一般会分成5级表示程度，1为最小，5为最大</p>\n<p><em>如图，不同的区域有有不同的营销策略</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RFM_model_res.png\"></p>\n<h3 id=\"传统RFM模型在航空行业的缺陷\"><a href=\"#传统RFM模型在航空行业的缺陷\" class=\"headerlink\" title=\"传统RFM模型在航空行业的缺陷\"></a>传统RFM模型在航空行业的缺陷</h3><p>在RFM模型中，消费金额表示在一段时间内，客户购买该企业产品金额的总和，由于航空票价受到运输距离，舱位等级等多种因素影响，同样消费金额的不同旅客对航空公司的价值是不同的，因此这个特征并不适合用于航空公司的客户价值分析。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_RFM_LOw.png\"></p>\n<h3 id=\"航空客户价值分析的LRFMC模型\"><a href=\"#航空客户价值分析的LRFMC模型\" class=\"headerlink\" title=\"航空客户价值分析的LRFMC模型\"></a>航空客户价值分析的LRFMC模型</h3><p>为了弥补传统RFM模型在实际应用中的缺陷，本次项目使用了适用于航空客户价值分析的<code>LRFMC模型</code></p>\n<p>本项目选择客户在一定时间内累积的飞行里程M和客户在一定时间内乘坐舱位所对应的折扣系数的平均值C两个特征代替消费金额。此外，航空公司会员入会时间的长短在一定程度上能够影响客户价值，所以在模型中增加客户关系长度L，作为区分客户的另一特征。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_LRFMC.png\"></p>\n<h2 id=\"构建航空客户价值分析的关键特征\"><a href=\"#构建航空客户价值分析的关键特征\" class=\"headerlink\" title=\"构建航空客户价值分析的关键特征\"></a>构建航空客户价值分析的关键特征</h2><p>这里依然使用模块封装和类封装，在<code>LRFMC.py</code>中封装<code>LRFMC</code>类来完成模型相关的数据处理</p>\n<h3 id=\"选取关键特征-和-构建L特征\"><a href=\"#选取关键特征-和-构建L特征\" class=\"headerlink\" title=\"选取关键特征 和 构建L特征\"></a>选取关键特征 和 构建L特征</h3><p>我们首先选取上图相关特征的列到<code>airline_selection</code>中，用于构建<code>L</code>特征和后面选取后四列与<code>L</code>列合并</p>\n<blockquote>\n<p>LRFMC.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">######## 构建 LRFMC模型 ########</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> log <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRFMC</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.log = Log()</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">getFeatures</span>(<span class=\"params\">self,airline</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 选取需求特征</span></span><br><span class=\"line\">        airline_selection = airline[[<span class=\"string\">&quot;FFP_DATE&quot;</span>,<span class=\"string\">&quot;LOAD_TIME&quot;</span>,</span><br><span class=\"line\">                                     <span class=\"string\">&quot;FLIGHT_COUNT&quot;</span>,<span class=\"string\">&quot;LAST_TO_END&quot;</span>,</span><br><span class=\"line\">                                     <span class=\"string\">&quot;avg_discount&quot;</span>,<span class=\"string\">&quot;SEG_KM_SUM&quot;</span>]]</span><br><span class=\"line\">        <span class=\"comment\"># 构建L特征</span></span><br><span class=\"line\">        L = pd.to_datetime(airline_selection[<span class=\"string\">&quot;LOAD_TIME&quot;</span>]) \\</span><br><span class=\"line\">            - pd.to_datetime(airline_selection[<span class=\"string\">&quot;FFP_DATE&quot;</span>])</span><br><span class=\"line\">        self.log(LOG_DEBUG,<span class=\"string\">&quot;\\n&quot;</span>,L[:<span class=\"number\">5</span>])  <span class=\"comment\">#测试前五行</span></span><br><span class=\"line\">        <span class=\"comment\"># 转成月份</span></span><br><span class=\"line\">        L = L.astype(<span class=\"string\">&quot;str&quot;</span>).<span class=\"built_in\">str</span>.split().<span class=\"built_in\">str</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">        L = L.astype(<span class=\"string\">&quot;int&quot;</span>)/<span class=\"number\">30</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#合并特征</span></span><br><span class=\"line\">        airline_features = pd.concat([L,</span><br><span class=\"line\">                airline_selection.iloc[:,<span class=\"number\">2</span>:]],axis = <span class=\"number\">1</span>)  <span class=\"comment\">#axis=1使函数按列合并,[:,2:]舍弃了原本的前两列</span></span><br><span class=\"line\">        airline_features =airline_features.rename(columns=&#123;<span class=\"number\">0</span>:<span class=\"string\">&quot;L&quot;</span>&#125;) <span class=\"comment\"># 重命名没有名字的列</span></span><br><span class=\"line\">        self.log(LOG_DEBUG,<span class=\"string\">&quot;\\n&quot;</span>,airline_features.head())  <span class=\"comment\">#缺省参数为5，打印前五行</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> airline_features</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"标准化\"><a href=\"#标准化\" class=\"headerlink\" title=\"标准化\"></a>标准化</h3><p>完成五个特征的构建以后，对每个特征数据分布情况进行分析，其数据的取值范围如下表所示。从表中数据可以发现，<strong>五个特征的取值范围数据差异较大</strong>，为了消除数量级数据带来的影响，需要对数据做<code>标准化处理</code>。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_Stadert_table.png\"></p>\n<p>这里使用 <code>sklearn</code>模块中的 <code>StandardScaler</code>类来自动标准化数据，然后我们将标准化后的数据再转成<code>pandas</code>表格，最后储存到临时文件<code>airline_scale.xlsx</code>中</p>\n<blockquote>\n<p>LRFMC.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">storeStandData</span>(<span class=\"params\">self,airline_features</span>):</span><br><span class=\"line\">    data = StandardScaler().fit_transform(airline_features)</span><br><span class=\"line\">    SDF = pd.DataFrame(data);  <span class=\"comment\">#获取 standardDataFrame(SDF)</span></span><br><span class=\"line\">    SDF = SDF.rename(columns=&#123;<span class=\"number\">0</span>:<span class=\"string\">&quot;L&quot;</span>,<span class=\"number\">1</span>:<span class=\"string\">&quot;F&quot;</span>,<span class=\"number\">2</span>:<span class=\"string\">&quot;R&quot;</span>,<span class=\"number\">3</span>:<span class=\"string\">&quot;C&quot;</span>,<span class=\"number\">4</span>:<span class=\"string\">&quot;M&quot;</span>&#125;)</span><br><span class=\"line\">    self.log(LOG_INFO,<span class=\"string\">&quot;标准化后的前五行的LRFMC五个特征为\\n&quot;</span>,SDF.head())</span><br><span class=\"line\">    SDF.to_excel(<span class=\"string\">&quot;../tmp/airline_scale.xlsx&quot;</span>)  <span class=\"comment\">##储存值tmp文件夹</span></span><br></pre></td></tr></table></figure>\n\n<p>前五行标准化前后的结果如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/acva_sta_raw.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_STA.png\"></p>\n<h2 id=\"了解和使用K-Means聚类算法\"><a href=\"#了解和使用K-Means聚类算法\" class=\"headerlink\" title=\"了解和使用K-Means聚类算法\"></a>了解和使用<code>K-Means</code>聚类算法</h2><p>即使经过了一系列预处理和模型建模，我们手上的数据依然还是比较原始，只有经过分类过的数据才更有分析价值，而自然数据一般都难以直接分类，需要用聚类算法进行分类，这里就用到了<code>K-Means</code>聚类算法</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>K-Means聚类算法是一种基于质心的划分方法，输入聚类个数k，以及包含n个数据对象的数据库，输出满足误差平方和最小标准的k个聚类。算法步骤如下:</p>\n<ul>\n<li>从n个样本数据中随机选取k个对象作为初始的聚类中心。</li>\n<li>分别计算每个样本到各个聚类质心的距离，将样本分配到距离最近的那个聚类中心类别中。</li>\n<li>所有样本分配完成后，重新计算k个聚类的中心。</li>\n<li>与前一次计算得到的k个聚类中心比较，如果聚类中心发生变化，转(2)，否则转(5)。</li>\n<li>当质心不发生变化时停止并输出聚类结果。</li>\n</ul>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_KMEANS.png\"></p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>K-Means聚类算法是在数值类型数据的基础上进行研究，然而数据分析的样本复杂多样，因此要求不仅能够对特征为数值类型的数据进行分析，还要适应数据类型的变化，对不同特征做不同变换，以满足算法的要求。</p>\n<h3 id=\"获取KMeans对象\"><a href=\"#获取KMeans对象\" class=\"headerlink\" title=\"获取KMeans对象\"></a>获取KMeans对象</h3><p>sklearn的cluster模块提供了KMeans函数构建K-Means聚类模型</p>\n<p>翻阅其源代码(下图)，可以看到<code>KMeans</code>是一个<strong>类</strong>，且构造函数有大量缺省参数，因此实例化<code>KMeans</code>对象时，只需提供无缺省的参数，和调整关键缺省参数即可</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/K-Means_org.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_Kmeans_para.png\"></p>\n<p>这里我们只显式传参<code>n_clusters</code>和<code>random_state</code>,其中后一个参数用时间戳</p>\n<p>因为本身<code>KMeans</code>就封装地很好，这部分代码就写在<code>main.py</code>的主逻辑中</p>\n<blockquote>\n<p>main.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 对象实例化</span></span><br><span class=\"line\">k = <span class=\"number\">5</span> <span class=\"comment\">## 确定聚类中心数，这里我们预期聚类5类客户</span></span><br><span class=\"line\">kmeans_model = KMeans(n_clusters=k,random_state=<span class=\"built_in\">int</span>(time.time()))  <span class=\"comment\"># 实例化对象</span></span><br><span class=\"line\">kmeans_model = kmeans_model.fit(airline_scale)  <span class=\"comment\"># 用准备好的数据训练模型</span></span><br><span class=\"line\">centers = kmeans_model.cluster_centers_</span><br><span class=\"line\">log(LOG_INFO,<span class=\"string\">&quot;五个聚类中心为\\n&quot;</span>,centers)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 统计不同类别样本的数目</span></span><br><span class=\"line\">r1 = pd.Series(kmeans_model.labels_).value_counts()</span><br><span class=\"line\">log(LOG_INFO,<span class=\"string\">&quot;最终每个类别的数目为\\n&quot;</span>,r1)</span><br></pre></td></tr></table></figure>\n\n<p>最后聚类的结果类似下表</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_CLUSTER_RES.png\"></p>\n<p>至此数据的分析，建模和聚类已经完成，数据处理部分告一段落，接下来是可视化处理</p>\n<h2 id=\"可视化雷达图\"><a href=\"#可视化雷达图\" class=\"headerlink\" title=\"可视化雷达图\"></a>可视化雷达图</h2><p>这里使用<code>matplotlib.pyplot</code>模块作图，<code>numpy</code>二次处理数据,封装代码到<code>RadarDrawer</code>类中并用<code>__call__</code>重载<code>()</code>操作符</p>\n<p>值得注意的是:</p>\n<ul>\n<li>因为这里使用了雷达图，所以绘制图形时使用<code>极坐标</code>会更方便</li>\n<li>因为这里使用了中文文字，而默认字体不支持中文，会报错，所以要<strong>提前设置中文字体</strong></li>\n</ul>\n<blockquote>\n<p>radar_chart.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RadarDrawer</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">self, kmeans_moudel, n_clusters</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 设置支持中文的字体</span></span><br><span class=\"line\">        plt.rc(<span class=\"string\">&quot;font&quot;</span>,family=<span class=\"string\">&quot;Microsoft YaHei&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 标签</span></span><br><span class=\"line\">        labels = np.array([<span class=\"string\">u&#x27;ZL&#x27;</span>,<span class=\"string\">u&#x27;ZR&#x27;</span>,<span class=\"string\">u&#x27;ZF&#x27;</span>,<span class=\"string\">u&#x27;ZM&#x27;</span>,<span class=\"string\">u&#x27;ZC&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        plot_data = kmeans_moudel.cluster_centers_</span><br><span class=\"line\">        <span class=\"comment\"># 指定颜色</span></span><br><span class=\"line\">        color = [<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;g&#x27;</span>,<span class=\"string\">&#x27;r&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;y&#x27;</span>]</span><br><span class=\"line\">        <span class=\"comment\"># 计算雷达图的角度</span></span><br><span class=\"line\">        angles = np.linspace(<span class=\"number\">0</span>,<span class=\"number\">2</span>*np.pi,n_clusters,endpoint=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 闭合(首尾列相同) 并用np把pandas的DataFrame转成原生数组</span></span><br><span class=\"line\">        plot_data = np.concatenate((plot_data,plot_data[:,[<span class=\"number\">0</span>]]),axis = <span class=\"number\">1</span>)</span><br><span class=\"line\">        angles_org = angles</span><br><span class=\"line\">        angles = np.concatenate((angles,[angles[<span class=\"number\">0</span>]]))</span><br><span class=\"line\"></span><br><span class=\"line\">        fig = plt.figure(figsize=(<span class=\"number\">6</span>,<span class=\"number\">6</span>),dpi = <span class=\"number\">160</span>)</span><br><span class=\"line\">        <span class=\"comment\">#polar参数</span></span><br><span class=\"line\">        ax = fig.add_subplot(<span class=\"number\">111</span>, polar=<span class=\"literal\">True</span>)  <span class=\"comment\"># 设置坐标为极坐标</span></span><br><span class=\"line\">        <span class=\"comment\"># 画若干个五边形</span></span><br><span class=\"line\">        floor = np.floor(plot_data.<span class=\"built_in\">min</span>())   <span class=\"comment\"># 大于最小值的最大整数</span></span><br><span class=\"line\">        ceil = np.ceil(plot_data.<span class=\"built_in\">max</span>())     <span class=\"comment\"># 小于最小值的最小整数</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(labels)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> np.arange(floor,ceil+<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>):</span><br><span class=\"line\">            ax.plot(angles,[i] *(n+<span class=\"number\">1</span>),<span class=\"string\">&#x27;-.&#x27;</span>,lw=<span class=\"number\">0.5</span>,color=<span class=\"string\">&#x27;black&#x27;</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 话不同客户群的分割线</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(plot_data)):</span><br><span class=\"line\">            ax.plot(angles,plot_data[i],color = color[i],</span><br><span class=\"line\">                    label=<span class=\"string\">&#x27;客户群&#x27;</span>+<span class=\"built_in\">str</span>(i+<span class=\"number\">1</span>),linewidth=<span class=\"number\">2</span>, linestyle=<span class=\"string\">&#x27;-.&#x27;</span>)</span><br><span class=\"line\">        ax.set_rgrids(np.arange(<span class=\"number\">0</span>,<span class=\"number\">2.5</span>, <span class=\"number\">0.5</span>))  <span class=\"comment\"># 画出每层的权重</span></span><br><span class=\"line\">        ax.set_thetagrids(angles_org* <span class=\"number\">180</span>/np.pi,labels)  <span class=\"comment\"># 设置显示的角度为度数制</span></span><br><span class=\"line\">        plt.legend(loc=<span class=\"string\">&#x27;lower right&#x27;</span>,bbox_to_anchor=(<span class=\"number\">1.1</span>, -<span class=\"number\">0.1</span>))  <span class=\"comment\">#设置图例位置在画布外</span></span><br><span class=\"line\">        <span class=\"comment\">#plt.legend()</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#ax.set_theta_zero_location(&#x27;N&#x27;)         # 设置极坐标的起点（即0°）在正北方向</span></span><br><span class=\"line\">        ax.spines[<span class=\"string\">&#x27;polar&#x27;</span>].set_visible(<span class=\"literal\">False</span>)   <span class=\"comment\"># 不显示极坐标最外面的圈</span></span><br><span class=\"line\">        ax.grid(<span class=\"literal\">False</span>)                          <span class=\"comment\"># 不显示默认分割线</span></span><br><span class=\"line\">        plt.savefig(<span class=\"string\">&quot;../tmp/ACVA_img.png&quot;</span>)      <span class=\"comment\"># 储存图像的临时文件</span></span><br><span class=\"line\">        plt.show()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重新组织main-py\"><a href=\"#重新组织main-py\" class=\"headerlink\" title=\"重新组织main.py\"></a>重新组织main.py</h2><p>至此所有的功能已经实现，并封装到了各个模块和类中，所以我们再重新组织一次<code>main.py</code>，并最终定档其中的代码</p>\n<blockquote>\n<p>main.py</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">######### 主程序入口 #############</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.cluster <span class=\"keyword\">import</span> KMeans</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> log <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> data_clean <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LRFMC <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> radar_chart <span class=\"keyword\">import</span>  *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    log = Log()  <span class=\"comment\"># 实例化一个日志器</span></span><br><span class=\"line\">    data_cleaner = DataCleaner() <span class=\"comment\">#实例化数据清洗器</span></span><br><span class=\"line\">    LRFMCobj = LRFMC() <span class=\"comment\"># 实例化模型处理器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 从数据源获取数据</span></span><br><span class=\"line\">    airline_data = pd.read_csv(<span class=\"string\">&quot;../data_raw/air_data.csv&quot;</span>,</span><br><span class=\"line\">        encoding=<span class=\"string\">&quot;gb18030&quot;</span>)  <span class=\"comment\"># 导入航空数据</span></span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&#x27;原始数据的形状为：&#x27;</span>, airline_data.shape)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#数据预处理</span></span><br><span class=\"line\">    <span class=\"comment\">## 缺失值处理：去除票价为空的记录</span></span><br><span class=\"line\">    airline_notnull = data_cleaner.notNull(airline_data)</span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&#x27;删除缺失记录后数据的形状为：&#x27;</span>, airline_notnull.shape)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">## 异常值处理: 只保留票价非零的，或者平均折扣率不为0且总飞行公里数大于0的记录。</span></span><br><span class=\"line\">    airline = data_cleaner.notOutlier(airline_notnull)</span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&#x27;删除异常记录后数据的形状为：&#x27;</span>, airline.shape)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 构建LRFMC五大特征</span></span><br><span class=\"line\">    airline_features = LRFMCobj.getFeatures(airline)</span><br><span class=\"line\">    LRFMCobj.storeStandData(airline_features)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取KMeans对象</span></span><br><span class=\"line\">    <span class=\"comment\">## 准备数据</span></span><br><span class=\"line\">    airline_scale = pd.read_excel(<span class=\"string\">&quot;../tmp/airline_scale.xlsx&quot;</span>)</span><br><span class=\"line\">    airline_scale = airline_scale.iloc[:,<span class=\"number\">1</span>:]  <span class=\"comment\"># 切掉第一列的作为行数标志的数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">## 对象实例化</span></span><br><span class=\"line\">    k = <span class=\"number\">5</span> <span class=\"comment\">## 确定聚类中心数，这里我们预期聚类5类客户</span></span><br><span class=\"line\">    kmeans_model = KMeans(n_clusters=k,random_state=<span class=\"built_in\">int</span>(time.time()))  <span class=\"comment\"># 实例化对象</span></span><br><span class=\"line\">    kmeans_model = kmeans_model.fit(airline_scale)  <span class=\"comment\"># 用准备好的数据训练模型</span></span><br><span class=\"line\">    centers = kmeans_model.cluster_centers_</span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&quot;五个聚类中心为\\n&quot;</span>,centers)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">## 统计不同类别样本的数目</span></span><br><span class=\"line\">    r1 = pd.Series(kmeans_model.labels_).value_counts()</span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&quot;最终每个类别的数目为\\n&quot;</span>,r1)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 作出图样</span></span><br><span class=\"line\">    RadarDrawer()(kmeans_model,n_clusters=k)</span><br><span class=\"line\">    log(LOG_INFO,<span class=\"string\">&quot;完成作图&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，经过一系列封装，<code>main.py</code>只有寥寥50多行，确已经体现了主要的 业务逻辑</p>\n<h1 id=\"分析聚类结果\"><a href=\"#分析聚类结果\" class=\"headerlink\" title=\"分析聚类结果\"></a>分析聚类结果</h1><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ACVA_output.png\"></p>\n<p>基于特征描述，本项目定义五个等级的客户类别：重要保持客户，重要发展客户，重要挽留客户，一般客户，低价值客户</p>\n<h1 id=\"模型应用\"><a href=\"#模型应用\" class=\"headerlink\" title=\"模型应用\"></a>模型应用</h1><p>根据对各个客户群进行特征分析，采取下面的一些营销手段和策略，为航空公司的价值客户群管理提供参考</p>\n<ul>\n<li><code>会员的升级与保级</code>：航空公司可以在对会员升级或保级进行评价的时间点之前，对那些接近但尚未达到要求的较高消费客户进行适当提醒甚至采取一些促销活动，刺激他们通过消费达到相应标准。这样既可以获得收益，同时也提高了客户的满意度，增加了公司的精英会员。</li>\n<li><code>首次兑换</code>：采取的措施是从数据库中提取出接近但尚未达到首次兑换标准的会员，对他们进行提醒或促销，使他们通过消费达到标准。一旦实现了首次兑换，客户在本公司进行再次消费兑换就比在其他公司进行兑换要容易许多，在一定程度上等于提高了转移的成本。</li>\n<li><code>交叉销售</code>：通过发行联名卡等与非航空类企业的合作，使客户在其他企业的消费过程中获得本公司的积分，增强与公司的联系，提高他们的忠诚度。</li>\n</ul>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本项目结合航空公司客户价值分析的案例，重点介绍了数据分析算法中K-Means聚类算法在客户价值分析中的应用。针对RFM客户价值分析模型的不足，使用K-Means算法构建了航空客户价值分析LRFMC模型，详细描述了数据分析的整个过程。</p>\n<h1 id=\"github项目文件-和-相关外部链接\"><a href=\"#github项目文件-和-相关外部链接\" class=\"headerlink\" title=\"github项目文件 和 相关外部链接\"></a>github项目文件 和 相关外部链接</h1><p><a href=\"https://github.com/sis-shen/ACVA\">戳我去github仓库🔗</a></p>\n<p><a href=\"https://github.com/scikit-learn/scikit-learn/blob/fd237278e/sklearn/cluster/_kmeans.py#L745\">戳我去KMeans源码🔗</a></p>\n<p><a href=\"https://pandas.pydata.org/docs/\">戳我去pandas文档下载🔗</a></p>\n<p><a href=\"https://matplotlib.org/stable/api/index\">戳我去matplotlib的API文档🔗</a></p>\n<p><a href=\"https://numpy.org/doc/stable/\">戳我去numpy文档🔗</a></p>\n"},{"title":"手撕AVL树","date":"2024-08-12T02:55:47.000Z","_content":"# AVL树的概念\n\n## 二叉搜索树的不足\n二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将**退化**为`单支树`，查找元素相当于在顺序表中搜索元素，效率低下。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/lajibstree2.png)\n\n## AVL树的提出\n\n两位俄罗斯的数学家*G.M.Adelson-Velskii*和*E.M.Landis*在1962年发明了一种解决上述问题的方法：\n**当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)**,即构建一颗`绝对的平衡搜索二叉树`，即可降低树的高度，从而减少平均搜索长度。\n\n**定义**: 一棵AVL树或者是空树，或者是具有以下性质的二`叉搜索树`：\n+ 它的左右子树都是AVL树\n+ 左右子树高度之差(简称`平衡因子`)的绝对值不超过1(-1/0/1)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/aaaAVL80.png)\n\n如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在`O(log_2 n)`,搜索的时间复杂度`O(log_2 n)`\n\n# 封装AVL树\n\n## 头文件\n```C++\n#include <utility>\n#include <cassert>\n```\n\n## 封装AVL树的节点\n+ 这里采用`键值(KV)`类型的二叉树节点,使其泛用性更高\n+ 并增加指向父节点的指针构造三叉链表，来**简化**对二叉树的调整，但代价是**维护成本**变高(多了一个指针要维护)。\n+ 引入`平衡因子`:\n  + `-1`表示左子树比右子树高`1`层  *左>右*\n  + `0`表示左右子树等高           *左=右*\n  + `1`表示右子树比左子树高`1`层   *左<右*\n\n```C++\n#include <utility>\n#include <iostream>\n#include <cassert>\n\ntemplate <class K,class V>\nstruct AVLTreeNode\n{\n\ttypedef AVLTreeNode<K, V> Node;//使用typedef简化代码\n\tNode* _left;                   \n\tNode* _right;\n\tNode* _parent;\n\tstd::pair<K, V> _kv; //节点储存的键值对\n\tint _bf;// ballance factor 平衡因子\n\n\t//构造函数，但不提供无参的默认构造函数\n\tAVLTreeNode(const std::pair<K, V>& kv)\n\t\t:_left(nullptr)\n\t\t, _right(nullptr)\n\t\t, _parent(nullptr)\n\t\t, _kv(kv)\n\t\t, _bf(0)\n\t{}\n};\n```\n\n## 规定AVLTree类的框架\n首先确定成员变量,这里仅用`_root`指向二叉树，具体的维护由`成员函数`完成\n\n代码简化方面，使用\n```C++\ntypedef AVLTreeNode<K, V> Node;\ntypedef std::pair<K,V> PKV;\n```\n简化代码\n\n然后是准备实现的`成员函数`\n\n**公共接口**\n+ `Insert`插入节点\n+ `Inorder`前序遍历打印节点，用于debug\n+ `IsBalance`检测是否平衡\n+ `Height`获取子树高度\n\n**私有接口**\n+ `RotateL`向左旋转子树，用于维护平衡\n+ `RotateR`向右旋转子树，用于维护平衡\n+ `RotateLR`向左再向右旋转子树，用于维护平衡\n+ `RotateRL`向右再向左旋转子树，用于维护平衡\n\n实现AVL树的核心就是实现这四个**旋转操作**,并再在`insert`中回调。所以`Insert`函数我们放到最后再实现\n\n## 默认构造函数\n```C++\ntemplate<class K, class V>\nclass AVLTree\n{\n\ttypedef AVLTreeNode<K, V> Node;\n\ttypedef std::pair<K, V> PKV;\npublic:\n\tAVLTree() :_root(nullptr) {}//默认构造函数\n\nprivate:\n\tNode* _root;\n};\n```\n\n## Inorder函数\n公共的`Inorder`接口为无参函数,内部调用另外定义的`_Inorder`子函数\n\n```C++\npublic:\n\tAVLTree() :_root(nullptr) {}//默认构造函数\n\n\tvoid Inorder()\n\t{\n\t\t_Inorder(_root);\n\t\tstd::cout<<\"nullptr\" << std::endl;\n\t}\n\nprotected:\n\tvoid _Inorder(Node* root)\n\t{\n\t\tif (root == nullptr) return;\n\t\t_Inorder(root->_left);\n\t\tstd::cout << root->_kv.second << \"->\";\n\t\t_Inorder(root->_right);\n\t}\n```\n\n## Height函数\n同上，使用`_Height`子函数\n\n```C++\npublic:\n\tint Height()\n\t{\n\t\treturn _Height(_root);\n\t}\nprivate:\n\tint _Height(Node* root)\n\t{\n\t\tif (root == nullptr) return 0;\n\n\t\tint LHeight = _Height(root->_left);\n\t\tint RHeight = _Height(root->_right);\n\t\tif (LHeight > RHeight) return LHeight + 1;\n\t\telse return RHeight + 1; //将左右子树相等的情况合并在这里\n\t}\n```\n\n## IsBalance函数\n同上，使用`_Balance`子函数\n\n这里要较为严格，**可靠**地地判定平衡,而平衡因子由我们自己维护，作为判定的依据，并**不可靠**，相比之下,计算左右子树的高度差**更可靠**,所以这里回调`_Height`函数\n\n```C++\npublic:\n\tbool IsBalance()\n\t{\n\t\treturn _IsBalance(_root);\n\t}\nprivate:\n\tbool _IsBalance(Node* root)\n\t{\n\t\tif (root == nullptr) return true;\n\t\tbool left = _IsBalance(root->_left);\n\t\tbool right = _IsBalance(root-> - _right);\n\n\t\tif (left == false || right == false) return false;//先判定左右子树\n\n\t\tint LHeight = _Height(root->_left);\n\t\tint RHeight = _Height(root->_right);\n\n\t\tif (LHeight - RHeight >= 2 || LHeight - RHeight <= -2)return false;//最后判定根\n\t\telse return true;\n\t}\n```\n\n## Insert函数\n`Insert`函数主要按步骤实现以下功能\n\n1. `插入节点`:先按照二叉搜索树的规则将节点插入到AVL树中\n2. `维护平衡`:新节点插入后，AVL树的平衡性可能会遭到破坏，此时就需要更新平衡因子，并检测是否破坏了AVL树\n\n### 插入节点\n具体插入方式与`平衡搜索二叉树`基本相同,但是还要额外维护`_parent`指针\n```C++\n\tbool Insert(const PKV& kv)\n\t{\n\t\tCmp cmp;//仿函数实例化一个对象\n\t\tif (_root == nullptr)\n\t\t{\n\t\t\t_root = new Node(kv);\n\t\t\treturn true;\n\t\t}\n\t\tNode* cur = _root;\n\t\tNode* parent = nullptr;\n\t\t//寻找插入位置\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur->_kv.first == kv.first)\n\t\t\t{\n\t\t\t\t//该键下的节点已存在，发生冲突\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (cmp(cur->_kv.first, kv.first))//根比节点\"大\"\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur->_left;\n\t\t\t}\n\t\t\telse //根比节点小\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur->_right;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//开始插入\n\t\tNode* node = new Node(kv);\n\n\t\tif (cmp(parent->_kv.first, kv.first))//应该插入左边\n\t\t{\n\t\t\tparent->_left = node;\n\t\t\tnode->_parent = parent;\n\t\t\tparent->_bf -= 1;//_bf越小，左子树越高\n\t\t}\n\t\telse //插入右子树\n\t\t{\n\t\t\tparent->_right = node;\n\t\t\tnode->_parent = parent;\n\t\t\tparent->_bf += 1;//_bf越大，右子树越高\n\t\t}\n\t\t//插入完成，准备开始维护平衡\n\t\t//.....\n\t\t\n\t}\n```\n### 维护平衡\n插入节点的所有父级子树的高度都有可能受到其影响，所以要**一路向上递归**维护，直至某棵子树的高度不变,或者到达根节点\n\n下面我们一一枚举所有情况,并逐一解决\n\n+ 父节点`_bf == 0`\n  + 右子树高度增加: `_bf = 1`,且父节点高度增加，需继续**向上调整**\n  + 左子树高度增加: `_bf = -1`,且父节点高度增加，需继续**向上调整**\n+ 父节点`_bf == -1`\n  + 右子树高度增加: `_bf = 0`,父节点高度不变，停止调整\n  + 左子树高度增加: `_bf = -2`,平衡被打破,需要**旋转调整**, *下文详细讨论*\n+ 父节点`_bf == 1`\n  + 右子树高度增加: `_bf = 2`,平衡被打破,需要**旋转调整**, *下文详细讨论*\n  + 左子树高度增加: `_bf = 0`,父节点高度不变，停止调整\n\n可以看到，需要调整调整的情况有两大方向，接下来详细介绍调整方法\n\n#### `RotateR `:`_bf == -2`且子树的左子树超高\n\n根据约定，`_bf == -2`表示左子树比右子树高`2`，所以我们要先通过向右旋转操作减少左子树高度\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409021916938.png)\n\n如图所示,通过向右旋转，成功地降低了左子树的高度，而根据`左子树`的平衡因子，又可以分为以下两种情况\n\n+ `-1`:旋转后平衡性得到维护，但整棵树的高度由`h+2`降低到了`h-1`,总高度`-1`,与原本的高度`+1`相抵消,停止调整\n+ `0`:非法情况,不可能左右子树同时超高\n+ `1`:不存在的情况，因为破坏了左子树超高的前提\n\n以上分析可知，一次向右旋转已经可以解决**两种**情况了，所以我们着手实现`RotateR`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RotateR2.gif)\n\n如上图所示，我们要对树里的父子关系作出调整，以此改变高度。\n\n然后除了图中的内容，我们还要维护一系列`_bf`,指针之类的内容\n\n```C++\nprivate:\n\tvoid RotateR(Node* parent)\n\t{\n\t\tif (parent == nullptr) return;\n\t\tNode* child = parent->_left;\n\n\t\t//维护树的结构\n\t\tparent->_left = child->_right;//过继子树的右子树\n\t\tchild->_right = parent;//重构树结构\n\t\tNode* grandParent = parent->_parent;//维护祖父节点\n\t\tchild->_parent = grandParent;//维护child\n\t\tparent->_parent = child;\n\t\tif (grandParent)//如果不是根节点\n\t\t{\n\t\t\t//维护根节点的父节点的子树\n\t\t\tif (parent == grandParent->_left) grandParent->_left = child;\n\t\t\telse grandParent->_right = child;\n\t\t}\n\t\t\n\t\t//维护平衡因子\n\t\tif (child->_bf == -1)\n\t\t{\n\t\t\tchild->_bf = 0;\n\t\t\tparent->_bf = 0;\n\t\t}\n\t\telse if (child->_bf == 0)\n\t\t{\n\t\t\tassert(false);//不存在的情况\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(false);//需要多次旋转时不应该调用该函数\n\t\t}\n\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = child;//更新根节点\n\t\t}\n\t}\n```\n\n#### `RotateL`:`_bf == 2`且子树的右子树超高\n根据约定，`_bf == -2`表示右子树比左子树高`2`，所以我们要先通过向左旋转操作减少右子树高度\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030810533.png)\n\n如图所示,通过向左旋转，成功地降低了右子树的高度，而根据`右子树`的平衡因子，又可以分为以下三种情况\n\n+ `-1`:旋转后平衡性得到维护，但整棵树的高度由`h+2`降低到了`h-1`,总高度`-1`,需继续**向上调整**\n+ `0`:非法情况,不可能左右子树同时超高\n+ `1`:不存在的情况，因为破坏了子树的右子树超高的前提\n\n以上分析可知，一次向左旋转已经可以解决**两种**情况了，所以我们先实现`RotateL`\n和`RotateL`一样，我们要对树里的父子关系作出调整，以此改变高度。\n\n然后除了图中的内容，我们还要维护一系列`_bf`,指针之类的内容\n\n```C++\nprivate:\n\tvoid RotateL(Node* parent)\n\t{\n\t\tif (parent == nullptr) return;\n\t\tNode* child = parent->_right;\n\t\t//维护树结构\n\t\tparent->_right = child->_left;//过继子树\n\t\tchild->_left = parent;//重构树结构\n\t\tNode* grandParent = parent->_parent;//维护祖父节点\n\t\tchild->_parent = grandParent;//维护_parent\n\t\tparent->_parent = child;//维护_parent\n\t\tif (grandParent)//如果不是根节点\n\t\t{\n\t\t\t//维护祖父节点的子树\n\t\t\tif (parent == grandParent->_left) grandParent->_left = child;\n\t\t\telse grandParent->_right = child;\n\t\t}\n\n\t\t//维护平衡因子\n\t\tif (child->_bf == 1)\n\t\t{\n\t\t\tchild->_bf = 0;\n\t\t\tparent->_bf = 0;\n\t\t}\n\t\telse if (child->_bf == 0)\n\t\t{\n\t\t\tassert(false);//不存在的情况\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(false);//需要多次旋转时不应该调用该函数\n\t\t}\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = child;//更新根节点\n\t\t}\n\t}\n```\n#### `RotateRL`:`_bf == -2`且子树的右子树超高\n\n当出现该情况时，单纯的向右旋转并不顶用,效果如下图\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RotateR_err.png)\n\n所以说我们要先调整左子树的平衡因子(左子树向左旋转)，再最后进行向右旋转\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ROtateLR_re.png)\n\n如上图，通过两次旋转，完成了整体的平衡因子的维护\n\n**高度变化**：整棵树的高度由`h+3`变成了`h+2`,高度减少了`1`,与原本的高度`+1`向抵消，停止调整\n\n```C++\nprivate:\n\tvoid RotateLR(Node* parent)\n\t{\n\t\tif (parent == nullptr) return;//错误情况\n\t\tNode* Lchild = parent->_left;\n\t\tif (Lchild == nullptr) return;//错误情况\n\t\tNode* Rchild = Lchild->_right;\n\n\t\t//先旋转左子树\n\n\t\t//维护树结构\n\t\tLchild->_right = Rchild->_left;\n\t\tRchild->_left = Lchild;\n\t\tLchild->_parent = Rchild;\n\t\tparent->_left = Rchild;\n\t\tRchild->_parent = parent;\n\n\t\t//维护_bf\n\t\tif (Lchild->_bf == 1)\n\t\t{\n\t\t\tLchild->_bf = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//_bf == -1 或 0都是非法的\n\t\t\tassert(false);\n\t\t}\n\n\t\t//再向右旋转\n\t\tNode* child = parent->_left;\n\t\t\n\t\t//维护树结构\n\t\tparent->_left = child->_right;\n\t\tchild->_right = parent;\n\n\t\tNode* grandParent = parent->_parent;\n\t\tchild->_parent = grandParent;\n\t\tparent->_parent = child;\n\n\t\tif (grandParent)//不是根节点\n\t\t{\n\t\t\tif (parent == grandParent->_left)grandParent->_left = child;\n\t\t\telse grandParent->_right = child;\n\t\t}\n\n\t\t//维护_bf\n\t\tparent->_bf = -1;\n\t\tchild->_bf = 0;\n\t\t\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = child;//更新根节点\n\t\t}\n\t}\n```\n\n#### `RotateLR`:`bf == 2`且子树的左子树超高\n具体情况与上一个接口相同，一次旋转无法完成任务，需要先向右旋转右子树调节平衡因子,再向左旋转，完成平衡的维护\n\n**高度变化**：整棵树的高度由`h+3`变成了`h+2`,高度减少了`1`\n\n\n```C++\nprivate:\n\tvoid RotateRL(Node* parent)\n\t{\n\t\t//先向右旋转子树\n\t\tNode* Rchild = parent->_right;\n\t\tNode* Lchild = Rchild->_left;\n\n\t\t//维护树结构\n\t\tRchild->_left = Lchild->_right;\n\t\tLchild->_right = Rchild;\n\t\tRchild->_parent = Lchild;\n\t\tLchild->_parent = parent;\n\t\tparent->_right = Lchild;\n\n\t\t//维护_bf\n\t\tif (Rchild->_bf == -1)\n\t\t{\n\t\t\tRchild->_bf = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(false);//非法的情况\n\t\t}\n\n\t\t//再向左旋转\n\t\tNode* child = parent->_right;\n\n\t\tparent->_right = child->_left;//过继左子树\n\t\tchild->_left = parent;\n\t\tparent->_parent = child;\n\t\tNode* grandParent = parent->_parent;\n\t\tchild->_parent = grandParent;\n\t\t\n\t\tif (grandParent)//如果不是根节点\n\t\t{\n\t\t\tif (parent == grandParent->_left)grandParent->_left = child;\n\t\t\telse grandParent->_right = child;\n\t\t}\n\n\t\t//维护_bf\n\t\tparent->_bf = -1;\n\t\tchild->_bf = 0;\n\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = child;//更新根节点\n\t\t}\n\t}\n```\n\n#### 完成Insert中调整二叉树的代码\n\n```C++\npublic:\n\tbool Insert(const PKV& kv)\n\t{\n\t\tCmp cmp;//仿函数实例化一个对象\n\t\tif (_root == nullptr)\n\t\t{\n\t\t\t_root = new Node(kv);\n\t\t\treturn true;\n\t\t}\n\t\tNode* cur = _root;\n\t\tNode* parent = nullptr;\n\t\t//寻找插入位置\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur->_kv.first == kv.first)\n\t\t\t{\n\t\t\t\t//该键下的节点已存在，发生冲突\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (cmp(cur->_kv.first, kv.first))//根比节点\"大\"\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur->_left;\n\t\t\t}\n\t\t\telse //根比节点小\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur->_right;\n\t\t\t}\n\t\t}\n\n\t\t//开始插入\n\t\tNode* node = new Node(kv);\n\t\tif (cmp(parent->_kv.first, kv.first))//应该插入左边\n\t\t{\n\t\t\tparent->_left = node;\n\t\t\tnode->_parent = parent;\n\t\t\tparent->_bf -= 1;//_bf越小，左子树越高\n\t\t}\n\t\telse //插入右子树\n\t\t{\n\t\t\tparent->_right = node;\n\t\t\tnode->_parent = parent;\n\t\t\tparent->_bf += 1;//_bf越大，右子树越高\n\t\t}\n\t\t//插入完成，准备开始维护平衡\n\t\twhile (true)\n\t\t{\n\t\t\tif (parent->_bf == 0)break;\n\t\t\telse if (parent->_bf == 1 || parent->_bf == -1)\n\t\t\t{\n\t\t\t\t//子树高度增加\n\t\t\t\tnode = parent;\n\t\t\t\tparent = parent->_parent;\n\t\t\t\tif (parent == nullptr)break;//走到根节点了\n\t\t\t\tif (node == parent->_left)\n\t\t\t\t{\n\t\t\t\t\tparent->_bf -= 1;\n\t\t\t\t}\n\t\t\t\telse if (node == parent->_right)\n\t\t\t\t{\n\t\t\t\t\tparent->_bf += 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tassert(false);//非法情况\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (parent->_bf == -2)\n\t\t\t{\n\t\t\t\tif (parent->_left->_bf == 0)\n\t\t\t\t{\n\t\t\t\t\tassert(false);//非法情况,不可能左右子树同时超高\n\t\t\t\t}\n\t\t\t\telse if (parent->_left->_bf == -1)\n\t\t\t\t{\n\t\t\t\t\t//子树的左子树超高\n\t\t\t\t\tRotateR(parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (parent->_left->_bf == 1)\n\t\t\t\t{\n\t\t\t\t\t//子树的右子树超高\n\t\t\t\t\tRotateLR(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (parent->_bf == 2)\n\t\t\t{\n\t\t\t\tif (parent->_right->_bf == 0)\n\t\t\t\t{\n\t\t\t\t\tassert(false);//非法情况,不可能左右子树同时超高\n\t\t\t\t}\n\t\t\t\telse if (parent->_right->_bf == 1)\n\t\t\t\t{\n\t\t\t\t\t//子树的右子树超高\n\t\t\t\t\tRotateL(parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (parent->_right->_bf == -1)\n\t\t\t\t{\n\t\t\t\t\t//子树的左子树超高\n\t\t\t\t\tRotateRL(parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(false);//非法情况\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n```\n\n# 测试\n我们来写个简单的`main`函数测试一下我们封装的`AVL树`\n\n> main.cpp\n```C++\n#include \"AVLTree.hpp\"\n#include <iostream>\nusing namespace std;\nint main()\n{\n\tAVLTree<int,int> avt;//实例化一个对象\n\tfor (int i = 0; i < 100; ++i)//准备100个数据\n\t{\n\t\tavt.Insert({ i,i });//插入数据\n\t}\n\tcout <<\"Height \" << avt.Height() << endl;   //检查高度\n\tcout << \"IsBalance \" << avt.IsBalance() << endl; //检测平衡\n\tavt.Inorder();//检测搜索树的特性\n\treturn 0;\n}\n```\n我们来看看结果\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030818252.png)\n\n可以看到,`100`个数据下，而且还是按顺序插入，`AVL树`的高度只有`7`，很好得提高了搜索效率\n\n# AVL树的性能\nAVL树是一棵绝**对平衡的二叉搜索树**，其要求每个节点的左右子树高度差的绝对值都不超过1，这样可以保证查询时高效的时间复杂度，即$log_2 (N)$。但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，**但一个结构经常修改，就不太适合。**\n\n# 改造成 红黑树\n目前的`AVL树`只是实现了最基本的功能，增删查改只支持了`增`,剩下的内容可自行完善，或者跟随作者的脚步，将`AVL树`改成`红黑树`,增加其修改的性能,并进一步完善增删查改的功能，以及封装`迭代器`等，最后将`红黑树`封装成我们自己的`set`类和`map`类\n\n[戳我前往红黑树篇🔗](https://www.supdriver.top/2024/09/03/RBTree/)","source":"_posts/AVLTree.md","raw":"---\ntitle: 手撕AVL树\ndate: 2024-08-12 10:55:47\ntags:\n---\n# AVL树的概念\n\n## 二叉搜索树的不足\n二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将**退化**为`单支树`，查找元素相当于在顺序表中搜索元素，效率低下。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/lajibstree2.png)\n\n## AVL树的提出\n\n两位俄罗斯的数学家*G.M.Adelson-Velskii*和*E.M.Landis*在1962年发明了一种解决上述问题的方法：\n**当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)**,即构建一颗`绝对的平衡搜索二叉树`，即可降低树的高度，从而减少平均搜索长度。\n\n**定义**: 一棵AVL树或者是空树，或者是具有以下性质的二`叉搜索树`：\n+ 它的左右子树都是AVL树\n+ 左右子树高度之差(简称`平衡因子`)的绝对值不超过1(-1/0/1)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/aaaAVL80.png)\n\n如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在`O(log_2 n)`,搜索的时间复杂度`O(log_2 n)`\n\n# 封装AVL树\n\n## 头文件\n```C++\n#include <utility>\n#include <cassert>\n```\n\n## 封装AVL树的节点\n+ 这里采用`键值(KV)`类型的二叉树节点,使其泛用性更高\n+ 并增加指向父节点的指针构造三叉链表，来**简化**对二叉树的调整，但代价是**维护成本**变高(多了一个指针要维护)。\n+ 引入`平衡因子`:\n  + `-1`表示左子树比右子树高`1`层  *左>右*\n  + `0`表示左右子树等高           *左=右*\n  + `1`表示右子树比左子树高`1`层   *左<右*\n\n```C++\n#include <utility>\n#include <iostream>\n#include <cassert>\n\ntemplate <class K,class V>\nstruct AVLTreeNode\n{\n\ttypedef AVLTreeNode<K, V> Node;//使用typedef简化代码\n\tNode* _left;                   \n\tNode* _right;\n\tNode* _parent;\n\tstd::pair<K, V> _kv; //节点储存的键值对\n\tint _bf;// ballance factor 平衡因子\n\n\t//构造函数，但不提供无参的默认构造函数\n\tAVLTreeNode(const std::pair<K, V>& kv)\n\t\t:_left(nullptr)\n\t\t, _right(nullptr)\n\t\t, _parent(nullptr)\n\t\t, _kv(kv)\n\t\t, _bf(0)\n\t{}\n};\n```\n\n## 规定AVLTree类的框架\n首先确定成员变量,这里仅用`_root`指向二叉树，具体的维护由`成员函数`完成\n\n代码简化方面，使用\n```C++\ntypedef AVLTreeNode<K, V> Node;\ntypedef std::pair<K,V> PKV;\n```\n简化代码\n\n然后是准备实现的`成员函数`\n\n**公共接口**\n+ `Insert`插入节点\n+ `Inorder`前序遍历打印节点，用于debug\n+ `IsBalance`检测是否平衡\n+ `Height`获取子树高度\n\n**私有接口**\n+ `RotateL`向左旋转子树，用于维护平衡\n+ `RotateR`向右旋转子树，用于维护平衡\n+ `RotateLR`向左再向右旋转子树，用于维护平衡\n+ `RotateRL`向右再向左旋转子树，用于维护平衡\n\n实现AVL树的核心就是实现这四个**旋转操作**,并再在`insert`中回调。所以`Insert`函数我们放到最后再实现\n\n## 默认构造函数\n```C++\ntemplate<class K, class V>\nclass AVLTree\n{\n\ttypedef AVLTreeNode<K, V> Node;\n\ttypedef std::pair<K, V> PKV;\npublic:\n\tAVLTree() :_root(nullptr) {}//默认构造函数\n\nprivate:\n\tNode* _root;\n};\n```\n\n## Inorder函数\n公共的`Inorder`接口为无参函数,内部调用另外定义的`_Inorder`子函数\n\n```C++\npublic:\n\tAVLTree() :_root(nullptr) {}//默认构造函数\n\n\tvoid Inorder()\n\t{\n\t\t_Inorder(_root);\n\t\tstd::cout<<\"nullptr\" << std::endl;\n\t}\n\nprotected:\n\tvoid _Inorder(Node* root)\n\t{\n\t\tif (root == nullptr) return;\n\t\t_Inorder(root->_left);\n\t\tstd::cout << root->_kv.second << \"->\";\n\t\t_Inorder(root->_right);\n\t}\n```\n\n## Height函数\n同上，使用`_Height`子函数\n\n```C++\npublic:\n\tint Height()\n\t{\n\t\treturn _Height(_root);\n\t}\nprivate:\n\tint _Height(Node* root)\n\t{\n\t\tif (root == nullptr) return 0;\n\n\t\tint LHeight = _Height(root->_left);\n\t\tint RHeight = _Height(root->_right);\n\t\tif (LHeight > RHeight) return LHeight + 1;\n\t\telse return RHeight + 1; //将左右子树相等的情况合并在这里\n\t}\n```\n\n## IsBalance函数\n同上，使用`_Balance`子函数\n\n这里要较为严格，**可靠**地地判定平衡,而平衡因子由我们自己维护，作为判定的依据，并**不可靠**，相比之下,计算左右子树的高度差**更可靠**,所以这里回调`_Height`函数\n\n```C++\npublic:\n\tbool IsBalance()\n\t{\n\t\treturn _IsBalance(_root);\n\t}\nprivate:\n\tbool _IsBalance(Node* root)\n\t{\n\t\tif (root == nullptr) return true;\n\t\tbool left = _IsBalance(root->_left);\n\t\tbool right = _IsBalance(root-> - _right);\n\n\t\tif (left == false || right == false) return false;//先判定左右子树\n\n\t\tint LHeight = _Height(root->_left);\n\t\tint RHeight = _Height(root->_right);\n\n\t\tif (LHeight - RHeight >= 2 || LHeight - RHeight <= -2)return false;//最后判定根\n\t\telse return true;\n\t}\n```\n\n## Insert函数\n`Insert`函数主要按步骤实现以下功能\n\n1. `插入节点`:先按照二叉搜索树的规则将节点插入到AVL树中\n2. `维护平衡`:新节点插入后，AVL树的平衡性可能会遭到破坏，此时就需要更新平衡因子，并检测是否破坏了AVL树\n\n### 插入节点\n具体插入方式与`平衡搜索二叉树`基本相同,但是还要额外维护`_parent`指针\n```C++\n\tbool Insert(const PKV& kv)\n\t{\n\t\tCmp cmp;//仿函数实例化一个对象\n\t\tif (_root == nullptr)\n\t\t{\n\t\t\t_root = new Node(kv);\n\t\t\treturn true;\n\t\t}\n\t\tNode* cur = _root;\n\t\tNode* parent = nullptr;\n\t\t//寻找插入位置\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur->_kv.first == kv.first)\n\t\t\t{\n\t\t\t\t//该键下的节点已存在，发生冲突\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (cmp(cur->_kv.first, kv.first))//根比节点\"大\"\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur->_left;\n\t\t\t}\n\t\t\telse //根比节点小\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur->_right;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//开始插入\n\t\tNode* node = new Node(kv);\n\n\t\tif (cmp(parent->_kv.first, kv.first))//应该插入左边\n\t\t{\n\t\t\tparent->_left = node;\n\t\t\tnode->_parent = parent;\n\t\t\tparent->_bf -= 1;//_bf越小，左子树越高\n\t\t}\n\t\telse //插入右子树\n\t\t{\n\t\t\tparent->_right = node;\n\t\t\tnode->_parent = parent;\n\t\t\tparent->_bf += 1;//_bf越大，右子树越高\n\t\t}\n\t\t//插入完成，准备开始维护平衡\n\t\t//.....\n\t\t\n\t}\n```\n### 维护平衡\n插入节点的所有父级子树的高度都有可能受到其影响，所以要**一路向上递归**维护，直至某棵子树的高度不变,或者到达根节点\n\n下面我们一一枚举所有情况,并逐一解决\n\n+ 父节点`_bf == 0`\n  + 右子树高度增加: `_bf = 1`,且父节点高度增加，需继续**向上调整**\n  + 左子树高度增加: `_bf = -1`,且父节点高度增加，需继续**向上调整**\n+ 父节点`_bf == -1`\n  + 右子树高度增加: `_bf = 0`,父节点高度不变，停止调整\n  + 左子树高度增加: `_bf = -2`,平衡被打破,需要**旋转调整**, *下文详细讨论*\n+ 父节点`_bf == 1`\n  + 右子树高度增加: `_bf = 2`,平衡被打破,需要**旋转调整**, *下文详细讨论*\n  + 左子树高度增加: `_bf = 0`,父节点高度不变，停止调整\n\n可以看到，需要调整调整的情况有两大方向，接下来详细介绍调整方法\n\n#### `RotateR `:`_bf == -2`且子树的左子树超高\n\n根据约定，`_bf == -2`表示左子树比右子树高`2`，所以我们要先通过向右旋转操作减少左子树高度\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409021916938.png)\n\n如图所示,通过向右旋转，成功地降低了左子树的高度，而根据`左子树`的平衡因子，又可以分为以下两种情况\n\n+ `-1`:旋转后平衡性得到维护，但整棵树的高度由`h+2`降低到了`h-1`,总高度`-1`,与原本的高度`+1`相抵消,停止调整\n+ `0`:非法情况,不可能左右子树同时超高\n+ `1`:不存在的情况，因为破坏了左子树超高的前提\n\n以上分析可知，一次向右旋转已经可以解决**两种**情况了，所以我们着手实现`RotateR`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RotateR2.gif)\n\n如上图所示，我们要对树里的父子关系作出调整，以此改变高度。\n\n然后除了图中的内容，我们还要维护一系列`_bf`,指针之类的内容\n\n```C++\nprivate:\n\tvoid RotateR(Node* parent)\n\t{\n\t\tif (parent == nullptr) return;\n\t\tNode* child = parent->_left;\n\n\t\t//维护树的结构\n\t\tparent->_left = child->_right;//过继子树的右子树\n\t\tchild->_right = parent;//重构树结构\n\t\tNode* grandParent = parent->_parent;//维护祖父节点\n\t\tchild->_parent = grandParent;//维护child\n\t\tparent->_parent = child;\n\t\tif (grandParent)//如果不是根节点\n\t\t{\n\t\t\t//维护根节点的父节点的子树\n\t\t\tif (parent == grandParent->_left) grandParent->_left = child;\n\t\t\telse grandParent->_right = child;\n\t\t}\n\t\t\n\t\t//维护平衡因子\n\t\tif (child->_bf == -1)\n\t\t{\n\t\t\tchild->_bf = 0;\n\t\t\tparent->_bf = 0;\n\t\t}\n\t\telse if (child->_bf == 0)\n\t\t{\n\t\t\tassert(false);//不存在的情况\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(false);//需要多次旋转时不应该调用该函数\n\t\t}\n\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = child;//更新根节点\n\t\t}\n\t}\n```\n\n#### `RotateL`:`_bf == 2`且子树的右子树超高\n根据约定，`_bf == -2`表示右子树比左子树高`2`，所以我们要先通过向左旋转操作减少右子树高度\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030810533.png)\n\n如图所示,通过向左旋转，成功地降低了右子树的高度，而根据`右子树`的平衡因子，又可以分为以下三种情况\n\n+ `-1`:旋转后平衡性得到维护，但整棵树的高度由`h+2`降低到了`h-1`,总高度`-1`,需继续**向上调整**\n+ `0`:非法情况,不可能左右子树同时超高\n+ `1`:不存在的情况，因为破坏了子树的右子树超高的前提\n\n以上分析可知，一次向左旋转已经可以解决**两种**情况了，所以我们先实现`RotateL`\n和`RotateL`一样，我们要对树里的父子关系作出调整，以此改变高度。\n\n然后除了图中的内容，我们还要维护一系列`_bf`,指针之类的内容\n\n```C++\nprivate:\n\tvoid RotateL(Node* parent)\n\t{\n\t\tif (parent == nullptr) return;\n\t\tNode* child = parent->_right;\n\t\t//维护树结构\n\t\tparent->_right = child->_left;//过继子树\n\t\tchild->_left = parent;//重构树结构\n\t\tNode* grandParent = parent->_parent;//维护祖父节点\n\t\tchild->_parent = grandParent;//维护_parent\n\t\tparent->_parent = child;//维护_parent\n\t\tif (grandParent)//如果不是根节点\n\t\t{\n\t\t\t//维护祖父节点的子树\n\t\t\tif (parent == grandParent->_left) grandParent->_left = child;\n\t\t\telse grandParent->_right = child;\n\t\t}\n\n\t\t//维护平衡因子\n\t\tif (child->_bf == 1)\n\t\t{\n\t\t\tchild->_bf = 0;\n\t\t\tparent->_bf = 0;\n\t\t}\n\t\telse if (child->_bf == 0)\n\t\t{\n\t\t\tassert(false);//不存在的情况\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(false);//需要多次旋转时不应该调用该函数\n\t\t}\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = child;//更新根节点\n\t\t}\n\t}\n```\n#### `RotateRL`:`_bf == -2`且子树的右子树超高\n\n当出现该情况时，单纯的向右旋转并不顶用,效果如下图\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RotateR_err.png)\n\n所以说我们要先调整左子树的平衡因子(左子树向左旋转)，再最后进行向右旋转\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ROtateLR_re.png)\n\n如上图，通过两次旋转，完成了整体的平衡因子的维护\n\n**高度变化**：整棵树的高度由`h+3`变成了`h+2`,高度减少了`1`,与原本的高度`+1`向抵消，停止调整\n\n```C++\nprivate:\n\tvoid RotateLR(Node* parent)\n\t{\n\t\tif (parent == nullptr) return;//错误情况\n\t\tNode* Lchild = parent->_left;\n\t\tif (Lchild == nullptr) return;//错误情况\n\t\tNode* Rchild = Lchild->_right;\n\n\t\t//先旋转左子树\n\n\t\t//维护树结构\n\t\tLchild->_right = Rchild->_left;\n\t\tRchild->_left = Lchild;\n\t\tLchild->_parent = Rchild;\n\t\tparent->_left = Rchild;\n\t\tRchild->_parent = parent;\n\n\t\t//维护_bf\n\t\tif (Lchild->_bf == 1)\n\t\t{\n\t\t\tLchild->_bf = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//_bf == -1 或 0都是非法的\n\t\t\tassert(false);\n\t\t}\n\n\t\t//再向右旋转\n\t\tNode* child = parent->_left;\n\t\t\n\t\t//维护树结构\n\t\tparent->_left = child->_right;\n\t\tchild->_right = parent;\n\n\t\tNode* grandParent = parent->_parent;\n\t\tchild->_parent = grandParent;\n\t\tparent->_parent = child;\n\n\t\tif (grandParent)//不是根节点\n\t\t{\n\t\t\tif (parent == grandParent->_left)grandParent->_left = child;\n\t\t\telse grandParent->_right = child;\n\t\t}\n\n\t\t//维护_bf\n\t\tparent->_bf = -1;\n\t\tchild->_bf = 0;\n\t\t\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = child;//更新根节点\n\t\t}\n\t}\n```\n\n#### `RotateLR`:`bf == 2`且子树的左子树超高\n具体情况与上一个接口相同，一次旋转无法完成任务，需要先向右旋转右子树调节平衡因子,再向左旋转，完成平衡的维护\n\n**高度变化**：整棵树的高度由`h+3`变成了`h+2`,高度减少了`1`\n\n\n```C++\nprivate:\n\tvoid RotateRL(Node* parent)\n\t{\n\t\t//先向右旋转子树\n\t\tNode* Rchild = parent->_right;\n\t\tNode* Lchild = Rchild->_left;\n\n\t\t//维护树结构\n\t\tRchild->_left = Lchild->_right;\n\t\tLchild->_right = Rchild;\n\t\tRchild->_parent = Lchild;\n\t\tLchild->_parent = parent;\n\t\tparent->_right = Lchild;\n\n\t\t//维护_bf\n\t\tif (Rchild->_bf == -1)\n\t\t{\n\t\t\tRchild->_bf = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(false);//非法的情况\n\t\t}\n\n\t\t//再向左旋转\n\t\tNode* child = parent->_right;\n\n\t\tparent->_right = child->_left;//过继左子树\n\t\tchild->_left = parent;\n\t\tparent->_parent = child;\n\t\tNode* grandParent = parent->_parent;\n\t\tchild->_parent = grandParent;\n\t\t\n\t\tif (grandParent)//如果不是根节点\n\t\t{\n\t\t\tif (parent == grandParent->_left)grandParent->_left = child;\n\t\t\telse grandParent->_right = child;\n\t\t}\n\n\t\t//维护_bf\n\t\tparent->_bf = -1;\n\t\tchild->_bf = 0;\n\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = child;//更新根节点\n\t\t}\n\t}\n```\n\n#### 完成Insert中调整二叉树的代码\n\n```C++\npublic:\n\tbool Insert(const PKV& kv)\n\t{\n\t\tCmp cmp;//仿函数实例化一个对象\n\t\tif (_root == nullptr)\n\t\t{\n\t\t\t_root = new Node(kv);\n\t\t\treturn true;\n\t\t}\n\t\tNode* cur = _root;\n\t\tNode* parent = nullptr;\n\t\t//寻找插入位置\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur->_kv.first == kv.first)\n\t\t\t{\n\t\t\t\t//该键下的节点已存在，发生冲突\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (cmp(cur->_kv.first, kv.first))//根比节点\"大\"\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur->_left;\n\t\t\t}\n\t\t\telse //根比节点小\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur->_right;\n\t\t\t}\n\t\t}\n\n\t\t//开始插入\n\t\tNode* node = new Node(kv);\n\t\tif (cmp(parent->_kv.first, kv.first))//应该插入左边\n\t\t{\n\t\t\tparent->_left = node;\n\t\t\tnode->_parent = parent;\n\t\t\tparent->_bf -= 1;//_bf越小，左子树越高\n\t\t}\n\t\telse //插入右子树\n\t\t{\n\t\t\tparent->_right = node;\n\t\t\tnode->_parent = parent;\n\t\t\tparent->_bf += 1;//_bf越大，右子树越高\n\t\t}\n\t\t//插入完成，准备开始维护平衡\n\t\twhile (true)\n\t\t{\n\t\t\tif (parent->_bf == 0)break;\n\t\t\telse if (parent->_bf == 1 || parent->_bf == -1)\n\t\t\t{\n\t\t\t\t//子树高度增加\n\t\t\t\tnode = parent;\n\t\t\t\tparent = parent->_parent;\n\t\t\t\tif (parent == nullptr)break;//走到根节点了\n\t\t\t\tif (node == parent->_left)\n\t\t\t\t{\n\t\t\t\t\tparent->_bf -= 1;\n\t\t\t\t}\n\t\t\t\telse if (node == parent->_right)\n\t\t\t\t{\n\t\t\t\t\tparent->_bf += 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tassert(false);//非法情况\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (parent->_bf == -2)\n\t\t\t{\n\t\t\t\tif (parent->_left->_bf == 0)\n\t\t\t\t{\n\t\t\t\t\tassert(false);//非法情况,不可能左右子树同时超高\n\t\t\t\t}\n\t\t\t\telse if (parent->_left->_bf == -1)\n\t\t\t\t{\n\t\t\t\t\t//子树的左子树超高\n\t\t\t\t\tRotateR(parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (parent->_left->_bf == 1)\n\t\t\t\t{\n\t\t\t\t\t//子树的右子树超高\n\t\t\t\t\tRotateLR(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (parent->_bf == 2)\n\t\t\t{\n\t\t\t\tif (parent->_right->_bf == 0)\n\t\t\t\t{\n\t\t\t\t\tassert(false);//非法情况,不可能左右子树同时超高\n\t\t\t\t}\n\t\t\t\telse if (parent->_right->_bf == 1)\n\t\t\t\t{\n\t\t\t\t\t//子树的右子树超高\n\t\t\t\t\tRotateL(parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (parent->_right->_bf == -1)\n\t\t\t\t{\n\t\t\t\t\t//子树的左子树超高\n\t\t\t\t\tRotateRL(parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(false);//非法情况\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n```\n\n# 测试\n我们来写个简单的`main`函数测试一下我们封装的`AVL树`\n\n> main.cpp\n```C++\n#include \"AVLTree.hpp\"\n#include <iostream>\nusing namespace std;\nint main()\n{\n\tAVLTree<int,int> avt;//实例化一个对象\n\tfor (int i = 0; i < 100; ++i)//准备100个数据\n\t{\n\t\tavt.Insert({ i,i });//插入数据\n\t}\n\tcout <<\"Height \" << avt.Height() << endl;   //检查高度\n\tcout << \"IsBalance \" << avt.IsBalance() << endl; //检测平衡\n\tavt.Inorder();//检测搜索树的特性\n\treturn 0;\n}\n```\n我们来看看结果\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030818252.png)\n\n可以看到,`100`个数据下，而且还是按顺序插入，`AVL树`的高度只有`7`，很好得提高了搜索效率\n\n# AVL树的性能\nAVL树是一棵绝**对平衡的二叉搜索树**，其要求每个节点的左右子树高度差的绝对值都不超过1，这样可以保证查询时高效的时间复杂度，即$log_2 (N)$。但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，**但一个结构经常修改，就不太适合。**\n\n# 改造成 红黑树\n目前的`AVL树`只是实现了最基本的功能，增删查改只支持了`增`,剩下的内容可自行完善，或者跟随作者的脚步，将`AVL树`改成`红黑树`,增加其修改的性能,并进一步完善增删查改的功能，以及封装`迭代器`等，最后将`红黑树`封装成我们自己的`set`类和`map`类\n\n[戳我前往红黑树篇🔗](https://www.supdriver.top/2024/09/03/RBTree/)","slug":"AVLTree","published":1,"updated":"2024-09-05T00:26:54.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08000034sp53rp32ak8","content":"<h1 id=\"AVL树的概念\"><a href=\"#AVL树的概念\" class=\"headerlink\" title=\"AVL树的概念\"></a>AVL树的概念</h1><h2 id=\"二叉搜索树的不足\"><a href=\"#二叉搜索树的不足\" class=\"headerlink\" title=\"二叉搜索树的不足\"></a>二叉搜索树的不足</h2><p>二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将<strong>退化</strong>为<code>单支树</code>，查找元素相当于在顺序表中搜索元素，效率低下。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/lajibstree2.png\"></p>\n<h2 id=\"AVL树的提出\"><a href=\"#AVL树的提出\" class=\"headerlink\" title=\"AVL树的提出\"></a>AVL树的提出</h2><p>两位俄罗斯的数学家<em>G.M.Adelson-Velskii</em>和<em>E.M.Landis</em>在1962年发明了一种解决上述问题的方法：<br><strong>当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)</strong>,即构建一颗<code>绝对的平衡搜索二叉树</code>，即可降低树的高度，从而减少平均搜索长度。</p>\n<p><strong>定义</strong>: 一棵AVL树或者是空树，或者是具有以下性质的二<code>叉搜索树</code>：</p>\n<ul>\n<li>它的左右子树都是AVL树</li>\n<li>左右子树高度之差(简称<code>平衡因子</code>)的绝对值不超过1(-1&#x2F;0&#x2F;1)</li>\n</ul>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/aaaAVL80.png\"></p>\n<p>如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在<code>O(log_2 n)</code>,搜索的时间复杂度<code>O(log_2 n)</code></p>\n<h1 id=\"封装AVL树\"><a href=\"#封装AVL树\" class=\"headerlink\" title=\"封装AVL树\"></a>封装AVL树</h1><h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cassert&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"封装AVL树的节点\"><a href=\"#封装AVL树的节点\" class=\"headerlink\" title=\"封装AVL树的节点\"></a>封装AVL树的节点</h2><ul>\n<li>这里采用<code>键值(KV)</code>类型的二叉树节点,使其泛用性更高</li>\n<li>并增加指向父节点的指针构造三叉链表，来<strong>简化</strong>对二叉树的调整，但代价是<strong>维护成本</strong>变高(多了一个指针要维护)。</li>\n<li>引入<code>平衡因子</code>:<ul>\n<li><code>-1</code>表示左子树比右子树高<code>1</code>层  <em>左&gt;右</em></li>\n<li><code>0</code>表示左右子树等高           <em>左&#x3D;右</em></li>\n<li><code>1</code>表示右子树比左子树高<code>1</code>层   <em>左&lt;右</em></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">AVLTreeNode</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> AVLTreeNode&lt;K, V&gt; Node;<span class=\"comment\">//使用typedef简化代码</span></span><br><span class=\"line\">\tNode* _left;                   </span><br><span class=\"line\">\tNode* _right;</span><br><span class=\"line\">\tNode* _parent;</span><br><span class=\"line\">\tstd::pair&lt;K, V&gt; _kv; <span class=\"comment\">//节点储存的键值对</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> _bf;<span class=\"comment\">// ballance factor 平衡因子</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//构造函数，但不提供无参的默认构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">AVLTreeNode</span>(<span class=\"type\">const</span> std::pair&lt;K, V&gt;&amp; kv)</span><br><span class=\"line\">\t\t:_left(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t, _right(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t, _parent(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t, _kv(kv)</span><br><span class=\"line\">\t\t, _bf(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"规定AVLTree类的框架\"><a href=\"#规定AVLTree类的框架\" class=\"headerlink\" title=\"规定AVLTree类的框架\"></a>规定AVLTree类的框架</h2><p>首先确定成员变量,这里仅用<code>_root</code>指向二叉树，具体的维护由<code>成员函数</code>完成</p>\n<p>代码简化方面，使用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> AVLTreeNode&lt;K, V&gt; Node;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> std::pair&lt;K,V&gt; PKV;</span><br></pre></td></tr></table></figure>\n<p>简化代码</p>\n<p>然后是准备实现的<code>成员函数</code></p>\n<p><strong>公共接口</strong></p>\n<ul>\n<li><code>Insert</code>插入节点</li>\n<li><code>Inorder</code>前序遍历打印节点，用于debug</li>\n<li><code>IsBalance</code>检测是否平衡</li>\n<li><code>Height</code>获取子树高度</li>\n</ul>\n<p><strong>私有接口</strong></p>\n<ul>\n<li><code>RotateL</code>向左旋转子树，用于维护平衡</li>\n<li><code>RotateR</code>向右旋转子树，用于维护平衡</li>\n<li><code>RotateLR</code>向左再向右旋转子树，用于维护平衡</li>\n<li><code>RotateRL</code>向右再向左旋转子树，用于维护平衡</li>\n</ul>\n<p>实现AVL树的核心就是实现这四个<strong>旋转操作</strong>,并再在<code>insert</code>中回调。所以<code>Insert</code>函数我们放到最后再实现</p>\n<h2 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AVLTree</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> AVLTreeNode&lt;K, V&gt; Node;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> std::pair&lt;K, V&gt; PKV;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">AVLTree</span>() :_root(<span class=\"literal\">nullptr</span>) &#123;&#125;<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode* _root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Inorder函数\"><a href=\"#Inorder函数\" class=\"headerlink\" title=\"Inorder函数\"></a>Inorder函数</h2><p>公共的<code>Inorder</code>接口为无参函数,内部调用另外定义的<code>_Inorder</code>子函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">AVLTree</span>() :_root(<span class=\"literal\">nullptr</span>) &#123;&#125;<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Inorder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t_Inorder(_root);</span><br><span class=\"line\">\t\tstd::cout&lt;&lt;<span class=\"string\">&quot;nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">void</span> _Inorder(Node* root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t_Inorder(root-&gt;_left);</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; root-&gt;_kv.second &lt;&lt; <span class=\"string\">&quot;-&gt;&quot;</span>;</span><br><span class=\"line\">\t\t_Inorder(root-&gt;_right);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Height函数\"><a href=\"#Height函数\" class=\"headerlink\" title=\"Height函数\"></a>Height函数</h2><p>同上，使用<code>_Height</code>子函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Height</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _Height(_root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _Height(Node* root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> LHeight = _Height(root-&gt;_left);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> RHeight = _Height(root-&gt;_right);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (LHeight &gt; RHeight) <span class=\"keyword\">return</span> LHeight + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> RHeight + <span class=\"number\">1</span>; <span class=\"comment\">//将左右子树相等的情况合并在这里</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IsBalance函数\"><a href=\"#IsBalance函数\" class=\"headerlink\" title=\"IsBalance函数\"></a>IsBalance函数</h2><p>同上，使用<code>_Balance</code>子函数</p>\n<p>这里要较为严格，<strong>可靠</strong>地地判定平衡,而平衡因子由我们自己维护，作为判定的依据，并<strong>不可靠</strong>，相比之下,计算左右子树的高度差<strong>更可靠</strong>,所以这里回调<code>_Height</code>函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">IsBalance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _IsBalance(_root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">bool</span> _IsBalance(Node* root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> left = _IsBalance(root-&gt;_left);</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> right = _IsBalance(root-&gt; - _right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (left == <span class=\"literal\">false</span> || right == <span class=\"literal\">false</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//先判定左右子树</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> LHeight = _Height(root-&gt;_left);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> RHeight = _Height(root-&gt;_right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (LHeight - RHeight &gt;= <span class=\"number\">2</span> || LHeight - RHeight &lt;= <span class=\"number\">-2</span>)<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//最后判定根</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Insert函数\"><a href=\"#Insert函数\" class=\"headerlink\" title=\"Insert函数\"></a>Insert函数</h2><p><code>Insert</code>函数主要按步骤实现以下功能</p>\n<ol>\n<li><code>插入节点</code>:先按照二叉搜索树的规则将节点插入到AVL树中</li>\n<li><code>维护平衡</code>:新节点插入后，AVL树的平衡性可能会遭到破坏，此时就需要更新平衡因子，并检测是否破坏了AVL树</li>\n</ol>\n<h3 id=\"插入节点\"><a href=\"#插入节点\" class=\"headerlink\" title=\"插入节点\"></a>插入节点</h3><p>具体插入方式与<code>平衡搜索二叉树</code>基本相同,但是还要额外维护<code>_parent</code>指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"type\">const</span> PKV&amp; kv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tCmp cmp;<span class=\"comment\">//仿函数实例化一个对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(kv);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode* cur = _root;</span><br><span class=\"line\">\tNode* parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//寻找插入位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur-&gt;_kv.first == kv.first)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//该键下的节点已存在，发生冲突</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">cmp</span>(cur-&gt;_kv.first, kv.first))<span class=\"comment\">//根比节点&quot;大&quot;</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\tcur = cur-&gt;_left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"comment\">//根比节点小</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\tcur = cur-&gt;_right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//开始插入</span></span><br><span class=\"line\">\tNode* node = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(kv);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">cmp</span>(parent-&gt;_kv.first, kv.first))<span class=\"comment\">//应该插入左边</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tparent-&gt;_left = node;</span><br><span class=\"line\">\t\tnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\tparent-&gt;_bf -= <span class=\"number\">1</span>;<span class=\"comment\">//_bf越小，左子树越高</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"comment\">//插入右子树</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tparent-&gt;_right = node;</span><br><span class=\"line\">\t\tnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\tparent-&gt;_bf += <span class=\"number\">1</span>;<span class=\"comment\">//_bf越大，右子树越高</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//插入完成，准备开始维护平衡</span></span><br><span class=\"line\">\t<span class=\"comment\">//.....</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"维护平衡\"><a href=\"#维护平衡\" class=\"headerlink\" title=\"维护平衡\"></a>维护平衡</h3><p>插入节点的所有父级子树的高度都有可能受到其影响，所以要<strong>一路向上递归</strong>维护，直至某棵子树的高度不变,或者到达根节点</p>\n<p>下面我们一一枚举所有情况,并逐一解决</p>\n<ul>\n<li>父节点<code>_bf == 0</code><ul>\n<li>右子树高度增加: <code>_bf = 1</code>,且父节点高度增加，需继续<strong>向上调整</strong></li>\n<li>左子树高度增加: <code>_bf = -1</code>,且父节点高度增加，需继续<strong>向上调整</strong></li>\n</ul>\n</li>\n<li>父节点<code>_bf == -1</code><ul>\n<li>右子树高度增加: <code>_bf = 0</code>,父节点高度不变，停止调整</li>\n<li>左子树高度增加: <code>_bf = -2</code>,平衡被打破,需要<strong>旋转调整</strong>, <em>下文详细讨论</em></li>\n</ul>\n</li>\n<li>父节点<code>_bf == 1</code><ul>\n<li>右子树高度增加: <code>_bf = 2</code>,平衡被打破,需要<strong>旋转调整</strong>, <em>下文详细讨论</em></li>\n<li>左子树高度增加: <code>_bf = 0</code>,父节点高度不变，停止调整</li>\n</ul>\n</li>\n</ul>\n<p>可以看到，需要调整调整的情况有两大方向，接下来详细介绍调整方法</p>\n<h4 id=\"RotateR-bf-2且子树的左子树超高\"><a href=\"#RotateR-bf-2且子树的左子树超高\" class=\"headerlink\" title=\"RotateR :_bf == -2且子树的左子树超高\"></a><code>RotateR </code>:<code>_bf == -2</code>且子树的左子树超高</h4><p>根据约定，<code>_bf == -2</code>表示左子树比右子树高<code>2</code>，所以我们要先通过向右旋转操作减少左子树高度</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409021916938.png\"></p>\n<p>如图所示,通过向右旋转，成功地降低了左子树的高度，而根据<code>左子树</code>的平衡因子，又可以分为以下两种情况</p>\n<ul>\n<li><code>-1</code>:旋转后平衡性得到维护，但整棵树的高度由<code>h+2</code>降低到了<code>h-1</code>,总高度<code>-1</code>,与原本的高度<code>+1</code>相抵消,停止调整</li>\n<li><code>0</code>:非法情况,不可能左右子树同时超高</li>\n<li><code>1</code>:不存在的情况，因为破坏了左子树超高的前提</li>\n</ul>\n<p>以上分析可知，一次向右旋转已经可以解决<strong>两种</strong>情况了，所以我们着手实现<code>RotateR</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RotateR2.gif\"></p>\n<p>如上图所示，我们要对树里的父子关系作出调整，以此改变高度。</p>\n<p>然后除了图中的内容，我们还要维护一系列<code>_bf</code>,指针之类的内容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateR</span><span class=\"params\">(Node* parent)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\tNode* child = parent-&gt;_left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护树的结构</span></span><br><span class=\"line\">\t\tparent-&gt;_left = child-&gt;_right;<span class=\"comment\">//过继子树的右子树</span></span><br><span class=\"line\">\t\tchild-&gt;_right = parent;<span class=\"comment\">//重构树结构</span></span><br><span class=\"line\">\t\tNode* grandParent = parent-&gt;_parent;<span class=\"comment\">//维护祖父节点</span></span><br><span class=\"line\">\t\tchild-&gt;_parent = grandParent;<span class=\"comment\">//维护child</span></span><br><span class=\"line\">\t\tparent-&gt;_parent = child;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (grandParent)<span class=\"comment\">//如果不是根节点</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//维护根节点的父节点的子树</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent == grandParent-&gt;_left) grandParent-&gt;_left = child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> grandParent-&gt;_right = child;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//维护平衡因子</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (child-&gt;_bf == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tchild-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tparent-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (child-&gt;_bf == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//不存在的情况</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//需要多次旋转时不应该调用该函数</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == _root)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = child;<span class=\"comment\">//更新根节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RotateL-bf-2且子树的右子树超高\"><a href=\"#RotateL-bf-2且子树的右子树超高\" class=\"headerlink\" title=\"RotateL:_bf == 2且子树的右子树超高\"></a><code>RotateL</code>:<code>_bf == 2</code>且子树的右子树超高</h4><p>根据约定，<code>_bf == -2</code>表示右子树比左子树高<code>2</code>，所以我们要先通过向左旋转操作减少右子树高度</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030810533.png\"></p>\n<p>如图所示,通过向左旋转，成功地降低了右子树的高度，而根据<code>右子树</code>的平衡因子，又可以分为以下三种情况</p>\n<ul>\n<li><code>-1</code>:旋转后平衡性得到维护，但整棵树的高度由<code>h+2</code>降低到了<code>h-1</code>,总高度<code>-1</code>,需继续<strong>向上调整</strong></li>\n<li><code>0</code>:非法情况,不可能左右子树同时超高</li>\n<li><code>1</code>:不存在的情况，因为破坏了子树的右子树超高的前提</li>\n</ul>\n<p>以上分析可知，一次向左旋转已经可以解决<strong>两种</strong>情况了，所以我们先实现<code>RotateL</code><br>和<code>RotateL</code>一样，我们要对树里的父子关系作出调整，以此改变高度。</p>\n<p>然后除了图中的内容，我们还要维护一系列<code>_bf</code>,指针之类的内容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateL</span><span class=\"params\">(Node* parent)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\tNode* child = parent-&gt;_right;</span><br><span class=\"line\">\t\t<span class=\"comment\">//维护树结构</span></span><br><span class=\"line\">\t\tparent-&gt;_right = child-&gt;_left;<span class=\"comment\">//过继子树</span></span><br><span class=\"line\">\t\tchild-&gt;_left = parent;<span class=\"comment\">//重构树结构</span></span><br><span class=\"line\">\t\tNode* grandParent = parent-&gt;_parent;<span class=\"comment\">//维护祖父节点</span></span><br><span class=\"line\">\t\tchild-&gt;_parent = grandParent;<span class=\"comment\">//维护_parent</span></span><br><span class=\"line\">\t\tparent-&gt;_parent = child;<span class=\"comment\">//维护_parent</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (grandParent)<span class=\"comment\">//如果不是根节点</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//维护祖父节点的子树</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent == grandParent-&gt;_left) grandParent-&gt;_left = child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> grandParent-&gt;_right = child;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护平衡因子</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (child-&gt;_bf == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tchild-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tparent-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (child-&gt;_bf == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//不存在的情况</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//需要多次旋转时不应该调用该函数</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == _root)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = child;<span class=\"comment\">//更新根节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"RotateRL-bf-2且子树的右子树超高\"><a href=\"#RotateRL-bf-2且子树的右子树超高\" class=\"headerlink\" title=\"RotateRL:_bf == -2且子树的右子树超高\"></a><code>RotateRL</code>:<code>_bf == -2</code>且子树的右子树超高</h4><p>当出现该情况时，单纯的向右旋转并不顶用,效果如下图</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RotateR_err.png\"></p>\n<p>所以说我们要先调整左子树的平衡因子(左子树向左旋转)，再最后进行向右旋转</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ROtateLR_re.png\"></p>\n<p>如上图，通过两次旋转，完成了整体的平衡因子的维护</p>\n<p><strong>高度变化</strong>：整棵树的高度由<code>h+3</code>变成了<code>h+2</code>,高度减少了<code>1</code>,与原本的高度<code>+1</code>向抵消，停止调整</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateLR</span><span class=\"params\">(Node* parent)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;<span class=\"comment\">//错误情况</span></span><br><span class=\"line\">\t\tNode* Lchild = parent-&gt;_left;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (Lchild == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;<span class=\"comment\">//错误情况</span></span><br><span class=\"line\">\t\tNode* Rchild = Lchild-&gt;_right;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//先旋转左子树</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护树结构</span></span><br><span class=\"line\">\t\tLchild-&gt;_right = Rchild-&gt;_left;</span><br><span class=\"line\">\t\tRchild-&gt;_left = Lchild;</span><br><span class=\"line\">\t\tLchild-&gt;_parent = Rchild;</span><br><span class=\"line\">\t\tparent-&gt;_left = Rchild;</span><br><span class=\"line\">\t\tRchild-&gt;_parent = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护_bf</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (Lchild-&gt;_bf == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tLchild-&gt;_bf = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//_bf == -1 或 0都是非法的</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//再向右旋转</span></span><br><span class=\"line\">\t\tNode* child = parent-&gt;_left;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//维护树结构</span></span><br><span class=\"line\">\t\tparent-&gt;_left = child-&gt;_right;</span><br><span class=\"line\">\t\tchild-&gt;_right = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tNode* grandParent = parent-&gt;_parent;</span><br><span class=\"line\">\t\tchild-&gt;_parent = grandParent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = child;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (grandParent)<span class=\"comment\">//不是根节点</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent == grandParent-&gt;_left)grandParent-&gt;_left = child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> grandParent-&gt;_right = child;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护_bf</span></span><br><span class=\"line\">\t\tparent-&gt;_bf = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\tchild-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == _root)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = child;<span class=\"comment\">//更新根节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RotateLR-bf-2且子树的左子树超高\"><a href=\"#RotateLR-bf-2且子树的左子树超高\" class=\"headerlink\" title=\"RotateLR:bf == 2且子树的左子树超高\"></a><code>RotateLR</code>:<code>bf == 2</code>且子树的左子树超高</h4><p>具体情况与上一个接口相同，一次旋转无法完成任务，需要先向右旋转右子树调节平衡因子,再向左旋转，完成平衡的维护</p>\n<p><strong>高度变化</strong>：整棵树的高度由<code>h+3</code>变成了<code>h+2</code>,高度减少了<code>1</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateRL</span><span class=\"params\">(Node* parent)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//先向右旋转子树</span></span><br><span class=\"line\">\t\tNode* Rchild = parent-&gt;_right;</span><br><span class=\"line\">\t\tNode* Lchild = Rchild-&gt;_left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护树结构</span></span><br><span class=\"line\">\t\tRchild-&gt;_left = Lchild-&gt;_right;</span><br><span class=\"line\">\t\tLchild-&gt;_right = Rchild;</span><br><span class=\"line\">\t\tRchild-&gt;_parent = Lchild;</span><br><span class=\"line\">\t\tLchild-&gt;_parent = parent;</span><br><span class=\"line\">\t\tparent-&gt;_right = Lchild;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护_bf</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (Rchild-&gt;_bf == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tRchild-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//非法的情况</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//再向左旋转</span></span><br><span class=\"line\">\t\tNode* child = parent-&gt;_right;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tparent-&gt;_right = child-&gt;_left;<span class=\"comment\">//过继左子树</span></span><br><span class=\"line\">\t\tchild-&gt;_left = parent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = child;</span><br><span class=\"line\">\t\tNode* grandParent = parent-&gt;_parent;</span><br><span class=\"line\">\t\tchild-&gt;_parent = grandParent;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (grandParent)<span class=\"comment\">//如果不是根节点</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent == grandParent-&gt;_left)grandParent-&gt;_left = child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> grandParent-&gt;_right = child;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护_bf</span></span><br><span class=\"line\">\t\tparent-&gt;_bf = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\tchild-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == _root)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = child;<span class=\"comment\">//更新根节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"完成Insert中调整二叉树的代码\"><a href=\"#完成Insert中调整二叉树的代码\" class=\"headerlink\" title=\"完成Insert中调整二叉树的代码\"></a>完成Insert中调整二叉树的代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"type\">const</span> PKV&amp; kv)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tCmp cmp;<span class=\"comment\">//仿函数实例化一个对象</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(kv);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tNode* cur = _root;</span><br><span class=\"line\">\t\tNode* parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//寻找插入位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cur-&gt;_kv.first == kv.first)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//该键下的节点已存在，发生冲突</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">cmp</span>(cur-&gt;_kv.first, kv.first))<span class=\"comment\">//根比节点&quot;大&quot;</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\tcur = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"comment\">//根比节点小</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\tcur = cur-&gt;_right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//开始插入</span></span><br><span class=\"line\">\t\tNode* node = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(kv);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">cmp</span>(parent-&gt;_kv.first, kv.first))<span class=\"comment\">//应该插入左边</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tparent-&gt;_left = node;</span><br><span class=\"line\">\t\t\tnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\t\tparent-&gt;_bf -= <span class=\"number\">1</span>;<span class=\"comment\">//_bf越小，左子树越高</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"comment\">//插入右子树</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tparent-&gt;_right = node;</span><br><span class=\"line\">\t\t\tnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\t\tparent-&gt;_bf += <span class=\"number\">1</span>;<span class=\"comment\">//_bf越大，右子树越高</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//插入完成，准备开始维护平衡</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent-&gt;_bf == <span class=\"number\">0</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_bf == <span class=\"number\">1</span> || parent-&gt;_bf == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//子树高度增加</span></span><br><span class=\"line\">\t\t\t\tnode = parent;</span><br><span class=\"line\">\t\t\t\tparent = parent-&gt;_parent;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">break</span>;<span class=\"comment\">//走到根节点了</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (node == parent-&gt;_left)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tparent-&gt;_bf -= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == parent-&gt;_right)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tparent-&gt;_bf += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//非法情况</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_bf == <span class=\"number\">-2</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (parent-&gt;_left-&gt;_bf == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//非法情况,不可能左右子树同时超高</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_left-&gt;_bf == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//子树的左子树超高</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">RotateR</span>(parent);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_left-&gt;_bf == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//子树的右子树超高</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">RotateLR</span>(parent);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_bf == <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (parent-&gt;_right-&gt;_bf == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//非法情况,不可能左右子树同时超高</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_right-&gt;_bf == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//子树的右子树超高</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">RotateL</span>(parent);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_right-&gt;_bf == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//子树的左子树超高</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">RotateRL</span>(parent);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//非法情况</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p>我们来写个简单的<code>main</code>函数测试一下我们封装的<code>AVL树</code></p>\n<blockquote>\n<p>main.cpp</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;AVLTree.hpp&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tAVLTree&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; avt;<span class=\"comment\">//实例化一个对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; ++i)<span class=\"comment\">//准备100个数据</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tavt.<span class=\"built_in\">Insert</span>(&#123; i,i &#125;);<span class=\"comment\">//插入数据</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt;<span class=\"string\">&quot;Height &quot;</span> &lt;&lt; avt.<span class=\"built_in\">Height</span>() &lt;&lt; endl;   <span class=\"comment\">//检查高度</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;IsBalance &quot;</span> &lt;&lt; avt.<span class=\"built_in\">IsBalance</span>() &lt;&lt; endl; <span class=\"comment\">//检测平衡</span></span><br><span class=\"line\">\tavt.<span class=\"built_in\">Inorder</span>();<span class=\"comment\">//检测搜索树的特性</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看看结果</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030818252.png\"></p>\n<p>可以看到,<code>100</code>个数据下，而且还是按顺序插入，<code>AVL树</code>的高度只有<code>7</code>，很好得提高了搜索效率</p>\n<h1 id=\"AVL树的性能\"><a href=\"#AVL树的性能\" class=\"headerlink\" title=\"AVL树的性能\"></a>AVL树的性能</h1><p>AVL树是一棵绝<strong>对平衡的二叉搜索树</strong>，其要求每个节点的左右子树高度差的绝对值都不超过1，这样可以保证查询时高效的时间复杂度，即$log_2 (N)$。但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，<strong>但一个结构经常修改，就不太适合。</strong></p>\n<h1 id=\"改造成-红黑树\"><a href=\"#改造成-红黑树\" class=\"headerlink\" title=\"改造成 红黑树\"></a>改造成 红黑树</h1><p>目前的<code>AVL树</code>只是实现了最基本的功能，增删查改只支持了<code>增</code>,剩下的内容可自行完善，或者跟随作者的脚步，将<code>AVL树</code>改成<code>红黑树</code>,增加其修改的性能,并进一步完善增删查改的功能，以及封装<code>迭代器</code>等，最后将<code>红黑树</code>封装成我们自己的<code>set</code>类和<code>map</code>类</p>\n<p><a href=\"https://www.supdriver.top/2024/09/03/RBTree/\">戳我前往红黑树篇🔗</a></p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/416b331ca8312ea153216646882e9ed9.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"AVL树的概念\"><a href=\"#AVL树的概念\" class=\"headerlink\" title=\"AVL树的概念\"></a>AVL树的概念</h1><h2 id=\"二叉搜索树的不足\"><a href=\"#二叉搜索树的不足\" class=\"headerlink\" title=\"二叉搜索树的不足\"></a>二叉搜索树的不足</h2><p>二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将<strong>退化</strong>为<code>单支树</code>，查找元素相当于在顺序表中搜索元素，效率低下。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/lajibstree2.png\"></p>\n<h2 id=\"AVL树的提出\"><a href=\"#AVL树的提出\" class=\"headerlink\" title=\"AVL树的提出\"></a>AVL树的提出</h2><p>两位俄罗斯的数学家<em>G.M.Adelson-Velskii</em>和<em>E.M.Landis</em>在1962年发明了一种解决上述问题的方法：<br><strong>当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)</strong>,即构建一颗<code>绝对的平衡搜索二叉树</code>，即可降低树的高度，从而减少平均搜索长度。</p>\n<p><strong>定义</strong>: 一棵AVL树或者是空树，或者是具有以下性质的二<code>叉搜索树</code>：</p>\n<ul>\n<li>它的左右子树都是AVL树</li>\n<li>左右子树高度之差(简称<code>平衡因子</code>)的绝对值不超过1(-1&#x2F;0&#x2F;1)</li>\n</ul>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/aaaAVL80.png\"></p>\n<p>如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在<code>O(log_2 n)</code>,搜索的时间复杂度<code>O(log_2 n)</code></p>\n<h1 id=\"封装AVL树\"><a href=\"#封装AVL树\" class=\"headerlink\" title=\"封装AVL树\"></a>封装AVL树</h1><h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cassert&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"封装AVL树的节点\"><a href=\"#封装AVL树的节点\" class=\"headerlink\" title=\"封装AVL树的节点\"></a>封装AVL树的节点</h2><ul>\n<li>这里采用<code>键值(KV)</code>类型的二叉树节点,使其泛用性更高</li>\n<li>并增加指向父节点的指针构造三叉链表，来<strong>简化</strong>对二叉树的调整，但代价是<strong>维护成本</strong>变高(多了一个指针要维护)。</li>\n<li>引入<code>平衡因子</code>:<ul>\n<li><code>-1</code>表示左子树比右子树高<code>1</code>层  <em>左&gt;右</em></li>\n<li><code>0</code>表示左右子树等高           <em>左&#x3D;右</em></li>\n<li><code>1</code>表示右子树比左子树高<code>1</code>层   <em>左&lt;右</em></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">AVLTreeNode</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> AVLTreeNode&lt;K, V&gt; Node;<span class=\"comment\">//使用typedef简化代码</span></span><br><span class=\"line\">\tNode* _left;                   </span><br><span class=\"line\">\tNode* _right;</span><br><span class=\"line\">\tNode* _parent;</span><br><span class=\"line\">\tstd::pair&lt;K, V&gt; _kv; <span class=\"comment\">//节点储存的键值对</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> _bf;<span class=\"comment\">// ballance factor 平衡因子</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//构造函数，但不提供无参的默认构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">AVLTreeNode</span>(<span class=\"type\">const</span> std::pair&lt;K, V&gt;&amp; kv)</span><br><span class=\"line\">\t\t:_left(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t, _right(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t, _parent(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t, _kv(kv)</span><br><span class=\"line\">\t\t, _bf(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"规定AVLTree类的框架\"><a href=\"#规定AVLTree类的框架\" class=\"headerlink\" title=\"规定AVLTree类的框架\"></a>规定AVLTree类的框架</h2><p>首先确定成员变量,这里仅用<code>_root</code>指向二叉树，具体的维护由<code>成员函数</code>完成</p>\n<p>代码简化方面，使用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> AVLTreeNode&lt;K, V&gt; Node;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> std::pair&lt;K,V&gt; PKV;</span><br></pre></td></tr></table></figure>\n<p>简化代码</p>\n<p>然后是准备实现的<code>成员函数</code></p>\n<p><strong>公共接口</strong></p>\n<ul>\n<li><code>Insert</code>插入节点</li>\n<li><code>Inorder</code>前序遍历打印节点，用于debug</li>\n<li><code>IsBalance</code>检测是否平衡</li>\n<li><code>Height</code>获取子树高度</li>\n</ul>\n<p><strong>私有接口</strong></p>\n<ul>\n<li><code>RotateL</code>向左旋转子树，用于维护平衡</li>\n<li><code>RotateR</code>向右旋转子树，用于维护平衡</li>\n<li><code>RotateLR</code>向左再向右旋转子树，用于维护平衡</li>\n<li><code>RotateRL</code>向右再向左旋转子树，用于维护平衡</li>\n</ul>\n<p>实现AVL树的核心就是实现这四个<strong>旋转操作</strong>,并再在<code>insert</code>中回调。所以<code>Insert</code>函数我们放到最后再实现</p>\n<h2 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AVLTree</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> AVLTreeNode&lt;K, V&gt; Node;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> std::pair&lt;K, V&gt; PKV;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">AVLTree</span>() :_root(<span class=\"literal\">nullptr</span>) &#123;&#125;<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode* _root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Inorder函数\"><a href=\"#Inorder函数\" class=\"headerlink\" title=\"Inorder函数\"></a>Inorder函数</h2><p>公共的<code>Inorder</code>接口为无参函数,内部调用另外定义的<code>_Inorder</code>子函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">AVLTree</span>() :_root(<span class=\"literal\">nullptr</span>) &#123;&#125;<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Inorder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t_Inorder(_root);</span><br><span class=\"line\">\t\tstd::cout&lt;&lt;<span class=\"string\">&quot;nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">void</span> _Inorder(Node* root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t_Inorder(root-&gt;_left);</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; root-&gt;_kv.second &lt;&lt; <span class=\"string\">&quot;-&gt;&quot;</span>;</span><br><span class=\"line\">\t\t_Inorder(root-&gt;_right);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Height函数\"><a href=\"#Height函数\" class=\"headerlink\" title=\"Height函数\"></a>Height函数</h2><p>同上，使用<code>_Height</code>子函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Height</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _Height(_root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _Height(Node* root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> LHeight = _Height(root-&gt;_left);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> RHeight = _Height(root-&gt;_right);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (LHeight &gt; RHeight) <span class=\"keyword\">return</span> LHeight + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> RHeight + <span class=\"number\">1</span>; <span class=\"comment\">//将左右子树相等的情况合并在这里</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IsBalance函数\"><a href=\"#IsBalance函数\" class=\"headerlink\" title=\"IsBalance函数\"></a>IsBalance函数</h2><p>同上，使用<code>_Balance</code>子函数</p>\n<p>这里要较为严格，<strong>可靠</strong>地地判定平衡,而平衡因子由我们自己维护，作为判定的依据，并<strong>不可靠</strong>，相比之下,计算左右子树的高度差<strong>更可靠</strong>,所以这里回调<code>_Height</code>函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">IsBalance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _IsBalance(_root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">bool</span> _IsBalance(Node* root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> left = _IsBalance(root-&gt;_left);</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> right = _IsBalance(root-&gt; - _right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (left == <span class=\"literal\">false</span> || right == <span class=\"literal\">false</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//先判定左右子树</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> LHeight = _Height(root-&gt;_left);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> RHeight = _Height(root-&gt;_right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (LHeight - RHeight &gt;= <span class=\"number\">2</span> || LHeight - RHeight &lt;= <span class=\"number\">-2</span>)<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//最后判定根</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Insert函数\"><a href=\"#Insert函数\" class=\"headerlink\" title=\"Insert函数\"></a>Insert函数</h2><p><code>Insert</code>函数主要按步骤实现以下功能</p>\n<ol>\n<li><code>插入节点</code>:先按照二叉搜索树的规则将节点插入到AVL树中</li>\n<li><code>维护平衡</code>:新节点插入后，AVL树的平衡性可能会遭到破坏，此时就需要更新平衡因子，并检测是否破坏了AVL树</li>\n</ol>\n<h3 id=\"插入节点\"><a href=\"#插入节点\" class=\"headerlink\" title=\"插入节点\"></a>插入节点</h3><p>具体插入方式与<code>平衡搜索二叉树</code>基本相同,但是还要额外维护<code>_parent</code>指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"type\">const</span> PKV&amp; kv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tCmp cmp;<span class=\"comment\">//仿函数实例化一个对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(kv);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode* cur = _root;</span><br><span class=\"line\">\tNode* parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//寻找插入位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur-&gt;_kv.first == kv.first)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//该键下的节点已存在，发生冲突</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">cmp</span>(cur-&gt;_kv.first, kv.first))<span class=\"comment\">//根比节点&quot;大&quot;</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\tcur = cur-&gt;_left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"comment\">//根比节点小</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\tcur = cur-&gt;_right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//开始插入</span></span><br><span class=\"line\">\tNode* node = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(kv);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">cmp</span>(parent-&gt;_kv.first, kv.first))<span class=\"comment\">//应该插入左边</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tparent-&gt;_left = node;</span><br><span class=\"line\">\t\tnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\tparent-&gt;_bf -= <span class=\"number\">1</span>;<span class=\"comment\">//_bf越小，左子树越高</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"comment\">//插入右子树</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tparent-&gt;_right = node;</span><br><span class=\"line\">\t\tnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\tparent-&gt;_bf += <span class=\"number\">1</span>;<span class=\"comment\">//_bf越大，右子树越高</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//插入完成，准备开始维护平衡</span></span><br><span class=\"line\">\t<span class=\"comment\">//.....</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"维护平衡\"><a href=\"#维护平衡\" class=\"headerlink\" title=\"维护平衡\"></a>维护平衡</h3><p>插入节点的所有父级子树的高度都有可能受到其影响，所以要<strong>一路向上递归</strong>维护，直至某棵子树的高度不变,或者到达根节点</p>\n<p>下面我们一一枚举所有情况,并逐一解决</p>\n<ul>\n<li>父节点<code>_bf == 0</code><ul>\n<li>右子树高度增加: <code>_bf = 1</code>,且父节点高度增加，需继续<strong>向上调整</strong></li>\n<li>左子树高度增加: <code>_bf = -1</code>,且父节点高度增加，需继续<strong>向上调整</strong></li>\n</ul>\n</li>\n<li>父节点<code>_bf == -1</code><ul>\n<li>右子树高度增加: <code>_bf = 0</code>,父节点高度不变，停止调整</li>\n<li>左子树高度增加: <code>_bf = -2</code>,平衡被打破,需要<strong>旋转调整</strong>, <em>下文详细讨论</em></li>\n</ul>\n</li>\n<li>父节点<code>_bf == 1</code><ul>\n<li>右子树高度增加: <code>_bf = 2</code>,平衡被打破,需要<strong>旋转调整</strong>, <em>下文详细讨论</em></li>\n<li>左子树高度增加: <code>_bf = 0</code>,父节点高度不变，停止调整</li>\n</ul>\n</li>\n</ul>\n<p>可以看到，需要调整调整的情况有两大方向，接下来详细介绍调整方法</p>\n<h4 id=\"RotateR-bf-2且子树的左子树超高\"><a href=\"#RotateR-bf-2且子树的左子树超高\" class=\"headerlink\" title=\"RotateR :_bf == -2且子树的左子树超高\"></a><code>RotateR </code>:<code>_bf == -2</code>且子树的左子树超高</h4><p>根据约定，<code>_bf == -2</code>表示左子树比右子树高<code>2</code>，所以我们要先通过向右旋转操作减少左子树高度</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409021916938.png\"></p>\n<p>如图所示,通过向右旋转，成功地降低了左子树的高度，而根据<code>左子树</code>的平衡因子，又可以分为以下两种情况</p>\n<ul>\n<li><code>-1</code>:旋转后平衡性得到维护，但整棵树的高度由<code>h+2</code>降低到了<code>h-1</code>,总高度<code>-1</code>,与原本的高度<code>+1</code>相抵消,停止调整</li>\n<li><code>0</code>:非法情况,不可能左右子树同时超高</li>\n<li><code>1</code>:不存在的情况，因为破坏了左子树超高的前提</li>\n</ul>\n<p>以上分析可知，一次向右旋转已经可以解决<strong>两种</strong>情况了，所以我们着手实现<code>RotateR</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RotateR2.gif\"></p>\n<p>如上图所示，我们要对树里的父子关系作出调整，以此改变高度。</p>\n<p>然后除了图中的内容，我们还要维护一系列<code>_bf</code>,指针之类的内容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateR</span><span class=\"params\">(Node* parent)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\tNode* child = parent-&gt;_left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护树的结构</span></span><br><span class=\"line\">\t\tparent-&gt;_left = child-&gt;_right;<span class=\"comment\">//过继子树的右子树</span></span><br><span class=\"line\">\t\tchild-&gt;_right = parent;<span class=\"comment\">//重构树结构</span></span><br><span class=\"line\">\t\tNode* grandParent = parent-&gt;_parent;<span class=\"comment\">//维护祖父节点</span></span><br><span class=\"line\">\t\tchild-&gt;_parent = grandParent;<span class=\"comment\">//维护child</span></span><br><span class=\"line\">\t\tparent-&gt;_parent = child;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (grandParent)<span class=\"comment\">//如果不是根节点</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//维护根节点的父节点的子树</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent == grandParent-&gt;_left) grandParent-&gt;_left = child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> grandParent-&gt;_right = child;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//维护平衡因子</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (child-&gt;_bf == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tchild-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tparent-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (child-&gt;_bf == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//不存在的情况</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//需要多次旋转时不应该调用该函数</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == _root)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = child;<span class=\"comment\">//更新根节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RotateL-bf-2且子树的右子树超高\"><a href=\"#RotateL-bf-2且子树的右子树超高\" class=\"headerlink\" title=\"RotateL:_bf == 2且子树的右子树超高\"></a><code>RotateL</code>:<code>_bf == 2</code>且子树的右子树超高</h4><p>根据约定，<code>_bf == -2</code>表示右子树比左子树高<code>2</code>，所以我们要先通过向左旋转操作减少右子树高度</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030810533.png\"></p>\n<p>如图所示,通过向左旋转，成功地降低了右子树的高度，而根据<code>右子树</code>的平衡因子，又可以分为以下三种情况</p>\n<ul>\n<li><code>-1</code>:旋转后平衡性得到维护，但整棵树的高度由<code>h+2</code>降低到了<code>h-1</code>,总高度<code>-1</code>,需继续<strong>向上调整</strong></li>\n<li><code>0</code>:非法情况,不可能左右子树同时超高</li>\n<li><code>1</code>:不存在的情况，因为破坏了子树的右子树超高的前提</li>\n</ul>\n<p>以上分析可知，一次向左旋转已经可以解决<strong>两种</strong>情况了，所以我们先实现<code>RotateL</code><br>和<code>RotateL</code>一样，我们要对树里的父子关系作出调整，以此改变高度。</p>\n<p>然后除了图中的内容，我们还要维护一系列<code>_bf</code>,指针之类的内容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateL</span><span class=\"params\">(Node* parent)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\tNode* child = parent-&gt;_right;</span><br><span class=\"line\">\t\t<span class=\"comment\">//维护树结构</span></span><br><span class=\"line\">\t\tparent-&gt;_right = child-&gt;_left;<span class=\"comment\">//过继子树</span></span><br><span class=\"line\">\t\tchild-&gt;_left = parent;<span class=\"comment\">//重构树结构</span></span><br><span class=\"line\">\t\tNode* grandParent = parent-&gt;_parent;<span class=\"comment\">//维护祖父节点</span></span><br><span class=\"line\">\t\tchild-&gt;_parent = grandParent;<span class=\"comment\">//维护_parent</span></span><br><span class=\"line\">\t\tparent-&gt;_parent = child;<span class=\"comment\">//维护_parent</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (grandParent)<span class=\"comment\">//如果不是根节点</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//维护祖父节点的子树</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent == grandParent-&gt;_left) grandParent-&gt;_left = child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> grandParent-&gt;_right = child;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护平衡因子</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (child-&gt;_bf == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tchild-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tparent-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (child-&gt;_bf == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//不存在的情况</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//需要多次旋转时不应该调用该函数</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == _root)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = child;<span class=\"comment\">//更新根节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"RotateRL-bf-2且子树的右子树超高\"><a href=\"#RotateRL-bf-2且子树的右子树超高\" class=\"headerlink\" title=\"RotateRL:_bf == -2且子树的右子树超高\"></a><code>RotateRL</code>:<code>_bf == -2</code>且子树的右子树超高</h4><p>当出现该情况时，单纯的向右旋转并不顶用,效果如下图</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RotateR_err.png\"></p>\n<p>所以说我们要先调整左子树的平衡因子(左子树向左旋转)，再最后进行向右旋转</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/ROtateLR_re.png\"></p>\n<p>如上图，通过两次旋转，完成了整体的平衡因子的维护</p>\n<p><strong>高度变化</strong>：整棵树的高度由<code>h+3</code>变成了<code>h+2</code>,高度减少了<code>1</code>,与原本的高度<code>+1</code>向抵消，停止调整</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateLR</span><span class=\"params\">(Node* parent)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;<span class=\"comment\">//错误情况</span></span><br><span class=\"line\">\t\tNode* Lchild = parent-&gt;_left;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (Lchild == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;<span class=\"comment\">//错误情况</span></span><br><span class=\"line\">\t\tNode* Rchild = Lchild-&gt;_right;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//先旋转左子树</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护树结构</span></span><br><span class=\"line\">\t\tLchild-&gt;_right = Rchild-&gt;_left;</span><br><span class=\"line\">\t\tRchild-&gt;_left = Lchild;</span><br><span class=\"line\">\t\tLchild-&gt;_parent = Rchild;</span><br><span class=\"line\">\t\tparent-&gt;_left = Rchild;</span><br><span class=\"line\">\t\tRchild-&gt;_parent = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护_bf</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (Lchild-&gt;_bf == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tLchild-&gt;_bf = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//_bf == -1 或 0都是非法的</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//再向右旋转</span></span><br><span class=\"line\">\t\tNode* child = parent-&gt;_left;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//维护树结构</span></span><br><span class=\"line\">\t\tparent-&gt;_left = child-&gt;_right;</span><br><span class=\"line\">\t\tchild-&gt;_right = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tNode* grandParent = parent-&gt;_parent;</span><br><span class=\"line\">\t\tchild-&gt;_parent = grandParent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = child;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (grandParent)<span class=\"comment\">//不是根节点</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent == grandParent-&gt;_left)grandParent-&gt;_left = child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> grandParent-&gt;_right = child;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护_bf</span></span><br><span class=\"line\">\t\tparent-&gt;_bf = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\tchild-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == _root)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = child;<span class=\"comment\">//更新根节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RotateLR-bf-2且子树的左子树超高\"><a href=\"#RotateLR-bf-2且子树的左子树超高\" class=\"headerlink\" title=\"RotateLR:bf == 2且子树的左子树超高\"></a><code>RotateLR</code>:<code>bf == 2</code>且子树的左子树超高</h4><p>具体情况与上一个接口相同，一次旋转无法完成任务，需要先向右旋转右子树调节平衡因子,再向左旋转，完成平衡的维护</p>\n<p><strong>高度变化</strong>：整棵树的高度由<code>h+3</code>变成了<code>h+2</code>,高度减少了<code>1</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateRL</span><span class=\"params\">(Node* parent)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//先向右旋转子树</span></span><br><span class=\"line\">\t\tNode* Rchild = parent-&gt;_right;</span><br><span class=\"line\">\t\tNode* Lchild = Rchild-&gt;_left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护树结构</span></span><br><span class=\"line\">\t\tRchild-&gt;_left = Lchild-&gt;_right;</span><br><span class=\"line\">\t\tLchild-&gt;_right = Rchild;</span><br><span class=\"line\">\t\tRchild-&gt;_parent = Lchild;</span><br><span class=\"line\">\t\tLchild-&gt;_parent = parent;</span><br><span class=\"line\">\t\tparent-&gt;_right = Lchild;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护_bf</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (Rchild-&gt;_bf == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tRchild-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//非法的情况</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//再向左旋转</span></span><br><span class=\"line\">\t\tNode* child = parent-&gt;_right;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tparent-&gt;_right = child-&gt;_left;<span class=\"comment\">//过继左子树</span></span><br><span class=\"line\">\t\tchild-&gt;_left = parent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = child;</span><br><span class=\"line\">\t\tNode* grandParent = parent-&gt;_parent;</span><br><span class=\"line\">\t\tchild-&gt;_parent = grandParent;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (grandParent)<span class=\"comment\">//如果不是根节点</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent == grandParent-&gt;_left)grandParent-&gt;_left = child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> grandParent-&gt;_right = child;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//维护_bf</span></span><br><span class=\"line\">\t\tparent-&gt;_bf = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\tchild-&gt;_bf = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == _root)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = child;<span class=\"comment\">//更新根节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"完成Insert中调整二叉树的代码\"><a href=\"#完成Insert中调整二叉树的代码\" class=\"headerlink\" title=\"完成Insert中调整二叉树的代码\"></a>完成Insert中调整二叉树的代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"type\">const</span> PKV&amp; kv)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tCmp cmp;<span class=\"comment\">//仿函数实例化一个对象</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(kv);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tNode* cur = _root;</span><br><span class=\"line\">\t\tNode* parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//寻找插入位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cur-&gt;_kv.first == kv.first)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//该键下的节点已存在，发生冲突</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">cmp</span>(cur-&gt;_kv.first, kv.first))<span class=\"comment\">//根比节点&quot;大&quot;</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\tcur = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"comment\">//根比节点小</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\tcur = cur-&gt;_right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//开始插入</span></span><br><span class=\"line\">\t\tNode* node = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(kv);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">cmp</span>(parent-&gt;_kv.first, kv.first))<span class=\"comment\">//应该插入左边</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tparent-&gt;_left = node;</span><br><span class=\"line\">\t\t\tnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\t\tparent-&gt;_bf -= <span class=\"number\">1</span>;<span class=\"comment\">//_bf越小，左子树越高</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"comment\">//插入右子树</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tparent-&gt;_right = node;</span><br><span class=\"line\">\t\t\tnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\t\tparent-&gt;_bf += <span class=\"number\">1</span>;<span class=\"comment\">//_bf越大，右子树越高</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//插入完成，准备开始维护平衡</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent-&gt;_bf == <span class=\"number\">0</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_bf == <span class=\"number\">1</span> || parent-&gt;_bf == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//子树高度增加</span></span><br><span class=\"line\">\t\t\t\tnode = parent;</span><br><span class=\"line\">\t\t\t\tparent = parent-&gt;_parent;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">break</span>;<span class=\"comment\">//走到根节点了</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (node == parent-&gt;_left)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tparent-&gt;_bf -= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == parent-&gt;_right)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tparent-&gt;_bf += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//非法情况</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_bf == <span class=\"number\">-2</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (parent-&gt;_left-&gt;_bf == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//非法情况,不可能左右子树同时超高</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_left-&gt;_bf == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//子树的左子树超高</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">RotateR</span>(parent);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_left-&gt;_bf == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//子树的右子树超高</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">RotateLR</span>(parent);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_bf == <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (parent-&gt;_right-&gt;_bf == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//非法情况,不可能左右子树同时超高</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_right-&gt;_bf == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//子树的右子树超高</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">RotateL</span>(parent);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;_right-&gt;_bf == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//子树的左子树超高</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">RotateRL</span>(parent);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);<span class=\"comment\">//非法情况</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p>我们来写个简单的<code>main</code>函数测试一下我们封装的<code>AVL树</code></p>\n<blockquote>\n<p>main.cpp</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;AVLTree.hpp&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tAVLTree&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; avt;<span class=\"comment\">//实例化一个对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; ++i)<span class=\"comment\">//准备100个数据</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tavt.<span class=\"built_in\">Insert</span>(&#123; i,i &#125;);<span class=\"comment\">//插入数据</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt;<span class=\"string\">&quot;Height &quot;</span> &lt;&lt; avt.<span class=\"built_in\">Height</span>() &lt;&lt; endl;   <span class=\"comment\">//检查高度</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;IsBalance &quot;</span> &lt;&lt; avt.<span class=\"built_in\">IsBalance</span>() &lt;&lt; endl; <span class=\"comment\">//检测平衡</span></span><br><span class=\"line\">\tavt.<span class=\"built_in\">Inorder</span>();<span class=\"comment\">//检测搜索树的特性</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看看结果</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030818252.png\"></p>\n<p>可以看到,<code>100</code>个数据下，而且还是按顺序插入，<code>AVL树</code>的高度只有<code>7</code>，很好得提高了搜索效率</p>\n<h1 id=\"AVL树的性能\"><a href=\"#AVL树的性能\" class=\"headerlink\" title=\"AVL树的性能\"></a>AVL树的性能</h1><p>AVL树是一棵绝<strong>对平衡的二叉搜索树</strong>，其要求每个节点的左右子树高度差的绝对值都不超过1，这样可以保证查询时高效的时间复杂度，即$log_2 (N)$。但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，<strong>但一个结构经常修改，就不太适合。</strong></p>\n<h1 id=\"改造成-红黑树\"><a href=\"#改造成-红黑树\" class=\"headerlink\" title=\"改造成 红黑树\"></a>改造成 红黑树</h1><p>目前的<code>AVL树</code>只是实现了最基本的功能，增删查改只支持了<code>增</code>,剩下的内容可自行完善，或者跟随作者的脚步，将<code>AVL树</code>改成<code>红黑树</code>,增加其修改的性能,并进一步完善增删查改的功能，以及封装<code>迭代器</code>等，最后将<code>红黑树</code>封装成我们自己的<code>set</code>类和<code>map</code>类</p>\n<p><a href=\"https://www.supdriver.top/2024/09/03/RBTree/\">戳我前往红黑树篇🔗</a></p>\n"},{"title":"【数据结构】一步到胃，键值对版二叉搜索树","date":"2024-07-27T00:14:12.000Z","_content":"# 什么是二叉搜索树\n二叉搜索树的`定义`是一颗二叉树的所有节点满足:`根的左右孩子存在时，满足 左孩子 < 根 < 右孩子`\n\n`递归定义`则是:\n1. `左子树的根` < `根` < `右子树的根`\n2. `左子树是二叉搜索树`,`右子树是二叉搜索树`\n\n## 写一个验证二叉搜索树的函数 ##\n[Leetecode题目链接🔗](https://leetcode.cn/problems/validate-binary-search-tree/)\n\n# 封装一个二叉树类\n\n## 文件布置\n+ `BSTree.h`用于声明和实现`BSTree`类\n+ `test.cpp`用于测试\n\n### 头文件\n`BSTree.h`\n```C++\n#include <iostream>\n#include <utility>\n\n```\n`test.cpp`\n```C++\n#include \"BSTree.h\"\n```\n## 命名空间\n```C++\nnamespace key_value\n```\n这里使用`key_value`作为命名空间，表示这是键值表示的搜索二叉树\n\n## 定义节点\n二叉树的节点用于储存`键值对`和`左右指针`，并提供`默认构造函数`,使用`初始化列表`初始化成员变量\n\n```C++\ntemplate<class K,class V>\nclass BSTNode\n{\npublic:\n    BSTNode(const K& key = K(), const V& value = V())\n        :_left(nullptr)\n        , _right(nullptr)\n        , _key(key)\n        , _value(value)\n    {}\n    BSTNode<K, V>* _left;//指向左子树\n    BSTNode<K, V>* _right;//指向右子树\n    K _key;//储存键\n    V _value;//储存值\n};\n```\n\n## 封装二叉搜索树\n`Binary Search Tree`,这里用简称`BSTree`封装\n\n### 基本架构\n鉴于该类的接口基本依赖于成员变量，所以先组织好成员变量\n\n作为一颗`二叉树类`,成员变量仅需一个`指向根的指`针即可\n\n再次之前先用`typedef`定义一个`节点类`出来用于简化代码\n\n最后提供一个`默认构造函数`将`_root`初始化为`nullptr`\n\n```C++\n\ttemplate<class K,class V>\n\tclass BSTree\n\t{\n\t\ttypedef BSTNode<K, V> Node;//使用typedef简化代码\n\tpublic:\n\t\tBSTree() :_root(nullptr) {}//提供默认构造函数\n\tprivate:\n\t\tNode* _root;//指向根节点的指针作为成员变量\n\t};\n```\n\n### `insert`函数\n准备好后第一个接口就是`insert`,用于构建搜索二叉树\n\n这里需要考虑的情况有\n\n+ 空树时的插入\n+ 插入的`key`已存在\n+ 一般情况下成功的插入\n\n```C++\npublic:\nbool insert(const K& key, const V& value)\n{\n    if (_root == nullptr)//空树\n    {\n        _root = new Node(key, value);\n        return true;\n    }\n\n    Node* cur = _root;\n    Node* parent = nullptr;\n    while (cur)\n    {\n        if (key < cur->_key)//key比当前节点小，往左子树走\n        {\n            parent = cur;\n            cur = cur->_left;\n        }\n        else if (key > cur->_key)//往右子树走\n        {\n            parent = cur;\n            cur = cur->_right;\n        }\n        else\n        {\n            return false;//key已存在，插入失败\n        }\n    }\n    //此时cur为nullptr, parent为cur的结点\n    if (key < parent->_key)parent->_left = new Node(key, value);\n    else parent->_right = new Node(key, value);\n    return true;//成功插入\n}\n```\n\n### `in_order`函数\n使用此函数`前序遍历打印`二叉树来验证其满足`搜索树`的性质\n\n这里使用递归打印,所以要借助`_in_order`子函数\n\n```C++\npublic:\n    void in_order()\n    {\n        _in_order(_root);//传入根结点\n        std::cout << std::endl;\n    }\nprotected:\n    void _in_order(Node* root)\n    {\n        if (root == nullptr) return;\n        _in_order(root->_left);//先访问左结点\n        std::cout << root->_value << \" \" << std::endl;//再访问根结点\n        _in_order(root->_right);//最后访问右结点\n    }\n```\n\n然后写一段测试代码测试性质\n\n> test.cpp\n```C++\n#include \"BSTree.h\"\n#include <vector>\nusing namespace std;\nint main()\n{\n\tvector<int> arr({ 2,3,1,5,4,6,8,7 });//准备待插入的键值对\n\tkey_value::BSTree<int, int> bst;\n\tfor (int i = 0; i < arr.size(); ++i)\n\t{\n\t\tbst.insert(arr[i],arr[i]);//这里使键值相同，方便观察\n\t}\n\n\tbst.in_order();//测试\n\n\treturn 0;\n}\n```\n\n### `find`函数\n可以用`find`函数查找对应`key`的结点。\n\n同时观察可知，控制`cur`和`parent`的移动的代码段和前面的函数很像，所以给`find`函数分出来一个`_find`子函数，并使它返回`pair<Node*,Node*>`，将这两个指针返回利于其它函数对`_find`的回调\n\n同时为了简化代码，继续用`typedef`封装类型\n\n```C++\npublic:\n    typedef std::pair< Node*, Node* > PNN;//简化代码\n    bool find(const K& key)\n    {\n        return _find(key).first != nullptr;//检查是否找到\n    }\nprotected:\n\n    PNN _find(const K& key)//返回PNN用于简化其它接口\n    {\n        if (_root == nullptr) return {nullptr,nullptr};\n        Node* cur = _root;\n        Node* parent = nullptr;\n        while (cur)\n        {\n            if (key < cur->_key)//key比当前节点小，往左子树走\n            {\n                parent = cur;\n                cur = cur->_left;\n            }\n            else if (key > cur->_key)//往右子树走\n            {\n                parent = cur;\n                cur = cur->_right;\n            }\n            else\n            {\n                //找到key\n                return { cur,parent };\n            }\n        }\n        //没找到key,cur为nullptr\n        return { nullptr,parent };\n    }\n```\n\n#### 重写`insert`函数\n```C++\n    bool insert(const K& key, const V& value)\n    {\n        if (_root == nullptr)//空树\n        {\n            _root = new Node(key, value);\n            return true;\n        }\n        //====修改的部分====\n        PNN pnn = _find(key);\n\n        Node* cur = pnn.first;\n        Node* parent = pnn.second;\n\n        if (cur != nullptr)//该key已存在，插入失败\n        {\n            return false;\n        }\n        //================\n        \n        //此时cur为nullptr, parent为cur的结点\n        if (key < parent->_key)parent->_left = new Node(key, value);\n        else parent->_right = new Node(key, value);\n        return true;//成功插入\n    }\n```\n\n### `erase`函数\n这里也可以复用`_find`来方便地删除结点\n\n这里要考虑的情况有:\n+ 树为空\n+ 删除最后一个结点\n+ 删除根节点\n+ 左子树为空（包括叶子结点）\n+ 右子树为空\n+ 删除一般的结点\n\n当树有`>=2`个结点，且要删除`非叶子`结点时，要考虑`结点替换`，否则二叉树会断掉，这里一般两种策略，取左子树的最右结点（最大结点），或取右子树的最左结点（最小结点）\n\n```C++\npublic:\n    bool erase(const K& key)\n    {\n        if (_root == nullptr)return false;//空树无法删除\n        if (_root->_key == key && _root->_left == nullptr && _root->_right == nullptr)//删除最后一个结点\n        {\n            delete _root;\n            _root = nullptr;\n        }\n        PNN pnn = _find(key);\n        Node* cur = pnn.first;\n        Node* parent = pnn.second;\n        if (cur == nullptr) return false;//没找到该结点\n\n        //下面的cur必不为空\n        if(cur->_left == nullptr)\n        {\n            if (cur == _root)//为根节点时要替换根节点\n            {\n                Node* right = _root->_right;\n                delete _root;\n                _root = right;\n            }\n            //没有左子树，则直接移除结点,右子树替代原结点\n            if (cur == parent->_left) parent->_left = cur->_right;\n            else parent->_right = cur->_right;\n            delete cur;\n        }\n        else if (cur->_right == nullptr)\n        {\n            if (cur == _root)\n            {\n                Node* left = _root->_left;\n                delete _root;\n                _root = left;\n            }\n            //直接过继左子树\n            if (cur == parent->_left)parent->_left = cur->_left;\n            else parent->_right = cur->_left;\n        }\n        else \n        {\n            //找到左子树的最右结点\n            Node* _cur = cur->_left;\n            Node* _parent = cur;\n            while (_cur->_right != nullptr)\n            {\n                _parent = _cur;\n                _cur = _cur->_right;\n            }\n            //移走结点\n            if (_cur == _parent->_left) _parent->_left = nullptr;\n            else _parent->_right = nullptr;\n            //获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点\n            _cur->_left = cur->_left;\n            _cur->_right = cur->_right;\n            //代替cur的位置\n            if (cur == _root)//删除根结点时\n            {\n                delete _root;\n                _root = _cur;\n            }\n            else//删除普通结点时\n            {\n                if (cur == parent->_left) parent->_left = _cur;\n                else parent->_right = _cur;\n                delete cur;\n            }\n\n        }\n        return true;\n    }\n```\n\n### 拷贝构造\n利用二叉树的性质，可以再构建个`copy`子函数来递归拷贝\n\n```C++\npublic:\n    BSTree(const BSTree<K>& t)\n    {\n        _root = Copy(t._root);\n    }\nprotected:\n    Node* copy(Node* root)\n    {\n        if (root == nullptr) return nullptr;//递归出口\n        Node* pnode = new Node(root->_key, root->_value);//复制结点\n        pnode->_left = copy(root->_left);\n        pnode->_right = copy(root->_right);\n        return pnode;\n    }\n```\n### 析构函数\n这里也用`destroy`子函数来递归地后序遍历依次删除各个结点\n```C++\npublic:\n    ~BSTree()\n    {\n        destroy(_root);\n    }\nprotected:\n    void destroy(Node* root)\n    {\n        if (root == nullptr) return;\n        destroy(root->_left);\n        destroy(root->_right);\n        delete root;\n    }\n```\n\n至此，一个基本的二叉搜索树已封装完成\n\n实现的功能有\n\n+ 构建二叉搜索树\n+ 拷贝复制二叉树\n+ 按`key`值查找\n+ 按`key`值删除\n\n### 完整代码\n```C++\n#pragma once\n#include <iostream>\n#include <utility>\n\nnamespace key_value\n{\n\ttemplate<class K,class V>\n\tclass BSTNode\n\t{\n\tpublic:\n\t\tBSTNode(const K& key = K(), const V& value = V())\n\t\t\t:_left(nullptr)\n\t\t\t, _right(nullptr)\n\t\t\t, _key(key)\n\t\t\t, _value(value)\n\t\t{}\n\t\tBSTNode<K, V>* _left;//指向左子树\n\t\tBSTNode<K, V>* _right;//指向右子树\n\t\tK _key;//储存键\n\t\tV _value;//储存值\n\t};\n\n\ttemplate<class K,class V>\n\tclass BSTree\n\t{\n\t\ttypedef BSTNode<K, V> Node;//使用typedef简化代码\n\tpublic:\n\t\tBSTree() :_root(nullptr) {}//提供默认构造函数\n\n\t\tBSTree(const BSTree<K, V>& bst)\n\t\t{\n\t\t\t_root = copy(bst._root);\n\t\t}\n\n\t\t~BSTree()\n\t\t{\n\t\t\tdestroy(_root);\n\t\t}\n\n\t\tbool insert(const K& key, const V& value)\n\t\t{\n\t\t\tif (_root == nullptr)//空树\n\t\t\t{\n\t\t\t\t_root = new Node(key, value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t//====修改的部分====\n\t\t\tPNN pnn = _find(key);\n\n\t\t\tNode* cur = pnn.first;\n\t\t\tNode* parent = pnn.second;\n\n\t\t\tif (cur != nullptr)//该key已存在，插入失败\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//================\n\t\t\t\n\t\t\t//此时cur为nullptr, parent为cur的结点\n\t\t\tif (key < parent->_key)parent->_left = new Node(key, value);\n\t\t\telse parent->_right = new Node(key, value);\n\t\t\treturn true;//成功插入\n\t\t}\n\n\t\tvoid in_order()\n\t\t{\n\t\t\t_in_order(_root);//传入根结点\n\t\t\tstd::cout << std::endl;\n\t\t}\n\tprotected:\n\t\tvoid _in_order(Node* root)\n\t\t{\n\t\t\tif (root == nullptr) return;\n\t\t\t_in_order(root->_left);//先访问左结点\n\t\t\tstd::cout << root->_value << \" \";//再访问根结点\n\t\t\t_in_order(root->_right);//最后访问右结点\n\t\t}\n\n\n\tpublic:\n\t\ttypedef std::pair< Node*, Node* > PNN;//简化代码\n\t\tbool find(const K& key)\n\t\t{\n\t\t\treturn _find(key).first != nullptr;//检查是否找到\n\t\t}\n\tprotected:\n\t\n\t\tPNN _find(const K& key)//返回PNN用于简化其它接口\n\t\t{\n\t\t\tif (_root == nullptr) return {nullptr,nullptr};\n\t\t\tNode* cur = _root;\n\t\t\tNode* parent = nullptr;\n\t\t\twhile (cur)\n\t\t\t{\n\t\t\t\tif (key < cur->_key)//key比当前节点小，往左子树走\n\t\t\t\t{\n\t\t\t\t\tparent = cur;\n\t\t\t\t\tcur = cur->_left;\n\t\t\t\t}\n\t\t\t\telse if (key > cur->_key)//往右子树走\n\t\t\t\t{\n\t\t\t\t\tparent = cur;\n\t\t\t\t\tcur = cur->_right;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//找到key\n\t\t\t\t\treturn { cur,parent };\n\t\t\t\t}\n\t\t\t}\n\t\t\t//没找到key,cur为nullptr\n\t\t\treturn { nullptr,parent };\n\t\t}\n\tpublic:\n\n\t\tbool erase(const K& key)\n\t\t{\n\t\t\tif (_root == nullptr)return false;//空树无法删除\n\t\t\tif (_root->_key == key && _root->_left == nullptr && _root->_right == nullptr)//删除最后一个结点\n\t\t\t{\n\t\t\t\tdelete _root;\n\t\t\t\t_root = nullptr;\n\t\t\t}\n\t\t\tPNN pnn = _find(key);\n\t\t\tNode* cur = pnn.first;\n\t\t\tNode* parent = pnn.second;\n\t\t\tif (cur == nullptr) return false;//没找到该结点\n\n\t\t\t//下面的cur必不为空\n\t\t\tif(cur->_left == nullptr)\n\t\t\t{\n\t\t\t\tif (cur == _root)//为根节点时要替换根节点\n\t\t\t\t{\n\t\t\t\t\tNode* right = _root->_right;\n\t\t\t\t\tdelete _root;\n\t\t\t\t\t_root = right;\n\t\t\t\t}\n\t\t\t\t//没有左子树，则直接移除结点,右子树替代原结点\n\t\t\t\tif (cur == parent->_left) parent->_left = cur->_right;\n\t\t\t\telse parent->_right = cur->_right;\n\t\t\t\tdelete cur;\n\t\t\t}\n\t\t\telse if (cur->_right == nullptr)\n\t\t\t{\n\t\t\t\tif (cur == _root)\n\t\t\t\t{\n\t\t\t\t\tNode* left = _root->_left;\n\t\t\t\t\tdelete _root;\n\t\t\t\t\t_root = left;\n\t\t\t\t}\n\t\t\t\t//直接过继左子树\n\t\t\t\tif (cur == parent->_left)parent->_left = cur->_left;\n\t\t\t\telse parent->_right = cur->_left;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\t//找到左子树的最右结点\n\t\t\t\tNode* _cur = cur->_left;\n\t\t\t\tNode* _parent = cur;\n\t\t\t\twhile (_cur->_right != nullptr)\n\t\t\t\t{\n\t\t\t\t\t_parent = _cur;\n\t\t\t\t\t_cur = _cur->_right;\n\t\t\t\t}\n\t\t\t\t//移走结点\n\t\t\t\tif (_cur == _parent->_left) _parent->_left = nullptr;\n\t\t\t\telse _parent->_right = nullptr;\n\t\t\t\t//获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点\n\t\t\t\t_cur->_left = cur->_left;\n\t\t\t\t_cur->_right = cur->_right;\n\t\t\t\t//代替cur的位置\n\t\t\t\tif (cur == _root)//删除根结点时\n\t\t\t\t{\n\t\t\t\t\tdelete _root;\n\t\t\t\t\t_root = _cur;\n\t\t\t\t}\n\t\t\t\telse//删除普通结点时\n\t\t\t\t{\n\t\t\t\t\tif (cur == parent->_left) parent->_left = _cur;\n\t\t\t\t\telse parent->_right = _cur;\n\t\t\t\t\tdelete cur;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\n\tprotected:\n\t\tNode* copy(Node* root)\n\t\t{\n\t\t\tif (root == nullptr) return nullptr;//递归出口\n\t\t\tNode* pnode = new Node(root->_key, root->_value);//复制结点\n\t\t\tpnode->_left = copy(root->_left);\n\t\t\tpnode->_right = copy(root->_right);\n\t\t\treturn pnode;\n\t\t}\n\n\t\tvoid destroy(Node* root)\n\t\t{\n\t\t\tif (root == nullptr) return;\n\t\t\tdestroy(root->_left);\n\t\t\tdestroy(root->_right);\n\t\t\tdelete root;\n\t\t}\n\tprivate:\n\t\tNode* _root;//指向根节点的指针作为成员变量\n\t};\n}\n```\n","source":"_posts/BSTree.md","raw":"---\ntitle: 【数据结构】一步到胃，键值对版二叉搜索树\ndate: 2024-07-27 08:14:12\ntags: 数据结构 二叉树 搜索树\n---\n# 什么是二叉搜索树\n二叉搜索树的`定义`是一颗二叉树的所有节点满足:`根的左右孩子存在时，满足 左孩子 < 根 < 右孩子`\n\n`递归定义`则是:\n1. `左子树的根` < `根` < `右子树的根`\n2. `左子树是二叉搜索树`,`右子树是二叉搜索树`\n\n## 写一个验证二叉搜索树的函数 ##\n[Leetecode题目链接🔗](https://leetcode.cn/problems/validate-binary-search-tree/)\n\n# 封装一个二叉树类\n\n## 文件布置\n+ `BSTree.h`用于声明和实现`BSTree`类\n+ `test.cpp`用于测试\n\n### 头文件\n`BSTree.h`\n```C++\n#include <iostream>\n#include <utility>\n\n```\n`test.cpp`\n```C++\n#include \"BSTree.h\"\n```\n## 命名空间\n```C++\nnamespace key_value\n```\n这里使用`key_value`作为命名空间，表示这是键值表示的搜索二叉树\n\n## 定义节点\n二叉树的节点用于储存`键值对`和`左右指针`，并提供`默认构造函数`,使用`初始化列表`初始化成员变量\n\n```C++\ntemplate<class K,class V>\nclass BSTNode\n{\npublic:\n    BSTNode(const K& key = K(), const V& value = V())\n        :_left(nullptr)\n        , _right(nullptr)\n        , _key(key)\n        , _value(value)\n    {}\n    BSTNode<K, V>* _left;//指向左子树\n    BSTNode<K, V>* _right;//指向右子树\n    K _key;//储存键\n    V _value;//储存值\n};\n```\n\n## 封装二叉搜索树\n`Binary Search Tree`,这里用简称`BSTree`封装\n\n### 基本架构\n鉴于该类的接口基本依赖于成员变量，所以先组织好成员变量\n\n作为一颗`二叉树类`,成员变量仅需一个`指向根的指`针即可\n\n再次之前先用`typedef`定义一个`节点类`出来用于简化代码\n\n最后提供一个`默认构造函数`将`_root`初始化为`nullptr`\n\n```C++\n\ttemplate<class K,class V>\n\tclass BSTree\n\t{\n\t\ttypedef BSTNode<K, V> Node;//使用typedef简化代码\n\tpublic:\n\t\tBSTree() :_root(nullptr) {}//提供默认构造函数\n\tprivate:\n\t\tNode* _root;//指向根节点的指针作为成员变量\n\t};\n```\n\n### `insert`函数\n准备好后第一个接口就是`insert`,用于构建搜索二叉树\n\n这里需要考虑的情况有\n\n+ 空树时的插入\n+ 插入的`key`已存在\n+ 一般情况下成功的插入\n\n```C++\npublic:\nbool insert(const K& key, const V& value)\n{\n    if (_root == nullptr)//空树\n    {\n        _root = new Node(key, value);\n        return true;\n    }\n\n    Node* cur = _root;\n    Node* parent = nullptr;\n    while (cur)\n    {\n        if (key < cur->_key)//key比当前节点小，往左子树走\n        {\n            parent = cur;\n            cur = cur->_left;\n        }\n        else if (key > cur->_key)//往右子树走\n        {\n            parent = cur;\n            cur = cur->_right;\n        }\n        else\n        {\n            return false;//key已存在，插入失败\n        }\n    }\n    //此时cur为nullptr, parent为cur的结点\n    if (key < parent->_key)parent->_left = new Node(key, value);\n    else parent->_right = new Node(key, value);\n    return true;//成功插入\n}\n```\n\n### `in_order`函数\n使用此函数`前序遍历打印`二叉树来验证其满足`搜索树`的性质\n\n这里使用递归打印,所以要借助`_in_order`子函数\n\n```C++\npublic:\n    void in_order()\n    {\n        _in_order(_root);//传入根结点\n        std::cout << std::endl;\n    }\nprotected:\n    void _in_order(Node* root)\n    {\n        if (root == nullptr) return;\n        _in_order(root->_left);//先访问左结点\n        std::cout << root->_value << \" \" << std::endl;//再访问根结点\n        _in_order(root->_right);//最后访问右结点\n    }\n```\n\n然后写一段测试代码测试性质\n\n> test.cpp\n```C++\n#include \"BSTree.h\"\n#include <vector>\nusing namespace std;\nint main()\n{\n\tvector<int> arr({ 2,3,1,5,4,6,8,7 });//准备待插入的键值对\n\tkey_value::BSTree<int, int> bst;\n\tfor (int i = 0; i < arr.size(); ++i)\n\t{\n\t\tbst.insert(arr[i],arr[i]);//这里使键值相同，方便观察\n\t}\n\n\tbst.in_order();//测试\n\n\treturn 0;\n}\n```\n\n### `find`函数\n可以用`find`函数查找对应`key`的结点。\n\n同时观察可知，控制`cur`和`parent`的移动的代码段和前面的函数很像，所以给`find`函数分出来一个`_find`子函数，并使它返回`pair<Node*,Node*>`，将这两个指针返回利于其它函数对`_find`的回调\n\n同时为了简化代码，继续用`typedef`封装类型\n\n```C++\npublic:\n    typedef std::pair< Node*, Node* > PNN;//简化代码\n    bool find(const K& key)\n    {\n        return _find(key).first != nullptr;//检查是否找到\n    }\nprotected:\n\n    PNN _find(const K& key)//返回PNN用于简化其它接口\n    {\n        if (_root == nullptr) return {nullptr,nullptr};\n        Node* cur = _root;\n        Node* parent = nullptr;\n        while (cur)\n        {\n            if (key < cur->_key)//key比当前节点小，往左子树走\n            {\n                parent = cur;\n                cur = cur->_left;\n            }\n            else if (key > cur->_key)//往右子树走\n            {\n                parent = cur;\n                cur = cur->_right;\n            }\n            else\n            {\n                //找到key\n                return { cur,parent };\n            }\n        }\n        //没找到key,cur为nullptr\n        return { nullptr,parent };\n    }\n```\n\n#### 重写`insert`函数\n```C++\n    bool insert(const K& key, const V& value)\n    {\n        if (_root == nullptr)//空树\n        {\n            _root = new Node(key, value);\n            return true;\n        }\n        //====修改的部分====\n        PNN pnn = _find(key);\n\n        Node* cur = pnn.first;\n        Node* parent = pnn.second;\n\n        if (cur != nullptr)//该key已存在，插入失败\n        {\n            return false;\n        }\n        //================\n        \n        //此时cur为nullptr, parent为cur的结点\n        if (key < parent->_key)parent->_left = new Node(key, value);\n        else parent->_right = new Node(key, value);\n        return true;//成功插入\n    }\n```\n\n### `erase`函数\n这里也可以复用`_find`来方便地删除结点\n\n这里要考虑的情况有:\n+ 树为空\n+ 删除最后一个结点\n+ 删除根节点\n+ 左子树为空（包括叶子结点）\n+ 右子树为空\n+ 删除一般的结点\n\n当树有`>=2`个结点，且要删除`非叶子`结点时，要考虑`结点替换`，否则二叉树会断掉，这里一般两种策略，取左子树的最右结点（最大结点），或取右子树的最左结点（最小结点）\n\n```C++\npublic:\n    bool erase(const K& key)\n    {\n        if (_root == nullptr)return false;//空树无法删除\n        if (_root->_key == key && _root->_left == nullptr && _root->_right == nullptr)//删除最后一个结点\n        {\n            delete _root;\n            _root = nullptr;\n        }\n        PNN pnn = _find(key);\n        Node* cur = pnn.first;\n        Node* parent = pnn.second;\n        if (cur == nullptr) return false;//没找到该结点\n\n        //下面的cur必不为空\n        if(cur->_left == nullptr)\n        {\n            if (cur == _root)//为根节点时要替换根节点\n            {\n                Node* right = _root->_right;\n                delete _root;\n                _root = right;\n            }\n            //没有左子树，则直接移除结点,右子树替代原结点\n            if (cur == parent->_left) parent->_left = cur->_right;\n            else parent->_right = cur->_right;\n            delete cur;\n        }\n        else if (cur->_right == nullptr)\n        {\n            if (cur == _root)\n            {\n                Node* left = _root->_left;\n                delete _root;\n                _root = left;\n            }\n            //直接过继左子树\n            if (cur == parent->_left)parent->_left = cur->_left;\n            else parent->_right = cur->_left;\n        }\n        else \n        {\n            //找到左子树的最右结点\n            Node* _cur = cur->_left;\n            Node* _parent = cur;\n            while (_cur->_right != nullptr)\n            {\n                _parent = _cur;\n                _cur = _cur->_right;\n            }\n            //移走结点\n            if (_cur == _parent->_left) _parent->_left = nullptr;\n            else _parent->_right = nullptr;\n            //获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点\n            _cur->_left = cur->_left;\n            _cur->_right = cur->_right;\n            //代替cur的位置\n            if (cur == _root)//删除根结点时\n            {\n                delete _root;\n                _root = _cur;\n            }\n            else//删除普通结点时\n            {\n                if (cur == parent->_left) parent->_left = _cur;\n                else parent->_right = _cur;\n                delete cur;\n            }\n\n        }\n        return true;\n    }\n```\n\n### 拷贝构造\n利用二叉树的性质，可以再构建个`copy`子函数来递归拷贝\n\n```C++\npublic:\n    BSTree(const BSTree<K>& t)\n    {\n        _root = Copy(t._root);\n    }\nprotected:\n    Node* copy(Node* root)\n    {\n        if (root == nullptr) return nullptr;//递归出口\n        Node* pnode = new Node(root->_key, root->_value);//复制结点\n        pnode->_left = copy(root->_left);\n        pnode->_right = copy(root->_right);\n        return pnode;\n    }\n```\n### 析构函数\n这里也用`destroy`子函数来递归地后序遍历依次删除各个结点\n```C++\npublic:\n    ~BSTree()\n    {\n        destroy(_root);\n    }\nprotected:\n    void destroy(Node* root)\n    {\n        if (root == nullptr) return;\n        destroy(root->_left);\n        destroy(root->_right);\n        delete root;\n    }\n```\n\n至此，一个基本的二叉搜索树已封装完成\n\n实现的功能有\n\n+ 构建二叉搜索树\n+ 拷贝复制二叉树\n+ 按`key`值查找\n+ 按`key`值删除\n\n### 完整代码\n```C++\n#pragma once\n#include <iostream>\n#include <utility>\n\nnamespace key_value\n{\n\ttemplate<class K,class V>\n\tclass BSTNode\n\t{\n\tpublic:\n\t\tBSTNode(const K& key = K(), const V& value = V())\n\t\t\t:_left(nullptr)\n\t\t\t, _right(nullptr)\n\t\t\t, _key(key)\n\t\t\t, _value(value)\n\t\t{}\n\t\tBSTNode<K, V>* _left;//指向左子树\n\t\tBSTNode<K, V>* _right;//指向右子树\n\t\tK _key;//储存键\n\t\tV _value;//储存值\n\t};\n\n\ttemplate<class K,class V>\n\tclass BSTree\n\t{\n\t\ttypedef BSTNode<K, V> Node;//使用typedef简化代码\n\tpublic:\n\t\tBSTree() :_root(nullptr) {}//提供默认构造函数\n\n\t\tBSTree(const BSTree<K, V>& bst)\n\t\t{\n\t\t\t_root = copy(bst._root);\n\t\t}\n\n\t\t~BSTree()\n\t\t{\n\t\t\tdestroy(_root);\n\t\t}\n\n\t\tbool insert(const K& key, const V& value)\n\t\t{\n\t\t\tif (_root == nullptr)//空树\n\t\t\t{\n\t\t\t\t_root = new Node(key, value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t//====修改的部分====\n\t\t\tPNN pnn = _find(key);\n\n\t\t\tNode* cur = pnn.first;\n\t\t\tNode* parent = pnn.second;\n\n\t\t\tif (cur != nullptr)//该key已存在，插入失败\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//================\n\t\t\t\n\t\t\t//此时cur为nullptr, parent为cur的结点\n\t\t\tif (key < parent->_key)parent->_left = new Node(key, value);\n\t\t\telse parent->_right = new Node(key, value);\n\t\t\treturn true;//成功插入\n\t\t}\n\n\t\tvoid in_order()\n\t\t{\n\t\t\t_in_order(_root);//传入根结点\n\t\t\tstd::cout << std::endl;\n\t\t}\n\tprotected:\n\t\tvoid _in_order(Node* root)\n\t\t{\n\t\t\tif (root == nullptr) return;\n\t\t\t_in_order(root->_left);//先访问左结点\n\t\t\tstd::cout << root->_value << \" \";//再访问根结点\n\t\t\t_in_order(root->_right);//最后访问右结点\n\t\t}\n\n\n\tpublic:\n\t\ttypedef std::pair< Node*, Node* > PNN;//简化代码\n\t\tbool find(const K& key)\n\t\t{\n\t\t\treturn _find(key).first != nullptr;//检查是否找到\n\t\t}\n\tprotected:\n\t\n\t\tPNN _find(const K& key)//返回PNN用于简化其它接口\n\t\t{\n\t\t\tif (_root == nullptr) return {nullptr,nullptr};\n\t\t\tNode* cur = _root;\n\t\t\tNode* parent = nullptr;\n\t\t\twhile (cur)\n\t\t\t{\n\t\t\t\tif (key < cur->_key)//key比当前节点小，往左子树走\n\t\t\t\t{\n\t\t\t\t\tparent = cur;\n\t\t\t\t\tcur = cur->_left;\n\t\t\t\t}\n\t\t\t\telse if (key > cur->_key)//往右子树走\n\t\t\t\t{\n\t\t\t\t\tparent = cur;\n\t\t\t\t\tcur = cur->_right;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//找到key\n\t\t\t\t\treturn { cur,parent };\n\t\t\t\t}\n\t\t\t}\n\t\t\t//没找到key,cur为nullptr\n\t\t\treturn { nullptr,parent };\n\t\t}\n\tpublic:\n\n\t\tbool erase(const K& key)\n\t\t{\n\t\t\tif (_root == nullptr)return false;//空树无法删除\n\t\t\tif (_root->_key == key && _root->_left == nullptr && _root->_right == nullptr)//删除最后一个结点\n\t\t\t{\n\t\t\t\tdelete _root;\n\t\t\t\t_root = nullptr;\n\t\t\t}\n\t\t\tPNN pnn = _find(key);\n\t\t\tNode* cur = pnn.first;\n\t\t\tNode* parent = pnn.second;\n\t\t\tif (cur == nullptr) return false;//没找到该结点\n\n\t\t\t//下面的cur必不为空\n\t\t\tif(cur->_left == nullptr)\n\t\t\t{\n\t\t\t\tif (cur == _root)//为根节点时要替换根节点\n\t\t\t\t{\n\t\t\t\t\tNode* right = _root->_right;\n\t\t\t\t\tdelete _root;\n\t\t\t\t\t_root = right;\n\t\t\t\t}\n\t\t\t\t//没有左子树，则直接移除结点,右子树替代原结点\n\t\t\t\tif (cur == parent->_left) parent->_left = cur->_right;\n\t\t\t\telse parent->_right = cur->_right;\n\t\t\t\tdelete cur;\n\t\t\t}\n\t\t\telse if (cur->_right == nullptr)\n\t\t\t{\n\t\t\t\tif (cur == _root)\n\t\t\t\t{\n\t\t\t\t\tNode* left = _root->_left;\n\t\t\t\t\tdelete _root;\n\t\t\t\t\t_root = left;\n\t\t\t\t}\n\t\t\t\t//直接过继左子树\n\t\t\t\tif (cur == parent->_left)parent->_left = cur->_left;\n\t\t\t\telse parent->_right = cur->_left;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\t//找到左子树的最右结点\n\t\t\t\tNode* _cur = cur->_left;\n\t\t\t\tNode* _parent = cur;\n\t\t\t\twhile (_cur->_right != nullptr)\n\t\t\t\t{\n\t\t\t\t\t_parent = _cur;\n\t\t\t\t\t_cur = _cur->_right;\n\t\t\t\t}\n\t\t\t\t//移走结点\n\t\t\t\tif (_cur == _parent->_left) _parent->_left = nullptr;\n\t\t\t\telse _parent->_right = nullptr;\n\t\t\t\t//获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点\n\t\t\t\t_cur->_left = cur->_left;\n\t\t\t\t_cur->_right = cur->_right;\n\t\t\t\t//代替cur的位置\n\t\t\t\tif (cur == _root)//删除根结点时\n\t\t\t\t{\n\t\t\t\t\tdelete _root;\n\t\t\t\t\t_root = _cur;\n\t\t\t\t}\n\t\t\t\telse//删除普通结点时\n\t\t\t\t{\n\t\t\t\t\tif (cur == parent->_left) parent->_left = _cur;\n\t\t\t\t\telse parent->_right = _cur;\n\t\t\t\t\tdelete cur;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\n\tprotected:\n\t\tNode* copy(Node* root)\n\t\t{\n\t\t\tif (root == nullptr) return nullptr;//递归出口\n\t\t\tNode* pnode = new Node(root->_key, root->_value);//复制结点\n\t\t\tpnode->_left = copy(root->_left);\n\t\t\tpnode->_right = copy(root->_right);\n\t\t\treturn pnode;\n\t\t}\n\n\t\tvoid destroy(Node* root)\n\t\t{\n\t\t\tif (root == nullptr) return;\n\t\t\tdestroy(root->_left);\n\t\t\tdestroy(root->_right);\n\t\t\tdelete root;\n\t\t}\n\tprivate:\n\t\tNode* _root;//指向根节点的指针作为成员变量\n\t};\n}\n```\n","slug":"BSTree","published":1,"updated":"2024-07-31T09:17:36.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08100054sp51602g02t","content":"<h1 id=\"什么是二叉搜索树\"><a href=\"#什么是二叉搜索树\" class=\"headerlink\" title=\"什么是二叉搜索树\"></a>什么是二叉搜索树</h1><p>二叉搜索树的<code>定义</code>是一颗二叉树的所有节点满足:<code>根的左右孩子存在时，满足 左孩子 &lt; 根 &lt; 右孩子</code></p>\n<p><code>递归定义</code>则是:</p>\n<ol>\n<li><code>左子树的根</code> &lt; <code>根</code> &lt; <code>右子树的根</code></li>\n<li><code>左子树是二叉搜索树</code>,<code>右子树是二叉搜索树</code></li>\n</ol>\n<h2 id=\"写一个验证二叉搜索树的函数\"><a href=\"#写一个验证二叉搜索树的函数\" class=\"headerlink\" title=\"写一个验证二叉搜索树的函数\"></a>写一个验证二叉搜索树的函数</h2><p><a href=\"https://leetcode.cn/problems/validate-binary-search-tree/\">Leetecode题目链接🔗</a></p>\n<h1 id=\"封装一个二叉树类\"><a href=\"#封装一个二叉树类\" class=\"headerlink\" title=\"封装一个二叉树类\"></a>封装一个二叉树类</h1><h2 id=\"文件布置\"><a href=\"#文件布置\" class=\"headerlink\" title=\"文件布置\"></a>文件布置</h2><ul>\n<li><code>BSTree.h</code>用于声明和实现<code>BSTree</code>类</li>\n<li><code>test.cpp</code>用于测试</li>\n</ul>\n<h3 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h3><p><code>BSTree.h</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>test.cpp</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;BSTree.h&quot;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> key_value</span><br></pre></td></tr></table></figure>\n<p>这里使用<code>key_value</code>作为命名空间，表示这是键值表示的搜索二叉树</p>\n<h2 id=\"定义节点\"><a href=\"#定义节点\" class=\"headerlink\" title=\"定义节点\"></a>定义节点</h2><p>二叉树的节点用于储存<code>键值对</code>和<code>左右指针</code>，并提供<code>默认构造函数</code>,使用<code>初始化列表</code>初始化成员变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BSTNode</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">BSTNode</span>(<span class=\"type\">const</span> K&amp; key = <span class=\"built_in\">K</span>(), <span class=\"type\">const</span> V&amp; value = <span class=\"built_in\">V</span>())</span><br><span class=\"line\">        :_left(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        , _right(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        , _key(key)</span><br><span class=\"line\">        , _value(value)</span><br><span class=\"line\">    &#123;&#125;</span><br><span class=\"line\">    BSTNode&lt;K, V&gt;* _left;<span class=\"comment\">//指向左子树</span></span><br><span class=\"line\">    BSTNode&lt;K, V&gt;* _right;<span class=\"comment\">//指向右子树</span></span><br><span class=\"line\">    K _key;<span class=\"comment\">//储存键</span></span><br><span class=\"line\">    V _value;<span class=\"comment\">//储存值</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"封装二叉搜索树\"><a href=\"#封装二叉搜索树\" class=\"headerlink\" title=\"封装二叉搜索树\"></a>封装二叉搜索树</h2><p><code>Binary Search Tree</code>,这里用简称<code>BSTree</code>封装</p>\n<h3 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h3><p>鉴于该类的接口基本依赖于成员变量，所以先组织好成员变量</p>\n<p>作为一颗<code>二叉树类</code>,成员变量仅需一个<code>指向根的指</code>针即可</p>\n<p>再次之前先用<code>typedef</code>定义一个<code>节点类</code>出来用于简化代码</p>\n<p>最后提供一个<code>默认构造函数</code>将<code>_root</code>初始化为<code>nullptr</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BSTree</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> BSTNode&lt;K, V&gt; Node;<span class=\"comment\">//使用typedef简化代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">BSTree</span>() :_root(<span class=\"literal\">nullptr</span>) &#123;&#125;<span class=\"comment\">//提供默认构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode* _root;<span class=\"comment\">//指向根节点的指针作为成员变量</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"insert函数\"><a href=\"#insert函数\" class=\"headerlink\" title=\"insert函数\"></a><code>insert</code>函数</h3><p>准备好后第一个接口就是<code>insert</code>,用于构建搜索二叉树</p>\n<p>这里需要考虑的情况有</p>\n<ul>\n<li>空树时的插入</li>\n<li>插入的<code>key</code>已存在</li>\n<li>一般情况下成功的插入</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key, <span class=\"type\">const</span> V&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//空树</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node* cur = _root;</span><br><span class=\"line\">    Node* parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; cur-&gt;_key)<span class=\"comment\">//key比当前节点小，往左子树走</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            parent = cur;</span><br><span class=\"line\">            cur = cur-&gt;_left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; cur-&gt;_key)<span class=\"comment\">//往右子树走</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            parent = cur;</span><br><span class=\"line\">            cur = cur-&gt;_right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//key已存在，插入失败</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//此时cur为nullptr, parent为cur的结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> parent-&gt;_right = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//成功插入</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"in-order函数\"><a href=\"#in-order函数\" class=\"headerlink\" title=\"in_order函数\"></a><code>in_order</code>函数</h3><p>使用此函数<code>前序遍历打印</code>二叉树来验证其满足<code>搜索树</code>的性质</p>\n<p>这里使用递归打印,所以要借助<code>_in_order</code>子函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">in_order</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _in_order(_root);<span class=\"comment\">//传入根结点</span></span><br><span class=\"line\">        std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"type\">void</span> _in_order(Node* root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        _in_order(root-&gt;_left);<span class=\"comment\">//先访问左结点</span></span><br><span class=\"line\">        std::cout &lt;&lt; root-&gt;_value &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; std::endl;<span class=\"comment\">//再访问根结点</span></span><br><span class=\"line\">        _in_order(root-&gt;_right);<span class=\"comment\">//最后访问右结点</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后写一段测试代码测试性质</p>\n<blockquote>\n<p>test.cpp</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;BSTree.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">arr</span><span class=\"params\">(&#123; <span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span> &#125;)</span></span>;<span class=\"comment\">//准备待插入的键值对</span></span><br><span class=\"line\">\tkey_value::BSTree&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; bst;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tbst.<span class=\"built_in\">insert</span>(arr[i],arr[i]);<span class=\"comment\">//这里使键值相同，方便观察</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbst.<span class=\"built_in\">in_order</span>();<span class=\"comment\">//测试</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"find函数\"><a href=\"#find函数\" class=\"headerlink\" title=\"find函数\"></a><code>find</code>函数</h3><p>可以用<code>find</code>函数查找对应<code>key</code>的结点。</p>\n<p>同时观察可知，控制<code>cur</code>和<code>parent</code>的移动的代码段和前面的函数很像，所以给<code>find</code>函数分出来一个<code>_find</code>子函数，并使它返回<code>pair&lt;Node*,Node*&gt;</code>，将这两个指针返回利于其它函数对<code>_find</code>的回调</p>\n<p>同时为了简化代码，继续用<code>typedef</code>封装类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::pair&lt; Node*, Node* &gt; PNN;<span class=\"comment\">//简化代码</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _find(key).first != <span class=\"literal\">nullptr</span>;<span class=\"comment\">//检查是否找到</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    PNN _find(<span class=\"type\">const</span> K&amp; key)<span class=\"comment\">//返回PNN用于简化其它接口</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> &#123;<span class=\"literal\">nullptr</span>,<span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">        Node* cur = _root;</span><br><span class=\"line\">        Node* parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; cur-&gt;_key)<span class=\"comment\">//key比当前节点小，往左子树走</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                parent = cur;</span><br><span class=\"line\">                cur = cur-&gt;_left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; cur-&gt;_key)<span class=\"comment\">//往右子树走</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                parent = cur;</span><br><span class=\"line\">                cur = cur-&gt;_right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到key</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123; cur,parent &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//没找到key,cur为nullptr</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"literal\">nullptr</span>,parent &#125;;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重写insert函数\"><a href=\"#重写insert函数\" class=\"headerlink\" title=\"重写insert函数\"></a>重写<code>insert</code>函数</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key, <span class=\"type\">const</span> V&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//空树</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//====修改的部分====</span></span><br><span class=\"line\">    PNN pnn = _find(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node* cur = pnn.first;</span><br><span class=\"line\">    Node* parent = pnn.second;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur != <span class=\"literal\">nullptr</span>)<span class=\"comment\">//该key已存在，插入失败</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//================</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//此时cur为nullptr, parent为cur的结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> parent-&gt;_right = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//成功插入</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"erase函数\"><a href=\"#erase函数\" class=\"headerlink\" title=\"erase函数\"></a><code>erase</code>函数</h3><p>这里也可以复用<code>_find</code>来方便地删除结点</p>\n<p>这里要考虑的情况有:</p>\n<ul>\n<li>树为空</li>\n<li>删除最后一个结点</li>\n<li>删除根节点</li>\n<li>左子树为空（包括叶子结点）</li>\n<li>右子树为空</li>\n<li>删除一般的结点</li>\n</ul>\n<p>当树有<code>&gt;=2</code>个结点，且要删除<code>非叶子</code>结点时，要考虑<code>结点替换</code>，否则二叉树会断掉，这里一般两种策略，取左子树的最右结点（最大结点），或取右子树的最左结点（最小结点）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//空树无法删除</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_root-&gt;_key == key &amp;&amp; _root-&gt;_left == <span class=\"literal\">nullptr</span> &amp;&amp; _root-&gt;_right == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//删除最后一个结点</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">            _root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        PNN pnn = _find(key);</span><br><span class=\"line\">        Node* cur = pnn.first;</span><br><span class=\"line\">        Node* parent = pnn.second;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//没找到该结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//下面的cur必不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur-&gt;_left == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur == _root)<span class=\"comment\">//为根节点时要替换根节点</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Node* right = _root-&gt;_right;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">                _root = right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//没有左子树，则直接移除结点,右子树替代原结点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur == parent-&gt;_left) parent-&gt;_left = cur-&gt;_right;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> parent-&gt;_right = cur-&gt;_right;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur-&gt;_right == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur == _root)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Node* left = _root-&gt;_left;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">                _root = left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//直接过继左子树</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur == parent-&gt;_left)parent-&gt;_left = cur-&gt;_left;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> parent-&gt;_right = cur-&gt;_left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//找到左子树的最右结点</span></span><br><span class=\"line\">            Node* _cur = cur-&gt;_left;</span><br><span class=\"line\">            Node* _parent = cur;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (_cur-&gt;_right != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                _parent = _cur;</span><br><span class=\"line\">                _cur = _cur-&gt;_right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//移走结点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_cur == _parent-&gt;_left) _parent-&gt;_left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> _parent-&gt;_right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"comment\">//获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点</span></span><br><span class=\"line\">            _cur-&gt;_left = cur-&gt;_left;</span><br><span class=\"line\">            _cur-&gt;_right = cur-&gt;_right;</span><br><span class=\"line\">            <span class=\"comment\">//代替cur的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur == _root)<span class=\"comment\">//删除根结点时</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">                _root = _cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//删除普通结点时</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur == parent-&gt;_left) parent-&gt;_left = _cur;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> parent-&gt;_right = _cur;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"拷贝构造\"><a href=\"#拷贝构造\" class=\"headerlink\" title=\"拷贝构造\"></a>拷贝构造</h3><p>利用二叉树的性质，可以再构建个<code>copy</code>子函数来递归拷贝</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">BSTree</span>(<span class=\"type\">const</span> BSTree&lt;K&gt;&amp; t)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _root = <span class=\"built_in\">Copy</span>(t._root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\">Node* <span class=\"title\">copy</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;<span class=\"comment\">//递归出口</span></span><br><span class=\"line\">        Node* pnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(root-&gt;_key, root-&gt;_value);<span class=\"comment\">//复制结点</span></span><br><span class=\"line\">        pnode-&gt;_left = <span class=\"built_in\">copy</span>(root-&gt;_left);</span><br><span class=\"line\">        pnode-&gt;_right = <span class=\"built_in\">copy</span>(root-&gt;_right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pnode;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>这里也用<code>destroy</code>子函数来递归地后序遍历依次删除各个结点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">BSTree</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroy</span>(_root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroy</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">destroy</span>(root-&gt;_left);</span><br><span class=\"line\">        <span class=\"built_in\">destroy</span>(root-&gt;_right);</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，一个基本的二叉搜索树已封装完成</p>\n<p>实现的功能有</p>\n<ul>\n<li>构建二叉搜索树</li>\n<li>拷贝复制二叉树</li>\n<li>按<code>key</code>值查找</li>\n<li>按<code>key</code>值删除</li>\n</ul>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> key_value</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">BSTNode</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">BSTNode</span>(<span class=\"type\">const</span> K&amp; key = <span class=\"built_in\">K</span>(), <span class=\"type\">const</span> V&amp; value = <span class=\"built_in\">V</span>())</span><br><span class=\"line\">\t\t\t:_left(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t, _right(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t, _key(key)</span><br><span class=\"line\">\t\t\t, _value(value)</span><br><span class=\"line\">\t\t&#123;&#125;</span><br><span class=\"line\">\t\tBSTNode&lt;K, V&gt;* _left;<span class=\"comment\">//指向左子树</span></span><br><span class=\"line\">\t\tBSTNode&lt;K, V&gt;* _right;<span class=\"comment\">//指向右子树</span></span><br><span class=\"line\">\t\tK _key;<span class=\"comment\">//储存键</span></span><br><span class=\"line\">\t\tV _value;<span class=\"comment\">//储存值</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">BSTree</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">typedef</span> BSTNode&lt;K, V&gt; Node;<span class=\"comment\">//使用typedef简化代码</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">BSTree</span>() :_root(<span class=\"literal\">nullptr</span>) &#123;&#125;<span class=\"comment\">//提供默认构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">BSTree</span>(<span class=\"type\">const</span> BSTree&lt;K, V&gt;&amp; bst)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = <span class=\"built_in\">copy</span>(bst._root);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t~<span class=\"built_in\">BSTree</span>()</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">destroy</span>(_root);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key, <span class=\"type\">const</span> V&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//空树</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t_root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//====修改的部分====</span></span><br><span class=\"line\">\t\t\tPNN pnn = _find(key);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tNode* cur = pnn.first;</span><br><span class=\"line\">\t\t\tNode* parent = pnn.second;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cur != <span class=\"literal\">nullptr</span>)<span class=\"comment\">//该key已存在，插入失败</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//================</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//此时cur为nullptr, parent为cur的结点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> parent-&gt;_right = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//成功插入</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">in_order</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t_in_order(_root);<span class=\"comment\">//传入根结点</span></span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> _in_order(Node* root)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t_in_order(root-&gt;_left);<span class=\"comment\">//先访问左结点</span></span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; root-&gt;_value &lt;&lt; <span class=\"string\">&quot; &quot;</span>;<span class=\"comment\">//再访问根结点</span></span><br><span class=\"line\">\t\t\t_in_order(root-&gt;_right);<span class=\"comment\">//最后访问右结点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">typedef</span> std::pair&lt; Node*, Node* &gt; PNN;<span class=\"comment\">//简化代码</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> _find(key).first != <span class=\"literal\">nullptr</span>;<span class=\"comment\">//检查是否找到</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tPNN _find(<span class=\"type\">const</span> K&amp; key)<span class=\"comment\">//返回PNN用于简化其它接口</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> &#123;<span class=\"literal\">nullptr</span>,<span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">\t\t\tNode* cur = _root;</span><br><span class=\"line\">\t\t\tNode* parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (key &lt; cur-&gt;_key)<span class=\"comment\">//key比当前节点小，往左子树走</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\t\tcur = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; cur-&gt;_key)<span class=\"comment\">//往右子树走</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\t\tcur = cur-&gt;_right;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//找到key</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> &#123; cur,parent &#125;;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//没找到key,cur为nullptr</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> &#123; <span class=\"literal\">nullptr</span>,parent &#125;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//空树无法删除</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_root-&gt;_key == key &amp;&amp; _root-&gt;_left == <span class=\"literal\">nullptr</span> &amp;&amp; _root-&gt;_right == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//删除最后一个结点</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">\t\t\t\t_root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tPNN pnn = _find(key);</span><br><span class=\"line\">\t\t\tNode* cur = pnn.first;</span><br><span class=\"line\">\t\t\tNode* parent = pnn.second;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cur == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//没找到该结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//下面的cur必不为空</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(cur-&gt;_left == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cur == _root)<span class=\"comment\">//为根节点时要替换根节点</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tNode* right = _root-&gt;_right;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">\t\t\t\t\t_root = right;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//没有左子树，则直接移除结点,右子树替代原结点</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cur == parent-&gt;_left) parent-&gt;_left = cur-&gt;_right;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> parent-&gt;_right = cur-&gt;_right;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">delete</span> cur;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur-&gt;_right == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cur == _root)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tNode* left = _root-&gt;_left;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">\t\t\t\t\t_root = left;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//直接过继左子树</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cur == parent-&gt;_left)parent-&gt;_left = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> parent-&gt;_right = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//找到左子树的最右结点</span></span><br><span class=\"line\">\t\t\t\tNode* _cur = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t\tNode* _parent = cur;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (_cur-&gt;_right != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t_parent = _cur;</span><br><span class=\"line\">\t\t\t\t\t_cur = _cur-&gt;_right;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//移走结点</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (_cur == _parent-&gt;_left) _parent-&gt;_left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> _parent-&gt;_right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点</span></span><br><span class=\"line\">\t\t\t\t_cur-&gt;_left = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t\t_cur-&gt;_right = cur-&gt;_right;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//代替cur的位置</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cur == _root)<span class=\"comment\">//删除根结点时</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">\t\t\t\t\t_root = _cur;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span><span class=\"comment\">//删除普通结点时</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (cur == parent-&gt;_left) parent-&gt;_left = _cur;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span> parent-&gt;_right = _cur;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> cur;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t<span class=\"function\">Node* <span class=\"title\">copy</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;<span class=\"comment\">//递归出口</span></span><br><span class=\"line\">\t\t\tNode* pnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(root-&gt;_key, root-&gt;_value);<span class=\"comment\">//复制结点</span></span><br><span class=\"line\">\t\t\tpnode-&gt;_left = <span class=\"built_in\">copy</span>(root-&gt;_left);</span><br><span class=\"line\">\t\t\tpnode-&gt;_right = <span class=\"built_in\">copy</span>(root-&gt;_right);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> pnode;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroy</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">destroy</span>(root-&gt;_left);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">destroy</span>(root-&gt;_right);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\tNode* _root;<span class=\"comment\">//指向根节点的指针作为成员变量</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/12a4cf6640ed132e210ab645ff95c1e2.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"什么是二叉搜索树\"><a href=\"#什么是二叉搜索树\" class=\"headerlink\" title=\"什么是二叉搜索树\"></a>什么是二叉搜索树</h1><p>二叉搜索树的<code>定义</code>是一颗二叉树的所有节点满足:<code>根的左右孩子存在时，满足 左孩子 &lt; 根 &lt; 右孩子</code></p>\n<p><code>递归定义</code>则是:</p>\n<ol>\n<li><code>左子树的根</code> &lt; <code>根</code> &lt; <code>右子树的根</code></li>\n<li><code>左子树是二叉搜索树</code>,<code>右子树是二叉搜索树</code></li>\n</ol>\n<h2 id=\"写一个验证二叉搜索树的函数\"><a href=\"#写一个验证二叉搜索树的函数\" class=\"headerlink\" title=\"写一个验证二叉搜索树的函数\"></a>写一个验证二叉搜索树的函数</h2><p><a href=\"https://leetcode.cn/problems/validate-binary-search-tree/\">Leetecode题目链接🔗</a></p>\n<h1 id=\"封装一个二叉树类\"><a href=\"#封装一个二叉树类\" class=\"headerlink\" title=\"封装一个二叉树类\"></a>封装一个二叉树类</h1><h2 id=\"文件布置\"><a href=\"#文件布置\" class=\"headerlink\" title=\"文件布置\"></a>文件布置</h2><ul>\n<li><code>BSTree.h</code>用于声明和实现<code>BSTree</code>类</li>\n<li><code>test.cpp</code>用于测试</li>\n</ul>\n<h3 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h3><p><code>BSTree.h</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>test.cpp</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;BSTree.h&quot;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> key_value</span><br></pre></td></tr></table></figure>\n<p>这里使用<code>key_value</code>作为命名空间，表示这是键值表示的搜索二叉树</p>\n<h2 id=\"定义节点\"><a href=\"#定义节点\" class=\"headerlink\" title=\"定义节点\"></a>定义节点</h2><p>二叉树的节点用于储存<code>键值对</code>和<code>左右指针</code>，并提供<code>默认构造函数</code>,使用<code>初始化列表</code>初始化成员变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BSTNode</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">BSTNode</span>(<span class=\"type\">const</span> K&amp; key = <span class=\"built_in\">K</span>(), <span class=\"type\">const</span> V&amp; value = <span class=\"built_in\">V</span>())</span><br><span class=\"line\">        :_left(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        , _right(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        , _key(key)</span><br><span class=\"line\">        , _value(value)</span><br><span class=\"line\">    &#123;&#125;</span><br><span class=\"line\">    BSTNode&lt;K, V&gt;* _left;<span class=\"comment\">//指向左子树</span></span><br><span class=\"line\">    BSTNode&lt;K, V&gt;* _right;<span class=\"comment\">//指向右子树</span></span><br><span class=\"line\">    K _key;<span class=\"comment\">//储存键</span></span><br><span class=\"line\">    V _value;<span class=\"comment\">//储存值</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"封装二叉搜索树\"><a href=\"#封装二叉搜索树\" class=\"headerlink\" title=\"封装二叉搜索树\"></a>封装二叉搜索树</h2><p><code>Binary Search Tree</code>,这里用简称<code>BSTree</code>封装</p>\n<h3 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h3><p>鉴于该类的接口基本依赖于成员变量，所以先组织好成员变量</p>\n<p>作为一颗<code>二叉树类</code>,成员变量仅需一个<code>指向根的指</code>针即可</p>\n<p>再次之前先用<code>typedef</code>定义一个<code>节点类</code>出来用于简化代码</p>\n<p>最后提供一个<code>默认构造函数</code>将<code>_root</code>初始化为<code>nullptr</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BSTree</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> BSTNode&lt;K, V&gt; Node;<span class=\"comment\">//使用typedef简化代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">BSTree</span>() :_root(<span class=\"literal\">nullptr</span>) &#123;&#125;<span class=\"comment\">//提供默认构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode* _root;<span class=\"comment\">//指向根节点的指针作为成员变量</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"insert函数\"><a href=\"#insert函数\" class=\"headerlink\" title=\"insert函数\"></a><code>insert</code>函数</h3><p>准备好后第一个接口就是<code>insert</code>,用于构建搜索二叉树</p>\n<p>这里需要考虑的情况有</p>\n<ul>\n<li>空树时的插入</li>\n<li>插入的<code>key</code>已存在</li>\n<li>一般情况下成功的插入</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key, <span class=\"type\">const</span> V&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//空树</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node* cur = _root;</span><br><span class=\"line\">    Node* parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; cur-&gt;_key)<span class=\"comment\">//key比当前节点小，往左子树走</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            parent = cur;</span><br><span class=\"line\">            cur = cur-&gt;_left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; cur-&gt;_key)<span class=\"comment\">//往右子树走</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            parent = cur;</span><br><span class=\"line\">            cur = cur-&gt;_right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//key已存在，插入失败</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//此时cur为nullptr, parent为cur的结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> parent-&gt;_right = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//成功插入</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"in-order函数\"><a href=\"#in-order函数\" class=\"headerlink\" title=\"in_order函数\"></a><code>in_order</code>函数</h3><p>使用此函数<code>前序遍历打印</code>二叉树来验证其满足<code>搜索树</code>的性质</p>\n<p>这里使用递归打印,所以要借助<code>_in_order</code>子函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">in_order</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _in_order(_root);<span class=\"comment\">//传入根结点</span></span><br><span class=\"line\">        std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"type\">void</span> _in_order(Node* root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        _in_order(root-&gt;_left);<span class=\"comment\">//先访问左结点</span></span><br><span class=\"line\">        std::cout &lt;&lt; root-&gt;_value &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; std::endl;<span class=\"comment\">//再访问根结点</span></span><br><span class=\"line\">        _in_order(root-&gt;_right);<span class=\"comment\">//最后访问右结点</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后写一段测试代码测试性质</p>\n<blockquote>\n<p>test.cpp</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;BSTree.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">arr</span><span class=\"params\">(&#123; <span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span> &#125;)</span></span>;<span class=\"comment\">//准备待插入的键值对</span></span><br><span class=\"line\">\tkey_value::BSTree&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; bst;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tbst.<span class=\"built_in\">insert</span>(arr[i],arr[i]);<span class=\"comment\">//这里使键值相同，方便观察</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbst.<span class=\"built_in\">in_order</span>();<span class=\"comment\">//测试</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"find函数\"><a href=\"#find函数\" class=\"headerlink\" title=\"find函数\"></a><code>find</code>函数</h3><p>可以用<code>find</code>函数查找对应<code>key</code>的结点。</p>\n<p>同时观察可知，控制<code>cur</code>和<code>parent</code>的移动的代码段和前面的函数很像，所以给<code>find</code>函数分出来一个<code>_find</code>子函数，并使它返回<code>pair&lt;Node*,Node*&gt;</code>，将这两个指针返回利于其它函数对<code>_find</code>的回调</p>\n<p>同时为了简化代码，继续用<code>typedef</code>封装类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::pair&lt; Node*, Node* &gt; PNN;<span class=\"comment\">//简化代码</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _find(key).first != <span class=\"literal\">nullptr</span>;<span class=\"comment\">//检查是否找到</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    PNN _find(<span class=\"type\">const</span> K&amp; key)<span class=\"comment\">//返回PNN用于简化其它接口</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> &#123;<span class=\"literal\">nullptr</span>,<span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">        Node* cur = _root;</span><br><span class=\"line\">        Node* parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &lt; cur-&gt;_key)<span class=\"comment\">//key比当前节点小，往左子树走</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                parent = cur;</span><br><span class=\"line\">                cur = cur-&gt;_left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; cur-&gt;_key)<span class=\"comment\">//往右子树走</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                parent = cur;</span><br><span class=\"line\">                cur = cur-&gt;_right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到key</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123; cur,parent &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//没找到key,cur为nullptr</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"literal\">nullptr</span>,parent &#125;;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重写insert函数\"><a href=\"#重写insert函数\" class=\"headerlink\" title=\"重写insert函数\"></a>重写<code>insert</code>函数</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key, <span class=\"type\">const</span> V&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//空树</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//====修改的部分====</span></span><br><span class=\"line\">    PNN pnn = _find(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node* cur = pnn.first;</span><br><span class=\"line\">    Node* parent = pnn.second;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur != <span class=\"literal\">nullptr</span>)<span class=\"comment\">//该key已存在，插入失败</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//================</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//此时cur为nullptr, parent为cur的结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> parent-&gt;_right = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//成功插入</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"erase函数\"><a href=\"#erase函数\" class=\"headerlink\" title=\"erase函数\"></a><code>erase</code>函数</h3><p>这里也可以复用<code>_find</code>来方便地删除结点</p>\n<p>这里要考虑的情况有:</p>\n<ul>\n<li>树为空</li>\n<li>删除最后一个结点</li>\n<li>删除根节点</li>\n<li>左子树为空（包括叶子结点）</li>\n<li>右子树为空</li>\n<li>删除一般的结点</li>\n</ul>\n<p>当树有<code>&gt;=2</code>个结点，且要删除<code>非叶子</code>结点时，要考虑<code>结点替换</code>，否则二叉树会断掉，这里一般两种策略，取左子树的最右结点（最大结点），或取右子树的最左结点（最小结点）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//空树无法删除</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_root-&gt;_key == key &amp;&amp; _root-&gt;_left == <span class=\"literal\">nullptr</span> &amp;&amp; _root-&gt;_right == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//删除最后一个结点</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">            _root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        PNN pnn = _find(key);</span><br><span class=\"line\">        Node* cur = pnn.first;</span><br><span class=\"line\">        Node* parent = pnn.second;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//没找到该结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//下面的cur必不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur-&gt;_left == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur == _root)<span class=\"comment\">//为根节点时要替换根节点</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Node* right = _root-&gt;_right;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">                _root = right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//没有左子树，则直接移除结点,右子树替代原结点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur == parent-&gt;_left) parent-&gt;_left = cur-&gt;_right;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> parent-&gt;_right = cur-&gt;_right;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur-&gt;_right == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur == _root)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Node* left = _root-&gt;_left;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">                _root = left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//直接过继左子树</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur == parent-&gt;_left)parent-&gt;_left = cur-&gt;_left;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> parent-&gt;_right = cur-&gt;_left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//找到左子树的最右结点</span></span><br><span class=\"line\">            Node* _cur = cur-&gt;_left;</span><br><span class=\"line\">            Node* _parent = cur;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (_cur-&gt;_right != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                _parent = _cur;</span><br><span class=\"line\">                _cur = _cur-&gt;_right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//移走结点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_cur == _parent-&gt;_left) _parent-&gt;_left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> _parent-&gt;_right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"comment\">//获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点</span></span><br><span class=\"line\">            _cur-&gt;_left = cur-&gt;_left;</span><br><span class=\"line\">            _cur-&gt;_right = cur-&gt;_right;</span><br><span class=\"line\">            <span class=\"comment\">//代替cur的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur == _root)<span class=\"comment\">//删除根结点时</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">                _root = _cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//删除普通结点时</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur == parent-&gt;_left) parent-&gt;_left = _cur;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> parent-&gt;_right = _cur;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"拷贝构造\"><a href=\"#拷贝构造\" class=\"headerlink\" title=\"拷贝构造\"></a>拷贝构造</h3><p>利用二叉树的性质，可以再构建个<code>copy</code>子函数来递归拷贝</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">BSTree</span>(<span class=\"type\">const</span> BSTree&lt;K&gt;&amp; t)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _root = <span class=\"built_in\">Copy</span>(t._root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\">Node* <span class=\"title\">copy</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;<span class=\"comment\">//递归出口</span></span><br><span class=\"line\">        Node* pnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(root-&gt;_key, root-&gt;_value);<span class=\"comment\">//复制结点</span></span><br><span class=\"line\">        pnode-&gt;_left = <span class=\"built_in\">copy</span>(root-&gt;_left);</span><br><span class=\"line\">        pnode-&gt;_right = <span class=\"built_in\">copy</span>(root-&gt;_right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pnode;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>这里也用<code>destroy</code>子函数来递归地后序遍历依次删除各个结点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">BSTree</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroy</span>(_root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroy</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">destroy</span>(root-&gt;_left);</span><br><span class=\"line\">        <span class=\"built_in\">destroy</span>(root-&gt;_right);</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，一个基本的二叉搜索树已封装完成</p>\n<p>实现的功能有</p>\n<ul>\n<li>构建二叉搜索树</li>\n<li>拷贝复制二叉树</li>\n<li>按<code>key</code>值查找</li>\n<li>按<code>key</code>值删除</li>\n</ul>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> key_value</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">BSTNode</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">BSTNode</span>(<span class=\"type\">const</span> K&amp; key = <span class=\"built_in\">K</span>(), <span class=\"type\">const</span> V&amp; value = <span class=\"built_in\">V</span>())</span><br><span class=\"line\">\t\t\t:_left(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t, _right(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t, _key(key)</span><br><span class=\"line\">\t\t\t, _value(value)</span><br><span class=\"line\">\t\t&#123;&#125;</span><br><span class=\"line\">\t\tBSTNode&lt;K, V&gt;* _left;<span class=\"comment\">//指向左子树</span></span><br><span class=\"line\">\t\tBSTNode&lt;K, V&gt;* _right;<span class=\"comment\">//指向右子树</span></span><br><span class=\"line\">\t\tK _key;<span class=\"comment\">//储存键</span></span><br><span class=\"line\">\t\tV _value;<span class=\"comment\">//储存值</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">BSTree</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">typedef</span> BSTNode&lt;K, V&gt; Node;<span class=\"comment\">//使用typedef简化代码</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">BSTree</span>() :_root(<span class=\"literal\">nullptr</span>) &#123;&#125;<span class=\"comment\">//提供默认构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">BSTree</span>(<span class=\"type\">const</span> BSTree&lt;K, V&gt;&amp; bst)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_root = <span class=\"built_in\">copy</span>(bst._root);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t~<span class=\"built_in\">BSTree</span>()</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">destroy</span>(_root);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key, <span class=\"type\">const</span> V&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//空树</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t_root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//====修改的部分====</span></span><br><span class=\"line\">\t\t\tPNN pnn = _find(key);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tNode* cur = pnn.first;</span><br><span class=\"line\">\t\t\tNode* parent = pnn.second;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cur != <span class=\"literal\">nullptr</span>)<span class=\"comment\">//该key已存在，插入失败</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//================</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//此时cur为nullptr, parent为cur的结点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (key &lt; parent-&gt;_key)parent-&gt;_left = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> parent-&gt;_right = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(key, value);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//成功插入</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">in_order</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t_in_order(_root);<span class=\"comment\">//传入根结点</span></span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t<span class=\"type\">void</span> _in_order(Node* root)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t_in_order(root-&gt;_left);<span class=\"comment\">//先访问左结点</span></span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; root-&gt;_value &lt;&lt; <span class=\"string\">&quot; &quot;</span>;<span class=\"comment\">//再访问根结点</span></span><br><span class=\"line\">\t\t\t_in_order(root-&gt;_right);<span class=\"comment\">//最后访问右结点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">typedef</span> std::pair&lt; Node*, Node* &gt; PNN;<span class=\"comment\">//简化代码</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> _find(key).first != <span class=\"literal\">nullptr</span>;<span class=\"comment\">//检查是否找到</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tPNN _find(<span class=\"type\">const</span> K&amp; key)<span class=\"comment\">//返回PNN用于简化其它接口</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> &#123;<span class=\"literal\">nullptr</span>,<span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">\t\t\tNode* cur = _root;</span><br><span class=\"line\">\t\t\tNode* parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (key &lt; cur-&gt;_key)<span class=\"comment\">//key比当前节点小，往左子树走</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\t\tcur = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; cur-&gt;_key)<span class=\"comment\">//往右子树走</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\t\tcur = cur-&gt;_right;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//找到key</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> &#123; cur,parent &#125;;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//没找到key,cur为nullptr</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> &#123; <span class=\"literal\">nullptr</span>,parent &#125;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_root == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//空树无法删除</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_root-&gt;_key == key &amp;&amp; _root-&gt;_left == <span class=\"literal\">nullptr</span> &amp;&amp; _root-&gt;_right == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//删除最后一个结点</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">\t\t\t\t_root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tPNN pnn = _find(key);</span><br><span class=\"line\">\t\t\tNode* cur = pnn.first;</span><br><span class=\"line\">\t\t\tNode* parent = pnn.second;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cur == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//没找到该结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//下面的cur必不为空</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(cur-&gt;_left == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cur == _root)<span class=\"comment\">//为根节点时要替换根节点</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tNode* right = _root-&gt;_right;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">\t\t\t\t\t_root = right;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//没有左子树，则直接移除结点,右子树替代原结点</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cur == parent-&gt;_left) parent-&gt;_left = cur-&gt;_right;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> parent-&gt;_right = cur-&gt;_right;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">delete</span> cur;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur-&gt;_right == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cur == _root)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tNode* left = _root-&gt;_left;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">\t\t\t\t\t_root = left;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//直接过继左子树</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cur == parent-&gt;_left)parent-&gt;_left = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> parent-&gt;_right = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//找到左子树的最右结点</span></span><br><span class=\"line\">\t\t\t\tNode* _cur = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t\tNode* _parent = cur;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (_cur-&gt;_right != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t_parent = _cur;</span><br><span class=\"line\">\t\t\t\t\t_cur = _cur-&gt;_right;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//移走结点</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (_cur == _parent-&gt;_left) _parent-&gt;_left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> _parent-&gt;_right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//获取cur的左右结点,必须再移走结点后，否则可能出现指向自己的结点</span></span><br><span class=\"line\">\t\t\t\t_cur-&gt;_left = cur-&gt;_left;</span><br><span class=\"line\">\t\t\t\t_cur-&gt;_right = cur-&gt;_right;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//代替cur的位置</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cur == _root)<span class=\"comment\">//删除根结点时</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> _root;</span><br><span class=\"line\">\t\t\t\t\t_root = _cur;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span><span class=\"comment\">//删除普通结点时</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (cur == parent-&gt;_left) parent-&gt;_left = _cur;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span> parent-&gt;_right = _cur;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">delete</span> cur;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t<span class=\"function\">Node* <span class=\"title\">copy</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;<span class=\"comment\">//递归出口</span></span><br><span class=\"line\">\t\t\tNode* pnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(root-&gt;_key, root-&gt;_value);<span class=\"comment\">//复制结点</span></span><br><span class=\"line\">\t\t\tpnode-&gt;_left = <span class=\"built_in\">copy</span>(root-&gt;_left);</span><br><span class=\"line\">\t\t\tpnode-&gt;_right = <span class=\"built_in\">copy</span>(root-&gt;_right);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> pnode;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroy</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">destroy</span>(root-&gt;_left);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">destroy</span>(root-&gt;_right);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\tNode* _root;<span class=\"comment\">//指向根节点的指针作为成员变量</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"网络股票信息爬虫与可视化","dat e":"2024-09-15T08:32:03.000Z","_content":"","source":"_posts/OLSIC.md","raw":"---\ntitle: 网络股票信息爬虫与可视化\ndat e: 2024-09-15 16:32:03\ntags:\n---\n","slug":"OLSIC","published":1,"date":"2024-09-15T08:32:03.310Z","updated":"2024-09-15T13:28:07.405Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08200074sp5a2fb0v9u","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409052348435.jpg","cover_type":"img","excerpt":"","more":""},{"title":"=C语言= 整型变量与过大的整数","date":"2023-10-13T23:09:14.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/bigint.jpg","_content":"## 整型家族 #\n在使用C语言写程序时，会储存各种长度的整型,而在整型家族中，长度的比较如下\n\n`char < short <= int <= long <long long `\n\n## 整型是如何储存在内存中的 #\n*以`char`为例*\n![char](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-14_15-33-30.jpg)\n\n`char`的长度为1个`字节`，8个`比特位`,其中**最高位**是**符号位**,`0`表示正数，`1`表示负数，剩下的位数用于储存变量的**绝对值**\n\n---\n而当使用无符号整型(带前缀`unsigned`)时，只需把符号位也用于存值即可\n\n## 能够储存的最大正整数 #\n\n`int`长度为4`字节`,能够储存的最大值为`2的31次方-1`,即**2,147,483,647**\n\n`unsigned int`能够储存的最大值为**4294967295**\n\n`unsigned long long`长度为8`字节`,能够储存的最大值为`2的64次方-1`,即**18,446,744,073,709,551,615**\n\n---\n\n## 限制 #\n\n虽然`unsigned long long`已经很大了，但当遇到`指数`,`阶乘`之类的运算时仍然可能**存不下!**(光`21!`就比`unsigned long long`长了)\n\n## 思路 #\n过大的整数，可能出现在**程序的过程**中，也可能出现在**输出**中，对于过程，可以尝试**改变实现思路**，让过程中不出现过大的整数；对于输出，可以尝试**改变输出的类型**，采用输出**字符或字符串**\n\n# 以下皆为例题 #\n\n## 1.求n!的结尾有多少个0\n\n最直白的思路就是把`n!`算出来，然后用`%10`再`/=10`的方法统计末尾的`0`,想法很简单，“实现”起来也不难，**但不幸的是**，`21!`就已经储存不了了，所以不能暴力求解\n\n所以要**改变思路**，先从末尾0是怎么来的下手。末尾的n个0来自因式分解后10的n次方，而采用质因数分解的方法，可以发现`0`来自分解后`2的n次方`和`5的n次方`,而一个数分解后`2的n次方`必定比`5的n次方` 多，所以只需统计`5的n次方`。**注意**：就别再倒回去，想着先算出阶乘再求`5的n次方`了。\n\n**这里采用逐步计数的方法**：结果中的`5的n次方`来自各个因数中`5的N次方`的累乘,所以只需要历遍每个因数，并统计其中`因数5`的次数。这样过程中就不会有过大的数字了\n\n```C\n//代码实现\nint count_num0(int n)\n{\n    int count = 0;\n    for(int i = 1;i<=n;i++)\n    {\n        int copy = i//防止改变循环变量\n        while(copy%5 == 0)//统计因数5的出现次数\n        {\n            if(copy%5 == 0)\n            {\n                count++;\n            }\n            copy/=5;\n        }\n    }\n\n    return count;\n}\n\n```\n\n## 快速输出1+2+……+10^n #\n*如下图*：当我们试图算一算答案时，发现`n`到了`10`时就已经算不出答案了\n\n![计算结果](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/gao_si.png)\n\n所以要**改变输出答案答案的方式**,观察一下`n`在`1~9`时的输出\n\n![输出](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_07-26-54.jpg)\n\n这时我们发现**答案颇有规律**：每个输出都是**两段**`先一个5，然后n-1个0`！\n\n这样我们只需**从最高位往最低位**逐位打印即可,代码如下\n\n```C\nvoid printChar(int n)//版本一，逐位打印字符(串)\n{\n    printf(\"5\");\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"0\");\n    }\n    //再重复一段\n    printf(\"5\");\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"0\");\n    }\n    printf(\"\\n\");\n}\n\nvoid printNum(int n)//版本二，逐位打印整型\n{\n    printf(\"%d\",5);\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"%d\",0);\n    }\n    //再重复一段\n    printf(\"%d\",5);\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"%d\",0);\n    }\n    printf(\"\\n\");\n}\n```","source":"_posts/BiiigInt.md","raw":"---\ntitle: =C语言= 整型变量与过大的整数\ndate: 2023-10-14 07:09:14\ntags: C语言\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/bigint.jpg\n---\n## 整型家族 #\n在使用C语言写程序时，会储存各种长度的整型,而在整型家族中，长度的比较如下\n\n`char < short <= int <= long <long long `\n\n## 整型是如何储存在内存中的 #\n*以`char`为例*\n![char](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-14_15-33-30.jpg)\n\n`char`的长度为1个`字节`，8个`比特位`,其中**最高位**是**符号位**,`0`表示正数，`1`表示负数，剩下的位数用于储存变量的**绝对值**\n\n---\n而当使用无符号整型(带前缀`unsigned`)时，只需把符号位也用于存值即可\n\n## 能够储存的最大正整数 #\n\n`int`长度为4`字节`,能够储存的最大值为`2的31次方-1`,即**2,147,483,647**\n\n`unsigned int`能够储存的最大值为**4294967295**\n\n`unsigned long long`长度为8`字节`,能够储存的最大值为`2的64次方-1`,即**18,446,744,073,709,551,615**\n\n---\n\n## 限制 #\n\n虽然`unsigned long long`已经很大了，但当遇到`指数`,`阶乘`之类的运算时仍然可能**存不下!**(光`21!`就比`unsigned long long`长了)\n\n## 思路 #\n过大的整数，可能出现在**程序的过程**中，也可能出现在**输出**中，对于过程，可以尝试**改变实现思路**，让过程中不出现过大的整数；对于输出，可以尝试**改变输出的类型**，采用输出**字符或字符串**\n\n# 以下皆为例题 #\n\n## 1.求n!的结尾有多少个0\n\n最直白的思路就是把`n!`算出来，然后用`%10`再`/=10`的方法统计末尾的`0`,想法很简单，“实现”起来也不难，**但不幸的是**，`21!`就已经储存不了了，所以不能暴力求解\n\n所以要**改变思路**，先从末尾0是怎么来的下手。末尾的n个0来自因式分解后10的n次方，而采用质因数分解的方法，可以发现`0`来自分解后`2的n次方`和`5的n次方`,而一个数分解后`2的n次方`必定比`5的n次方` 多，所以只需统计`5的n次方`。**注意**：就别再倒回去，想着先算出阶乘再求`5的n次方`了。\n\n**这里采用逐步计数的方法**：结果中的`5的n次方`来自各个因数中`5的N次方`的累乘,所以只需要历遍每个因数，并统计其中`因数5`的次数。这样过程中就不会有过大的数字了\n\n```C\n//代码实现\nint count_num0(int n)\n{\n    int count = 0;\n    for(int i = 1;i<=n;i++)\n    {\n        int copy = i//防止改变循环变量\n        while(copy%5 == 0)//统计因数5的出现次数\n        {\n            if(copy%5 == 0)\n            {\n                count++;\n            }\n            copy/=5;\n        }\n    }\n\n    return count;\n}\n\n```\n\n## 快速输出1+2+……+10^n #\n*如下图*：当我们试图算一算答案时，发现`n`到了`10`时就已经算不出答案了\n\n![计算结果](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/gao_si.png)\n\n所以要**改变输出答案答案的方式**,观察一下`n`在`1~9`时的输出\n\n![输出](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_07-26-54.jpg)\n\n这时我们发现**答案颇有规律**：每个输出都是**两段**`先一个5，然后n-1个0`！\n\n这样我们只需**从最高位往最低位**逐位打印即可,代码如下\n\n```C\nvoid printChar(int n)//版本一，逐位打印字符(串)\n{\n    printf(\"5\");\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"0\");\n    }\n    //再重复一段\n    printf(\"5\");\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"0\");\n    }\n    printf(\"\\n\");\n}\n\nvoid printNum(int n)//版本二，逐位打印整型\n{\n    printf(\"%d\",5);\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"%d\",0);\n    }\n    //再重复一段\n    printf(\"%d\",5);\n    for(int i =0;i<n-1;i++)\n    {\n        printf(\"%d\",0);\n    }\n    printf(\"\\n\");\n}\n```","slug":"BiiigInt","published":1,"updated":"2024-05-08T23:56:16.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p083000a4sp5fvrv2l07","content":"<h2 id=\"整型家族\"><a href=\"#整型家族\" class=\"headerlink\" title=\"整型家族\"></a>整型家族</h2><p>在使用C语言写程序时，会储存各种长度的整型,而在整型家族中，长度的比较如下</p>\n<p><code>char &lt; short &lt;= int &lt;= long &lt;long long </code></p>\n<h2 id=\"整型是如何储存在内存中的\"><a href=\"#整型是如何储存在内存中的\" class=\"headerlink\" title=\"整型是如何储存在内存中的\"></a>整型是如何储存在内存中的</h2><p><em>以<code>char</code>为例</em><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-14_15-33-30.jpg\" alt=\"char\"></p>\n<p><code>char</code>的长度为1个<code>字节</code>，8个<code>比特位</code>,其中<strong>最高位</strong>是<strong>符号位</strong>,<code>0</code>表示正数，<code>1</code>表示负数，剩下的位数用于储存变量的<strong>绝对值</strong></p>\n<hr>\n<p>而当使用无符号整型(带前缀<code>unsigned</code>)时，只需把符号位也用于存值即可</p>\n<h2 id=\"能够储存的最大正整数\"><a href=\"#能够储存的最大正整数\" class=\"headerlink\" title=\"能够储存的最大正整数\"></a>能够储存的最大正整数</h2><p><code>int</code>长度为4<code>字节</code>,能够储存的最大值为<code>2的31次方-1</code>,即<strong>2,147,483,647</strong></p>\n<p><code>unsigned int</code>能够储存的最大值为<strong>4294967295</strong></p>\n<p><code>unsigned long long</code>长度为8<code>字节</code>,能够储存的最大值为<code>2的64次方-1</code>,即<strong>18,446,744,073,709,551,615</strong></p>\n<hr>\n<h2 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h2><p>虽然<code>unsigned long long</code>已经很大了，但当遇到<code>指数</code>,<code>阶乘</code>之类的运算时仍然可能<strong>存不下!</strong>(光<code>21!</code>就比<code>unsigned long long</code>长了)</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>过大的整数，可能出现在<strong>程序的过程</strong>中，也可能出现在<strong>输出</strong>中，对于过程，可以尝试<strong>改变实现思路</strong>，让过程中不出现过大的整数；对于输出，可以尝试<strong>改变输出的类型</strong>，采用输出<strong>字符或字符串</strong></p>\n<h1 id=\"以下皆为例题\"><a href=\"#以下皆为例题\" class=\"headerlink\" title=\"以下皆为例题\"></a>以下皆为例题</h1><h2 id=\"1-求n-的结尾有多少个0\"><a href=\"#1-求n-的结尾有多少个0\" class=\"headerlink\" title=\"1.求n!的结尾有多少个0\"></a>1.求n!的结尾有多少个0</h2><p>最直白的思路就是把<code>n!</code>算出来，然后用<code>%10</code>再<code>/=10</code>的方法统计末尾的<code>0</code>,想法很简单，“实现”起来也不难，<strong>但不幸的是</strong>，<code>21!</code>就已经储存不了了，所以不能暴力求解</p>\n<p>所以要<strong>改变思路</strong>，先从末尾0是怎么来的下手。末尾的n个0来自因式分解后10的n次方，而采用质因数分解的方法，可以发现<code>0</code>来自分解后<code>2的n次方</code>和<code>5的n次方</code>,而一个数分解后<code>2的n次方</code>必定比<code>5的n次方</code> 多，所以只需统计<code>5的n次方</code>。<strong>注意</strong>：就别再倒回去，想着先算出阶乘再求<code>5的n次方</code>了。</p>\n<p><strong>这里采用逐步计数的方法</strong>：结果中的<code>5的n次方</code>来自各个因数中<code>5的N次方</code>的累乘,所以只需要历遍每个因数，并统计其中<code>因数5</code>的次数。这样过程中就不会有过大的数字了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">count_num0</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> copy = i<span class=\"comment\">//防止改变循环变量</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(copy%<span class=\"number\">5</span> == <span class=\"number\">0</span>)<span class=\"comment\">//统计因数5的出现次数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(copy%<span class=\"number\">5</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            copy/=<span class=\"number\">5</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"快速输出1-2-……-10-n\"><a href=\"#快速输出1-2-……-10-n\" class=\"headerlink\" title=\"快速输出1+2+……+10^n\"></a>快速输出1+2+……+10^n</h2><p><em>如下图</em>：当我们试图算一算答案时，发现<code>n</code>到了<code>10</code>时就已经算不出答案了</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/gao_si.png\" alt=\"计算结果\"></p>\n<p>所以要<strong>改变输出答案答案的方式</strong>,观察一下<code>n</code>在<code>1~9</code>时的输出</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_07-26-54.jpg\" alt=\"输出\"></p>\n<p>这时我们发现<strong>答案颇有规律</strong>：每个输出都是<strong>两段</strong><code>先一个5，然后n-1个0</code>！</p>\n<p>这样我们只需<strong>从最高位往最低位</strong>逐位打印即可,代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">printChar</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//版本一，逐位打印字符(串)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//再重复一段</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">printNum</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//版本二，逐位打印整型</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//再重复一段</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h2 id=\"整型家族\"><a href=\"#整型家族\" class=\"headerlink\" title=\"整型家族\"></a>整型家族</h2><p>在使用C语言写程序时，会储存各种长度的整型,而在整型家族中，长度的比较如下</p>\n<p><code>char &lt; short &lt;= int &lt;= long &lt;long long </code></p>\n<h2 id=\"整型是如何储存在内存中的\"><a href=\"#整型是如何储存在内存中的\" class=\"headerlink\" title=\"整型是如何储存在内存中的\"></a>整型是如何储存在内存中的</h2><p><em>以<code>char</code>为例</em><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-14_15-33-30.jpg\" alt=\"char\"></p>\n<p><code>char</code>的长度为1个<code>字节</code>，8个<code>比特位</code>,其中<strong>最高位</strong>是<strong>符号位</strong>,<code>0</code>表示正数，<code>1</code>表示负数，剩下的位数用于储存变量的<strong>绝对值</strong></p>\n<hr>\n<p>而当使用无符号整型(带前缀<code>unsigned</code>)时，只需把符号位也用于存值即可</p>\n<h2 id=\"能够储存的最大正整数\"><a href=\"#能够储存的最大正整数\" class=\"headerlink\" title=\"能够储存的最大正整数\"></a>能够储存的最大正整数</h2><p><code>int</code>长度为4<code>字节</code>,能够储存的最大值为<code>2的31次方-1</code>,即<strong>2,147,483,647</strong></p>\n<p><code>unsigned int</code>能够储存的最大值为<strong>4294967295</strong></p>\n<p><code>unsigned long long</code>长度为8<code>字节</code>,能够储存的最大值为<code>2的64次方-1</code>,即<strong>18,446,744,073,709,551,615</strong></p>\n<hr>\n<h2 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h2><p>虽然<code>unsigned long long</code>已经很大了，但当遇到<code>指数</code>,<code>阶乘</code>之类的运算时仍然可能<strong>存不下!</strong>(光<code>21!</code>就比<code>unsigned long long</code>长了)</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>过大的整数，可能出现在<strong>程序的过程</strong>中，也可能出现在<strong>输出</strong>中，对于过程，可以尝试<strong>改变实现思路</strong>，让过程中不出现过大的整数；对于输出，可以尝试<strong>改变输出的类型</strong>，采用输出<strong>字符或字符串</strong></p>\n<h1 id=\"以下皆为例题\"><a href=\"#以下皆为例题\" class=\"headerlink\" title=\"以下皆为例题\"></a>以下皆为例题</h1><h2 id=\"1-求n-的结尾有多少个0\"><a href=\"#1-求n-的结尾有多少个0\" class=\"headerlink\" title=\"1.求n!的结尾有多少个0\"></a>1.求n!的结尾有多少个0</h2><p>最直白的思路就是把<code>n!</code>算出来，然后用<code>%10</code>再<code>/=10</code>的方法统计末尾的<code>0</code>,想法很简单，“实现”起来也不难，<strong>但不幸的是</strong>，<code>21!</code>就已经储存不了了，所以不能暴力求解</p>\n<p>所以要<strong>改变思路</strong>，先从末尾0是怎么来的下手。末尾的n个0来自因式分解后10的n次方，而采用质因数分解的方法，可以发现<code>0</code>来自分解后<code>2的n次方</code>和<code>5的n次方</code>,而一个数分解后<code>2的n次方</code>必定比<code>5的n次方</code> 多，所以只需统计<code>5的n次方</code>。<strong>注意</strong>：就别再倒回去，想着先算出阶乘再求<code>5的n次方</code>了。</p>\n<p><strong>这里采用逐步计数的方法</strong>：结果中的<code>5的n次方</code>来自各个因数中<code>5的N次方</code>的累乘,所以只需要历遍每个因数，并统计其中<code>因数5</code>的次数。这样过程中就不会有过大的数字了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">count_num0</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> copy = i<span class=\"comment\">//防止改变循环变量</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(copy%<span class=\"number\">5</span> == <span class=\"number\">0</span>)<span class=\"comment\">//统计因数5的出现次数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(copy%<span class=\"number\">5</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            copy/=<span class=\"number\">5</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"快速输出1-2-……-10-n\"><a href=\"#快速输出1-2-……-10-n\" class=\"headerlink\" title=\"快速输出1+2+……+10^n\"></a>快速输出1+2+……+10^n</h2><p><em>如下图</em>：当我们试图算一算答案时，发现<code>n</code>到了<code>10</code>时就已经算不出答案了</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/gao_si.png\" alt=\"计算结果\"></p>\n<p>所以要<strong>改变输出答案答案的方式</strong>,观察一下<code>n</code>在<code>1~9</code>时的输出</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_07-26-54.jpg\" alt=\"输出\"></p>\n<p>这时我们发现<strong>答案颇有规律</strong>：每个输出都是<strong>两段</strong><code>先一个5，然后n-1个0</code>！</p>\n<p>这样我们只需<strong>从最高位往最低位</strong>逐位打印即可,代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">printChar</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//版本一，逐位打印字符(串)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//再重复一段</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">printNum</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//版本二，逐位打印整型</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//再重复一段</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"hexo","title":"C++继承","date":"2024-09-02T07:26:20.000Z","_content":"# 继承的概念及定义\n\n## 继承的概念\n`继承`(inheritance)机制是面向对象程序设计使代码可以**复用**的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称`派生类`。继承呈现了面向对象程序设计的`层次结构`，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的`复用`\n\n下面用一个简单的示例演示一下继承\n**示例**\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person\n{\npublic:\n\tvoid Info()\n\t{\n\t\tprintf(\"name:%s age:%d\\n\", _name.c_str(), _age);\n\t}\nprotected:\n\tstring _name = \"supdriver\";\n\tint _age = 24;\n};\n\nclass Student:public Person\n{\npublic:\n\tvoid getID()\n\t{\n\t\tcout << \"ID:\" << _ID << endl;\n\t}\nprivate:\n\tint _ID = 114514;\n};\n\n\nint main()\n{\n\tStudent stu;\n\tstu.Info();\n\tstu.getID();\n\treturn 0;\n}\n```\n\n## 继承的使用\n当我们准备好一个`基类`后，便可将其用于`派生类`的声明\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Inherit.png)\n\n由图中可以看到，新的概念：`继承方式`，而且很巧的是，它和`访问限定符`的关键字是一一对应的\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030857308.png)\n\n实际上，它们共同决定了基类成员在派生类内的访问限定符\n\n### 继承基类成员访问方式的变化\n\n| 类成员/继承方式       | `public`继承            | `protected`继承         | `private`继承         |\n| --------------------- | ----------------------- | ----------------------- | --------------------- |\n| 基类的`public`成员    | 派生类的`public`成员    | 派生类的`protected`成员 | 派生类的`private`成员 |\n| 基类的`protected`成员 | 派生类的`protected`成员 | 派生类的`protected`成员 | 派生类的`private`成员 |\n| 基类的`private`成员   | 在派生类中`不可见`      | 在派生类中`不可见`      | 在派生类中`不可见`    |\n\n#### 总结\n1. `不可见`:基类private成员在派生类中无论以什么方式继承都是不可见的。**这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。**\n2. `protected`:基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected。**可以看出`protected`保护成员限定符是因继承才出现的。**\n3. `规律`:实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 == `Min(成员在基类的访问限定符，继承方式)`，其中的大小关系为`public > protected > private`\n4. `默认行为`:使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过**最好显示**的写出继承方式。\n5. `扩展性`:在实际运用中一般使用都是public继承，几乎很少使用protetced/private继承，也不提倡使用protetced/private继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强\n\n## 派生类的构造函数\n有时基类并不提供无参的默认构造函数,那么如何在派生类的构造函数里`显示地调用基类构造函数`呢?\n\n其实编译器的报错也给出了提示\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/inherit_construct.png)\n\n可以看到，在初始化列表后面出现了报错:`Person不存在默认构造函数`,显然，显示调用构造函数的位置在初始化列表。\n\n那么怎么调用呢？构造函数也是成员函数！除了基类中`private`修饰的构造函数，派生类中皆可调用父类的成员函数，直接在初始化列表中显式调用即可\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person\n{\npublic:\n\t//基类的公有构造函数\n\tPerson(const string& name, const string& gender, int age)\n\t\t:_name(name)\n\t\t,_gender(gender)\n\t\t,_age(age)\n\t{}\n\tvoid Info()\n\t{\n\t\tprintf(\"name:%s age:%d\\n\", _name.c_str(), _age);\n\t}\nprotected:\n\tstring _name;\n\tstring _gender;\n\tint _age;\n};\n\nclass Student :public Person\n{\npublic:\n\tStudent(const string& name,const string& gender,int age,int ID)\n\t\t:Person(name,gender,age)//显式调用父类的构造函数\n\t\t,_ID(ID)\n\t{}\n\tvoid getID()\n\t{\n\t\tcout << \"ID:\" << _ID << endl;\n\t}\nprivate:\n\tint _ID;\n};\n\n\nint main()\n{\n\tStudent stu(\"supdriver\", \"male\", 24, 114514);//调用构造函数\n\treturn 0;\n}\n```\n\n## 基类和派生类的赋值转化\n+ 派生类对象 可以赋值给 `基类的对象` / `基类的指针` / `基类的引用`。这里有个形象的说法叫`切片`或者`切割`。寓意把派生类中父类那部分切来赋值过去。\n+ 基类对象**不能**赋值给派生类对象\n+ 基类的`指针`或者`引用`可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是**基类的指针是指向派生类对象时才是安全的**。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/slice.png)\n\n下面用一个示例演示一下切片,赋值转换等问题\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person\n{\npublic:\n\t//基类的公有构造函数\n\tPerson(const string& name, const string& gender, int age)\n\t\t:_name(name)\n\t\t,_gender(gender)\n\t\t,_age(age)\n\t{}\n\tvoid Info()\n\t{\n\t\tprintf(\"name:%s age:%d\\n\", _name.c_str(), _age);\n\t}\nprotected:\n\tstring _name;\n\tstring _gender;\n\tint _age;\n};\n\nclass Student :public Person\n{\npublic:\n\tStudent(const string& name,const string& gender,int age,int ID)\n\t\t:Person(name,gender,age)//显式调用父类的构造函数\n\t\t,_ID(ID)\n\t{}\n\tvoid getID()\n\t{\n\t\tcout << \"ID:\" << _ID << endl;\n\t}\npublic:\n\tint _ID;\n};\n\n\nint main()\n{\n\tStudent stu(\"supdriver\", \"male\", 24, 114514);//调用构造函数\n\n\tPerson  person(stu);//这里没有显式声明对应的构造函数，而是自动切片\n\tPerson* pp = &stu;//父类指针可以指向派生类\n\tPerson& rp = stu;//父类引用可以指向派生类\n\n\t//stu = person;//父类对象不能赋值给派生类\n\n\t//基类的指针可以通过强制类型转换赋值给派生类的指针\n\tpp = &stu;\n\tStudent* pstu = (Student*)pp;//指针地址就是指向派生类的，所以这种情况是安全的，合法的\n\tpstu->_ID = 233;//这里并没有越界\n\n\tpp = &person;\n\tpstu = (Student*)pp;//这种就是不安全的，可能会越界访问\t\n\treturn 0;\n}\n```\n\n## 继承中的作用域(`隐藏`机制)\n1. 在继承体系中`基类`和`派生类`都有独立的作用域(`类域`)\n2. 子类和父类中有同名成员，**不指定成员所在类域时**，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫`隐藏`，也叫`重定义`。\n3. 需要注意的是如果是成员函数的隐藏，只需要**函数名相**同就构成隐藏。\n4. 注意在**实际中**在继承体系里面最好**不要定义同名的成员**。\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person\n{\npublic:\n\tvoid Info()\n\t{\n\t\tprintf(\"name:%s age:%d\\n\", _name.c_str(), _age);\n\t}\nprotected:\n\tstring _name = \"supdriver\";\n\tint _age = 24;\n};\n\nclass Student:public Person\n{\npublic:\n\tvoid Info()//同名函数构成隐藏\n\t{\n\t\tprintf(\"name:%s age:%d\\n ID:%d\", _name.c_str(), _age,_ID);\n\t}\nprivate:\n\tint _ID = 114514;\n};\n\n\nint main()\n{\n\tStudent stu;\n\tstu.Info();//调用Student类内的Info函数，而父类内的被隐藏\n\tstu.Person::Info();//显式调用Person内的Info函数\n\treturn 0;\n}\n```\n\n### 隐藏与重载辨析\n\n+ `重载`：函数重载是根据同名函数的`参数类型`和`参数顺序`选择实际调用的函数，选择的动作只能由编译器完成\n+ `隐藏`：成员的隐藏是同名成员根据`类域`的`就近原则`由编译器自动调用，但也可以通过指定类域，在代码中选择\n\n## 派生类的默认成员函数\n6个默认成员函数，“默认\"的意思就是指我们不写，编译器会变我们自动生成一个，那么在派生类\n中，这几个成员函数是如何生成的呢?\n\n1. 派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。\n2. 派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。\n3. 派生类的operator=必须要调用基类的operator=完成基类的复制。\n4. 派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。\n5. 派生类对象初始化先调用基类构造再调派生类构造。\n6. 派生类对象析构清理先调用派生类析构再调基类的析构。\n7. 因为后续一些场景析构函数需要构成重写，重写的条件之一是函数名相同(这个我们后面会讲解)。那么编译器会对**析构函数名进行特殊处理**，处理成`destrutor()`，所以父类析构函数不加virtual的情况下，子类析构函数和父类析构函数构成隐藏关系。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409031848644.png)\n\n## 继承与友元函数\n友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员 \n\n示例如下\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Student;\nclass Person\n{\npublic:\n\tfriend void Display(const Person& p, const Student& s);\nprotected:\n\tstring _name; // 姓名\n};\nclass Student : public Person\n{\nprotected:\n\tint _stuNum; // 学号\n};\n\nvoid Display(const Person& p, const Student& s)\n{\n\tcout << p._name << endl;\n\tcout << s._name << endl;//这行代码不会报错，因为_name是继承自Person类的\n\tcout << s._stuNum << endl;//这行代码会报错，因为函数没有权限访问Student类自己声明的成员\n}\nvoid main()\n{\n\tPerson p;\n\tStudent s;\n\tDisplay(p, s);\n}\n```\n\n## 继承与静态成员\n基类定义了`static静态成员`，则**整个继承体系里面只有一个这样的成员**。无论派生出多少个子类，都**只有一个**static成员实例 。\n\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person\n{\npublic:\n\tPerson() { ++_count; }\nprotected:\n\tstring _name; // 姓名\npublic:\n\tstatic int _count; // 静态成员变量,统计人的个数。\n};\nint Person::_count = 0;\n\nclass Student : public Person\n{\nprotected:\n\tint _stuNum; // 学号\n};\nclass Graduate : public Student\n{\nprotected:\n\tstring _seminarCourse; // 研究科目\n};\nint main()\n{\n\tStudent s1;\n\tStudent s2;\n\tStudent s3;\n\tGraduate s4;\n\tcout << \" 人数 :\" << Person::_count << endl;\n\tStudent::_count = 0;\n\tcout << \" 人数 :\" << Person::_count << endl;\n\treturn 0;\n}\n```\n结果如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409040748921.png)\n\n## 复杂的菱形继承及菱形虚拟继承\n\n### 单继承\n\n`单继承`：一个子类只有*一个直接父类*时称这个继承关系为`单继承`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/single_inherit.png)\n\n### 多继承\n\n`多继承`：一个子类有**两个或以上直接父类**时称这个继承关系为`多继承`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/multi_inherit.png)\n\n### 菱形继承\n\n`菱形继承`：菱形继承是多继承的一种**特殊情况**。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Diamond_Inherit.png)\n\n`菱形继承的问题`：从下面的对象成员模型构造，可以看出菱形继承有`数据冗余`和`二义性`的问题。\n在Assistant的对象中Person成员会有两份。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/IHR_diamond.png)\n\n```C++\nclass Person\n{\npublic :\n \tstring _name ; // 姓名\n};\nclass Student : public Person\n{\nprotected :\n \tint _num ; //学号\n};\nclass Teacher : public Person\n{\nprotected :\n \tint _id ; // 职工编号\n};\nclass Assistant : public Student, public Teacher\n{\nprotected :\n \tstring _majorCourse ; // 主修课程\n};\nvoid Test ()\n{\n\t// 这样会有二义性无法明确知道访问的是哪一个\n\tAssistant a ;\n\ta._name = \"peter\";\n\t// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决\n\ta.Student::_name = \"xxx\";\n\ta.Teacher::_name = \"yyy\";\n}\n```\n\n####  虚拟继承 \n`虚拟继承`可以解决**菱形继承**的二义性和数据冗余的问题。如上面的继承关系，在Student和Teacher的继承Person时使用`虚拟继承`，即可解决问题。需要注意的是，**虚拟继承不要在其他地方去使用。**\n\n```C++\nclass Person\n{\npublic :\n \tstring _name ; // 姓名\n};\nclass Student : virtual public Person //虚拟继承共同父类\n{\nprotected :\n \tint _num ; //学号\n};\nclass Teacher : virtual public Person //虚拟继承共同父类\n{\nprotected :\n \tint _id ; // 职工编号\n};\nclass Assistant : public Student, public Teacher\n{\nprotected :\n \tstring _majorCourse ; // 主修课程\n};\nvoid Test ()\n{\n \tAssistant a ;\n \ta._name = \"peter\";//二义性和数据冗余已被解决\n}\n```\n\n**虚拟继承解决数据冗余和二义性的原理**\n下图是菱形虚拟继承的内存对象成员模型：这里可以分析出`Assistant`对象中将`Person`放到的了对象组成的最下面，这个`Person`同时属于`Student`和`Teacher`，那么`Student`和`Teacher`如何去找到公共的`Person`呢？**这里是通过了`Student`和`Teacher`的两个指针，指向的一张表。这两个指针叫`虚基表指针`，这两个表叫`虚基表`。虚基表中存的偏移量。通过偏移量可以找到下面的`Person`**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/INHERIT_virtual.png)\n\n# 继承的总结和反思\n\n## 尽量不使用多继承，不要设计出菱形继承\nC++语法中的`多继承`正是其语法复杂性的体现之一。有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟继承，底层实现就很复杂。所以**一般不建议设计出多继承，一定不要设计出菱形继承**。否则在复杂度及性能上都有问题。\n\n## 继承和组成辨析\n+ public继承是一种`is-a`的关系。也就是说每个派生类对象都是一个基类对象\n+ 组合是一种`has-a`的关系。假设B组合了A，每个B对象中都有一个A对象。\n+ 为了提高代码的`封装性`和`解耦合`，[优先使用对象组合，而不是类继承🔗](https://www.cnblogs.com/nexiyi/archive/2013/06/16/3138568.html)\n+ `白箱复用`：继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，**基类的内部细节对子类可见** 。继承一定程度**破坏**了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，**耦合度高**。\n+ `黑箱复用`：对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装。\n+ 实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。","source":"_posts/CppInherit.md","raw":"---\nlayout: hexo\ntitle: C++继承\ndate: 2024-09-02 15:26:20\ntags: C++ 继承\n---\n# 继承的概念及定义\n\n## 继承的概念\n`继承`(inheritance)机制是面向对象程序设计使代码可以**复用**的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称`派生类`。继承呈现了面向对象程序设计的`层次结构`，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的`复用`\n\n下面用一个简单的示例演示一下继承\n**示例**\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person\n{\npublic:\n\tvoid Info()\n\t{\n\t\tprintf(\"name:%s age:%d\\n\", _name.c_str(), _age);\n\t}\nprotected:\n\tstring _name = \"supdriver\";\n\tint _age = 24;\n};\n\nclass Student:public Person\n{\npublic:\n\tvoid getID()\n\t{\n\t\tcout << \"ID:\" << _ID << endl;\n\t}\nprivate:\n\tint _ID = 114514;\n};\n\n\nint main()\n{\n\tStudent stu;\n\tstu.Info();\n\tstu.getID();\n\treturn 0;\n}\n```\n\n## 继承的使用\n当我们准备好一个`基类`后，便可将其用于`派生类`的声明\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Inherit.png)\n\n由图中可以看到，新的概念：`继承方式`，而且很巧的是，它和`访问限定符`的关键字是一一对应的\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030857308.png)\n\n实际上，它们共同决定了基类成员在派生类内的访问限定符\n\n### 继承基类成员访问方式的变化\n\n| 类成员/继承方式       | `public`继承            | `protected`继承         | `private`继承         |\n| --------------------- | ----------------------- | ----------------------- | --------------------- |\n| 基类的`public`成员    | 派生类的`public`成员    | 派生类的`protected`成员 | 派生类的`private`成员 |\n| 基类的`protected`成员 | 派生类的`protected`成员 | 派生类的`protected`成员 | 派生类的`private`成员 |\n| 基类的`private`成员   | 在派生类中`不可见`      | 在派生类中`不可见`      | 在派生类中`不可见`    |\n\n#### 总结\n1. `不可见`:基类private成员在派生类中无论以什么方式继承都是不可见的。**这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。**\n2. `protected`:基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected。**可以看出`protected`保护成员限定符是因继承才出现的。**\n3. `规律`:实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 == `Min(成员在基类的访问限定符，继承方式)`，其中的大小关系为`public > protected > private`\n4. `默认行为`:使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过**最好显示**的写出继承方式。\n5. `扩展性`:在实际运用中一般使用都是public继承，几乎很少使用protetced/private继承，也不提倡使用protetced/private继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强\n\n## 派生类的构造函数\n有时基类并不提供无参的默认构造函数,那么如何在派生类的构造函数里`显示地调用基类构造函数`呢?\n\n其实编译器的报错也给出了提示\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/inherit_construct.png)\n\n可以看到，在初始化列表后面出现了报错:`Person不存在默认构造函数`,显然，显示调用构造函数的位置在初始化列表。\n\n那么怎么调用呢？构造函数也是成员函数！除了基类中`private`修饰的构造函数，派生类中皆可调用父类的成员函数，直接在初始化列表中显式调用即可\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person\n{\npublic:\n\t//基类的公有构造函数\n\tPerson(const string& name, const string& gender, int age)\n\t\t:_name(name)\n\t\t,_gender(gender)\n\t\t,_age(age)\n\t{}\n\tvoid Info()\n\t{\n\t\tprintf(\"name:%s age:%d\\n\", _name.c_str(), _age);\n\t}\nprotected:\n\tstring _name;\n\tstring _gender;\n\tint _age;\n};\n\nclass Student :public Person\n{\npublic:\n\tStudent(const string& name,const string& gender,int age,int ID)\n\t\t:Person(name,gender,age)//显式调用父类的构造函数\n\t\t,_ID(ID)\n\t{}\n\tvoid getID()\n\t{\n\t\tcout << \"ID:\" << _ID << endl;\n\t}\nprivate:\n\tint _ID;\n};\n\n\nint main()\n{\n\tStudent stu(\"supdriver\", \"male\", 24, 114514);//调用构造函数\n\treturn 0;\n}\n```\n\n## 基类和派生类的赋值转化\n+ 派生类对象 可以赋值给 `基类的对象` / `基类的指针` / `基类的引用`。这里有个形象的说法叫`切片`或者`切割`。寓意把派生类中父类那部分切来赋值过去。\n+ 基类对象**不能**赋值给派生类对象\n+ 基类的`指针`或者`引用`可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是**基类的指针是指向派生类对象时才是安全的**。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/slice.png)\n\n下面用一个示例演示一下切片,赋值转换等问题\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person\n{\npublic:\n\t//基类的公有构造函数\n\tPerson(const string& name, const string& gender, int age)\n\t\t:_name(name)\n\t\t,_gender(gender)\n\t\t,_age(age)\n\t{}\n\tvoid Info()\n\t{\n\t\tprintf(\"name:%s age:%d\\n\", _name.c_str(), _age);\n\t}\nprotected:\n\tstring _name;\n\tstring _gender;\n\tint _age;\n};\n\nclass Student :public Person\n{\npublic:\n\tStudent(const string& name,const string& gender,int age,int ID)\n\t\t:Person(name,gender,age)//显式调用父类的构造函数\n\t\t,_ID(ID)\n\t{}\n\tvoid getID()\n\t{\n\t\tcout << \"ID:\" << _ID << endl;\n\t}\npublic:\n\tint _ID;\n};\n\n\nint main()\n{\n\tStudent stu(\"supdriver\", \"male\", 24, 114514);//调用构造函数\n\n\tPerson  person(stu);//这里没有显式声明对应的构造函数，而是自动切片\n\tPerson* pp = &stu;//父类指针可以指向派生类\n\tPerson& rp = stu;//父类引用可以指向派生类\n\n\t//stu = person;//父类对象不能赋值给派生类\n\n\t//基类的指针可以通过强制类型转换赋值给派生类的指针\n\tpp = &stu;\n\tStudent* pstu = (Student*)pp;//指针地址就是指向派生类的，所以这种情况是安全的，合法的\n\tpstu->_ID = 233;//这里并没有越界\n\n\tpp = &person;\n\tpstu = (Student*)pp;//这种就是不安全的，可能会越界访问\t\n\treturn 0;\n}\n```\n\n## 继承中的作用域(`隐藏`机制)\n1. 在继承体系中`基类`和`派生类`都有独立的作用域(`类域`)\n2. 子类和父类中有同名成员，**不指定成员所在类域时**，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫`隐藏`，也叫`重定义`。\n3. 需要注意的是如果是成员函数的隐藏，只需要**函数名相**同就构成隐藏。\n4. 注意在**实际中**在继承体系里面最好**不要定义同名的成员**。\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person\n{\npublic:\n\tvoid Info()\n\t{\n\t\tprintf(\"name:%s age:%d\\n\", _name.c_str(), _age);\n\t}\nprotected:\n\tstring _name = \"supdriver\";\n\tint _age = 24;\n};\n\nclass Student:public Person\n{\npublic:\n\tvoid Info()//同名函数构成隐藏\n\t{\n\t\tprintf(\"name:%s age:%d\\n ID:%d\", _name.c_str(), _age,_ID);\n\t}\nprivate:\n\tint _ID = 114514;\n};\n\n\nint main()\n{\n\tStudent stu;\n\tstu.Info();//调用Student类内的Info函数，而父类内的被隐藏\n\tstu.Person::Info();//显式调用Person内的Info函数\n\treturn 0;\n}\n```\n\n### 隐藏与重载辨析\n\n+ `重载`：函数重载是根据同名函数的`参数类型`和`参数顺序`选择实际调用的函数，选择的动作只能由编译器完成\n+ `隐藏`：成员的隐藏是同名成员根据`类域`的`就近原则`由编译器自动调用，但也可以通过指定类域，在代码中选择\n\n## 派生类的默认成员函数\n6个默认成员函数，“默认\"的意思就是指我们不写，编译器会变我们自动生成一个，那么在派生类\n中，这几个成员函数是如何生成的呢?\n\n1. 派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。\n2. 派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。\n3. 派生类的operator=必须要调用基类的operator=完成基类的复制。\n4. 派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。\n5. 派生类对象初始化先调用基类构造再调派生类构造。\n6. 派生类对象析构清理先调用派生类析构再调基类的析构。\n7. 因为后续一些场景析构函数需要构成重写，重写的条件之一是函数名相同(这个我们后面会讲解)。那么编译器会对**析构函数名进行特殊处理**，处理成`destrutor()`，所以父类析构函数不加virtual的情况下，子类析构函数和父类析构函数构成隐藏关系。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409031848644.png)\n\n## 继承与友元函数\n友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员 \n\n示例如下\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Student;\nclass Person\n{\npublic:\n\tfriend void Display(const Person& p, const Student& s);\nprotected:\n\tstring _name; // 姓名\n};\nclass Student : public Person\n{\nprotected:\n\tint _stuNum; // 学号\n};\n\nvoid Display(const Person& p, const Student& s)\n{\n\tcout << p._name << endl;\n\tcout << s._name << endl;//这行代码不会报错，因为_name是继承自Person类的\n\tcout << s._stuNum << endl;//这行代码会报错，因为函数没有权限访问Student类自己声明的成员\n}\nvoid main()\n{\n\tPerson p;\n\tStudent s;\n\tDisplay(p, s);\n}\n```\n\n## 继承与静态成员\n基类定义了`static静态成员`，则**整个继承体系里面只有一个这样的成员**。无论派生出多少个子类，都**只有一个**static成员实例 。\n\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person\n{\npublic:\n\tPerson() { ++_count; }\nprotected:\n\tstring _name; // 姓名\npublic:\n\tstatic int _count; // 静态成员变量,统计人的个数。\n};\nint Person::_count = 0;\n\nclass Student : public Person\n{\nprotected:\n\tint _stuNum; // 学号\n};\nclass Graduate : public Student\n{\nprotected:\n\tstring _seminarCourse; // 研究科目\n};\nint main()\n{\n\tStudent s1;\n\tStudent s2;\n\tStudent s3;\n\tGraduate s4;\n\tcout << \" 人数 :\" << Person::_count << endl;\n\tStudent::_count = 0;\n\tcout << \" 人数 :\" << Person::_count << endl;\n\treturn 0;\n}\n```\n结果如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409040748921.png)\n\n## 复杂的菱形继承及菱形虚拟继承\n\n### 单继承\n\n`单继承`：一个子类只有*一个直接父类*时称这个继承关系为`单继承`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/single_inherit.png)\n\n### 多继承\n\n`多继承`：一个子类有**两个或以上直接父类**时称这个继承关系为`多继承`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/multi_inherit.png)\n\n### 菱形继承\n\n`菱形继承`：菱形继承是多继承的一种**特殊情况**。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Diamond_Inherit.png)\n\n`菱形继承的问题`：从下面的对象成员模型构造，可以看出菱形继承有`数据冗余`和`二义性`的问题。\n在Assistant的对象中Person成员会有两份。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/IHR_diamond.png)\n\n```C++\nclass Person\n{\npublic :\n \tstring _name ; // 姓名\n};\nclass Student : public Person\n{\nprotected :\n \tint _num ; //学号\n};\nclass Teacher : public Person\n{\nprotected :\n \tint _id ; // 职工编号\n};\nclass Assistant : public Student, public Teacher\n{\nprotected :\n \tstring _majorCourse ; // 主修课程\n};\nvoid Test ()\n{\n\t// 这样会有二义性无法明确知道访问的是哪一个\n\tAssistant a ;\n\ta._name = \"peter\";\n\t// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决\n\ta.Student::_name = \"xxx\";\n\ta.Teacher::_name = \"yyy\";\n}\n```\n\n####  虚拟继承 \n`虚拟继承`可以解决**菱形继承**的二义性和数据冗余的问题。如上面的继承关系，在Student和Teacher的继承Person时使用`虚拟继承`，即可解决问题。需要注意的是，**虚拟继承不要在其他地方去使用。**\n\n```C++\nclass Person\n{\npublic :\n \tstring _name ; // 姓名\n};\nclass Student : virtual public Person //虚拟继承共同父类\n{\nprotected :\n \tint _num ; //学号\n};\nclass Teacher : virtual public Person //虚拟继承共同父类\n{\nprotected :\n \tint _id ; // 职工编号\n};\nclass Assistant : public Student, public Teacher\n{\nprotected :\n \tstring _majorCourse ; // 主修课程\n};\nvoid Test ()\n{\n \tAssistant a ;\n \ta._name = \"peter\";//二义性和数据冗余已被解决\n}\n```\n\n**虚拟继承解决数据冗余和二义性的原理**\n下图是菱形虚拟继承的内存对象成员模型：这里可以分析出`Assistant`对象中将`Person`放到的了对象组成的最下面，这个`Person`同时属于`Student`和`Teacher`，那么`Student`和`Teacher`如何去找到公共的`Person`呢？**这里是通过了`Student`和`Teacher`的两个指针，指向的一张表。这两个指针叫`虚基表指针`，这两个表叫`虚基表`。虚基表中存的偏移量。通过偏移量可以找到下面的`Person`**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/INHERIT_virtual.png)\n\n# 继承的总结和反思\n\n## 尽量不使用多继承，不要设计出菱形继承\nC++语法中的`多继承`正是其语法复杂性的体现之一。有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟继承，底层实现就很复杂。所以**一般不建议设计出多继承，一定不要设计出菱形继承**。否则在复杂度及性能上都有问题。\n\n## 继承和组成辨析\n+ public继承是一种`is-a`的关系。也就是说每个派生类对象都是一个基类对象\n+ 组合是一种`has-a`的关系。假设B组合了A，每个B对象中都有一个A对象。\n+ 为了提高代码的`封装性`和`解耦合`，[优先使用对象组合，而不是类继承🔗](https://www.cnblogs.com/nexiyi/archive/2013/06/16/3138568.html)\n+ `白箱复用`：继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，**基类的内部细节对子类可见** 。继承一定程度**破坏**了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，**耦合度高**。\n+ `黑箱复用`：对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装。\n+ 实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。","slug":"CppInherit","published":1,"updated":"2024-09-06T08:55:46.135Z","comments":1,"photos":[],"link":"","_id":"cm155p084000b4sp57qlzhyhs","content":"<h1 id=\"继承的概念及定义\"><a href=\"#继承的概念及定义\" class=\"headerlink\" title=\"继承的概念及定义\"></a>继承的概念及定义</h1><h2 id=\"继承的概念\"><a href=\"#继承的概念\" class=\"headerlink\" title=\"继承的概念\"></a>继承的概念</h2><p><code>继承</code>(inheritance)机制是面向对象程序设计使代码可以<strong>复用</strong>的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称<code>派生类</code>。继承呈现了面向对象程序设计的<code>层次结构</code>，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的<code>复用</code></p>\n<p>下面用一个简单的示例演示一下继承<br><strong>示例</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Info</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name:%s age:%d\\n&quot;</span>, _name.<span class=\"built_in\">c_str</span>(), _age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name = <span class=\"string\">&quot;supdriver&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> _age = <span class=\"number\">24</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>:<span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getID</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;ID:&quot;</span> &lt;&lt; _ID &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _ID = <span class=\"number\">114514</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tStudent stu;</span><br><span class=\"line\">\tstu.<span class=\"built_in\">Info</span>();</span><br><span class=\"line\">\tstu.<span class=\"built_in\">getID</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承的使用\"><a href=\"#继承的使用\" class=\"headerlink\" title=\"继承的使用\"></a>继承的使用</h2><p>当我们准备好一个<code>基类</code>后，便可将其用于<code>派生类</code>的声明</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Inherit.png\"></p>\n<p>由图中可以看到，新的概念：<code>继承方式</code>，而且很巧的是，它和<code>访问限定符</code>的关键字是一一对应的</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030857308.png\"></p>\n<p>实际上，它们共同决定了基类成员在派生类内的访问限定符</p>\n<h3 id=\"继承基类成员访问方式的变化\"><a href=\"#继承基类成员访问方式的变化\" class=\"headerlink\" title=\"继承基类成员访问方式的变化\"></a>继承基类成员访问方式的变化</h3><table>\n<thead>\n<tr>\n<th>类成员&#x2F;继承方式</th>\n<th><code>public</code>继承</th>\n<th><code>protected</code>继承</th>\n<th><code>private</code>继承</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>基类的<code>public</code>成员</td>\n<td>派生类的<code>public</code>成员</td>\n<td>派生类的<code>protected</code>成员</td>\n<td>派生类的<code>private</code>成员</td>\n</tr>\n<tr>\n<td>基类的<code>protected</code>成员</td>\n<td>派生类的<code>protected</code>成员</td>\n<td>派生类的<code>protected</code>成员</td>\n<td>派生类的<code>private</code>成员</td>\n</tr>\n<tr>\n<td>基类的<code>private</code>成员</td>\n<td>在派生类中<code>不可见</code></td>\n<td>在派生类中<code>不可见</code></td>\n<td>在派生类中<code>不可见</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li><code>不可见</code>:基类private成员在派生类中无论以什么方式继承都是不可见的。<strong>这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。</strong></li>\n<li><code>protected</code>:基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected。<strong>可以看出<code>protected</code>保护成员限定符是因继承才出现的。</strong></li>\n<li><code>规律</code>:实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 &#x3D;&#x3D; <code>Min(成员在基类的访问限定符，继承方式)</code>，其中的大小关系为<code>public &gt; protected &gt; private</code></li>\n<li><code>默认行为</code>:使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过<strong>最好显示</strong>的写出继承方式。</li>\n<li><code>扩展性</code>:在实际运用中一般使用都是public继承，几乎很少使用protetced&#x2F;private继承，也不提倡使用protetced&#x2F;private继承，因为protetced&#x2F;private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强</li>\n</ol>\n<h2 id=\"派生类的构造函数\"><a href=\"#派生类的构造函数\" class=\"headerlink\" title=\"派生类的构造函数\"></a>派生类的构造函数</h2><p>有时基类并不提供无参的默认构造函数,那么如何在派生类的构造函数里<code>显示地调用基类构造函数</code>呢?</p>\n<p>其实编译器的报错也给出了提示</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/inherit_construct.png\"></p>\n<p>可以看到，在初始化列表后面出现了报错:<code>Person不存在默认构造函数</code>,显然，显示调用构造函数的位置在初始化列表。</p>\n<p>那么怎么调用呢？构造函数也是成员函数！除了基类中<code>private</code>修饰的构造函数，派生类中皆可调用父类的成员函数，直接在初始化列表中显式调用即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//基类的公有构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"type\">const</span> string&amp; name, <span class=\"type\">const</span> string&amp; gender, <span class=\"type\">int</span> age)</span><br><span class=\"line\">\t\t:_name(name)</span><br><span class=\"line\">\t\t,_gender(gender)</span><br><span class=\"line\">\t\t,_age(age)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Info</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name:%s age:%d\\n&quot;</span>, _name.<span class=\"built_in\">c_str</span>(), _age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tstring _gender;</span><br><span class=\"line\">\t<span class=\"type\">int</span> _age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> :<span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Student</span>(<span class=\"type\">const</span> string&amp; name,<span class=\"type\">const</span> string&amp; gender,<span class=\"type\">int</span> age,<span class=\"type\">int</span> ID)</span><br><span class=\"line\">\t\t:<span class=\"built_in\">Person</span>(name,gender,age)<span class=\"comment\">//显式调用父类的构造函数</span></span><br><span class=\"line\">\t\t,_ID(ID)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getID</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;ID:&quot;</span> &lt;&lt; _ID &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _ID;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Student <span class=\"title\">stu</span><span class=\"params\">(<span class=\"string\">&quot;supdriver&quot;</span>, <span class=\"string\">&quot;male&quot;</span>, <span class=\"number\">24</span>, <span class=\"number\">114514</span>)</span></span>;<span class=\"comment\">//调用构造函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基类和派生类的赋值转化\"><a href=\"#基类和派生类的赋值转化\" class=\"headerlink\" title=\"基类和派生类的赋值转化\"></a>基类和派生类的赋值转化</h2><ul>\n<li>派生类对象 可以赋值给 <code>基类的对象</code> &#x2F; <code>基类的指针</code> &#x2F; <code>基类的引用</code>。这里有个形象的说法叫<code>切片</code>或者<code>切割</code>。寓意把派生类中父类那部分切来赋值过去。</li>\n<li>基类对象<strong>不能</strong>赋值给派生类对象</li>\n<li>基类的<code>指针</code>或者<code>引用</code>可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是<strong>基类的指针是指向派生类对象时才是安全的</strong>。</li>\n</ul>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/slice.png\"></p>\n<p>下面用一个示例演示一下切片,赋值转换等问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//基类的公有构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"type\">const</span> string&amp; name, <span class=\"type\">const</span> string&amp; gender, <span class=\"type\">int</span> age)</span><br><span class=\"line\">\t\t:_name(name)</span><br><span class=\"line\">\t\t,_gender(gender)</span><br><span class=\"line\">\t\t,_age(age)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Info</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name:%s age:%d\\n&quot;</span>, _name.<span class=\"built_in\">c_str</span>(), _age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tstring _gender;</span><br><span class=\"line\">\t<span class=\"type\">int</span> _age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> :<span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Student</span>(<span class=\"type\">const</span> string&amp; name,<span class=\"type\">const</span> string&amp; gender,<span class=\"type\">int</span> age,<span class=\"type\">int</span> ID)</span><br><span class=\"line\">\t\t:<span class=\"built_in\">Person</span>(name,gender,age)<span class=\"comment\">//显式调用父类的构造函数</span></span><br><span class=\"line\">\t\t,_ID(ID)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getID</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;ID:&quot;</span> &lt;&lt; _ID &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _ID;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Student <span class=\"title\">stu</span><span class=\"params\">(<span class=\"string\">&quot;supdriver&quot;</span>, <span class=\"string\">&quot;male&quot;</span>, <span class=\"number\">24</span>, <span class=\"number\">114514</span>)</span></span>;<span class=\"comment\">//调用构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Person  <span class=\"title\">person</span><span class=\"params\">(stu)</span></span>;<span class=\"comment\">//这里没有显式声明对应的构造函数，而是自动切片</span></span><br><span class=\"line\">\tPerson* pp = &amp;stu;<span class=\"comment\">//父类指针可以指向派生类</span></span><br><span class=\"line\">\tPerson&amp; rp = stu;<span class=\"comment\">//父类引用可以指向派生类</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//stu = person;//父类对象不能赋值给派生类</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//基类的指针可以通过强制类型转换赋值给派生类的指针</span></span><br><span class=\"line\">\tpp = &amp;stu;</span><br><span class=\"line\">\tStudent* pstu = (Student*)pp;<span class=\"comment\">//指针地址就是指向派生类的，所以这种情况是安全的，合法的</span></span><br><span class=\"line\">\tpstu-&gt;_ID = <span class=\"number\">233</span>;<span class=\"comment\">//这里并没有越界</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tpp = &amp;person;</span><br><span class=\"line\">\tpstu = (Student*)pp;<span class=\"comment\">//这种就是不安全的，可能会越界访问\t</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承中的作用域-隐藏机制\"><a href=\"#继承中的作用域-隐藏机制\" class=\"headerlink\" title=\"继承中的作用域(隐藏机制)\"></a>继承中的作用域(<code>隐藏</code>机制)</h2><ol>\n<li>在继承体系中<code>基类</code>和<code>派生类</code>都有独立的作用域(<code>类域</code>)</li>\n<li>子类和父类中有同名成员，<strong>不指定成员所在类域时</strong>，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫<code>隐藏</code>，也叫<code>重定义</code>。</li>\n<li>需要注意的是如果是成员函数的隐藏，只需要<strong>函数名相</strong>同就构成隐藏。</li>\n<li>注意在<strong>实际中</strong>在继承体系里面最好<strong>不要定义同名的成员</strong>。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Info</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name:%s age:%d\\n&quot;</span>, _name.<span class=\"built_in\">c_str</span>(), _age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name = <span class=\"string\">&quot;supdriver&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> _age = <span class=\"number\">24</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>:<span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Info</span><span class=\"params\">()</span><span class=\"comment\">//同名函数构成隐藏</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name:%s age:%d\\n ID:%d&quot;</span>, _name.<span class=\"built_in\">c_str</span>(), _age,_ID);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _ID = <span class=\"number\">114514</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tStudent stu;</span><br><span class=\"line\">\tstu.<span class=\"built_in\">Info</span>();<span class=\"comment\">//调用Student类内的Info函数，而父类内的被隐藏</span></span><br><span class=\"line\">\tstu.Person::<span class=\"built_in\">Info</span>();<span class=\"comment\">//显式调用Person内的Info函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐藏与重载辨析\"><a href=\"#隐藏与重载辨析\" class=\"headerlink\" title=\"隐藏与重载辨析\"></a>隐藏与重载辨析</h3><ul>\n<li><code>重载</code>：函数重载是根据同名函数的<code>参数类型</code>和<code>参数顺序</code>选择实际调用的函数，选择的动作只能由编译器完成</li>\n<li><code>隐藏</code>：成员的隐藏是同名成员根据<code>类域</code>的<code>就近原则</code>由编译器自动调用，但也可以通过指定类域，在代码中选择</li>\n</ul>\n<h2 id=\"派生类的默认成员函数\"><a href=\"#派生类的默认成员函数\" class=\"headerlink\" title=\"派生类的默认成员函数\"></a>派生类的默认成员函数</h2><p>6个默认成员函数，“默认”的意思就是指我们不写，编译器会变我们自动生成一个，那么在派生类<br>中，这几个成员函数是如何生成的呢?</p>\n<ol>\n<li>派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。</li>\n<li>派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。</li>\n<li>派生类的operator&#x3D;必须要调用基类的operator&#x3D;完成基类的复制。</li>\n<li>派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。</li>\n<li>派生类对象初始化先调用基类构造再调派生类构造。</li>\n<li>派生类对象析构清理先调用派生类析构再调基类的析构。</li>\n<li>因为后续一些场景析构函数需要构成重写，重写的条件之一是函数名相同(这个我们后面会讲解)。那么编译器会对<strong>析构函数名进行特殊处理</strong>，处理成<code>destrutor()</code>，所以父类析构函数不加virtual的情况下，子类析构函数和父类析构函数构成隐藏关系。</li>\n</ol>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409031848644.png\"></p>\n<h2 id=\"继承与友元函数\"><a href=\"#继承与友元函数\" class=\"headerlink\" title=\"继承与友元函数\"></a>继承与友元函数</h2><p>友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员 </p>\n<p>示例如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"type\">const</span> Person&amp; p, <span class=\"type\">const</span> Student&amp; s)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name; <span class=\"comment\">// 姓名</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> : <span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _stuNum; <span class=\"comment\">// 学号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"type\">const</span> Person&amp; p, <span class=\"type\">const</span> Student&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; p._name &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; s._name &lt;&lt; endl;<span class=\"comment\">//这行代码不会报错，因为_name是继承自Person类的</span></span><br><span class=\"line\">\tcout &lt;&lt; s._stuNum &lt;&lt; endl;<span class=\"comment\">//这行代码会报错，因为函数没有权限访问Student类自己声明的成员</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tPerson p;</span><br><span class=\"line\">\tStudent s;</span><br><span class=\"line\">\t<span class=\"built_in\">Display</span>(p, s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承与静态成员\"><a href=\"#继承与静态成员\" class=\"headerlink\" title=\"继承与静态成员\"></a>继承与静态成员</h2><p>基类定义了<code>static静态成员</code>，则<strong>整个继承体系里面只有一个这样的成员</strong>。无论派生出多少个子类，都<strong>只有一个</strong>static成员实例 。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123; ++_count; &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name; <span class=\"comment\">// 姓名</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> _count; <span class=\"comment\">// 静态成员变量,统计人的个数。</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> Person::_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> : <span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _stuNum; <span class=\"comment\">// 学号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Graduate</span> : <span class=\"keyword\">public</span> Student</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _seminarCourse; <span class=\"comment\">// 研究科目</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tStudent s1;</span><br><span class=\"line\">\tStudent s2;</span><br><span class=\"line\">\tStudent s3;</span><br><span class=\"line\">\tGraduate s4;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot; 人数 :&quot;</span> &lt;&lt; Person::_count &lt;&lt; endl;</span><br><span class=\"line\">\tStudent::_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot; 人数 :&quot;</span> &lt;&lt; Person::_count &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409040748921.png\"></p>\n<h2 id=\"复杂的菱形继承及菱形虚拟继承\"><a href=\"#复杂的菱形继承及菱形虚拟继承\" class=\"headerlink\" title=\"复杂的菱形继承及菱形虚拟继承\"></a>复杂的菱形继承及菱形虚拟继承</h2><h3 id=\"单继承\"><a href=\"#单继承\" class=\"headerlink\" title=\"单继承\"></a>单继承</h3><p><code>单继承</code>：一个子类只有<em>一个直接父类</em>时称这个继承关系为<code>单继承</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/single_inherit.png\"></p>\n<h3 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h3><p><code>多继承</code>：一个子类有<strong>两个或以上直接父类</strong>时称这个继承关系为<code>多继承</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/multi_inherit.png\"></p>\n<h3 id=\"菱形继承\"><a href=\"#菱形继承\" class=\"headerlink\" title=\"菱形继承\"></a>菱形继承</h3><p><code>菱形继承</code>：菱形继承是多继承的一种<strong>特殊情况</strong>。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Diamond_Inherit.png\"></p>\n<p><code>菱形继承的问题</code>：从下面的对象成员模型构造，可以看出菱形继承有<code>数据冗余</code>和<code>二义性</code>的问题。<br>在Assistant的对象中Person成员会有两份。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/IHR_diamond.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\"> \tstring _name ; <span class=\"comment\">// 姓名</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> : <span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \t<span class=\"type\">int</span> _num ; <span class=\"comment\">//学号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Teacher</span> : <span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \t<span class=\"type\">int</span> _id ; <span class=\"comment\">// 职工编号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Assistant</span> : <span class=\"keyword\">public</span> Student, <span class=\"keyword\">public</span> Teacher</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \tstring _majorCourse ; <span class=\"comment\">// 主修课程</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Test</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 这样会有二义性无法明确知道访问的是哪一个</span></span><br><span class=\"line\">\tAssistant a ;</span><br><span class=\"line\">\ta._name = <span class=\"string\">&quot;peter&quot;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决</span></span><br><span class=\"line\">\ta.Student::_name = <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\">\ta.Teacher::_name = <span class=\"string\">&quot;yyy&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"虚拟继承\"><a href=\"#虚拟继承\" class=\"headerlink\" title=\"虚拟继承\"></a>虚拟继承</h4><p><code>虚拟继承</code>可以解决<strong>菱形继承</strong>的二义性和数据冗余的问题。如上面的继承关系，在Student和Teacher的继承Person时使用<code>虚拟继承</code>，即可解决问题。需要注意的是，<strong>虚拟继承不要在其他地方去使用。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\"> \tstring _name ; <span class=\"comment\">// 姓名</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Person <span class=\"comment\">//虚拟继承共同父类</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \t<span class=\"type\">int</span> _num ; <span class=\"comment\">//学号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Teacher</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Person <span class=\"comment\">//虚拟继承共同父类</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \t<span class=\"type\">int</span> _id ; <span class=\"comment\">// 职工编号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Assistant</span> : <span class=\"keyword\">public</span> Student, <span class=\"keyword\">public</span> Teacher</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \tstring _majorCourse ; <span class=\"comment\">// 主修课程</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Test</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> \tAssistant a ;</span><br><span class=\"line\"> \ta._name = <span class=\"string\">&quot;peter&quot;</span>;<span class=\"comment\">//二义性和数据冗余已被解决</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>虚拟继承解决数据冗余和二义性的原理</strong><br>下图是菱形虚拟继承的内存对象成员模型：这里可以分析出<code>Assistant</code>对象中将<code>Person</code>放到的了对象组成的最下面，这个<code>Person</code>同时属于<code>Student</code>和<code>Teacher</code>，那么<code>Student</code>和<code>Teacher</code>如何去找到公共的<code>Person</code>呢？<strong>这里是通过了<code>Student</code>和<code>Teacher</code>的两个指针，指向的一张表。这两个指针叫<code>虚基表指针</code>，这两个表叫<code>虚基表</code>。虚基表中存的偏移量。通过偏移量可以找到下面的<code>Person</code></strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/INHERIT_virtual.png\"></p>\n<h1 id=\"继承的总结和反思\"><a href=\"#继承的总结和反思\" class=\"headerlink\" title=\"继承的总结和反思\"></a>继承的总结和反思</h1><h2 id=\"尽量不使用多继承，不要设计出菱形继承\"><a href=\"#尽量不使用多继承，不要设计出菱形继承\" class=\"headerlink\" title=\"尽量不使用多继承，不要设计出菱形继承\"></a>尽量不使用多继承，不要设计出菱形继承</h2><p>C++语法中的<code>多继承</code>正是其语法复杂性的体现之一。有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟继承，底层实现就很复杂。所以<strong>一般不建议设计出多继承，一定不要设计出菱形继承</strong>。否则在复杂度及性能上都有问题。</p>\n<h2 id=\"继承和组成辨析\"><a href=\"#继承和组成辨析\" class=\"headerlink\" title=\"继承和组成辨析\"></a>继承和组成辨析</h2><ul>\n<li>public继承是一种<code>is-a</code>的关系。也就是说每个派生类对象都是一个基类对象</li>\n<li>组合是一种<code>has-a</code>的关系。假设B组合了A，每个B对象中都有一个A对象。</li>\n<li>为了提高代码的<code>封装性</code>和<code>解耦合</code>，<a href=\"https://www.cnblogs.com/nexiyi/archive/2013/06/16/3138568.html\">优先使用对象组合，而不是类继承🔗</a></li>\n<li><code>白箱复用</code>：继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，<strong>基类的内部细节对子类可见</strong> 。继承一定程度<strong>破坏</strong>了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，<strong>耦合度高</strong>。</li>\n<li><code>黑箱复用</code>：对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装。</li>\n<li>实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409052348435.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"继承的概念及定义\"><a href=\"#继承的概念及定义\" class=\"headerlink\" title=\"继承的概念及定义\"></a>继承的概念及定义</h1><h2 id=\"继承的概念\"><a href=\"#继承的概念\" class=\"headerlink\" title=\"继承的概念\"></a>继承的概念</h2><p><code>继承</code>(inheritance)机制是面向对象程序设计使代码可以<strong>复用</strong>的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称<code>派生类</code>。继承呈现了面向对象程序设计的<code>层次结构</code>，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的<code>复用</code></p>\n<p>下面用一个简单的示例演示一下继承<br><strong>示例</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Info</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name:%s age:%d\\n&quot;</span>, _name.<span class=\"built_in\">c_str</span>(), _age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name = <span class=\"string\">&quot;supdriver&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> _age = <span class=\"number\">24</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>:<span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getID</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;ID:&quot;</span> &lt;&lt; _ID &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _ID = <span class=\"number\">114514</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tStudent stu;</span><br><span class=\"line\">\tstu.<span class=\"built_in\">Info</span>();</span><br><span class=\"line\">\tstu.<span class=\"built_in\">getID</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承的使用\"><a href=\"#继承的使用\" class=\"headerlink\" title=\"继承的使用\"></a>继承的使用</h2><p>当我们准备好一个<code>基类</code>后，便可将其用于<code>派生类</code>的声明</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Inherit.png\"></p>\n<p>由图中可以看到，新的概念：<code>继承方式</code>，而且很巧的是，它和<code>访问限定符</code>的关键字是一一对应的</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409030857308.png\"></p>\n<p>实际上，它们共同决定了基类成员在派生类内的访问限定符</p>\n<h3 id=\"继承基类成员访问方式的变化\"><a href=\"#继承基类成员访问方式的变化\" class=\"headerlink\" title=\"继承基类成员访问方式的变化\"></a>继承基类成员访问方式的变化</h3><table>\n<thead>\n<tr>\n<th>类成员&#x2F;继承方式</th>\n<th><code>public</code>继承</th>\n<th><code>protected</code>继承</th>\n<th><code>private</code>继承</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>基类的<code>public</code>成员</td>\n<td>派生类的<code>public</code>成员</td>\n<td>派生类的<code>protected</code>成员</td>\n<td>派生类的<code>private</code>成员</td>\n</tr>\n<tr>\n<td>基类的<code>protected</code>成员</td>\n<td>派生类的<code>protected</code>成员</td>\n<td>派生类的<code>protected</code>成员</td>\n<td>派生类的<code>private</code>成员</td>\n</tr>\n<tr>\n<td>基类的<code>private</code>成员</td>\n<td>在派生类中<code>不可见</code></td>\n<td>在派生类中<code>不可见</code></td>\n<td>在派生类中<code>不可见</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li><code>不可见</code>:基类private成员在派生类中无论以什么方式继承都是不可见的。<strong>这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。</strong></li>\n<li><code>protected</code>:基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected。<strong>可以看出<code>protected</code>保护成员限定符是因继承才出现的。</strong></li>\n<li><code>规律</code>:实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 &#x3D;&#x3D; <code>Min(成员在基类的访问限定符，继承方式)</code>，其中的大小关系为<code>public &gt; protected &gt; private</code></li>\n<li><code>默认行为</code>:使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过<strong>最好显示</strong>的写出继承方式。</li>\n<li><code>扩展性</code>:在实际运用中一般使用都是public继承，几乎很少使用protetced&#x2F;private继承，也不提倡使用protetced&#x2F;private继承，因为protetced&#x2F;private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强</li>\n</ol>\n<h2 id=\"派生类的构造函数\"><a href=\"#派生类的构造函数\" class=\"headerlink\" title=\"派生类的构造函数\"></a>派生类的构造函数</h2><p>有时基类并不提供无参的默认构造函数,那么如何在派生类的构造函数里<code>显示地调用基类构造函数</code>呢?</p>\n<p>其实编译器的报错也给出了提示</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/inherit_construct.png\"></p>\n<p>可以看到，在初始化列表后面出现了报错:<code>Person不存在默认构造函数</code>,显然，显示调用构造函数的位置在初始化列表。</p>\n<p>那么怎么调用呢？构造函数也是成员函数！除了基类中<code>private</code>修饰的构造函数，派生类中皆可调用父类的成员函数，直接在初始化列表中显式调用即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//基类的公有构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"type\">const</span> string&amp; name, <span class=\"type\">const</span> string&amp; gender, <span class=\"type\">int</span> age)</span><br><span class=\"line\">\t\t:_name(name)</span><br><span class=\"line\">\t\t,_gender(gender)</span><br><span class=\"line\">\t\t,_age(age)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Info</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name:%s age:%d\\n&quot;</span>, _name.<span class=\"built_in\">c_str</span>(), _age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tstring _gender;</span><br><span class=\"line\">\t<span class=\"type\">int</span> _age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> :<span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Student</span>(<span class=\"type\">const</span> string&amp; name,<span class=\"type\">const</span> string&amp; gender,<span class=\"type\">int</span> age,<span class=\"type\">int</span> ID)</span><br><span class=\"line\">\t\t:<span class=\"built_in\">Person</span>(name,gender,age)<span class=\"comment\">//显式调用父类的构造函数</span></span><br><span class=\"line\">\t\t,_ID(ID)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getID</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;ID:&quot;</span> &lt;&lt; _ID &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _ID;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Student <span class=\"title\">stu</span><span class=\"params\">(<span class=\"string\">&quot;supdriver&quot;</span>, <span class=\"string\">&quot;male&quot;</span>, <span class=\"number\">24</span>, <span class=\"number\">114514</span>)</span></span>;<span class=\"comment\">//调用构造函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基类和派生类的赋值转化\"><a href=\"#基类和派生类的赋值转化\" class=\"headerlink\" title=\"基类和派生类的赋值转化\"></a>基类和派生类的赋值转化</h2><ul>\n<li>派生类对象 可以赋值给 <code>基类的对象</code> &#x2F; <code>基类的指针</code> &#x2F; <code>基类的引用</code>。这里有个形象的说法叫<code>切片</code>或者<code>切割</code>。寓意把派生类中父类那部分切来赋值过去。</li>\n<li>基类对象<strong>不能</strong>赋值给派生类对象</li>\n<li>基类的<code>指针</code>或者<code>引用</code>可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是<strong>基类的指针是指向派生类对象时才是安全的</strong>。</li>\n</ul>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/slice.png\"></p>\n<p>下面用一个示例演示一下切片,赋值转换等问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//基类的公有构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>(<span class=\"type\">const</span> string&amp; name, <span class=\"type\">const</span> string&amp; gender, <span class=\"type\">int</span> age)</span><br><span class=\"line\">\t\t:_name(name)</span><br><span class=\"line\">\t\t,_gender(gender)</span><br><span class=\"line\">\t\t,_age(age)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Info</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name:%s age:%d\\n&quot;</span>, _name.<span class=\"built_in\">c_str</span>(), _age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tstring _gender;</span><br><span class=\"line\">\t<span class=\"type\">int</span> _age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> :<span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Student</span>(<span class=\"type\">const</span> string&amp; name,<span class=\"type\">const</span> string&amp; gender,<span class=\"type\">int</span> age,<span class=\"type\">int</span> ID)</span><br><span class=\"line\">\t\t:<span class=\"built_in\">Person</span>(name,gender,age)<span class=\"comment\">//显式调用父类的构造函数</span></span><br><span class=\"line\">\t\t,_ID(ID)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getID</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;ID:&quot;</span> &lt;&lt; _ID &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _ID;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Student <span class=\"title\">stu</span><span class=\"params\">(<span class=\"string\">&quot;supdriver&quot;</span>, <span class=\"string\">&quot;male&quot;</span>, <span class=\"number\">24</span>, <span class=\"number\">114514</span>)</span></span>;<span class=\"comment\">//调用构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Person  <span class=\"title\">person</span><span class=\"params\">(stu)</span></span>;<span class=\"comment\">//这里没有显式声明对应的构造函数，而是自动切片</span></span><br><span class=\"line\">\tPerson* pp = &amp;stu;<span class=\"comment\">//父类指针可以指向派生类</span></span><br><span class=\"line\">\tPerson&amp; rp = stu;<span class=\"comment\">//父类引用可以指向派生类</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//stu = person;//父类对象不能赋值给派生类</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//基类的指针可以通过强制类型转换赋值给派生类的指针</span></span><br><span class=\"line\">\tpp = &amp;stu;</span><br><span class=\"line\">\tStudent* pstu = (Student*)pp;<span class=\"comment\">//指针地址就是指向派生类的，所以这种情况是安全的，合法的</span></span><br><span class=\"line\">\tpstu-&gt;_ID = <span class=\"number\">233</span>;<span class=\"comment\">//这里并没有越界</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tpp = &amp;person;</span><br><span class=\"line\">\tpstu = (Student*)pp;<span class=\"comment\">//这种就是不安全的，可能会越界访问\t</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承中的作用域-隐藏机制\"><a href=\"#继承中的作用域-隐藏机制\" class=\"headerlink\" title=\"继承中的作用域(隐藏机制)\"></a>继承中的作用域(<code>隐藏</code>机制)</h2><ol>\n<li>在继承体系中<code>基类</code>和<code>派生类</code>都有独立的作用域(<code>类域</code>)</li>\n<li>子类和父类中有同名成员，<strong>不指定成员所在类域时</strong>，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫<code>隐藏</code>，也叫<code>重定义</code>。</li>\n<li>需要注意的是如果是成员函数的隐藏，只需要<strong>函数名相</strong>同就构成隐藏。</li>\n<li>注意在<strong>实际中</strong>在继承体系里面最好<strong>不要定义同名的成员</strong>。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Info</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name:%s age:%d\\n&quot;</span>, _name.<span class=\"built_in\">c_str</span>(), _age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name = <span class=\"string\">&quot;supdriver&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> _age = <span class=\"number\">24</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>:<span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Info</span><span class=\"params\">()</span><span class=\"comment\">//同名函数构成隐藏</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name:%s age:%d\\n ID:%d&quot;</span>, _name.<span class=\"built_in\">c_str</span>(), _age,_ID);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _ID = <span class=\"number\">114514</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tStudent stu;</span><br><span class=\"line\">\tstu.<span class=\"built_in\">Info</span>();<span class=\"comment\">//调用Student类内的Info函数，而父类内的被隐藏</span></span><br><span class=\"line\">\tstu.Person::<span class=\"built_in\">Info</span>();<span class=\"comment\">//显式调用Person内的Info函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐藏与重载辨析\"><a href=\"#隐藏与重载辨析\" class=\"headerlink\" title=\"隐藏与重载辨析\"></a>隐藏与重载辨析</h3><ul>\n<li><code>重载</code>：函数重载是根据同名函数的<code>参数类型</code>和<code>参数顺序</code>选择实际调用的函数，选择的动作只能由编译器完成</li>\n<li><code>隐藏</code>：成员的隐藏是同名成员根据<code>类域</code>的<code>就近原则</code>由编译器自动调用，但也可以通过指定类域，在代码中选择</li>\n</ul>\n<h2 id=\"派生类的默认成员函数\"><a href=\"#派生类的默认成员函数\" class=\"headerlink\" title=\"派生类的默认成员函数\"></a>派生类的默认成员函数</h2><p>6个默认成员函数，“默认”的意思就是指我们不写，编译器会变我们自动生成一个，那么在派生类<br>中，这几个成员函数是如何生成的呢?</p>\n<ol>\n<li>派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。</li>\n<li>派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。</li>\n<li>派生类的operator&#x3D;必须要调用基类的operator&#x3D;完成基类的复制。</li>\n<li>派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。</li>\n<li>派生类对象初始化先调用基类构造再调派生类构造。</li>\n<li>派生类对象析构清理先调用派生类析构再调基类的析构。</li>\n<li>因为后续一些场景析构函数需要构成重写，重写的条件之一是函数名相同(这个我们后面会讲解)。那么编译器会对<strong>析构函数名进行特殊处理</strong>，处理成<code>destrutor()</code>，所以父类析构函数不加virtual的情况下，子类析构函数和父类析构函数构成隐藏关系。</li>\n</ol>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409031848644.png\"></p>\n<h2 id=\"继承与友元函数\"><a href=\"#继承与友元函数\" class=\"headerlink\" title=\"继承与友元函数\"></a>继承与友元函数</h2><p>友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员 </p>\n<p>示例如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"type\">const</span> Person&amp; p, <span class=\"type\">const</span> Student&amp; s)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name; <span class=\"comment\">// 姓名</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> : <span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _stuNum; <span class=\"comment\">// 学号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Display</span><span class=\"params\">(<span class=\"type\">const</span> Person&amp; p, <span class=\"type\">const</span> Student&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; p._name &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; s._name &lt;&lt; endl;<span class=\"comment\">//这行代码不会报错，因为_name是继承自Person类的</span></span><br><span class=\"line\">\tcout &lt;&lt; s._stuNum &lt;&lt; endl;<span class=\"comment\">//这行代码会报错，因为函数没有权限访问Student类自己声明的成员</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tPerson p;</span><br><span class=\"line\">\tStudent s;</span><br><span class=\"line\">\t<span class=\"built_in\">Display</span>(p, s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承与静态成员\"><a href=\"#继承与静态成员\" class=\"headerlink\" title=\"继承与静态成员\"></a>继承与静态成员</h2><p>基类定义了<code>static静态成员</code>，则<strong>整个继承体系里面只有一个这样的成员</strong>。无论派生出多少个子类，都<strong>只有一个</strong>static成员实例 。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123; ++_count; &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _name; <span class=\"comment\">// 姓名</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> _count; <span class=\"comment\">// 静态成员变量,统计人的个数。</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> Person::_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> : <span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _stuNum; <span class=\"comment\">// 学号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Graduate</span> : <span class=\"keyword\">public</span> Student</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tstring _seminarCourse; <span class=\"comment\">// 研究科目</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tStudent s1;</span><br><span class=\"line\">\tStudent s2;</span><br><span class=\"line\">\tStudent s3;</span><br><span class=\"line\">\tGraduate s4;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot; 人数 :&quot;</span> &lt;&lt; Person::_count &lt;&lt; endl;</span><br><span class=\"line\">\tStudent::_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot; 人数 :&quot;</span> &lt;&lt; Person::_count &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409040748921.png\"></p>\n<h2 id=\"复杂的菱形继承及菱形虚拟继承\"><a href=\"#复杂的菱形继承及菱形虚拟继承\" class=\"headerlink\" title=\"复杂的菱形继承及菱形虚拟继承\"></a>复杂的菱形继承及菱形虚拟继承</h2><h3 id=\"单继承\"><a href=\"#单继承\" class=\"headerlink\" title=\"单继承\"></a>单继承</h3><p><code>单继承</code>：一个子类只有<em>一个直接父类</em>时称这个继承关系为<code>单继承</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/single_inherit.png\"></p>\n<h3 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h3><p><code>多继承</code>：一个子类有<strong>两个或以上直接父类</strong>时称这个继承关系为<code>多继承</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/multi_inherit.png\"></p>\n<h3 id=\"菱形继承\"><a href=\"#菱形继承\" class=\"headerlink\" title=\"菱形继承\"></a>菱形继承</h3><p><code>菱形继承</code>：菱形继承是多继承的一种<strong>特殊情况</strong>。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Diamond_Inherit.png\"></p>\n<p><code>菱形继承的问题</code>：从下面的对象成员模型构造，可以看出菱形继承有<code>数据冗余</code>和<code>二义性</code>的问题。<br>在Assistant的对象中Person成员会有两份。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/IHR_diamond.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\"> \tstring _name ; <span class=\"comment\">// 姓名</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> : <span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \t<span class=\"type\">int</span> _num ; <span class=\"comment\">//学号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Teacher</span> : <span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \t<span class=\"type\">int</span> _id ; <span class=\"comment\">// 职工编号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Assistant</span> : <span class=\"keyword\">public</span> Student, <span class=\"keyword\">public</span> Teacher</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \tstring _majorCourse ; <span class=\"comment\">// 主修课程</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Test</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 这样会有二义性无法明确知道访问的是哪一个</span></span><br><span class=\"line\">\tAssistant a ;</span><br><span class=\"line\">\ta._name = <span class=\"string\">&quot;peter&quot;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决</span></span><br><span class=\"line\">\ta.Student::_name = <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\">\ta.Teacher::_name = <span class=\"string\">&quot;yyy&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"虚拟继承\"><a href=\"#虚拟继承\" class=\"headerlink\" title=\"虚拟继承\"></a>虚拟继承</h4><p><code>虚拟继承</code>可以解决<strong>菱形继承</strong>的二义性和数据冗余的问题。如上面的继承关系，在Student和Teacher的继承Person时使用<code>虚拟继承</code>，即可解决问题。需要注意的是，<strong>虚拟继承不要在其他地方去使用。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\"> \tstring _name ; <span class=\"comment\">// 姓名</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Person <span class=\"comment\">//虚拟继承共同父类</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \t<span class=\"type\">int</span> _num ; <span class=\"comment\">//学号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Teacher</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Person <span class=\"comment\">//虚拟继承共同父类</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \t<span class=\"type\">int</span> _id ; <span class=\"comment\">// 职工编号</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Assistant</span> : <span class=\"keyword\">public</span> Student, <span class=\"keyword\">public</span> Teacher</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> :</span><br><span class=\"line\"> \tstring _majorCourse ; <span class=\"comment\">// 主修课程</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Test</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> \tAssistant a ;</span><br><span class=\"line\"> \ta._name = <span class=\"string\">&quot;peter&quot;</span>;<span class=\"comment\">//二义性和数据冗余已被解决</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>虚拟继承解决数据冗余和二义性的原理</strong><br>下图是菱形虚拟继承的内存对象成员模型：这里可以分析出<code>Assistant</code>对象中将<code>Person</code>放到的了对象组成的最下面，这个<code>Person</code>同时属于<code>Student</code>和<code>Teacher</code>，那么<code>Student</code>和<code>Teacher</code>如何去找到公共的<code>Person</code>呢？<strong>这里是通过了<code>Student</code>和<code>Teacher</code>的两个指针，指向的一张表。这两个指针叫<code>虚基表指针</code>，这两个表叫<code>虚基表</code>。虚基表中存的偏移量。通过偏移量可以找到下面的<code>Person</code></strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/INHERIT_virtual.png\"></p>\n<h1 id=\"继承的总结和反思\"><a href=\"#继承的总结和反思\" class=\"headerlink\" title=\"继承的总结和反思\"></a>继承的总结和反思</h1><h2 id=\"尽量不使用多继承，不要设计出菱形继承\"><a href=\"#尽量不使用多继承，不要设计出菱形继承\" class=\"headerlink\" title=\"尽量不使用多继承，不要设计出菱形继承\"></a>尽量不使用多继承，不要设计出菱形继承</h2><p>C++语法中的<code>多继承</code>正是其语法复杂性的体现之一。有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟继承，底层实现就很复杂。所以<strong>一般不建议设计出多继承，一定不要设计出菱形继承</strong>。否则在复杂度及性能上都有问题。</p>\n<h2 id=\"继承和组成辨析\"><a href=\"#继承和组成辨析\" class=\"headerlink\" title=\"继承和组成辨析\"></a>继承和组成辨析</h2><ul>\n<li>public继承是一种<code>is-a</code>的关系。也就是说每个派生类对象都是一个基类对象</li>\n<li>组合是一种<code>has-a</code>的关系。假设B组合了A，每个B对象中都有一个A对象。</li>\n<li>为了提高代码的<code>封装性</code>和<code>解耦合</code>，<a href=\"https://www.cnblogs.com/nexiyi/archive/2013/06/16/3138568.html\">优先使用对象组合，而不是类继承🔗</a></li>\n<li><code>白箱复用</code>：继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，<strong>基类的内部细节对子类可见</strong> 。继承一定程度<strong>破坏</strong>了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，<strong>耦合度高</strong>。</li>\n<li><code>黑箱复用</code>：对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装。</li>\n<li>实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。</li>\n</ul>\n"},{"title":"手撕红黑树 并封装map和set","date":"2024-09-03T00:21:33.000Z","_content":"\n# 红黑树\n\n虽然`AVL树`作为绝对的平衡搜索二叉树，有着极高的查询效率，但正因为其严格的要求，修改`AVL树`的某个结点时，可能要一路调整到根节点，效率低下。为了解决这一痛点，略微没那么严格的**近似平衡搜索二叉树**，即`红黑树`被提出\n\n## 红黑树的概念\n红黑树，是一种二叉搜索树，但在每个结点上`增加一个存储位表示结点的颜色`，可以是`Red`或`Black`。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，**红黑树确保没有一条路径会比其他路径长出俩倍**，因而是**接近平衡**的。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTree_RBT.png)\n\n## 红黑树的性质\n首先与一般的定义不同，在红黑树中将`空指针`(上图为`NIL`)作为`叶子节点`,然后我们来讨论具体的性质\n\n1. 每个结点不是`红色`就是`黑色`\n2. 根节点必定是`黑色`的\n3. 如果一个结点是`红色`的,则它的两个**孩子结点**是`黑色`的\n4. 对于每个结点，该结点到其所有后代叶结点的简单路径上，均包含**相同数目**的`黑色`结点\n5. 每个**叶子结点**都是`黑色`的此处的叶子结点指的是`空结点NIL`\n\n**思考：为什么满足上面的性质，红黑树就能保证：其最长路径中节点个数不会超过最短路径节点个数的两倍？**\n> 红黑树的性质保证了从根节点到所有叶子结点（空结点）的路径上，**包含相同数量的黑色结点**。这是红黑树平衡性的重要保证，以下是如何保证最长路径不会超过最短路径两倍的具体解释：\n> 1. 黑色高度的定义：\n>   + 对于红黑树中的每个结点，定义其黑色高度为从该结点到叶子结点的路径上黑色结点的数量。根据性质 4，这个数量在所有路径上都是相同的。\n>   + 设定黑色高度为`h`。那么从根到任意叶子结点的路径都包含`h`个黑色结点。\n> 2. 红色结点的插入：\n>   + 根据性质3，如果一个结点是红色的，则它的两个孩子结点是黑色的。这就意味着每个红色结点必定有两个黑色的孩子。\n>   + 因此，从根到叶子结点的路径上，红色结点与黑色结点交替出现，红色结点之间的路径长度会相对较短。\n> 3. 路径长度的关系：\n>   + 根到一个叶子结点的路径的最长可能路径是最短路径的两倍。这是因为每个红色结点都在路径上增加了一个额外的层级，但它们只增加了一个红色结点的高度，而黑色结点的数量不变。\n>   + 如果某条路径上有 `r` 个红色结点，那么该路径的总长度将是 `h + r`，其中 `h` 是黑色结点的数量。因为红色结点的数量 `r` 可以最大等于 `h`，所以最长路径的长度 `h + r`最大为 `2h`，即**最长路径的长度不会超过最短路径的两倍**。\n\n\n## 红黑树的实现\n这里我们仿照`STL30`的源码,再用更简洁易懂的代码形式实现红黑树,*比如节点和迭代器的双层设计，这里就不使用了*\n\n### 红黑树结点\n+ 因为要经常访问父结点，所以这里用三叉链表维护树结构\n+ 红黑树的节点需要一个变量表示颜色，这里用`typedef`把`bool`类型封装为`Color`类\n+ 使用模板来存储泛类型的值\n\n```C++\n#pragma once\n#include <functional>\n\ntypedef bool Color;//只有红黑两种颜色，正好使用bool类型\nconst Color Red = false;//定义两种颜色\nconst Color Black = true;\n\n//红黑树结点的定义\ntemplate <class ValueType>\nstruct RBTreeNode\n{\n\ttypedef RBTreeNode<ValueType> Node;//简化代码\n\tNode* _left;\n\tNode* _right;\n\tNode* _parent;\n\tColor _color;\n\n\tValueType _value;\n\tRBTreeNode(const ValueType& val, Color color)\n\t\t:_value(val)\n\t\t, _color(color)\n\t\t, _left(nullptr)\n\t\t, _right(nullptr)\n\t\t, _parent(nullptr)\n\t{}\n};\n```\n\n### 红黑树的基本结构\n+ 模板参数:红黑树也是`KV`类型的二叉树，所以模板参数有:\n  + `K`:即Key,节点使用`K`类型的参数比较\n  + `V`:即ValueType,构造红黑树结点时传入的模板参数\n  + `KeyOfValue`:因为节点将`Key`值也存在了节点的值域，所以需要外部传入`仿函数KeyOfValue`将Key值取出\n  + `Compare`:允许外部自定义`K类型`的比较规则\n+ typedef封装:\n  + `typedef RBTreeNode<V> Node;`\n+ 私有成员变量:\n  + `Compare _cmp`:声明一个仿函数成员变量，整个对象里都能直接调用\n  + `KeyOfValue _kof`:用处同上\n  + `Node* _header`\n+ 默认构造函数：\n  + 使用缺省传入`const Compare&`类型定义的`std::greater<K>()`临时对象\n  + 创建哨兵位作为头结点，使后续对根结点的调整与一般情况统一\n+ 私有函数`GetRoot()` `left()` `right()`\n  + 将对根节点的获取封装起来，使代码更直观\n  + 简化代码，获取左右子树\n\n至于迭代器的封装，我们在[后文实现](#iterator )\n\n```C++\ntemplate<class K,class V,class KeyOfValue,class Compare = std::greater<int> >\nclass RBTree\n{\n\ttypedef RBTreeNode<V> Node;\n\npublic:\n\tRBTree(const Compare& cmp =Compare())\n\t\t:_cmp(cmp), _header(nullptr)\n\t{\n\t\t//创建哨兵位头结点，使后面调整树形状不用区分根节点\n\t\t_header = new Node(V(), Black);\n\t}\n\nprivate:\n\tNode* GetRoot()\n\t{\n\t\tif (_header->_parent == _header)return nullptr;\n\t\telse return _header->_parent;\n\t}\n\n\tNode* SetRoot(Node* root)\n\t{\n\t\tif (root == nullptr)return nullptr;\n\t\troot->_parent = _header;\n\t\t_header->_parent = root;\n\t}\n\n\tNode* left(Node* root)\n\t{\n\t\tif (root == nullptr)return nullptr;\n\t\treturn root->_left;\n\t}\n\n\tNode* right(Node* root)\n\t{\n\t\tif (root == nullptr)return nullptr;\n\t\treturn root->_right;\n\t}\n\nprivate:\n\tCompare _cmp;\n\tKeyOfValue _kof;\n\tNode* _header;\n};\n```\n\n### 红黑树的插入\n和`AVL树`一样，红黑树的插入也分为两步`新增结点`和`调整`\n\n#### 新增结点\n关于根结点的颜色，前面的[规定性质](#红黑树的性质)里也说了，根节点为黑色，这里在重申一下为什么一定是黑色\n\n> 1. 简化性质的维护：根节点为黑色可以简化在插入和删除操作后维持红黑树性质的过程。特别是在插入节点时，新的节点（通常为红色）可能违反了红黑树的性质。根节点为黑色确保了在树的高度平衡和黑色节点数量保持一致的情况下，维护这些性质更加容易。\n> 2. 平衡树的高度：红黑树的性质确保了树的高度约为 ( \\log(n) )，其中 ( n ) 是树中节点的数量。通过将根节点设为黑色，红黑树的黑色高度（从根到所有叶子节点的黑色节点数目）得到保证，从而有助于维护树的平衡。\n> 3. 避免违反性质：如果根节点允许是红色，可能会导致在某些情况下难以保证红色节点的数量平衡，特别是在连续插入和删除操作之后。将根节点设为黑色可以避免这种复杂情况，从而简化了实现和维护过程。\n\n首先我们先写个`Find`函数防止插入重复数据\n\n```C++\npublic:\n\tbool Find(const K& key)\n\t{\n\t\tNode* prev = nullptr;\n\t\tNode* cur = GetRoot();\n\t\twhile (cur)\n\t\t{\n\t\t\tif (_cmp(_kof(cur->_value), key))//相等或在左子树\n\t\t\t{\n\t\t\t\tprev = cur;\n\t\t\t\tcur = left(cur);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcur = right(cur);//可能在右子树\n\t\t\t}\n\t\t}\n\n\t\tif (prev == nullptr || _cmp(_kof(prev->_value),key))//一直向右走或一直向左走\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse return true;//走到头的过程中左转了一次之后一直向右走\n\t}\n```\n\n关于新结点（非根）的颜色,这里规定为`红色`，使新结点对红黑树中`黑树`高度的影响最小\n\n```C++\npublic:\n\tNode* proot = GetRoot();\n\tif (proot == nullptr)//树为空\n\t{\n\t\tNode* newnode = new Node(value, Black);\n\t\tnewnode->_parent = _header;\n\t\t_header->_parent = newnode;\n\t\treturn true;\n\t}\n\n\tif (Find(_kof(value)))return false;//结点已存在，插入失败\n\tNode* cur = proot;\n\tNode* parent = proot->_parent;\n\twhile (cur)\n\t{\n\t\tif (_cmp(_kof(cur->_value), _kof(value)))\n\t\t{\n\t\t\t//插在左子树\n\t\t\tparent = cur;\n\t\t\tcur = left(cur);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//插在右子树\n\t\t\tparent = cur;\n\t\t\tcur = right(cur);\n\t\t}\n\t}\n\t//开始插入\n\tNode* newnode = new Node(value, Red);\n\tif (_cmp(_kof(parent->_value),_kof(value) ))\n\t{\n\t\t//插入右子树\n\t\tparent->_left = newnode;\n\t\tnewnode->_parent = parent;\n\t}\n\telse\n\t{\n\t\tparent->_right = newnode;\n\t\tnewnode->_parent = parent;\n\t}\n\n\t//开始调整\n\t//.......\n\n\t\n```\n#### 调整红黑树\n每次新节点插入后，都要检测红黑树的性质是否造到破坏\n\n因为新节点的默认颜色是红色，因此：如果其双亲节点的颜色是黑色，没有违反红黑树任何性质，则不需要调整；但当新插入节点的双亲节点颜色为红色时，就违反了性质三`不能有连在一起的红色节点`，此时需要对红黑树分情况来讨论:\n\n**约定** **`cur`当前结点,`parent`为父结点,`uncle`为叔叔结点,`gp`为祖父结点**\n\n##### 情况一：直接染色\n\n+ ![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_1.png)\n+ 可以看到这种情况只需染色即可,将`gp`染色为红色，防止整棵树的`黑树高度`改变0\n+ 不过当该树为整棵树而不是子树时，根节点(`gp`)在最后还需染色回黑色（这里留到所有调整的最后）\n+ 当该树为子树，即`gp`存在父结点时，因为`gp`变为了红色，还需继续向上调整\n+ ![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_1_1.png)\n\n##### 情况二：单次旋转+染色\n+ ![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_2.png)\n+ 图中`uncle`的情况有两种\n  + 如果`uncle`节点不存在，则`cur`一定是**新插入节点**，因为如果`cur`不是新插入节点，则`cur`和`parent`一定有一个节点的颜色是黑色，就不满足性质4：每条路径黑色节点个数相同。\n  + 如果`uncle`节点存在，则其一定是黑色的，那么`cur`节点原来的颜色一定是黑色的，现在看到其是红色的原因是因为`cur`的子树在**调整的过程中**将`cur`节点的颜色由黑色改成红色。\n+ 调整步骤：\n  + `parent`为`pg`的左孩子，`cur`为`parent`的左孩子，则进行右单旋转\n  + `parent`为`pg`的右孩子，`cur`为`parent`的右孩子，则进行左单旋转\n  + `parent`->黑色\n  + `pg`->红色\n\n##### 情况三：两次旋转\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_3.png)\n\n+ 如图，一次旋转后变成了**情况二**,所以总共要旋转两次\n  + `parent`为`gp`的左孩子，`cur`为`parent`的右孩子，则针对`parent`做左单旋转\n  + `pparent`为`gp`的右孩子，`cur`为`parent`的左孩子，则针对`parent`做右单旋转\n+ 变成情况二后按情况二处理即可\n\n##### 封装代码\n旋转操作的代码量较大，我们选择封装到成员函数中\n\n```C++\nprivate:\n\tvoid RotateR(Node* node)\n\t{\n\t\tif (node == nullptr)assert(false);\n\t\tNode* cur = node;\n\t\tNode* parent = cur->_parent;\n\t\tif (parent == nullptr) assert(false);\n\t\tNode* gp = parent->_parent;\n\t\tif (gp == nullptr) assert(false);\n\n\t\t//调整树结构\n\t\tNode* ggp = gp->_parent;\n\t\tif (gp == ggp->_left)ggp->_left = parent;\n\t\telse ggp->_right = parent;\n\t\tparent->_parent = ggp;\n\n\t\tgp->_left = parent->_right;\n\t\tif (parent->_right)parent->_right->_parent = gp;\n\t\tparent->_right = gp;\n\t\tgp->_parent = parent;\n\n\t\tif (gp == GetRoot())\n\t\t{\n\t\t\tSetRoot(parent);\n\t\t}\n\n\t\t//染色\n\t\tparent->_color = Black;\n\t\tgp->_color = Red;\n\t}\n\n\tvoid RotateL(Node* node)\n\t{\n\t\tNode* cur = node;\n\t\tif (cur == nullptr)assert(false);\n\t\tNode* parent = cur->_parent;\n\t\tif (parent == nullptr)assert(false);\n\t\tNode* gp = parent->_parent;\n\t\tif (gp == nullptr)assert(false);\n\n\t\t//调整树结构\n\t\tNode* ggp = gp->_parent;\n\t\tif (ggp->_left == gp) ggp->_left = parent;\n\t\telse ggp->_right = parent;\n\t\tparent->_parent = ggp;\n\t\t\n\t\tgp->_right = parent->_left;\n\t\tif (parent->_left)parent->_left->_parent = gp;\n\t\tparent->_left = gp;\n\t\tgp->_parent = parent;\n\n\t\tif (gp == GetRoot())\n\t\t{\n\t\t\tSetRoot(parent);\n\t\t}\n\n\t\t//染色\n\t\tparent->_color = Black;\n\t\tgp->_color = Red;\n\t}\n\n\tvoid RotateLR(Node* node)\n\t{\n\t\tNode* cur = node;\n\t\tif (cur == nullptr)assert(false);\n\t\tNode* parent = cur->_parent;\n\t\tif (parent == nullptr)assert(false);\n\t\tNode* gp = parent->_parent;\n\t\tif (gp == nullptr) assert(false);\n\n\t\tparent->_right = cur->_left;\n\t\tif (cur->_left)cur->_left->_parent = parent;\n\t\tcur->_left = parent;\n\t\tparent->_parent = cur;\n\t\tcur->_parent = gp;\n\t\tgp->_left = cur;\n\n\t\tRotateR(parent);\n\t}\n\n\tvoid RotateRL(Node* node)\n\t{\n\t\tNode* cur = node;\n\t\tif (cur == nullptr)assert(false);\n\t\tNode* parent = cur->_parent;\n\t\tif (parent == nullptr)assert(false);\n\t\tNode* gp = parent->_parent;\n\t\tif (gp == nullptr) assert(false);\n\n\t\tparent->_left = cur->_right;\n\t\tif (cur->_right)cur->_right->_parent = parent;\n\t\tcur->_right = parent;\n\t\tparent->_parent = cur;\n\t\tcur->_parent = gp;\n\t\tgp->_right = cur;\n\n\t\tRotateL(parent);\n\t}\n```\n\n然后将`Insert`函数补充完整\n\n```C++\npublic:\n\tbool Insert(const V& value)\n\t{\n\t\tNode* proot = GetRoot();\n\t\tif (proot == nullptr)//树为空\n\t\t{\n\t\t\tNode* newnode = new Node(value, Black);\n\t\t\tnewnode->_parent = _header;\n\t\t\t_header->_parent = newnode;\n\t\t\treturn true;\n\t\t}\n\n\t\tif (Find(_kof(value)))return false;//结点已存在，插入失败\n\t\tNode* cur = proot;\n\t\tNode* parent = proot->_parent;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (_cmp(_kof(cur->_value), _kof(value)))\n\t\t\t{\n\t\t\t\t//插在左子树\n\t\t\t\tparent = cur;\n\t\t\t\tcur = left(cur);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//插在右子树\n\t\t\t\tparent = cur;\n\t\t\t\tcur = right(cur);\n\t\t\t}\n\t\t}\n\t\t//开始插入\n\t\tNode* newnode = new Node(value, Red);\n\t\tif (_cmp(_kof(parent->_value),_kof(value) ))\n\t\t{\n\t\t\t//插入右子树\n\t\t\tparent->_left = newnode;\n\t\t\tnewnode->_parent = parent;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent->_right = newnode;\n\t\t\tnewnode->_parent = parent;\n\t\t}\n\n\t\tcur = newnode;\n\t\t//开始调整\n\t\twhile (parent != _header && parent->_color == Red)\n\t\t{\n\t\t\tNode* gp = parent->_parent;\n\t\t\tNode* uncle = nullptr;\n\t\t\tif (parent == gp->_left)uncle = gp->_right;\n\t\t\telse uncle = gp->_left;\n\n\t\t\tif (uncle && uncle->_color == Red)//情况一\n\t\t\t{\n\t\t\t\tparent->_color = Black;\n\t\t\t\tuncle->_color = Black;\n\t\t\t\tgp->_color = Red;\n\n\t\t\t\tcur = gp;\n\t\t\t\tparent = gp->_parent;\n\t\t\t}\n\t\t\telse if (cur == parent->_left && parent == gp->_left)\n\t\t\t{\n\t\t\t\tRotateR(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cur == parent->_right && parent == gp->_right)\n\t\t\t{\n\t\t\t\tRotateL(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cur == parent->_right && parent == gp->_left)\n\t\t\t{\n\t\t\t\tRotateLR(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cur == parent->_left && parent == gp->_right)\n\t\t\t{\n\t\t\t\tRotateRL(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tNode* root = GetRoot();\n\t\troot->_color = Black;//修改根节点颜色\n\t\treturn true;\n\t}\n```\n\n### 红黑树的删除\n\n~~让红黑树和进程一起被清理也不是不行~~\n\n*under construction*\n\n### 红黑树的验证、高度和遍历\n下面再补充一些获取红黑树参数的接口\n\n```C++\npublic:\n\tvoid Inorder()\n\t{\n\t\t_Inorder(GetRoot());\n\t\tstd::cout << \"nullptr\" << std::endl;\n\t}\n\nprotected:\n\tvoid _Inorder(Node* root)\n\t{\n\t\tif (root == nullptr) return;\n\t\t_Inorder(root->_left);\n\t\tstd::cout << root->_value << \"->\";\n\t\t_Inorder(root->_right);\n\t}\npublic:\n\tint Height()\n\t{\n\t\treturn _Height(GetRoot());\n\t}\nprivate:\n\tint _Height(Node* root)\n\t{\n\t\tif (root == nullptr) return 0;\n\n\t\tint LHeight = _Height(root->_left);\n\t\tint RHeight = _Height(root->_right);\n\t\tif (LHeight > RHeight) return LHeight + 1;\n\t\telse return RHeight + 1; //将左右子树相等的情况合并在这里\n\t}\n\npublic:\n\tbool IsValidRBTree()\n\t{\n\t\tNode* root = GetRoot();\n\t\tif (root->_color != Black)return false;//违反根节点染色规则\n\t\t\n\t\tint blackCount = 0;\n\t\tNode* cur = root;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur->_color == Black) blackCount++;\n\t\t\tcur = cur->_left;\n\t\t}\n\n\t\tblackCount++;//cur为nullptr时也算作一个黑节点\n\n\t\treturn _IsValidRBTree(root,0,blackCount);\n\t}\n\nprotected:\n\tbool _IsValidRBTree(Node* root,int cnt,const int blackCount)\n\t{\n\t\tif (root == nullptr)\n\t\t{\n\t\t\tcnt++;\n\t\t\tif (cnt == blackCount)return true;\n\t\t\telse return false;//黑色节点数量不相等\n\t\t}\n\t\t//检测与父结点的染色规则\n\t\tif (root->_color == Red && root->_parent->_color == Red)\n\t\t{\n\t\t\treturn false;\n\t\t\t//不能有连续的红色节点\n\t\t}\n\n\t\tif (root->_color == Black) cnt++;\n\t\treturn _IsValidRBTree(root->_left, cnt, blackCount)\n\t\t\t&& _IsValidRBTree(root->_right, cnt, blackCount);\n\t}\n\n```\n\n### 封装迭代器\n\n红黑树的迭代器是双向迭代器，所以储存`空指针`的迭代器没有意义，我们在构造函数上就禁掉用空指针构造\n\n#### `拷贝构造`\n\n除了直接构造迭代器，还要提供用`const_iterator`构造`iterator`的拷贝构造，而我们依然使用`template <class Value,class Ref,class Ptr>`作为模板参数，所以要在`iterator`类型需要在类内手动封装,代码如下\n\n```C++\ntemplate <class Value,class Ref,class Ptr>\nclass __rbtree_iterator\n{\n\ttypedef __rbtree_iterator<Value, const Value&, const Value*> const_iterator;\n\ttypedef __rbtree_iterator<Value, Ref, Ptr> self;\n\ttypedef RBTreeNode<Value>* linkeType;\nprivate:\n\tlinkType _ptr;\n}\n```\n\n#### 迭代器的++和--\n迭代器的`++`和`--`是按前序遍历的顺序和逆序来访问的，而三叉链表有自己独特的访问方式\n\n**`++`**\n\n+ 操作当前结点时，该结点和该节点的左子树已经完成遍历,前序遍历已经走过 `左子树`->`根`\n  + 该节点有右子树时，前序遍历右子树\n  + 该节点没有右子树时，该子树完成遍历，回到根节点`root`的父节点`p`再次执行`++`操作(这里可以用递归),下面介绍循环\n    + 当根节点`root`为`p`的右结点时，`p`为根节点的子树也完成了遍历，把`p`作为所在子树的`root`，执行上一条操作\n    + 当根节点`root`为`p`的左结点时，`p`的左子树完成了遍历，正好下一步访问根节点,即`p`,返回指向`p`的迭代器即可\n\n**`--`**\n\n+ 操作当前结点时，该结点和该节点的右子树已经完成遍历,前序遍历已经走过 `右子树`->`根`\n  + 该节点有左子树时，后序遍历右子树\n  + 该节点没有左子树时，该子树完成遍历，回到根节点`root`的父节点`p`再次执行`--`操作(这里可以用递归),下面介绍循环\n    + 当根节点`root`为`p`的左结点时，`p`为根节点的子树也完成了遍历，把`p`作为所在子树的`root`，执行上一条操作\n    + 当根节点`root`为`p`的右结点时，`p`的右子树完成了遍历，正好下一步访问根节点,即`p`,返回指向`p`的迭代器即可\n\n完整代码如下\n```C++\ntemplate <class Value,class Ref,class Ptr>\nclass __rbtree_iterator\n{\n\ttypedef __rbtree_iterator<Value, const Value&, const Value*> const_iterator;\n\ttypedef __rbtree_iterator<Value, Ref, Ptr> self;\n\ttypedef RBTreeNode<Value>* linkeType;\n\npublic:\n\t__rbtree_iterator(const linkeType& ptr)\n\t\t:_ptr(ptr)\n\t{\n\t\tif (_ptr == nullptr)exit(-1);//非法的空迭代器\n\t}\n\n\t__rbtree_iterator(const const_iterator& const_it)\n\t\t:_ptr(const_it._ptr)\n\t{}\n\n\tself operator++()\n\t{\n\t\tif (_ptr == nullptr || _ptr->_right == _ptr )\n\t\t{\n\t\t\texit(-1);//end()迭代器不能++,空迭代器不能加减\n\t\t}\n\t\tif (_ptr->_right)\n\t\t{\n\t\t\t_ptr = _ptr->_right;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlinkeType parent = _ptr->_parent;\n\t\t\twhile (parent->_right == _ptr)\n\t\t\t{\n\t\t\t\t_ptr = parent;\n\t\t\t\tparent = _ptr->_parent;\n\t\t\t}\n\t\t\t_ptr = parent;\n\t\t}\n\t\treturn (*this);\n\t}\n\n\tself operator--()\n\t{\n\t\tif (_ptr == nullptr)\n\t\t{\n\t\t\texit(-1);//非法情况\n\t\t}\n\t\telse if (_ptr->_left == _ptr)//在头结点\n\t\t{\n\t\t\tlinkeType right = _ptr->_parent;//走到根节点\n\t\t\twhile (right)\n\t\t\t{\n\t\t\t\t_ptr = right;\n\t\t\t\tright = _ptr->_right;\n\t\t\t}\n\t\t}\n\t\telse if (_ptr->_left)\n\t\t{\n\t\t\t_ptr = _ptr->_left;\n\t\t\tlinkeType right = _ptr->_right;//寻找左子树的最右结点\n\t\t\twhile (right)\n\t\t\t{\n\t\t\t\t_ptr = right;\n\t\t\t\tright = _ptr->_right;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlinkeType parent = _ptr->_parent;\n\t\t\twhile (parent->_left == _ptr)\n\t\t\t{\n\t\t\t\t_ptr = parent;\n\t\t\t\tparent = _ptr->_parent;\n\t\t\t}\n\t\t\t_ptr = parent;\n\t\t}\n\n\t\treturn *this;\n\t}\n\n\tRef operator*()\n\t{\n\t\treturn _ptr->_value;\n\t}\n\n\tPtr operator->()\n\t{\n\t\treturn &(_ptr->_value);\n\t}\n\n\tbool operator!=(const self& it)\n\t{\n\t\treturn _ptr != it._ptr;\n\t}\n\n\tbool operator==(const self& it)\n\t{\n\t\treturn !operator!=(it);\n\t}\n\n\nprivate:\n\tlinkeType _ptr;\n};\n```\n\n在`RBTree`类中声明迭代器类并添加接口\n\n```C++\npublic:\n\ttypedef __rbtree_iterator<V, V&, V*> iterator;\n\ttypedef __rbtree_iterator<V, const V&, const V*>const_iterator;\n\tpublic:\n\titerator begin()\n\t{\n\t\treturn iterator(Most_Left());\n\t}\n\n\titerator end()\n\t{\n\t\treturn iterator(_header);\n\t}\n\n\tconst_iterator begin()const\n\t{\n\t\treturn const_iterator(Most_Left());\n\t}\n\n\tconst_iterator end()const\n\t{\n\t\treturn const_iterator(_header);\n\t}\n```\n\n### 修改Insert\n封装了迭代器之后，我们就可以让`insert`承担更多的功能了,让它同时返回`bool`和`iterator/const_iterator`\n\n`std::pair<bool,iterator>`\n\n### 新增关于容量的接口\n这里我们新增一个私有成员变量`size_t _size`记录红黑树中有效节点个数，此处需要修改一下构造函数和`Insert`函数，这里就不列出来了\n\n```C++\npublic:\n\tsize_t size()const\n\t{\n\t\treturn _size;\n\t}\n\tbool empty()const\n\t{\n\t\treturn _size == 0;\n\t}\n```\n\n### 新增拷贝构造\n有了迭代器，拷贝构造也十分好写了\n\n```C++\n\tRBTree(const self& rbt)\n\t{\n\t\tfor (auto value : rbt)\n\t\t{\n\t\t\tInsert(value);\n\t\t}\n\t}\n```\n","source":"_posts/RBTree.md","raw":"---\ntitle: 手撕红黑树 并封装map和set\ndate: 2024-09-03 08:21:33\ntags:\n---\n\n# 红黑树\n\n虽然`AVL树`作为绝对的平衡搜索二叉树，有着极高的查询效率，但正因为其严格的要求，修改`AVL树`的某个结点时，可能要一路调整到根节点，效率低下。为了解决这一痛点，略微没那么严格的**近似平衡搜索二叉树**，即`红黑树`被提出\n\n## 红黑树的概念\n红黑树，是一种二叉搜索树，但在每个结点上`增加一个存储位表示结点的颜色`，可以是`Red`或`Black`。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，**红黑树确保没有一条路径会比其他路径长出俩倍**，因而是**接近平衡**的。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTree_RBT.png)\n\n## 红黑树的性质\n首先与一般的定义不同，在红黑树中将`空指针`(上图为`NIL`)作为`叶子节点`,然后我们来讨论具体的性质\n\n1. 每个结点不是`红色`就是`黑色`\n2. 根节点必定是`黑色`的\n3. 如果一个结点是`红色`的,则它的两个**孩子结点**是`黑色`的\n4. 对于每个结点，该结点到其所有后代叶结点的简单路径上，均包含**相同数目**的`黑色`结点\n5. 每个**叶子结点**都是`黑色`的此处的叶子结点指的是`空结点NIL`\n\n**思考：为什么满足上面的性质，红黑树就能保证：其最长路径中节点个数不会超过最短路径节点个数的两倍？**\n> 红黑树的性质保证了从根节点到所有叶子结点（空结点）的路径上，**包含相同数量的黑色结点**。这是红黑树平衡性的重要保证，以下是如何保证最长路径不会超过最短路径两倍的具体解释：\n> 1. 黑色高度的定义：\n>   + 对于红黑树中的每个结点，定义其黑色高度为从该结点到叶子结点的路径上黑色结点的数量。根据性质 4，这个数量在所有路径上都是相同的。\n>   + 设定黑色高度为`h`。那么从根到任意叶子结点的路径都包含`h`个黑色结点。\n> 2. 红色结点的插入：\n>   + 根据性质3，如果一个结点是红色的，则它的两个孩子结点是黑色的。这就意味着每个红色结点必定有两个黑色的孩子。\n>   + 因此，从根到叶子结点的路径上，红色结点与黑色结点交替出现，红色结点之间的路径长度会相对较短。\n> 3. 路径长度的关系：\n>   + 根到一个叶子结点的路径的最长可能路径是最短路径的两倍。这是因为每个红色结点都在路径上增加了一个额外的层级，但它们只增加了一个红色结点的高度，而黑色结点的数量不变。\n>   + 如果某条路径上有 `r` 个红色结点，那么该路径的总长度将是 `h + r`，其中 `h` 是黑色结点的数量。因为红色结点的数量 `r` 可以最大等于 `h`，所以最长路径的长度 `h + r`最大为 `2h`，即**最长路径的长度不会超过最短路径的两倍**。\n\n\n## 红黑树的实现\n这里我们仿照`STL30`的源码,再用更简洁易懂的代码形式实现红黑树,*比如节点和迭代器的双层设计，这里就不使用了*\n\n### 红黑树结点\n+ 因为要经常访问父结点，所以这里用三叉链表维护树结构\n+ 红黑树的节点需要一个变量表示颜色，这里用`typedef`把`bool`类型封装为`Color`类\n+ 使用模板来存储泛类型的值\n\n```C++\n#pragma once\n#include <functional>\n\ntypedef bool Color;//只有红黑两种颜色，正好使用bool类型\nconst Color Red = false;//定义两种颜色\nconst Color Black = true;\n\n//红黑树结点的定义\ntemplate <class ValueType>\nstruct RBTreeNode\n{\n\ttypedef RBTreeNode<ValueType> Node;//简化代码\n\tNode* _left;\n\tNode* _right;\n\tNode* _parent;\n\tColor _color;\n\n\tValueType _value;\n\tRBTreeNode(const ValueType& val, Color color)\n\t\t:_value(val)\n\t\t, _color(color)\n\t\t, _left(nullptr)\n\t\t, _right(nullptr)\n\t\t, _parent(nullptr)\n\t{}\n};\n```\n\n### 红黑树的基本结构\n+ 模板参数:红黑树也是`KV`类型的二叉树，所以模板参数有:\n  + `K`:即Key,节点使用`K`类型的参数比较\n  + `V`:即ValueType,构造红黑树结点时传入的模板参数\n  + `KeyOfValue`:因为节点将`Key`值也存在了节点的值域，所以需要外部传入`仿函数KeyOfValue`将Key值取出\n  + `Compare`:允许外部自定义`K类型`的比较规则\n+ typedef封装:\n  + `typedef RBTreeNode<V> Node;`\n+ 私有成员变量:\n  + `Compare _cmp`:声明一个仿函数成员变量，整个对象里都能直接调用\n  + `KeyOfValue _kof`:用处同上\n  + `Node* _header`\n+ 默认构造函数：\n  + 使用缺省传入`const Compare&`类型定义的`std::greater<K>()`临时对象\n  + 创建哨兵位作为头结点，使后续对根结点的调整与一般情况统一\n+ 私有函数`GetRoot()` `left()` `right()`\n  + 将对根节点的获取封装起来，使代码更直观\n  + 简化代码，获取左右子树\n\n至于迭代器的封装，我们在[后文实现](#iterator )\n\n```C++\ntemplate<class K,class V,class KeyOfValue,class Compare = std::greater<int> >\nclass RBTree\n{\n\ttypedef RBTreeNode<V> Node;\n\npublic:\n\tRBTree(const Compare& cmp =Compare())\n\t\t:_cmp(cmp), _header(nullptr)\n\t{\n\t\t//创建哨兵位头结点，使后面调整树形状不用区分根节点\n\t\t_header = new Node(V(), Black);\n\t}\n\nprivate:\n\tNode* GetRoot()\n\t{\n\t\tif (_header->_parent == _header)return nullptr;\n\t\telse return _header->_parent;\n\t}\n\n\tNode* SetRoot(Node* root)\n\t{\n\t\tif (root == nullptr)return nullptr;\n\t\troot->_parent = _header;\n\t\t_header->_parent = root;\n\t}\n\n\tNode* left(Node* root)\n\t{\n\t\tif (root == nullptr)return nullptr;\n\t\treturn root->_left;\n\t}\n\n\tNode* right(Node* root)\n\t{\n\t\tif (root == nullptr)return nullptr;\n\t\treturn root->_right;\n\t}\n\nprivate:\n\tCompare _cmp;\n\tKeyOfValue _kof;\n\tNode* _header;\n};\n```\n\n### 红黑树的插入\n和`AVL树`一样，红黑树的插入也分为两步`新增结点`和`调整`\n\n#### 新增结点\n关于根结点的颜色，前面的[规定性质](#红黑树的性质)里也说了，根节点为黑色，这里在重申一下为什么一定是黑色\n\n> 1. 简化性质的维护：根节点为黑色可以简化在插入和删除操作后维持红黑树性质的过程。特别是在插入节点时，新的节点（通常为红色）可能违反了红黑树的性质。根节点为黑色确保了在树的高度平衡和黑色节点数量保持一致的情况下，维护这些性质更加容易。\n> 2. 平衡树的高度：红黑树的性质确保了树的高度约为 ( \\log(n) )，其中 ( n ) 是树中节点的数量。通过将根节点设为黑色，红黑树的黑色高度（从根到所有叶子节点的黑色节点数目）得到保证，从而有助于维护树的平衡。\n> 3. 避免违反性质：如果根节点允许是红色，可能会导致在某些情况下难以保证红色节点的数量平衡，特别是在连续插入和删除操作之后。将根节点设为黑色可以避免这种复杂情况，从而简化了实现和维护过程。\n\n首先我们先写个`Find`函数防止插入重复数据\n\n```C++\npublic:\n\tbool Find(const K& key)\n\t{\n\t\tNode* prev = nullptr;\n\t\tNode* cur = GetRoot();\n\t\twhile (cur)\n\t\t{\n\t\t\tif (_cmp(_kof(cur->_value), key))//相等或在左子树\n\t\t\t{\n\t\t\t\tprev = cur;\n\t\t\t\tcur = left(cur);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcur = right(cur);//可能在右子树\n\t\t\t}\n\t\t}\n\n\t\tif (prev == nullptr || _cmp(_kof(prev->_value),key))//一直向右走或一直向左走\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse return true;//走到头的过程中左转了一次之后一直向右走\n\t}\n```\n\n关于新结点（非根）的颜色,这里规定为`红色`，使新结点对红黑树中`黑树`高度的影响最小\n\n```C++\npublic:\n\tNode* proot = GetRoot();\n\tif (proot == nullptr)//树为空\n\t{\n\t\tNode* newnode = new Node(value, Black);\n\t\tnewnode->_parent = _header;\n\t\t_header->_parent = newnode;\n\t\treturn true;\n\t}\n\n\tif (Find(_kof(value)))return false;//结点已存在，插入失败\n\tNode* cur = proot;\n\tNode* parent = proot->_parent;\n\twhile (cur)\n\t{\n\t\tif (_cmp(_kof(cur->_value), _kof(value)))\n\t\t{\n\t\t\t//插在左子树\n\t\t\tparent = cur;\n\t\t\tcur = left(cur);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//插在右子树\n\t\t\tparent = cur;\n\t\t\tcur = right(cur);\n\t\t}\n\t}\n\t//开始插入\n\tNode* newnode = new Node(value, Red);\n\tif (_cmp(_kof(parent->_value),_kof(value) ))\n\t{\n\t\t//插入右子树\n\t\tparent->_left = newnode;\n\t\tnewnode->_parent = parent;\n\t}\n\telse\n\t{\n\t\tparent->_right = newnode;\n\t\tnewnode->_parent = parent;\n\t}\n\n\t//开始调整\n\t//.......\n\n\t\n```\n#### 调整红黑树\n每次新节点插入后，都要检测红黑树的性质是否造到破坏\n\n因为新节点的默认颜色是红色，因此：如果其双亲节点的颜色是黑色，没有违反红黑树任何性质，则不需要调整；但当新插入节点的双亲节点颜色为红色时，就违反了性质三`不能有连在一起的红色节点`，此时需要对红黑树分情况来讨论:\n\n**约定** **`cur`当前结点,`parent`为父结点,`uncle`为叔叔结点,`gp`为祖父结点**\n\n##### 情况一：直接染色\n\n+ ![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_1.png)\n+ 可以看到这种情况只需染色即可,将`gp`染色为红色，防止整棵树的`黑树高度`改变0\n+ 不过当该树为整棵树而不是子树时，根节点(`gp`)在最后还需染色回黑色（这里留到所有调整的最后）\n+ 当该树为子树，即`gp`存在父结点时，因为`gp`变为了红色，还需继续向上调整\n+ ![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_1_1.png)\n\n##### 情况二：单次旋转+染色\n+ ![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_2.png)\n+ 图中`uncle`的情况有两种\n  + 如果`uncle`节点不存在，则`cur`一定是**新插入节点**，因为如果`cur`不是新插入节点，则`cur`和`parent`一定有一个节点的颜色是黑色，就不满足性质4：每条路径黑色节点个数相同。\n  + 如果`uncle`节点存在，则其一定是黑色的，那么`cur`节点原来的颜色一定是黑色的，现在看到其是红色的原因是因为`cur`的子树在**调整的过程中**将`cur`节点的颜色由黑色改成红色。\n+ 调整步骤：\n  + `parent`为`pg`的左孩子，`cur`为`parent`的左孩子，则进行右单旋转\n  + `parent`为`pg`的右孩子，`cur`为`parent`的右孩子，则进行左单旋转\n  + `parent`->黑色\n  + `pg`->红色\n\n##### 情况三：两次旋转\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_3.png)\n\n+ 如图，一次旋转后变成了**情况二**,所以总共要旋转两次\n  + `parent`为`gp`的左孩子，`cur`为`parent`的右孩子，则针对`parent`做左单旋转\n  + `pparent`为`gp`的右孩子，`cur`为`parent`的左孩子，则针对`parent`做右单旋转\n+ 变成情况二后按情况二处理即可\n\n##### 封装代码\n旋转操作的代码量较大，我们选择封装到成员函数中\n\n```C++\nprivate:\n\tvoid RotateR(Node* node)\n\t{\n\t\tif (node == nullptr)assert(false);\n\t\tNode* cur = node;\n\t\tNode* parent = cur->_parent;\n\t\tif (parent == nullptr) assert(false);\n\t\tNode* gp = parent->_parent;\n\t\tif (gp == nullptr) assert(false);\n\n\t\t//调整树结构\n\t\tNode* ggp = gp->_parent;\n\t\tif (gp == ggp->_left)ggp->_left = parent;\n\t\telse ggp->_right = parent;\n\t\tparent->_parent = ggp;\n\n\t\tgp->_left = parent->_right;\n\t\tif (parent->_right)parent->_right->_parent = gp;\n\t\tparent->_right = gp;\n\t\tgp->_parent = parent;\n\n\t\tif (gp == GetRoot())\n\t\t{\n\t\t\tSetRoot(parent);\n\t\t}\n\n\t\t//染色\n\t\tparent->_color = Black;\n\t\tgp->_color = Red;\n\t}\n\n\tvoid RotateL(Node* node)\n\t{\n\t\tNode* cur = node;\n\t\tif (cur == nullptr)assert(false);\n\t\tNode* parent = cur->_parent;\n\t\tif (parent == nullptr)assert(false);\n\t\tNode* gp = parent->_parent;\n\t\tif (gp == nullptr)assert(false);\n\n\t\t//调整树结构\n\t\tNode* ggp = gp->_parent;\n\t\tif (ggp->_left == gp) ggp->_left = parent;\n\t\telse ggp->_right = parent;\n\t\tparent->_parent = ggp;\n\t\t\n\t\tgp->_right = parent->_left;\n\t\tif (parent->_left)parent->_left->_parent = gp;\n\t\tparent->_left = gp;\n\t\tgp->_parent = parent;\n\n\t\tif (gp == GetRoot())\n\t\t{\n\t\t\tSetRoot(parent);\n\t\t}\n\n\t\t//染色\n\t\tparent->_color = Black;\n\t\tgp->_color = Red;\n\t}\n\n\tvoid RotateLR(Node* node)\n\t{\n\t\tNode* cur = node;\n\t\tif (cur == nullptr)assert(false);\n\t\tNode* parent = cur->_parent;\n\t\tif (parent == nullptr)assert(false);\n\t\tNode* gp = parent->_parent;\n\t\tif (gp == nullptr) assert(false);\n\n\t\tparent->_right = cur->_left;\n\t\tif (cur->_left)cur->_left->_parent = parent;\n\t\tcur->_left = parent;\n\t\tparent->_parent = cur;\n\t\tcur->_parent = gp;\n\t\tgp->_left = cur;\n\n\t\tRotateR(parent);\n\t}\n\n\tvoid RotateRL(Node* node)\n\t{\n\t\tNode* cur = node;\n\t\tif (cur == nullptr)assert(false);\n\t\tNode* parent = cur->_parent;\n\t\tif (parent == nullptr)assert(false);\n\t\tNode* gp = parent->_parent;\n\t\tif (gp == nullptr) assert(false);\n\n\t\tparent->_left = cur->_right;\n\t\tif (cur->_right)cur->_right->_parent = parent;\n\t\tcur->_right = parent;\n\t\tparent->_parent = cur;\n\t\tcur->_parent = gp;\n\t\tgp->_right = cur;\n\n\t\tRotateL(parent);\n\t}\n```\n\n然后将`Insert`函数补充完整\n\n```C++\npublic:\n\tbool Insert(const V& value)\n\t{\n\t\tNode* proot = GetRoot();\n\t\tif (proot == nullptr)//树为空\n\t\t{\n\t\t\tNode* newnode = new Node(value, Black);\n\t\t\tnewnode->_parent = _header;\n\t\t\t_header->_parent = newnode;\n\t\t\treturn true;\n\t\t}\n\n\t\tif (Find(_kof(value)))return false;//结点已存在，插入失败\n\t\tNode* cur = proot;\n\t\tNode* parent = proot->_parent;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (_cmp(_kof(cur->_value), _kof(value)))\n\t\t\t{\n\t\t\t\t//插在左子树\n\t\t\t\tparent = cur;\n\t\t\t\tcur = left(cur);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//插在右子树\n\t\t\t\tparent = cur;\n\t\t\t\tcur = right(cur);\n\t\t\t}\n\t\t}\n\t\t//开始插入\n\t\tNode* newnode = new Node(value, Red);\n\t\tif (_cmp(_kof(parent->_value),_kof(value) ))\n\t\t{\n\t\t\t//插入右子树\n\t\t\tparent->_left = newnode;\n\t\t\tnewnode->_parent = parent;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent->_right = newnode;\n\t\t\tnewnode->_parent = parent;\n\t\t}\n\n\t\tcur = newnode;\n\t\t//开始调整\n\t\twhile (parent != _header && parent->_color == Red)\n\t\t{\n\t\t\tNode* gp = parent->_parent;\n\t\t\tNode* uncle = nullptr;\n\t\t\tif (parent == gp->_left)uncle = gp->_right;\n\t\t\telse uncle = gp->_left;\n\n\t\t\tif (uncle && uncle->_color == Red)//情况一\n\t\t\t{\n\t\t\t\tparent->_color = Black;\n\t\t\t\tuncle->_color = Black;\n\t\t\t\tgp->_color = Red;\n\n\t\t\t\tcur = gp;\n\t\t\t\tparent = gp->_parent;\n\t\t\t}\n\t\t\telse if (cur == parent->_left && parent == gp->_left)\n\t\t\t{\n\t\t\t\tRotateR(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cur == parent->_right && parent == gp->_right)\n\t\t\t{\n\t\t\t\tRotateL(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cur == parent->_right && parent == gp->_left)\n\t\t\t{\n\t\t\t\tRotateLR(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (cur == parent->_left && parent == gp->_right)\n\t\t\t{\n\t\t\t\tRotateRL(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tNode* root = GetRoot();\n\t\troot->_color = Black;//修改根节点颜色\n\t\treturn true;\n\t}\n```\n\n### 红黑树的删除\n\n~~让红黑树和进程一起被清理也不是不行~~\n\n*under construction*\n\n### 红黑树的验证、高度和遍历\n下面再补充一些获取红黑树参数的接口\n\n```C++\npublic:\n\tvoid Inorder()\n\t{\n\t\t_Inorder(GetRoot());\n\t\tstd::cout << \"nullptr\" << std::endl;\n\t}\n\nprotected:\n\tvoid _Inorder(Node* root)\n\t{\n\t\tif (root == nullptr) return;\n\t\t_Inorder(root->_left);\n\t\tstd::cout << root->_value << \"->\";\n\t\t_Inorder(root->_right);\n\t}\npublic:\n\tint Height()\n\t{\n\t\treturn _Height(GetRoot());\n\t}\nprivate:\n\tint _Height(Node* root)\n\t{\n\t\tif (root == nullptr) return 0;\n\n\t\tint LHeight = _Height(root->_left);\n\t\tint RHeight = _Height(root->_right);\n\t\tif (LHeight > RHeight) return LHeight + 1;\n\t\telse return RHeight + 1; //将左右子树相等的情况合并在这里\n\t}\n\npublic:\n\tbool IsValidRBTree()\n\t{\n\t\tNode* root = GetRoot();\n\t\tif (root->_color != Black)return false;//违反根节点染色规则\n\t\t\n\t\tint blackCount = 0;\n\t\tNode* cur = root;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur->_color == Black) blackCount++;\n\t\t\tcur = cur->_left;\n\t\t}\n\n\t\tblackCount++;//cur为nullptr时也算作一个黑节点\n\n\t\treturn _IsValidRBTree(root,0,blackCount);\n\t}\n\nprotected:\n\tbool _IsValidRBTree(Node* root,int cnt,const int blackCount)\n\t{\n\t\tif (root == nullptr)\n\t\t{\n\t\t\tcnt++;\n\t\t\tif (cnt == blackCount)return true;\n\t\t\telse return false;//黑色节点数量不相等\n\t\t}\n\t\t//检测与父结点的染色规则\n\t\tif (root->_color == Red && root->_parent->_color == Red)\n\t\t{\n\t\t\treturn false;\n\t\t\t//不能有连续的红色节点\n\t\t}\n\n\t\tif (root->_color == Black) cnt++;\n\t\treturn _IsValidRBTree(root->_left, cnt, blackCount)\n\t\t\t&& _IsValidRBTree(root->_right, cnt, blackCount);\n\t}\n\n```\n\n### 封装迭代器\n\n红黑树的迭代器是双向迭代器，所以储存`空指针`的迭代器没有意义，我们在构造函数上就禁掉用空指针构造\n\n#### `拷贝构造`\n\n除了直接构造迭代器，还要提供用`const_iterator`构造`iterator`的拷贝构造，而我们依然使用`template <class Value,class Ref,class Ptr>`作为模板参数，所以要在`iterator`类型需要在类内手动封装,代码如下\n\n```C++\ntemplate <class Value,class Ref,class Ptr>\nclass __rbtree_iterator\n{\n\ttypedef __rbtree_iterator<Value, const Value&, const Value*> const_iterator;\n\ttypedef __rbtree_iterator<Value, Ref, Ptr> self;\n\ttypedef RBTreeNode<Value>* linkeType;\nprivate:\n\tlinkType _ptr;\n}\n```\n\n#### 迭代器的++和--\n迭代器的`++`和`--`是按前序遍历的顺序和逆序来访问的，而三叉链表有自己独特的访问方式\n\n**`++`**\n\n+ 操作当前结点时，该结点和该节点的左子树已经完成遍历,前序遍历已经走过 `左子树`->`根`\n  + 该节点有右子树时，前序遍历右子树\n  + 该节点没有右子树时，该子树完成遍历，回到根节点`root`的父节点`p`再次执行`++`操作(这里可以用递归),下面介绍循环\n    + 当根节点`root`为`p`的右结点时，`p`为根节点的子树也完成了遍历，把`p`作为所在子树的`root`，执行上一条操作\n    + 当根节点`root`为`p`的左结点时，`p`的左子树完成了遍历，正好下一步访问根节点,即`p`,返回指向`p`的迭代器即可\n\n**`--`**\n\n+ 操作当前结点时，该结点和该节点的右子树已经完成遍历,前序遍历已经走过 `右子树`->`根`\n  + 该节点有左子树时，后序遍历右子树\n  + 该节点没有左子树时，该子树完成遍历，回到根节点`root`的父节点`p`再次执行`--`操作(这里可以用递归),下面介绍循环\n    + 当根节点`root`为`p`的左结点时，`p`为根节点的子树也完成了遍历，把`p`作为所在子树的`root`，执行上一条操作\n    + 当根节点`root`为`p`的右结点时，`p`的右子树完成了遍历，正好下一步访问根节点,即`p`,返回指向`p`的迭代器即可\n\n完整代码如下\n```C++\ntemplate <class Value,class Ref,class Ptr>\nclass __rbtree_iterator\n{\n\ttypedef __rbtree_iterator<Value, const Value&, const Value*> const_iterator;\n\ttypedef __rbtree_iterator<Value, Ref, Ptr> self;\n\ttypedef RBTreeNode<Value>* linkeType;\n\npublic:\n\t__rbtree_iterator(const linkeType& ptr)\n\t\t:_ptr(ptr)\n\t{\n\t\tif (_ptr == nullptr)exit(-1);//非法的空迭代器\n\t}\n\n\t__rbtree_iterator(const const_iterator& const_it)\n\t\t:_ptr(const_it._ptr)\n\t{}\n\n\tself operator++()\n\t{\n\t\tif (_ptr == nullptr || _ptr->_right == _ptr )\n\t\t{\n\t\t\texit(-1);//end()迭代器不能++,空迭代器不能加减\n\t\t}\n\t\tif (_ptr->_right)\n\t\t{\n\t\t\t_ptr = _ptr->_right;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlinkeType parent = _ptr->_parent;\n\t\t\twhile (parent->_right == _ptr)\n\t\t\t{\n\t\t\t\t_ptr = parent;\n\t\t\t\tparent = _ptr->_parent;\n\t\t\t}\n\t\t\t_ptr = parent;\n\t\t}\n\t\treturn (*this);\n\t}\n\n\tself operator--()\n\t{\n\t\tif (_ptr == nullptr)\n\t\t{\n\t\t\texit(-1);//非法情况\n\t\t}\n\t\telse if (_ptr->_left == _ptr)//在头结点\n\t\t{\n\t\t\tlinkeType right = _ptr->_parent;//走到根节点\n\t\t\twhile (right)\n\t\t\t{\n\t\t\t\t_ptr = right;\n\t\t\t\tright = _ptr->_right;\n\t\t\t}\n\t\t}\n\t\telse if (_ptr->_left)\n\t\t{\n\t\t\t_ptr = _ptr->_left;\n\t\t\tlinkeType right = _ptr->_right;//寻找左子树的最右结点\n\t\t\twhile (right)\n\t\t\t{\n\t\t\t\t_ptr = right;\n\t\t\t\tright = _ptr->_right;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlinkeType parent = _ptr->_parent;\n\t\t\twhile (parent->_left == _ptr)\n\t\t\t{\n\t\t\t\t_ptr = parent;\n\t\t\t\tparent = _ptr->_parent;\n\t\t\t}\n\t\t\t_ptr = parent;\n\t\t}\n\n\t\treturn *this;\n\t}\n\n\tRef operator*()\n\t{\n\t\treturn _ptr->_value;\n\t}\n\n\tPtr operator->()\n\t{\n\t\treturn &(_ptr->_value);\n\t}\n\n\tbool operator!=(const self& it)\n\t{\n\t\treturn _ptr != it._ptr;\n\t}\n\n\tbool operator==(const self& it)\n\t{\n\t\treturn !operator!=(it);\n\t}\n\n\nprivate:\n\tlinkeType _ptr;\n};\n```\n\n在`RBTree`类中声明迭代器类并添加接口\n\n```C++\npublic:\n\ttypedef __rbtree_iterator<V, V&, V*> iterator;\n\ttypedef __rbtree_iterator<V, const V&, const V*>const_iterator;\n\tpublic:\n\titerator begin()\n\t{\n\t\treturn iterator(Most_Left());\n\t}\n\n\titerator end()\n\t{\n\t\treturn iterator(_header);\n\t}\n\n\tconst_iterator begin()const\n\t{\n\t\treturn const_iterator(Most_Left());\n\t}\n\n\tconst_iterator end()const\n\t{\n\t\treturn const_iterator(_header);\n\t}\n```\n\n### 修改Insert\n封装了迭代器之后，我们就可以让`insert`承担更多的功能了,让它同时返回`bool`和`iterator/const_iterator`\n\n`std::pair<bool,iterator>`\n\n### 新增关于容量的接口\n这里我们新增一个私有成员变量`size_t _size`记录红黑树中有效节点个数，此处需要修改一下构造函数和`Insert`函数，这里就不列出来了\n\n```C++\npublic:\n\tsize_t size()const\n\t{\n\t\treturn _size;\n\t}\n\tbool empty()const\n\t{\n\t\treturn _size == 0;\n\t}\n```\n\n### 新增拷贝构造\n有了迭代器，拷贝构造也十分好写了\n\n```C++\n\tRBTree(const self& rbt)\n\t{\n\t\tfor (auto value : rbt)\n\t\t{\n\t\t\tInsert(value);\n\t\t}\n\t}\n```\n","slug":"RBTree","published":1,"updated":"2024-09-16T07:16:13.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p084000c4sp5ater74ps","content":"<h1 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h1><p>虽然<code>AVL树</code>作为绝对的平衡搜索二叉树，有着极高的查询效率，但正因为其严格的要求，修改<code>AVL树</code>的某个结点时，可能要一路调整到根节点，效率低下。为了解决这一痛点，略微没那么严格的<strong>近似平衡搜索二叉树</strong>，即<code>红黑树</code>被提出</p>\n<h2 id=\"红黑树的概念\"><a href=\"#红黑树的概念\" class=\"headerlink\" title=\"红黑树的概念\"></a>红黑树的概念</h2><p>红黑树，是一种二叉搜索树，但在每个结点上<code>增加一个存储位表示结点的颜色</code>，可以是<code>Red</code>或<code>Black</code>。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，<strong>红黑树确保没有一条路径会比其他路径长出俩倍</strong>，因而是<strong>接近平衡</strong>的。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTree_RBT.png\"></p>\n<h2 id=\"红黑树的性质\"><a href=\"#红黑树的性质\" class=\"headerlink\" title=\"红黑树的性质\"></a>红黑树的性质</h2><p>首先与一般的定义不同，在红黑树中将<code>空指针</code>(上图为<code>NIL</code>)作为<code>叶子节点</code>,然后我们来讨论具体的性质</p>\n<ol>\n<li>每个结点不是<code>红色</code>就是<code>黑色</code></li>\n<li>根节点必定是<code>黑色</code>的</li>\n<li>如果一个结点是<code>红色</code>的,则它的两个<strong>孩子结点</strong>是<code>黑色</code>的</li>\n<li>对于每个结点，该结点到其所有后代叶结点的简单路径上，均包含<strong>相同数目</strong>的<code>黑色</code>结点</li>\n<li>每个<strong>叶子结点</strong>都是<code>黑色</code>的此处的叶子结点指的是<code>空结点NIL</code></li>\n</ol>\n<p><strong>思考：为什么满足上面的性质，红黑树就能保证：其最长路径中节点个数不会超过最短路径节点个数的两倍？</strong></p>\n<blockquote>\n<p>红黑树的性质保证了从根节点到所有叶子结点（空结点）的路径上，<strong>包含相同数量的黑色结点</strong>。这是红黑树平衡性的重要保证，以下是如何保证最长路径不会超过最短路径两倍的具体解释：</p>\n<ol>\n<li>黑色高度的定义：</li>\n</ol>\n<ul>\n<li>对于红黑树中的每个结点，定义其黑色高度为从该结点到叶子结点的路径上黑色结点的数量。根据性质 4，这个数量在所有路径上都是相同的。</li>\n<li>设定黑色高度为<code>h</code>。那么从根到任意叶子结点的路径都包含<code>h</code>个黑色结点。</li>\n</ul>\n<ol start=\"2\">\n<li>红色结点的插入：</li>\n</ol>\n<ul>\n<li>根据性质3，如果一个结点是红色的，则它的两个孩子结点是黑色的。这就意味着每个红色结点必定有两个黑色的孩子。</li>\n<li>因此，从根到叶子结点的路径上，红色结点与黑色结点交替出现，红色结点之间的路径长度会相对较短。</li>\n</ul>\n<ol start=\"3\">\n<li>路径长度的关系：</li>\n</ol>\n<ul>\n<li>根到一个叶子结点的路径的最长可能路径是最短路径的两倍。这是因为每个红色结点都在路径上增加了一个额外的层级，但它们只增加了一个红色结点的高度，而黑色结点的数量不变。</li>\n<li>如果某条路径上有 <code>r</code> 个红色结点，那么该路径的总长度将是 <code>h + r</code>，其中 <code>h</code> 是黑色结点的数量。因为红色结点的数量 <code>r</code> 可以最大等于 <code>h</code>，所以最长路径的长度 <code>h + r</code>最大为 <code>2h</code>，即<strong>最长路径的长度不会超过最短路径的两倍</strong>。</li>\n</ul>\n</blockquote>\n<h2 id=\"红黑树的实现\"><a href=\"#红黑树的实现\" class=\"headerlink\" title=\"红黑树的实现\"></a>红黑树的实现</h2><p>这里我们仿照<code>STL30</code>的源码,再用更简洁易懂的代码形式实现红黑树,<em>比如节点和迭代器的双层设计，这里就不使用了</em></p>\n<h3 id=\"红黑树结点\"><a href=\"#红黑树结点\" class=\"headerlink\" title=\"红黑树结点\"></a>红黑树结点</h3><ul>\n<li>因为要经常访问父结点，所以这里用三叉链表维护树结构</li>\n<li>红黑树的节点需要一个变量表示颜色，这里用<code>typedef</code>把<code>bool</code>类型封装为<code>Color</code>类</li>\n<li>使用模板来存储泛类型的值</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">bool</span> Color;<span class=\"comment\">//只有红黑两种颜色，正好使用bool类型</span></span><br><span class=\"line\"><span class=\"type\">const</span> Color Red = <span class=\"literal\">false</span>;<span class=\"comment\">//定义两种颜色</span></span><br><span class=\"line\"><span class=\"type\">const</span> Color Black = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//红黑树结点的定义</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">ValueType</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">RBTreeNode</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> RBTreeNode&lt;ValueType&gt; Node;<span class=\"comment\">//简化代码</span></span><br><span class=\"line\">\tNode* _left;</span><br><span class=\"line\">\tNode* _right;</span><br><span class=\"line\">\tNode* _parent;</span><br><span class=\"line\">\tColor _color;</span><br><span class=\"line\"></span><br><span class=\"line\">\tValueType _value;</span><br><span class=\"line\">\t<span class=\"built_in\">RBTreeNode</span>(<span class=\"type\">const</span> ValueType&amp; val, Color color)</span><br><span class=\"line\">\t\t:_value(val)</span><br><span class=\"line\">\t\t, _color(color)</span><br><span class=\"line\">\t\t, _left(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t, _right(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t, _parent(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"红黑树的基本结构\"><a href=\"#红黑树的基本结构\" class=\"headerlink\" title=\"红黑树的基本结构\"></a>红黑树的基本结构</h3><ul>\n<li>模板参数:红黑树也是<code>KV</code>类型的二叉树，所以模板参数有:<ul>\n<li><code>K</code>:即Key,节点使用<code>K</code>类型的参数比较</li>\n<li><code>V</code>:即ValueType,构造红黑树结点时传入的模板参数</li>\n<li><code>KeyOfValue</code>:因为节点将<code>Key</code>值也存在了节点的值域，所以需要外部传入<code>仿函数KeyOfValue</code>将Key值取出</li>\n<li><code>Compare</code>:允许外部自定义<code>K类型</code>的比较规则</li>\n</ul>\n</li>\n<li>typedef封装:<ul>\n<li><code>typedef RBTreeNode&lt;V&gt; Node;</code></li>\n</ul>\n</li>\n<li>私有成员变量:<ul>\n<li><code>Compare _cmp</code>:声明一个仿函数成员变量，整个对象里都能直接调用</li>\n<li><code>KeyOfValue _kof</code>:用处同上</li>\n<li><code>Node* _header</code></li>\n</ul>\n</li>\n<li>默认构造函数：<ul>\n<li>使用缺省传入<code>const Compare&amp;</code>类型定义的<code>std::greater&lt;K&gt;()</code>临时对象</li>\n<li>创建哨兵位作为头结点，使后续对根结点的调整与一般情况统一</li>\n</ul>\n</li>\n<li>私有函数<code>GetRoot()</code> <code>left()</code> <code>right()</code><ul>\n<li>将对根节点的获取封装起来，使代码更直观</li>\n<li>简化代码，获取左右子树</li>\n</ul>\n</li>\n</ul>\n<p>至于迭代器的封装，我们在<a href=\"#iterator\">后文实现</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">KeyOfValue</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Compare</span> = std::greater&lt;<span class=\"type\">int</span>&gt; &gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> RBTree</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> RBTreeNode&lt;V&gt; Node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">RBTree</span>(<span class=\"type\">const</span> Compare&amp; cmp =<span class=\"built_in\">Compare</span>())</span><br><span class=\"line\">\t\t:_cmp(cmp), _header(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//创建哨兵位头结点，使后面调整树形状不用区分根节点</span></span><br><span class=\"line\">\t\t_header = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(<span class=\"built_in\">V</span>(), Black);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\">Node* <span class=\"title\">GetRoot</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_header-&gt;_parent == _header)<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> _header-&gt;_parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Node* <span class=\"title\">SetRoot</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\troot-&gt;_parent = _header;</span><br><span class=\"line\">\t\t_header-&gt;_parent = root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Node* <span class=\"title\">left</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root-&gt;_left;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Node* <span class=\"title\">right</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root-&gt;_right;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tCompare _cmp;</span><br><span class=\"line\">\tKeyOfValue _kof;</span><br><span class=\"line\">\tNode* _header;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"红黑树的插入\"><a href=\"#红黑树的插入\" class=\"headerlink\" title=\"红黑树的插入\"></a>红黑树的插入</h3><p>和<code>AVL树</code>一样，红黑树的插入也分为两步<code>新增结点</code>和<code>调整</code></p>\n<h4 id=\"新增结点\"><a href=\"#新增结点\" class=\"headerlink\" title=\"新增结点\"></a>新增结点</h4><p>关于根结点的颜色，前面的<a href=\"#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8\">规定性质</a>里也说了，根节点为黑色，这里在重申一下为什么一定是黑色</p>\n<blockquote>\n<ol>\n<li>简化性质的维护：根节点为黑色可以简化在插入和删除操作后维持红黑树性质的过程。特别是在插入节点时，新的节点（通常为红色）可能违反了红黑树的性质。根节点为黑色确保了在树的高度平衡和黑色节点数量保持一致的情况下，维护这些性质更加容易。</li>\n<li>平衡树的高度：红黑树的性质确保了树的高度约为 ( \\log(n) )，其中 ( n ) 是树中节点的数量。通过将根节点设为黑色，红黑树的黑色高度（从根到所有叶子节点的黑色节点数目）得到保证，从而有助于维护树的平衡。</li>\n<li>避免违反性质：如果根节点允许是红色，可能会导致在某些情况下难以保证红色节点的数量平衡，特别是在连续插入和删除操作之后。将根节点设为黑色可以避免这种复杂情况，从而简化了实现和维护过程。</li>\n</ol>\n</blockquote>\n<p>首先我们先写个<code>Find</code>函数防止插入重复数据</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\tNode* cur = <span class=\"built_in\">GetRoot</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_cmp(_kof(cur-&gt;_value), key))<span class=\"comment\">//相等或在左子树</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tprev = cur;</span><br><span class=\"line\">\t\t\t\tcur = <span class=\"built_in\">left</span>(cur);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcur = <span class=\"built_in\">right</span>(cur);<span class=\"comment\">//可能在右子树</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (prev == <span class=\"literal\">nullptr</span> || _cmp(_kof(prev-&gt;_value),key))<span class=\"comment\">//一直向右走或一直向左走</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//走到头的过程中左转了一次之后一直向右走</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于新结点（非根）的颜色,这里规定为<code>红色</code>，使新结点对红黑树中<code>黑树</code>高度的影响最小</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNode* proot = <span class=\"built_in\">GetRoot</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (proot == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//树为空</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tNode* newnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(value, Black);</span><br><span class=\"line\">\t\tnewnode-&gt;_parent = _header;</span><br><span class=\"line\">\t\t_header-&gt;_parent = newnode;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">Find</span>(_kof(value)))<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//结点已存在，插入失败</span></span><br><span class=\"line\">\tNode* cur = proot;</span><br><span class=\"line\">\tNode* parent = proot-&gt;_parent;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_cmp(_kof(cur-&gt;_value), _kof(value)))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//插在左子树</span></span><br><span class=\"line\">\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\tcur = <span class=\"built_in\">left</span>(cur);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//插在右子树</span></span><br><span class=\"line\">\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\tcur = <span class=\"built_in\">right</span>(cur);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//开始插入</span></span><br><span class=\"line\">\tNode* newnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(value, Red);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (_cmp(_kof(parent-&gt;_value),_kof(value) ))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//插入右子树</span></span><br><span class=\"line\">\t\tparent-&gt;_left = newnode;</span><br><span class=\"line\">\t\tnewnode-&gt;_parent = parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tparent-&gt;_right = newnode;</span><br><span class=\"line\">\t\tnewnode-&gt;_parent = parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//开始调整</span></span><br><span class=\"line\">\t<span class=\"comment\">//.......</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n<h4 id=\"调整红黑树\"><a href=\"#调整红黑树\" class=\"headerlink\" title=\"调整红黑树\"></a>调整红黑树</h4><p>每次新节点插入后，都要检测红黑树的性质是否造到破坏</p>\n<p>因为新节点的默认颜色是红色，因此：如果其双亲节点的颜色是黑色，没有违反红黑树任何性质，则不需要调整；但当新插入节点的双亲节点颜色为红色时，就违反了性质三<code>不能有连在一起的红色节点</code>，此时需要对红黑树分情况来讨论:</p>\n<p><strong>约定</strong> <strong><code>cur</code>当前结点,<code>parent</code>为父结点,<code>uncle</code>为叔叔结点,<code>gp</code>为祖父结点</strong></p>\n<h5 id=\"情况一：直接染色\"><a href=\"#情况一：直接染色\" class=\"headerlink\" title=\"情况一：直接染色\"></a>情况一：直接染色</h5><ul>\n<li><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_1.png\"></li>\n<li>可以看到这种情况只需染色即可,将<code>gp</code>染色为红色，防止整棵树的<code>黑树高度</code>改变0</li>\n<li>不过当该树为整棵树而不是子树时，根节点(<code>gp</code>)在最后还需染色回黑色（这里留到所有调整的最后）</li>\n<li>当该树为子树，即<code>gp</code>存在父结点时，因为<code>gp</code>变为了红色，还需继续向上调整</li>\n<li><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_1_1.png\"></li>\n</ul>\n<h5 id=\"情况二：单次旋转-染色\"><a href=\"#情况二：单次旋转-染色\" class=\"headerlink\" title=\"情况二：单次旋转+染色\"></a>情况二：单次旋转+染色</h5><ul>\n<li><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_2.png\"></li>\n<li>图中<code>uncle</code>的情况有两种<ul>\n<li>如果<code>uncle</code>节点不存在，则<code>cur</code>一定是<strong>新插入节点</strong>，因为如果<code>cur</code>不是新插入节点，则<code>cur</code>和<code>parent</code>一定有一个节点的颜色是黑色，就不满足性质4：每条路径黑色节点个数相同。</li>\n<li>如果<code>uncle</code>节点存在，则其一定是黑色的，那么<code>cur</code>节点原来的颜色一定是黑色的，现在看到其是红色的原因是因为<code>cur</code>的子树在<strong>调整的过程中</strong>将<code>cur</code>节点的颜色由黑色改成红色。</li>\n</ul>\n</li>\n<li>调整步骤：<ul>\n<li><code>parent</code>为<code>pg</code>的左孩子，<code>cur</code>为<code>parent</code>的左孩子，则进行右单旋转</li>\n<li><code>parent</code>为<code>pg</code>的右孩子，<code>cur</code>为<code>parent</code>的右孩子，则进行左单旋转</li>\n<li><code>parent</code>-&gt;黑色</li>\n<li><code>pg</code>-&gt;红色</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"情况三：两次旋转\"><a href=\"#情况三：两次旋转\" class=\"headerlink\" title=\"情况三：两次旋转\"></a>情况三：两次旋转</h5><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_3.png\"></p>\n<ul>\n<li>如图，一次旋转后变成了<strong>情况二</strong>,所以总共要旋转两次<ul>\n<li><code>parent</code>为<code>gp</code>的左孩子，<code>cur</code>为<code>parent</code>的右孩子，则针对<code>parent</code>做左单旋转</li>\n<li><code>pparent</code>为<code>gp</code>的右孩子，<code>cur</code>为<code>parent</code>的左孩子，则针对<code>parent</code>做右单旋转</li>\n</ul>\n</li>\n<li>变成情况二后按情况二处理即可</li>\n</ul>\n<h5 id=\"封装代码\"><a href=\"#封装代码\" class=\"headerlink\" title=\"封装代码\"></a>封装代码</h5><p>旋转操作的代码量较大，我们选择封装到成员函数中</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateR</span><span class=\"params\">(Node* node)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* cur = node;</span><br><span class=\"line\">\t\tNode* parent = cur-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>) <span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* gp = parent-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"literal\">nullptr</span>) <span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//调整树结构</span></span><br><span class=\"line\">\t\tNode* ggp = gp-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == ggp-&gt;_left)ggp-&gt;_left = parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ggp-&gt;_right = parent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = ggp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tgp-&gt;_left = parent-&gt;_right;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent-&gt;_right)parent-&gt;_right-&gt;_parent = gp;</span><br><span class=\"line\">\t\tparent-&gt;_right = gp;</span><br><span class=\"line\">\t\tgp-&gt;_parent = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"built_in\">GetRoot</span>())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SetRoot</span>(parent);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//染色</span></span><br><span class=\"line\">\t\tparent-&gt;_color = Black;</span><br><span class=\"line\">\t\tgp-&gt;_color = Red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateL</span><span class=\"params\">(Node* node)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* cur = node;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* parent = cur-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* gp = parent-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//调整树结构</span></span><br><span class=\"line\">\t\tNode* ggp = gp-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ggp-&gt;_left == gp) ggp-&gt;_left = parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ggp-&gt;_right = parent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = ggp;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tgp-&gt;_right = parent-&gt;_left;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent-&gt;_left)parent-&gt;_left-&gt;_parent = gp;</span><br><span class=\"line\">\t\tparent-&gt;_left = gp;</span><br><span class=\"line\">\t\tgp-&gt;_parent = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"built_in\">GetRoot</span>())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SetRoot</span>(parent);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//染色</span></span><br><span class=\"line\">\t\tparent-&gt;_color = Black;</span><br><span class=\"line\">\t\tgp-&gt;_color = Red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateLR</span><span class=\"params\">(Node* node)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* cur = node;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* parent = cur-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* gp = parent-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"literal\">nullptr</span>) <span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tparent-&gt;_right = cur-&gt;_left;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur-&gt;_left)cur-&gt;_left-&gt;_parent = parent;</span><br><span class=\"line\">\t\tcur-&gt;_left = parent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = cur;</span><br><span class=\"line\">\t\tcur-&gt;_parent = gp;</span><br><span class=\"line\">\t\tgp-&gt;_left = cur;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">RotateR</span>(parent);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateRL</span><span class=\"params\">(Node* node)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* cur = node;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* parent = cur-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* gp = parent-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"literal\">nullptr</span>) <span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tparent-&gt;_left = cur-&gt;_right;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur-&gt;_right)cur-&gt;_right-&gt;_parent = parent;</span><br><span class=\"line\">\t\tcur-&gt;_right = parent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = cur;</span><br><span class=\"line\">\t\tcur-&gt;_parent = gp;</span><br><span class=\"line\">\t\tgp-&gt;_right = cur;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">RotateL</span>(parent);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后将<code>Insert</code>函数补充完整</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"type\">const</span> V&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* proot = <span class=\"built_in\">GetRoot</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (proot == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//树为空</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNode* newnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(value, Black);</span><br><span class=\"line\">\t\t\tnewnode-&gt;_parent = _header;</span><br><span class=\"line\">\t\t\t_header-&gt;_parent = newnode;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">Find</span>(_kof(value)))<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//结点已存在，插入失败</span></span><br><span class=\"line\">\t\tNode* cur = proot;</span><br><span class=\"line\">\t\tNode* parent = proot-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_cmp(_kof(cur-&gt;_value), _kof(value)))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//插在左子树</span></span><br><span class=\"line\">\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\tcur = <span class=\"built_in\">left</span>(cur);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//插在右子树</span></span><br><span class=\"line\">\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\tcur = <span class=\"built_in\">right</span>(cur);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//开始插入</span></span><br><span class=\"line\">\t\tNode* newnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(value, Red);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_cmp(_kof(parent-&gt;_value),_kof(value) ))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//插入右子树</span></span><br><span class=\"line\">\t\t\tparent-&gt;_left = newnode;</span><br><span class=\"line\">\t\t\tnewnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tparent-&gt;_right = newnode;</span><br><span class=\"line\">\t\t\tnewnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcur = newnode;</span><br><span class=\"line\">\t\t<span class=\"comment\">//开始调整</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (parent != _header &amp;&amp; parent-&gt;_color == Red)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNode* gp = parent-&gt;_parent;</span><br><span class=\"line\">\t\t\tNode* uncle = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent == gp-&gt;_left)uncle = gp-&gt;_right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> uncle = gp-&gt;_left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (uncle &amp;&amp; uncle-&gt;_color == Red)<span class=\"comment\">//情况一</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tparent-&gt;_color = Black;</span><br><span class=\"line\">\t\t\t\tuncle-&gt;_color = Black;</span><br><span class=\"line\">\t\t\t\tgp-&gt;_color = Red;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tcur = gp;</span><br><span class=\"line\">\t\t\t\tparent = gp-&gt;_parent;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == parent-&gt;_left &amp;&amp; parent == gp-&gt;_left)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">RotateR</span>(cur);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == parent-&gt;_right &amp;&amp; parent == gp-&gt;_right)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">RotateL</span>(cur);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == parent-&gt;_right &amp;&amp; parent == gp-&gt;_left)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">RotateLR</span>(cur);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == parent-&gt;_left &amp;&amp; parent == gp-&gt;_right)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">RotateRL</span>(cur);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tNode* root = <span class=\"built_in\">GetRoot</span>();</span><br><span class=\"line\">\t\troot-&gt;_color = Black;<span class=\"comment\">//修改根节点颜色</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"红黑树的删除\"><a href=\"#红黑树的删除\" class=\"headerlink\" title=\"红黑树的删除\"></a>红黑树的删除</h3><p><del>让红黑树和进程一起被清理也不是不行</del></p>\n<p><em>under construction</em></p>\n<h3 id=\"红黑树的验证、高度和遍历\"><a href=\"#红黑树的验证、高度和遍历\" class=\"headerlink\" title=\"红黑树的验证、高度和遍历\"></a>红黑树的验证、高度和遍历</h3><p>下面再补充一些获取红黑树参数的接口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Inorder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t_Inorder(<span class=\"built_in\">GetRoot</span>());</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; <span class=\"string\">&quot;nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">void</span> _Inorder(Node* root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t_Inorder(root-&gt;_left);</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; root-&gt;_value &lt;&lt; <span class=\"string\">&quot;-&gt;&quot;</span>;</span><br><span class=\"line\">\t\t_Inorder(root-&gt;_right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Height</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _Height(<span class=\"built_in\">GetRoot</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _Height(Node* root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> LHeight = _Height(root-&gt;_left);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> RHeight = _Height(root-&gt;_right);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (LHeight &gt; RHeight) <span class=\"keyword\">return</span> LHeight + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> RHeight + <span class=\"number\">1</span>; <span class=\"comment\">//将左右子树相等的情况合并在这里</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">IsValidRBTree</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* root = <span class=\"built_in\">GetRoot</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root-&gt;_color != Black)<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//违反根节点染色规则</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> blackCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tNode* cur = root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cur-&gt;_color == Black) blackCount++;</span><br><span class=\"line\">\t\t\tcur = cur-&gt;_left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tblackCount++;<span class=\"comment\">//cur为nullptr时也算作一个黑节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _IsValidRBTree(root,<span class=\"number\">0</span>,blackCount);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">bool</span> _IsValidRBTree(Node* root,<span class=\"type\">int</span> cnt,<span class=\"type\">const</span> <span class=\"type\">int</span> blackCount)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcnt++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cnt == blackCount)<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//黑色节点数量不相等</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//检测与父结点的染色规则</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root-&gt;_color == Red &amp;&amp; root-&gt;_parent-&gt;_color == Red)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//不能有连续的红色节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root-&gt;_color == Black) cnt++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _IsValidRBTree(root-&gt;_left, cnt, blackCount)</span><br><span class=\"line\">\t\t\t&amp;&amp; _IsValidRBTree(root-&gt;_right, cnt, blackCount);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"封装迭代器\"><a href=\"#封装迭代器\" class=\"headerlink\" title=\"封装迭代器\"></a>封装迭代器</h3><p>红黑树的迭代器是双向迭代器，所以储存<code>空指针</code>的迭代器没有意义，我们在构造函数上就禁掉用空指针构造</p>\n<h4 id=\"拷贝构造\"><a href=\"#拷贝构造\" class=\"headerlink\" title=\"拷贝构造\"></a><code>拷贝构造</code></h4><p>除了直接构造迭代器，还要提供用<code>const_iterator</code>构造<code>iterator</code>的拷贝构造，而我们依然使用<code>template &lt;class Value,class Ref,class Ptr&gt;</code>作为模板参数，所以要在<code>iterator</code>类型需要在类内手动封装,代码如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Value</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ref</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">__rbtree_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;Value, <span class=\"type\">const</span> Value&amp;, <span class=\"type\">const</span> Value*&gt; const_iterator;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> RBTreeNode&lt;Value&gt;* linkeType;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tlinkType _ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"迭代器的-和–\"><a href=\"#迭代器的-和–\" class=\"headerlink\" title=\"迭代器的++和–\"></a>迭代器的++和–</h4><p>迭代器的<code>++</code>和<code>--</code>是按前序遍历的顺序和逆序来访问的，而三叉链表有自己独特的访问方式</p>\n<p><strong><code>++</code></strong></p>\n<ul>\n<li>操作当前结点时，该结点和该节点的左子树已经完成遍历,前序遍历已经走过 <code>左子树</code>-&gt;<code>根</code><ul>\n<li>该节点有右子树时，前序遍历右子树</li>\n<li>该节点没有右子树时，该子树完成遍历，回到根节点<code>root</code>的父节点<code>p</code>再次执行<code>++</code>操作(这里可以用递归),下面介绍循环<ul>\n<li>当根节点<code>root</code>为<code>p</code>的右结点时，<code>p</code>为根节点的子树也完成了遍历，把<code>p</code>作为所在子树的<code>root</code>，执行上一条操作</li>\n<li>当根节点<code>root</code>为<code>p</code>的左结点时，<code>p</code>的左子树完成了遍历，正好下一步访问根节点,即<code>p</code>,返回指向<code>p</code>的迭代器即可</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong><code>--</code></strong></p>\n<ul>\n<li>操作当前结点时，该结点和该节点的右子树已经完成遍历,前序遍历已经走过 <code>右子树</code>-&gt;<code>根</code><ul>\n<li>该节点有左子树时，后序遍历右子树</li>\n<li>该节点没有左子树时，该子树完成遍历，回到根节点<code>root</code>的父节点<code>p</code>再次执行<code>--</code>操作(这里可以用递归),下面介绍循环<ul>\n<li>当根节点<code>root</code>为<code>p</code>的左结点时，<code>p</code>为根节点的子树也完成了遍历，把<code>p</code>作为所在子树的<code>root</code>，执行上一条操作</li>\n<li>当根节点<code>root</code>为<code>p</code>的右结点时，<code>p</code>的右子树完成了遍历，正好下一步访问根节点,即<code>p</code>,返回指向<code>p</code>的迭代器即可</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>完整代码如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Value</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ref</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">__rbtree_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;Value, <span class=\"type\">const</span> Value&amp;, <span class=\"type\">const</span> Value*&gt; const_iterator;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> RBTreeNode&lt;Value&gt;* linkeType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t__rbtree_iterator(<span class=\"type\">const</span> linkeType&amp; ptr)</span><br><span class=\"line\">\t\t:_ptr(ptr)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_ptr == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);<span class=\"comment\">//非法的空迭代器</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__rbtree_iterator(<span class=\"type\">const</span> const_iterator&amp; const_it)</span><br><span class=\"line\">\t\t:_ptr(const_it._ptr)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tself <span class=\"keyword\">operator</span>++()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_ptr == <span class=\"literal\">nullptr</span> || _ptr-&gt;_right == _ptr )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);<span class=\"comment\">//end()迭代器不能++,空迭代器不能加减</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_ptr-&gt;_right)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_ptr = _ptr-&gt;_right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tlinkeType parent = _ptr-&gt;_parent;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (parent-&gt;_right == _ptr)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t_ptr = parent;</span><br><span class=\"line\">\t\t\t\tparent = _ptr-&gt;_parent;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t_ptr = parent;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tself <span class=\"keyword\">operator</span>--()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_ptr == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);<span class=\"comment\">//非法情况</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_ptr-&gt;_left == _ptr)<span class=\"comment\">//在头结点</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tlinkeType right = _ptr-&gt;_parent;<span class=\"comment\">//走到根节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (right)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t_ptr = right;</span><br><span class=\"line\">\t\t\t\tright = _ptr-&gt;_right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_ptr-&gt;_left)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_ptr = _ptr-&gt;_left;</span><br><span class=\"line\">\t\t\tlinkeType right = _ptr-&gt;_right;<span class=\"comment\">//寻找左子树的最右结点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (right)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t_ptr = right;</span><br><span class=\"line\">\t\t\t\tright = _ptr-&gt;_right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tlinkeType parent = _ptr-&gt;_parent;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (parent-&gt;_left == _ptr)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t_ptr = parent;</span><br><span class=\"line\">\t\t\t\tparent = _ptr-&gt;_parent;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t_ptr = parent;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRef <span class=\"keyword\">operator</span>*()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _ptr-&gt;_value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPtr <span class=\"keyword\">operator</span>-&gt;()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;(_ptr-&gt;_value);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"type\">const</span> self&amp; it)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _ptr != it._ptr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"type\">const</span> self&amp; it)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> !<span class=\"keyword\">operator</span>!=(it);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tlinkeType _ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>RBTree</code>类中声明迭代器类并添加接口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;V, V&amp;, V*&gt; iterator;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;V, <span class=\"type\">const</span> V&amp;, <span class=\"type\">const</span> V*&gt;const_iterator;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\">iterator <span class=\"title\">begin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">iterator</span>(<span class=\"built_in\">Most_Left</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">iterator <span class=\"title\">end</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">iterator</span>(_header);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">const_iterator <span class=\"title\">begin</span><span class=\"params\">()</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">const_iterator</span>(<span class=\"built_in\">Most_Left</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">const_iterator <span class=\"title\">end</span><span class=\"params\">()</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">const_iterator</span>(_header);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改Insert\"><a href=\"#修改Insert\" class=\"headerlink\" title=\"修改Insert\"></a>修改Insert</h3><p>封装了迭代器之后，我们就可以让<code>insert</code>承担更多的功能了,让它同时返回<code>bool</code>和<code>iterator/const_iterator</code></p>\n<p><code>std::pair&lt;bool,iterator&gt;</code></p>\n<h3 id=\"新增关于容量的接口\"><a href=\"#新增关于容量的接口\" class=\"headerlink\" title=\"新增关于容量的接口\"></a>新增关于容量的接口</h3><p>这里我们新增一个私有成员变量<code>size_t _size</code>记录红黑树中有效节点个数，此处需要修改一下构造函数和<code>Insert</code>函数，这里就不列出来了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">size</span><span class=\"params\">()</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _size == <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"新增拷贝构造\"><a href=\"#新增拷贝构造\" class=\"headerlink\" title=\"新增拷贝构造\"></a>新增拷贝构造</h3><p>有了迭代器，拷贝构造也十分好写了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">RBTree</span>(<span class=\"type\">const</span> self&amp; rbt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> value : rbt)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">Insert</span>(value);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/d13a1291622bbd20e6b92dd4c9aab2b0.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h1><p>虽然<code>AVL树</code>作为绝对的平衡搜索二叉树，有着极高的查询效率，但正因为其严格的要求，修改<code>AVL树</code>的某个结点时，可能要一路调整到根节点，效率低下。为了解决这一痛点，略微没那么严格的<strong>近似平衡搜索二叉树</strong>，即<code>红黑树</code>被提出</p>\n<h2 id=\"红黑树的概念\"><a href=\"#红黑树的概念\" class=\"headerlink\" title=\"红黑树的概念\"></a>红黑树的概念</h2><p>红黑树，是一种二叉搜索树，但在每个结点上<code>增加一个存储位表示结点的颜色</code>，可以是<code>Red</code>或<code>Black</code>。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，<strong>红黑树确保没有一条路径会比其他路径长出俩倍</strong>，因而是<strong>接近平衡</strong>的。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTree_RBT.png\"></p>\n<h2 id=\"红黑树的性质\"><a href=\"#红黑树的性质\" class=\"headerlink\" title=\"红黑树的性质\"></a>红黑树的性质</h2><p>首先与一般的定义不同，在红黑树中将<code>空指针</code>(上图为<code>NIL</code>)作为<code>叶子节点</code>,然后我们来讨论具体的性质</p>\n<ol>\n<li>每个结点不是<code>红色</code>就是<code>黑色</code></li>\n<li>根节点必定是<code>黑色</code>的</li>\n<li>如果一个结点是<code>红色</code>的,则它的两个<strong>孩子结点</strong>是<code>黑色</code>的</li>\n<li>对于每个结点，该结点到其所有后代叶结点的简单路径上，均包含<strong>相同数目</strong>的<code>黑色</code>结点</li>\n<li>每个<strong>叶子结点</strong>都是<code>黑色</code>的此处的叶子结点指的是<code>空结点NIL</code></li>\n</ol>\n<p><strong>思考：为什么满足上面的性质，红黑树就能保证：其最长路径中节点个数不会超过最短路径节点个数的两倍？</strong></p>\n<blockquote>\n<p>红黑树的性质保证了从根节点到所有叶子结点（空结点）的路径上，<strong>包含相同数量的黑色结点</strong>。这是红黑树平衡性的重要保证，以下是如何保证最长路径不会超过最短路径两倍的具体解释：</p>\n<ol>\n<li>黑色高度的定义：</li>\n</ol>\n<ul>\n<li>对于红黑树中的每个结点，定义其黑色高度为从该结点到叶子结点的路径上黑色结点的数量。根据性质 4，这个数量在所有路径上都是相同的。</li>\n<li>设定黑色高度为<code>h</code>。那么从根到任意叶子结点的路径都包含<code>h</code>个黑色结点。</li>\n</ul>\n<ol start=\"2\">\n<li>红色结点的插入：</li>\n</ol>\n<ul>\n<li>根据性质3，如果一个结点是红色的，则它的两个孩子结点是黑色的。这就意味着每个红色结点必定有两个黑色的孩子。</li>\n<li>因此，从根到叶子结点的路径上，红色结点与黑色结点交替出现，红色结点之间的路径长度会相对较短。</li>\n</ul>\n<ol start=\"3\">\n<li>路径长度的关系：</li>\n</ol>\n<ul>\n<li>根到一个叶子结点的路径的最长可能路径是最短路径的两倍。这是因为每个红色结点都在路径上增加了一个额外的层级，但它们只增加了一个红色结点的高度，而黑色结点的数量不变。</li>\n<li>如果某条路径上有 <code>r</code> 个红色结点，那么该路径的总长度将是 <code>h + r</code>，其中 <code>h</code> 是黑色结点的数量。因为红色结点的数量 <code>r</code> 可以最大等于 <code>h</code>，所以最长路径的长度 <code>h + r</code>最大为 <code>2h</code>，即<strong>最长路径的长度不会超过最短路径的两倍</strong>。</li>\n</ul>\n</blockquote>\n<h2 id=\"红黑树的实现\"><a href=\"#红黑树的实现\" class=\"headerlink\" title=\"红黑树的实现\"></a>红黑树的实现</h2><p>这里我们仿照<code>STL30</code>的源码,再用更简洁易懂的代码形式实现红黑树,<em>比如节点和迭代器的双层设计，这里就不使用了</em></p>\n<h3 id=\"红黑树结点\"><a href=\"#红黑树结点\" class=\"headerlink\" title=\"红黑树结点\"></a>红黑树结点</h3><ul>\n<li>因为要经常访问父结点，所以这里用三叉链表维护树结构</li>\n<li>红黑树的节点需要一个变量表示颜色，这里用<code>typedef</code>把<code>bool</code>类型封装为<code>Color</code>类</li>\n<li>使用模板来存储泛类型的值</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">bool</span> Color;<span class=\"comment\">//只有红黑两种颜色，正好使用bool类型</span></span><br><span class=\"line\"><span class=\"type\">const</span> Color Red = <span class=\"literal\">false</span>;<span class=\"comment\">//定义两种颜色</span></span><br><span class=\"line\"><span class=\"type\">const</span> Color Black = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//红黑树结点的定义</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">ValueType</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">RBTreeNode</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> RBTreeNode&lt;ValueType&gt; Node;<span class=\"comment\">//简化代码</span></span><br><span class=\"line\">\tNode* _left;</span><br><span class=\"line\">\tNode* _right;</span><br><span class=\"line\">\tNode* _parent;</span><br><span class=\"line\">\tColor _color;</span><br><span class=\"line\"></span><br><span class=\"line\">\tValueType _value;</span><br><span class=\"line\">\t<span class=\"built_in\">RBTreeNode</span>(<span class=\"type\">const</span> ValueType&amp; val, Color color)</span><br><span class=\"line\">\t\t:_value(val)</span><br><span class=\"line\">\t\t, _color(color)</span><br><span class=\"line\">\t\t, _left(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t, _right(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t, _parent(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"红黑树的基本结构\"><a href=\"#红黑树的基本结构\" class=\"headerlink\" title=\"红黑树的基本结构\"></a>红黑树的基本结构</h3><ul>\n<li>模板参数:红黑树也是<code>KV</code>类型的二叉树，所以模板参数有:<ul>\n<li><code>K</code>:即Key,节点使用<code>K</code>类型的参数比较</li>\n<li><code>V</code>:即ValueType,构造红黑树结点时传入的模板参数</li>\n<li><code>KeyOfValue</code>:因为节点将<code>Key</code>值也存在了节点的值域，所以需要外部传入<code>仿函数KeyOfValue</code>将Key值取出</li>\n<li><code>Compare</code>:允许外部自定义<code>K类型</code>的比较规则</li>\n</ul>\n</li>\n<li>typedef封装:<ul>\n<li><code>typedef RBTreeNode&lt;V&gt; Node;</code></li>\n</ul>\n</li>\n<li>私有成员变量:<ul>\n<li><code>Compare _cmp</code>:声明一个仿函数成员变量，整个对象里都能直接调用</li>\n<li><code>KeyOfValue _kof</code>:用处同上</li>\n<li><code>Node* _header</code></li>\n</ul>\n</li>\n<li>默认构造函数：<ul>\n<li>使用缺省传入<code>const Compare&amp;</code>类型定义的<code>std::greater&lt;K&gt;()</code>临时对象</li>\n<li>创建哨兵位作为头结点，使后续对根结点的调整与一般情况统一</li>\n</ul>\n</li>\n<li>私有函数<code>GetRoot()</code> <code>left()</code> <code>right()</code><ul>\n<li>将对根节点的获取封装起来，使代码更直观</li>\n<li>简化代码，获取左右子树</li>\n</ul>\n</li>\n</ul>\n<p>至于迭代器的封装，我们在<a href=\"#iterator\">后文实现</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">K</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">V</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">KeyOfValue</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Compare</span> = std::greater&lt;<span class=\"type\">int</span>&gt; &gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> RBTree</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> RBTreeNode&lt;V&gt; Node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">RBTree</span>(<span class=\"type\">const</span> Compare&amp; cmp =<span class=\"built_in\">Compare</span>())</span><br><span class=\"line\">\t\t:_cmp(cmp), _header(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//创建哨兵位头结点，使后面调整树形状不用区分根节点</span></span><br><span class=\"line\">\t\t_header = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(<span class=\"built_in\">V</span>(), Black);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\">Node* <span class=\"title\">GetRoot</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_header-&gt;_parent == _header)<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> _header-&gt;_parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Node* <span class=\"title\">SetRoot</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\troot-&gt;_parent = _header;</span><br><span class=\"line\">\t\t_header-&gt;_parent = root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Node* <span class=\"title\">left</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root-&gt;_left;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Node* <span class=\"title\">right</span><span class=\"params\">(Node* root)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root-&gt;_right;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tCompare _cmp;</span><br><span class=\"line\">\tKeyOfValue _kof;</span><br><span class=\"line\">\tNode* _header;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"红黑树的插入\"><a href=\"#红黑树的插入\" class=\"headerlink\" title=\"红黑树的插入\"></a>红黑树的插入</h3><p>和<code>AVL树</code>一样，红黑树的插入也分为两步<code>新增结点</code>和<code>调整</code></p>\n<h4 id=\"新增结点\"><a href=\"#新增结点\" class=\"headerlink\" title=\"新增结点\"></a>新增结点</h4><p>关于根结点的颜色，前面的<a href=\"#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8\">规定性质</a>里也说了，根节点为黑色，这里在重申一下为什么一定是黑色</p>\n<blockquote>\n<ol>\n<li>简化性质的维护：根节点为黑色可以简化在插入和删除操作后维持红黑树性质的过程。特别是在插入节点时，新的节点（通常为红色）可能违反了红黑树的性质。根节点为黑色确保了在树的高度平衡和黑色节点数量保持一致的情况下，维护这些性质更加容易。</li>\n<li>平衡树的高度：红黑树的性质确保了树的高度约为 ( \\log(n) )，其中 ( n ) 是树中节点的数量。通过将根节点设为黑色，红黑树的黑色高度（从根到所有叶子节点的黑色节点数目）得到保证，从而有助于维护树的平衡。</li>\n<li>避免违反性质：如果根节点允许是红色，可能会导致在某些情况下难以保证红色节点的数量平衡，特别是在连续插入和删除操作之后。将根节点设为黑色可以避免这种复杂情况，从而简化了实现和维护过程。</li>\n</ol>\n</blockquote>\n<p>首先我们先写个<code>Find</code>函数防止插入重复数据</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">const</span> K&amp; key)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\tNode* cur = <span class=\"built_in\">GetRoot</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_cmp(_kof(cur-&gt;_value), key))<span class=\"comment\">//相等或在左子树</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tprev = cur;</span><br><span class=\"line\">\t\t\t\tcur = <span class=\"built_in\">left</span>(cur);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcur = <span class=\"built_in\">right</span>(cur);<span class=\"comment\">//可能在右子树</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (prev == <span class=\"literal\">nullptr</span> || _cmp(_kof(prev-&gt;_value),key))<span class=\"comment\">//一直向右走或一直向左走</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//走到头的过程中左转了一次之后一直向右走</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于新结点（非根）的颜色,这里规定为<code>红色</code>，使新结点对红黑树中<code>黑树</code>高度的影响最小</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNode* proot = <span class=\"built_in\">GetRoot</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (proot == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//树为空</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tNode* newnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(value, Black);</span><br><span class=\"line\">\t\tnewnode-&gt;_parent = _header;</span><br><span class=\"line\">\t\t_header-&gt;_parent = newnode;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">Find</span>(_kof(value)))<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//结点已存在，插入失败</span></span><br><span class=\"line\">\tNode* cur = proot;</span><br><span class=\"line\">\tNode* parent = proot-&gt;_parent;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_cmp(_kof(cur-&gt;_value), _kof(value)))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//插在左子树</span></span><br><span class=\"line\">\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\tcur = <span class=\"built_in\">left</span>(cur);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//插在右子树</span></span><br><span class=\"line\">\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\tcur = <span class=\"built_in\">right</span>(cur);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//开始插入</span></span><br><span class=\"line\">\tNode* newnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(value, Red);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (_cmp(_kof(parent-&gt;_value),_kof(value) ))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//插入右子树</span></span><br><span class=\"line\">\t\tparent-&gt;_left = newnode;</span><br><span class=\"line\">\t\tnewnode-&gt;_parent = parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tparent-&gt;_right = newnode;</span><br><span class=\"line\">\t\tnewnode-&gt;_parent = parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//开始调整</span></span><br><span class=\"line\">\t<span class=\"comment\">//.......</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n<h4 id=\"调整红黑树\"><a href=\"#调整红黑树\" class=\"headerlink\" title=\"调整红黑树\"></a>调整红黑树</h4><p>每次新节点插入后，都要检测红黑树的性质是否造到破坏</p>\n<p>因为新节点的默认颜色是红色，因此：如果其双亲节点的颜色是黑色，没有违反红黑树任何性质，则不需要调整；但当新插入节点的双亲节点颜色为红色时，就违反了性质三<code>不能有连在一起的红色节点</code>，此时需要对红黑树分情况来讨论:</p>\n<p><strong>约定</strong> <strong><code>cur</code>当前结点,<code>parent</code>为父结点,<code>uncle</code>为叔叔结点,<code>gp</code>为祖父结点</strong></p>\n<h5 id=\"情况一：直接染色\"><a href=\"#情况一：直接染色\" class=\"headerlink\" title=\"情况一：直接染色\"></a>情况一：直接染色</h5><ul>\n<li><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_1.png\"></li>\n<li>可以看到这种情况只需染色即可,将<code>gp</code>染色为红色，防止整棵树的<code>黑树高度</code>改变0</li>\n<li>不过当该树为整棵树而不是子树时，根节点(<code>gp</code>)在最后还需染色回黑色（这里留到所有调整的最后）</li>\n<li>当该树为子树，即<code>gp</code>存在父结点时，因为<code>gp</code>变为了红色，还需继续向上调整</li>\n<li><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_1_1.png\"></li>\n</ul>\n<h5 id=\"情况二：单次旋转-染色\"><a href=\"#情况二：单次旋转-染色\" class=\"headerlink\" title=\"情况二：单次旋转+染色\"></a>情况二：单次旋转+染色</h5><ul>\n<li><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_2.png\"></li>\n<li>图中<code>uncle</code>的情况有两种<ul>\n<li>如果<code>uncle</code>节点不存在，则<code>cur</code>一定是<strong>新插入节点</strong>，因为如果<code>cur</code>不是新插入节点，则<code>cur</code>和<code>parent</code>一定有一个节点的颜色是黑色，就不满足性质4：每条路径黑色节点个数相同。</li>\n<li>如果<code>uncle</code>节点存在，则其一定是黑色的，那么<code>cur</code>节点原来的颜色一定是黑色的，现在看到其是红色的原因是因为<code>cur</code>的子树在<strong>调整的过程中</strong>将<code>cur</code>节点的颜色由黑色改成红色。</li>\n</ul>\n</li>\n<li>调整步骤：<ul>\n<li><code>parent</code>为<code>pg</code>的左孩子，<code>cur</code>为<code>parent</code>的左孩子，则进行右单旋转</li>\n<li><code>parent</code>为<code>pg</code>的右孩子，<code>cur</code>为<code>parent</code>的右孩子，则进行左单旋转</li>\n<li><code>parent</code>-&gt;黑色</li>\n<li><code>pg</code>-&gt;红色</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"情况三：两次旋转\"><a href=\"#情况三：两次旋转\" class=\"headerlink\" title=\"情况三：两次旋转\"></a>情况三：两次旋转</h5><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/RBTREE_3.png\"></p>\n<ul>\n<li>如图，一次旋转后变成了<strong>情况二</strong>,所以总共要旋转两次<ul>\n<li><code>parent</code>为<code>gp</code>的左孩子，<code>cur</code>为<code>parent</code>的右孩子，则针对<code>parent</code>做左单旋转</li>\n<li><code>pparent</code>为<code>gp</code>的右孩子，<code>cur</code>为<code>parent</code>的左孩子，则针对<code>parent</code>做右单旋转</li>\n</ul>\n</li>\n<li>变成情况二后按情况二处理即可</li>\n</ul>\n<h5 id=\"封装代码\"><a href=\"#封装代码\" class=\"headerlink\" title=\"封装代码\"></a>封装代码</h5><p>旋转操作的代码量较大，我们选择封装到成员函数中</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateR</span><span class=\"params\">(Node* node)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* cur = node;</span><br><span class=\"line\">\t\tNode* parent = cur-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>) <span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* gp = parent-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"literal\">nullptr</span>) <span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//调整树结构</span></span><br><span class=\"line\">\t\tNode* ggp = gp-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == ggp-&gt;_left)ggp-&gt;_left = parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ggp-&gt;_right = parent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = ggp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tgp-&gt;_left = parent-&gt;_right;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent-&gt;_right)parent-&gt;_right-&gt;_parent = gp;</span><br><span class=\"line\">\t\tparent-&gt;_right = gp;</span><br><span class=\"line\">\t\tgp-&gt;_parent = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"built_in\">GetRoot</span>())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SetRoot</span>(parent);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//染色</span></span><br><span class=\"line\">\t\tparent-&gt;_color = Black;</span><br><span class=\"line\">\t\tgp-&gt;_color = Red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateL</span><span class=\"params\">(Node* node)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* cur = node;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* parent = cur-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* gp = parent-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//调整树结构</span></span><br><span class=\"line\">\t\tNode* ggp = gp-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ggp-&gt;_left == gp) ggp-&gt;_left = parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ggp-&gt;_right = parent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = ggp;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tgp-&gt;_right = parent-&gt;_left;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent-&gt;_left)parent-&gt;_left-&gt;_parent = gp;</span><br><span class=\"line\">\t\tparent-&gt;_left = gp;</span><br><span class=\"line\">\t\tgp-&gt;_parent = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"built_in\">GetRoot</span>())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SetRoot</span>(parent);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//染色</span></span><br><span class=\"line\">\t\tparent-&gt;_color = Black;</span><br><span class=\"line\">\t\tgp-&gt;_color = Red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateLR</span><span class=\"params\">(Node* node)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* cur = node;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* parent = cur-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* gp = parent-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"literal\">nullptr</span>) <span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tparent-&gt;_right = cur-&gt;_left;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur-&gt;_left)cur-&gt;_left-&gt;_parent = parent;</span><br><span class=\"line\">\t\tcur-&gt;_left = parent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = cur;</span><br><span class=\"line\">\t\tcur-&gt;_parent = gp;</span><br><span class=\"line\">\t\tgp-&gt;_left = cur;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">RotateR</span>(parent);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RotateRL</span><span class=\"params\">(Node* node)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* cur = node;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* parent = cur-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (parent == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\tNode* gp = parent-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (gp == <span class=\"literal\">nullptr</span>) <span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tparent-&gt;_left = cur-&gt;_right;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur-&gt;_right)cur-&gt;_right-&gt;_parent = parent;</span><br><span class=\"line\">\t\tcur-&gt;_right = parent;</span><br><span class=\"line\">\t\tparent-&gt;_parent = cur;</span><br><span class=\"line\">\t\tcur-&gt;_parent = gp;</span><br><span class=\"line\">\t\tgp-&gt;_right = cur;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">RotateL</span>(parent);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后将<code>Insert</code>函数补充完整</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"type\">const</span> V&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* proot = <span class=\"built_in\">GetRoot</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (proot == <span class=\"literal\">nullptr</span>)<span class=\"comment\">//树为空</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNode* newnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(value, Black);</span><br><span class=\"line\">\t\t\tnewnode-&gt;_parent = _header;</span><br><span class=\"line\">\t\t\t_header-&gt;_parent = newnode;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">Find</span>(_kof(value)))<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//结点已存在，插入失败</span></span><br><span class=\"line\">\t\tNode* cur = proot;</span><br><span class=\"line\">\t\tNode* parent = proot-&gt;_parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_cmp(_kof(cur-&gt;_value), _kof(value)))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//插在左子树</span></span><br><span class=\"line\">\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\tcur = <span class=\"built_in\">left</span>(cur);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//插在右子树</span></span><br><span class=\"line\">\t\t\t\tparent = cur;</span><br><span class=\"line\">\t\t\t\tcur = <span class=\"built_in\">right</span>(cur);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//开始插入</span></span><br><span class=\"line\">\t\tNode* newnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(value, Red);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_cmp(_kof(parent-&gt;_value),_kof(value) ))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//插入右子树</span></span><br><span class=\"line\">\t\t\tparent-&gt;_left = newnode;</span><br><span class=\"line\">\t\t\tnewnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tparent-&gt;_right = newnode;</span><br><span class=\"line\">\t\t\tnewnode-&gt;_parent = parent;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcur = newnode;</span><br><span class=\"line\">\t\t<span class=\"comment\">//开始调整</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (parent != _header &amp;&amp; parent-&gt;_color == Red)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNode* gp = parent-&gt;_parent;</span><br><span class=\"line\">\t\t\tNode* uncle = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent == gp-&gt;_left)uncle = gp-&gt;_right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> uncle = gp-&gt;_left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (uncle &amp;&amp; uncle-&gt;_color == Red)<span class=\"comment\">//情况一</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tparent-&gt;_color = Black;</span><br><span class=\"line\">\t\t\t\tuncle-&gt;_color = Black;</span><br><span class=\"line\">\t\t\t\tgp-&gt;_color = Red;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tcur = gp;</span><br><span class=\"line\">\t\t\t\tparent = gp-&gt;_parent;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == parent-&gt;_left &amp;&amp; parent == gp-&gt;_left)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">RotateR</span>(cur);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == parent-&gt;_right &amp;&amp; parent == gp-&gt;_right)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">RotateL</span>(cur);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == parent-&gt;_right &amp;&amp; parent == gp-&gt;_left)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">RotateLR</span>(cur);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == parent-&gt;_left &amp;&amp; parent == gp-&gt;_right)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">RotateRL</span>(cur);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tNode* root = <span class=\"built_in\">GetRoot</span>();</span><br><span class=\"line\">\t\troot-&gt;_color = Black;<span class=\"comment\">//修改根节点颜色</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"红黑树的删除\"><a href=\"#红黑树的删除\" class=\"headerlink\" title=\"红黑树的删除\"></a>红黑树的删除</h3><p><del>让红黑树和进程一起被清理也不是不行</del></p>\n<p><em>under construction</em></p>\n<h3 id=\"红黑树的验证、高度和遍历\"><a href=\"#红黑树的验证、高度和遍历\" class=\"headerlink\" title=\"红黑树的验证、高度和遍历\"></a>红黑树的验证、高度和遍历</h3><p>下面再补充一些获取红黑树参数的接口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Inorder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t_Inorder(<span class=\"built_in\">GetRoot</span>());</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; <span class=\"string\">&quot;nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">void</span> _Inorder(Node* root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t_Inorder(root-&gt;_left);</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; root-&gt;_value &lt;&lt; <span class=\"string\">&quot;-&gt;&quot;</span>;</span><br><span class=\"line\">\t\t_Inorder(root-&gt;_right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Height</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _Height(<span class=\"built_in\">GetRoot</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> _Height(Node* root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> LHeight = _Height(root-&gt;_left);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> RHeight = _Height(root-&gt;_right);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (LHeight &gt; RHeight) <span class=\"keyword\">return</span> LHeight + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> RHeight + <span class=\"number\">1</span>; <span class=\"comment\">//将左右子树相等的情况合并在这里</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">IsValidRBTree</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* root = <span class=\"built_in\">GetRoot</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root-&gt;_color != Black)<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//违反根节点染色规则</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> blackCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tNode* cur = root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cur-&gt;_color == Black) blackCount++;</span><br><span class=\"line\">\t\t\tcur = cur-&gt;_left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tblackCount++;<span class=\"comment\">//cur为nullptr时也算作一个黑节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _IsValidRBTree(root,<span class=\"number\">0</span>,blackCount);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">bool</span> _IsValidRBTree(Node* root,<span class=\"type\">int</span> cnt,<span class=\"type\">const</span> <span class=\"type\">int</span> blackCount)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcnt++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cnt == blackCount)<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//黑色节点数量不相等</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//检测与父结点的染色规则</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root-&gt;_color == Red &amp;&amp; root-&gt;_parent-&gt;_color == Red)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//不能有连续的红色节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root-&gt;_color == Black) cnt++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _IsValidRBTree(root-&gt;_left, cnt, blackCount)</span><br><span class=\"line\">\t\t\t&amp;&amp; _IsValidRBTree(root-&gt;_right, cnt, blackCount);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"封装迭代器\"><a href=\"#封装迭代器\" class=\"headerlink\" title=\"封装迭代器\"></a>封装迭代器</h3><p>红黑树的迭代器是双向迭代器，所以储存<code>空指针</code>的迭代器没有意义，我们在构造函数上就禁掉用空指针构造</p>\n<h4 id=\"拷贝构造\"><a href=\"#拷贝构造\" class=\"headerlink\" title=\"拷贝构造\"></a><code>拷贝构造</code></h4><p>除了直接构造迭代器，还要提供用<code>const_iterator</code>构造<code>iterator</code>的拷贝构造，而我们依然使用<code>template &lt;class Value,class Ref,class Ptr&gt;</code>作为模板参数，所以要在<code>iterator</code>类型需要在类内手动封装,代码如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Value</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ref</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">__rbtree_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;Value, <span class=\"type\">const</span> Value&amp;, <span class=\"type\">const</span> Value*&gt; const_iterator;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> RBTreeNode&lt;Value&gt;* linkeType;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tlinkType _ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"迭代器的-和–\"><a href=\"#迭代器的-和–\" class=\"headerlink\" title=\"迭代器的++和–\"></a>迭代器的++和–</h4><p>迭代器的<code>++</code>和<code>--</code>是按前序遍历的顺序和逆序来访问的，而三叉链表有自己独特的访问方式</p>\n<p><strong><code>++</code></strong></p>\n<ul>\n<li>操作当前结点时，该结点和该节点的左子树已经完成遍历,前序遍历已经走过 <code>左子树</code>-&gt;<code>根</code><ul>\n<li>该节点有右子树时，前序遍历右子树</li>\n<li>该节点没有右子树时，该子树完成遍历，回到根节点<code>root</code>的父节点<code>p</code>再次执行<code>++</code>操作(这里可以用递归),下面介绍循环<ul>\n<li>当根节点<code>root</code>为<code>p</code>的右结点时，<code>p</code>为根节点的子树也完成了遍历，把<code>p</code>作为所在子树的<code>root</code>，执行上一条操作</li>\n<li>当根节点<code>root</code>为<code>p</code>的左结点时，<code>p</code>的左子树完成了遍历，正好下一步访问根节点,即<code>p</code>,返回指向<code>p</code>的迭代器即可</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong><code>--</code></strong></p>\n<ul>\n<li>操作当前结点时，该结点和该节点的右子树已经完成遍历,前序遍历已经走过 <code>右子树</code>-&gt;<code>根</code><ul>\n<li>该节点有左子树时，后序遍历右子树</li>\n<li>该节点没有左子树时，该子树完成遍历，回到根节点<code>root</code>的父节点<code>p</code>再次执行<code>--</code>操作(这里可以用递归),下面介绍循环<ul>\n<li>当根节点<code>root</code>为<code>p</code>的左结点时，<code>p</code>为根节点的子树也完成了遍历，把<code>p</code>作为所在子树的<code>root</code>，执行上一条操作</li>\n<li>当根节点<code>root</code>为<code>p</code>的右结点时，<code>p</code>的右子树完成了遍历，正好下一步访问根节点,即<code>p</code>,返回指向<code>p</code>的迭代器即可</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>完整代码如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Value</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ref</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">__rbtree_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;Value, <span class=\"type\">const</span> Value&amp;, <span class=\"type\">const</span> Value*&gt; const_iterator;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> RBTreeNode&lt;Value&gt;* linkeType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t__rbtree_iterator(<span class=\"type\">const</span> linkeType&amp; ptr)</span><br><span class=\"line\">\t\t:_ptr(ptr)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_ptr == <span class=\"literal\">nullptr</span>)<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);<span class=\"comment\">//非法的空迭代器</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__rbtree_iterator(<span class=\"type\">const</span> const_iterator&amp; const_it)</span><br><span class=\"line\">\t\t:_ptr(const_it._ptr)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tself <span class=\"keyword\">operator</span>++()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_ptr == <span class=\"literal\">nullptr</span> || _ptr-&gt;_right == _ptr )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);<span class=\"comment\">//end()迭代器不能++,空迭代器不能加减</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_ptr-&gt;_right)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_ptr = _ptr-&gt;_right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tlinkeType parent = _ptr-&gt;_parent;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (parent-&gt;_right == _ptr)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t_ptr = parent;</span><br><span class=\"line\">\t\t\t\tparent = _ptr-&gt;_parent;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t_ptr = parent;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tself <span class=\"keyword\">operator</span>--()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_ptr == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);<span class=\"comment\">//非法情况</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_ptr-&gt;_left == _ptr)<span class=\"comment\">//在头结点</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tlinkeType right = _ptr-&gt;_parent;<span class=\"comment\">//走到根节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (right)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t_ptr = right;</span><br><span class=\"line\">\t\t\t\tright = _ptr-&gt;_right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_ptr-&gt;_left)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_ptr = _ptr-&gt;_left;</span><br><span class=\"line\">\t\t\tlinkeType right = _ptr-&gt;_right;<span class=\"comment\">//寻找左子树的最右结点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (right)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t_ptr = right;</span><br><span class=\"line\">\t\t\t\tright = _ptr-&gt;_right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tlinkeType parent = _ptr-&gt;_parent;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (parent-&gt;_left == _ptr)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t_ptr = parent;</span><br><span class=\"line\">\t\t\t\tparent = _ptr-&gt;_parent;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t_ptr = parent;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRef <span class=\"keyword\">operator</span>*()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _ptr-&gt;_value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPtr <span class=\"keyword\">operator</span>-&gt;()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;(_ptr-&gt;_value);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"type\">const</span> self&amp; it)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _ptr != it._ptr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"type\">const</span> self&amp; it)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> !<span class=\"keyword\">operator</span>!=(it);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tlinkeType _ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>RBTree</code>类中声明迭代器类并添加接口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;V, V&amp;, V*&gt; iterator;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __rbtree_iterator&lt;V, <span class=\"type\">const</span> V&amp;, <span class=\"type\">const</span> V*&gt;const_iterator;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\">iterator <span class=\"title\">begin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">iterator</span>(<span class=\"built_in\">Most_Left</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">iterator <span class=\"title\">end</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">iterator</span>(_header);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">const_iterator <span class=\"title\">begin</span><span class=\"params\">()</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">const_iterator</span>(<span class=\"built_in\">Most_Left</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">const_iterator <span class=\"title\">end</span><span class=\"params\">()</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">const_iterator</span>(_header);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改Insert\"><a href=\"#修改Insert\" class=\"headerlink\" title=\"修改Insert\"></a>修改Insert</h3><p>封装了迭代器之后，我们就可以让<code>insert</code>承担更多的功能了,让它同时返回<code>bool</code>和<code>iterator/const_iterator</code></p>\n<p><code>std::pair&lt;bool,iterator&gt;</code></p>\n<h3 id=\"新增关于容量的接口\"><a href=\"#新增关于容量的接口\" class=\"headerlink\" title=\"新增关于容量的接口\"></a>新增关于容量的接口</h3><p>这里我们新增一个私有成员变量<code>size_t _size</code>记录红黑树中有效节点个数，此处需要修改一下构造函数和<code>Insert</code>函数，这里就不列出来了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">size</span><span class=\"params\">()</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _size == <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"新增拷贝构造\"><a href=\"#新增拷贝构造\" class=\"headerlink\" title=\"新增拷贝构造\"></a>新增拷贝构造</h3><p>有了迭代器，拷贝构造也十分好写了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">RBTree</span>(<span class=\"type\">const</span> self&amp; rbt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> value : rbt)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">Insert</span>(value);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"基础IO","date":"2024-07-10T07:24:34.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-25_12-52-35.png","_content":"# 共识原理\n+ 文件 = 内容 + 属性\n+ 被打开的文件需要加载到内存中\n+ **内存中**的文件需要被操作系统**管理**\n\n# 用户级文件接口\n[详见C++文件操作](https://www.supdriver.top/2024/05/14/cpp-file-op/)\n\n[详见C语言文件操作](https://www.supdriver.top/2024/07/15/cfileop/)\n\n# Linux系统调用接口\n\n## fd 文件描述符 与访问文件的本质\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_17-10-26.png)\n\n`fd`(*file descriptor*),即文件描述符,下文的系统调用接口经常以`fd`命名变量，`fd`是整形变量，作为数组下标，用于管理**打开的文件**\n\n可以看到,一个进程通过`struct files _struct`里的指针数组，管理多个同时打开的文件\n\n且每个进程启动时，会默认打开三个文件,且默认`fd`固定\n\n1. stdout \n\n## read \n**所需头文件**\n`#include <unistd.h>`\n**声明**\n`ssize_t read(int fd, void *buf, size_t count);`\n\n**参数**\n+ `fd`即为目标文件的文件描述符\n+ `buf`为要从文件读取字节到的内存地址\n+ `count`为最大读取字节数\n\n**返回值**\n+ 若成功，返回读取文件的字节数,类型为`ssize_t`,是层层封装的`long int`\n+ 若失败，返回`-1`,并设置`errno`的值\n\n## write\n**所需头文件**\n`#include <unistd.h>`\n**声明**\n`ssize_t write(int fd, const void *buf, size_t count);`\n\n**参数**\n+ `fd` 为目标文件的文件描述符\n+ `buf`为要写入文件的`源内存地址`,输入字节数量取决于`count`形参\n+ `count`为要输入的字节数量,若要输入为字符串，且要输入字符串的全部内容，建议使用`strlen(buf)`，防止输入`\\0`,因为对于**文件**来说，`\\0`是**非法字符**\n\n**返回值**\n+ 若成功，返回写入文件的字节数,类型为`ssize_t`,是层层封装的`long int`\n+ 若失败，返回`-1`,并设置`errno`的值\n\n**特别的**\n`read`函数从文件中读取的是`字节`内容，不把读取的内容看作字符串，因此，**不会自动**添加`\\0`在写入`buf`内容的结尾\n\n*用法见后文对`open`的介绍*\n\n\n## open\n**所需头文件**\n```C\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n```\n**声明**\n`int open(const char *pathname, int flags);`\n`int open(const char *pathname, int flags，mode_t mode);`\n\n**参数**:\n\n+ `pathname`为文件路径，若只有文件名，则默认在当前工作路径搜索\n+ `flag`则是一个`位图`,而**不应**看作整型参数，传参时可用`|`位运算传递多个参数到位图中,例如`O_CREAT | O_WRONLY`\n+ `mode`则是在**创建**文件时,传入权限信息,这里使用`八进制表示法`，例如传入`0666`\n**返回值**:\n+ 若成功，返回打开文件的`fd`值\n+ 若失败，则返回`-1`\n\n### 写入操作\n\n相关的`flags`\n\n+ `O_WRONLY` 仅写入\n+ `O_CREAT` 如果文件不存在，就创建，**注**新文件的权限由`open`函数传入的`mode`参数决定\n+ `O_TRUNC` 如果文件已存在且是`常规文件`,并且打开的模式组合**支持写入操作**(`O_RDWR`或`O_WRONLY`),该文件内容将会被清除。但如果该文件是`FIFO`(命名管道)文件或`终端设备文件`，则`O_TRUNC`将会被**忽略**\n+ `O_EXCL` 保证此次`open`操作打开新文件。**必须**和`O_CREAT`联合使用，否则打开**失败**。若`pathname`存在，即该路径的文件存在时，也会打开**失败**\n\n#### 打开已有文件并写入\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n    //前提是log.txt已存在\n    int fd = open(\"log.txt\",O_WRONLY,0666);//只写模式打开文件\n    \n    char msg[] = \"this is a msg\";//准备字符串\n    write(fd,msg,strlen(msg));//写入\n    close(fd);//关闭文件\n    return 0;\n}\n```\n\n当原本`log.txt`为空文件时\n```log.txt\nthis is a msg\n```\n当原`log.txt`不为空且内容长度大于程序输入的`msg`时，发生`部分覆写`\n\n例如原内容为`0000111100001111`时，执行后为\n```log.txt\nthis is a msg111\n```\n可以看到有一部分没有被覆盖\n\n#### 打开空文件 或 创建空文件\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n    //唯一的区别是这里的参数\n    //O_CREAT可以创建空文件\n    //O_TRUNC保证打开已有文件时，清空原文内容\n    int fd = open(\"log.txt\",O_CREAT|O_WRONLY|O_TRUNC,0666);\n    \n    char msg[] = \"this is a msg\";\n    write(fd,msg,strlen(msg));\n    close(fd);\n    return 0;\n}\n```\n#### 追加写入\n追加写入只需把`O_TRUNC`改成`O_APPEND`即可\n\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_CREAT|O_WRONLY|O_APPEND,0666);//追加模式打开文化\n    \n    char msg[] = \"this is a msg\";\n    write(fd,msg,strlen(msg));\n    close(fd);\n    return 0;\n}\n```\n\n这里我们事先删除`log.txt`文件，然后运行两次编译出的程序,可以获得如下内容\n```log.txt\nthis is a msgthis is a msg\n```\n可以看到内容追加了两次\n\n### 读取操作\n相关的`flags`\n\n+ `O_RDONLY`只读模式打开文件\n+ `O_RDWR` 读写模式打开文件\n\n#### 只读模式读取内容\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_RDONLY);\n    char* buf[1024];\n    ssize_t n = read(fd,buf,sizeof(buf)-1);//这里要储存字符串，所以要留一位给\\0\n    if(n<0) perror(\"read\");//打开失败，输出错误信息\n    else buf[n] = '\\0';//添加结尾\n    printf(\"%s\\n\",buf);//打印读取到的内容\n    return 0;\n}\n```\n实现准备内容为`123456`的`log.txt`文件\n\n然后运行`./mycmd`\n\n得到输出和文件内容\n```SHELL\n456\n```\n```log.txt\nzzz456\n```\n关于`read`没读取到前面新写入的`zzz`,是因为`wtrite`和`read`操作都是从文件的`同一处继续`操作的，并不会发生回退\n## close\n`int close(int fd);`\n\n用于冲刷缓冲区，并**关闭**一个文件描述符\n\n## dup2 文件重定向\n`int dup2(int oldfd, int newfd);`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_19-55-30.png)\n\n如图所示，`dup2`能将`oldfd`对应的数组元素`覆盖`到`newfd`对应的数组元素处，完成对`newfd`对应文件的重定向\n\n图中就是完成了对`标准输出`的重定向,像`printf`之类的函数会直接输出内容到文件中,而不是显示器\n\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_RDWR|O_CREAT|O_TRUNC,0666);//打开一个新的空文件\n    dup2(fd,1);//标准输出重定向\n\n    printf(\"output1\\n\");//输出\n    printf(\"output2\\n\");//输出\n\n    return 0;\n}\n```\n运行代码后，可以看到`终端`**没有输出**\n\n而打开`log.txt`\n```log.txt\noutput1\noutput2\n```\n \n# 子进程 与 父进程的文件关系\n\n## 子进程对父进程的拷贝\n先运行一段代码测试 子进程是否**继承**父进程的打开文件\n\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_RDWR|O_CREAT|O_TRUNC|O_APPEND);//追加模式打开一个新文件\n    dup2(fd,1);//在fork前就打开文件\n\n    pid_t id = fork();//创建子进程\n    if(id == 0)\n    {\n        printf(\"child output\\n\");//子进程输出到文件\n        exit(0);\n    }\n    else \n    {\n        waitpid(id,0,0);//阻塞等待子进程\n        printf(\"parent output\\n\");//父进程输出\n    }\n\n    return 0;\n}\n```\n这段代码中，我们在`fork`**之前**完成了对标准输出的**重定向**,然后`fork`之后令父进程和子进程进行不同的标准输出\n\n运行结果为父进程和子进程的`标准输出`都**重定向**到了文件\n\n```log.txt\nchild output\nparent output\n```\n\n## 子进程和父进程的 独立性\n接下来一段代码测试 父进程 和 子进程 的打开文件是否独立\n\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_RDWR|O_CREAT|O_TRUNC|O_APPEND);//追加模式打开一个新文件\n\n    pid_t id = fork();//创建子进程\n    if(id == 0)\n    {\n        dup2(fd,1);//只有子进程重定向了标准输出\n        printf(\"child output\\n\");//子进程输出到文件\n        exit(0);\n    }\n    else \n    {\n        waitpid(id,0,0);//阻塞等待子进程\n        printf(\"parent output\\n\");//父进程输出\n    }\n\n    return 0;\n}\n```\n\n这里我们在`fork`之前都不进行重定向，`fork`后仅对子进程进行了标准输出重定向，而父进程不作任何重定向\n\n在运行后发现子进程的输出重定向不会影响父进程,二者有`独立性`\n\n```SHELL\nparent output\n```\n```log.txt\nchild output\n```\n\n# 进程替换\n先在同级文件夹准备一个待替换的程序\n\n> execute.c\n```C\n#include <stdio.h>\n\nint main()\n{\n    printf(\"exe output\\n\");\n}\n```\n然后运行`gcc -o execute execute.c`编译获得一个程序\n\n然后准备主程序\n\n> mycmd.c\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_RDWR|O_CREAT|O_TRUNC|O_APPEND);//追加模式打开一个新文件\n\n    pid_t id = fork();//创建子进程\n    if(id == 0)\n    {\n        dup2(fd,1);//只有子进程重定向了标准输出\n        execvp(\"./execute\",NULL);//进程替换\n        exit(0);\n    }\n    else \n    {\n        waitpid(id,0,0);//阻塞等待子进程\n        printf(\"parent wait success\\n\");//父进程输出\n    }\n\n    return 0;\n}\n```\n这里我们使子进程**先**标准输出重定向， **再**进行进程替换，发现替换后的进程，也是标准输出重定向的状态\n\n```log.txt\nexe output\n```\n\n## 结论\n进程替换**不会**改变原进程的文件打开状态和重定向关系","source":"_posts/basicIO.md","raw":"---\ntitle: 基础IO\ndate: 2024-07-10 15:24:34\ntags: Linux\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-25_12-52-35.png\n---\n# 共识原理\n+ 文件 = 内容 + 属性\n+ 被打开的文件需要加载到内存中\n+ **内存中**的文件需要被操作系统**管理**\n\n# 用户级文件接口\n[详见C++文件操作](https://www.supdriver.top/2024/05/14/cpp-file-op/)\n\n[详见C语言文件操作](https://www.supdriver.top/2024/07/15/cfileop/)\n\n# Linux系统调用接口\n\n## fd 文件描述符 与访问文件的本质\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_17-10-26.png)\n\n`fd`(*file descriptor*),即文件描述符,下文的系统调用接口经常以`fd`命名变量，`fd`是整形变量，作为数组下标，用于管理**打开的文件**\n\n可以看到,一个进程通过`struct files _struct`里的指针数组，管理多个同时打开的文件\n\n且每个进程启动时，会默认打开三个文件,且默认`fd`固定\n\n1. stdout \n\n## read \n**所需头文件**\n`#include <unistd.h>`\n**声明**\n`ssize_t read(int fd, void *buf, size_t count);`\n\n**参数**\n+ `fd`即为目标文件的文件描述符\n+ `buf`为要从文件读取字节到的内存地址\n+ `count`为最大读取字节数\n\n**返回值**\n+ 若成功，返回读取文件的字节数,类型为`ssize_t`,是层层封装的`long int`\n+ 若失败，返回`-1`,并设置`errno`的值\n\n## write\n**所需头文件**\n`#include <unistd.h>`\n**声明**\n`ssize_t write(int fd, const void *buf, size_t count);`\n\n**参数**\n+ `fd` 为目标文件的文件描述符\n+ `buf`为要写入文件的`源内存地址`,输入字节数量取决于`count`形参\n+ `count`为要输入的字节数量,若要输入为字符串，且要输入字符串的全部内容，建议使用`strlen(buf)`，防止输入`\\0`,因为对于**文件**来说，`\\0`是**非法字符**\n\n**返回值**\n+ 若成功，返回写入文件的字节数,类型为`ssize_t`,是层层封装的`long int`\n+ 若失败，返回`-1`,并设置`errno`的值\n\n**特别的**\n`read`函数从文件中读取的是`字节`内容，不把读取的内容看作字符串，因此，**不会自动**添加`\\0`在写入`buf`内容的结尾\n\n*用法见后文对`open`的介绍*\n\n\n## open\n**所需头文件**\n```C\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n```\n**声明**\n`int open(const char *pathname, int flags);`\n`int open(const char *pathname, int flags，mode_t mode);`\n\n**参数**:\n\n+ `pathname`为文件路径，若只有文件名，则默认在当前工作路径搜索\n+ `flag`则是一个`位图`,而**不应**看作整型参数，传参时可用`|`位运算传递多个参数到位图中,例如`O_CREAT | O_WRONLY`\n+ `mode`则是在**创建**文件时,传入权限信息,这里使用`八进制表示法`，例如传入`0666`\n**返回值**:\n+ 若成功，返回打开文件的`fd`值\n+ 若失败，则返回`-1`\n\n### 写入操作\n\n相关的`flags`\n\n+ `O_WRONLY` 仅写入\n+ `O_CREAT` 如果文件不存在，就创建，**注**新文件的权限由`open`函数传入的`mode`参数决定\n+ `O_TRUNC` 如果文件已存在且是`常规文件`,并且打开的模式组合**支持写入操作**(`O_RDWR`或`O_WRONLY`),该文件内容将会被清除。但如果该文件是`FIFO`(命名管道)文件或`终端设备文件`，则`O_TRUNC`将会被**忽略**\n+ `O_EXCL` 保证此次`open`操作打开新文件。**必须**和`O_CREAT`联合使用，否则打开**失败**。若`pathname`存在，即该路径的文件存在时，也会打开**失败**\n\n#### 打开已有文件并写入\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n    //前提是log.txt已存在\n    int fd = open(\"log.txt\",O_WRONLY,0666);//只写模式打开文件\n    \n    char msg[] = \"this is a msg\";//准备字符串\n    write(fd,msg,strlen(msg));//写入\n    close(fd);//关闭文件\n    return 0;\n}\n```\n\n当原本`log.txt`为空文件时\n```log.txt\nthis is a msg\n```\n当原`log.txt`不为空且内容长度大于程序输入的`msg`时，发生`部分覆写`\n\n例如原内容为`0000111100001111`时，执行后为\n```log.txt\nthis is a msg111\n```\n可以看到有一部分没有被覆盖\n\n#### 打开空文件 或 创建空文件\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n    //唯一的区别是这里的参数\n    //O_CREAT可以创建空文件\n    //O_TRUNC保证打开已有文件时，清空原文内容\n    int fd = open(\"log.txt\",O_CREAT|O_WRONLY|O_TRUNC,0666);\n    \n    char msg[] = \"this is a msg\";\n    write(fd,msg,strlen(msg));\n    close(fd);\n    return 0;\n}\n```\n#### 追加写入\n追加写入只需把`O_TRUNC`改成`O_APPEND`即可\n\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_CREAT|O_WRONLY|O_APPEND,0666);//追加模式打开文化\n    \n    char msg[] = \"this is a msg\";\n    write(fd,msg,strlen(msg));\n    close(fd);\n    return 0;\n}\n```\n\n这里我们事先删除`log.txt`文件，然后运行两次编译出的程序,可以获得如下内容\n```log.txt\nthis is a msgthis is a msg\n```\n可以看到内容追加了两次\n\n### 读取操作\n相关的`flags`\n\n+ `O_RDONLY`只读模式打开文件\n+ `O_RDWR` 读写模式打开文件\n\n#### 只读模式读取内容\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_RDONLY);\n    char* buf[1024];\n    ssize_t n = read(fd,buf,sizeof(buf)-1);//这里要储存字符串，所以要留一位给\\0\n    if(n<0) perror(\"read\");//打开失败，输出错误信息\n    else buf[n] = '\\0';//添加结尾\n    printf(\"%s\\n\",buf);//打印读取到的内容\n    return 0;\n}\n```\n实现准备内容为`123456`的`log.txt`文件\n\n然后运行`./mycmd`\n\n得到输出和文件内容\n```SHELL\n456\n```\n```log.txt\nzzz456\n```\n关于`read`没读取到前面新写入的`zzz`,是因为`wtrite`和`read`操作都是从文件的`同一处继续`操作的，并不会发生回退\n## close\n`int close(int fd);`\n\n用于冲刷缓冲区，并**关闭**一个文件描述符\n\n## dup2 文件重定向\n`int dup2(int oldfd, int newfd);`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_19-55-30.png)\n\n如图所示，`dup2`能将`oldfd`对应的数组元素`覆盖`到`newfd`对应的数组元素处，完成对`newfd`对应文件的重定向\n\n图中就是完成了对`标准输出`的重定向,像`printf`之类的函数会直接输出内容到文件中,而不是显示器\n\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_RDWR|O_CREAT|O_TRUNC,0666);//打开一个新的空文件\n    dup2(fd,1);//标准输出重定向\n\n    printf(\"output1\\n\");//输出\n    printf(\"output2\\n\");//输出\n\n    return 0;\n}\n```\n运行代码后，可以看到`终端`**没有输出**\n\n而打开`log.txt`\n```log.txt\noutput1\noutput2\n```\n \n# 子进程 与 父进程的文件关系\n\n## 子进程对父进程的拷贝\n先运行一段代码测试 子进程是否**继承**父进程的打开文件\n\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_RDWR|O_CREAT|O_TRUNC|O_APPEND);//追加模式打开一个新文件\n    dup2(fd,1);//在fork前就打开文件\n\n    pid_t id = fork();//创建子进程\n    if(id == 0)\n    {\n        printf(\"child output\\n\");//子进程输出到文件\n        exit(0);\n    }\n    else \n    {\n        waitpid(id,0,0);//阻塞等待子进程\n        printf(\"parent output\\n\");//父进程输出\n    }\n\n    return 0;\n}\n```\n这段代码中，我们在`fork`**之前**完成了对标准输出的**重定向**,然后`fork`之后令父进程和子进程进行不同的标准输出\n\n运行结果为父进程和子进程的`标准输出`都**重定向**到了文件\n\n```log.txt\nchild output\nparent output\n```\n\n## 子进程和父进程的 独立性\n接下来一段代码测试 父进程 和 子进程 的打开文件是否独立\n\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_RDWR|O_CREAT|O_TRUNC|O_APPEND);//追加模式打开一个新文件\n\n    pid_t id = fork();//创建子进程\n    if(id == 0)\n    {\n        dup2(fd,1);//只有子进程重定向了标准输出\n        printf(\"child output\\n\");//子进程输出到文件\n        exit(0);\n    }\n    else \n    {\n        waitpid(id,0,0);//阻塞等待子进程\n        printf(\"parent output\\n\");//父进程输出\n    }\n\n    return 0;\n}\n```\n\n这里我们在`fork`之前都不进行重定向，`fork`后仅对子进程进行了标准输出重定向，而父进程不作任何重定向\n\n在运行后发现子进程的输出重定向不会影响父进程,二者有`独立性`\n\n```SHELL\nparent output\n```\n```log.txt\nchild output\n```\n\n# 进程替换\n先在同级文件夹准备一个待替换的程序\n\n> execute.c\n```C\n#include <stdio.h>\n\nint main()\n{\n    printf(\"exe output\\n\");\n}\n```\n然后运行`gcc -o execute execute.c`编译获得一个程序\n\n然后准备主程序\n\n> mycmd.c\n```C\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n\nint main()\n{\n    int fd = open(\"log.txt\",O_RDWR|O_CREAT|O_TRUNC|O_APPEND);//追加模式打开一个新文件\n\n    pid_t id = fork();//创建子进程\n    if(id == 0)\n    {\n        dup2(fd,1);//只有子进程重定向了标准输出\n        execvp(\"./execute\",NULL);//进程替换\n        exit(0);\n    }\n    else \n    {\n        waitpid(id,0,0);//阻塞等待子进程\n        printf(\"parent wait success\\n\");//父进程输出\n    }\n\n    return 0;\n}\n```\n这里我们使子进程**先**标准输出重定向， **再**进行进程替换，发现替换后的进程，也是标准输出重定向的状态\n\n```log.txt\nexe output\n```\n\n## 结论\n进程替换**不会**改变原进程的文件打开状态和重定向关系","slug":"basicIO","published":1,"updated":"2024-07-25T04:53:14.416Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p085000f4sp591vb490r","content":"<h1 id=\"共识原理\"><a href=\"#共识原理\" class=\"headerlink\" title=\"共识原理\"></a>共识原理</h1><ul>\n<li>文件 &#x3D; 内容 + 属性</li>\n<li>被打开的文件需要加载到内存中</li>\n<li><strong>内存中</strong>的文件需要被操作系统<strong>管理</strong></li>\n</ul>\n<h1 id=\"用户级文件接口\"><a href=\"#用户级文件接口\" class=\"headerlink\" title=\"用户级文件接口\"></a>用户级文件接口</h1><p><a href=\"https://www.supdriver.top/2024/05/14/cpp-file-op/\">详见C++文件操作</a></p>\n<p><a href=\"https://www.supdriver.top/2024/07/15/cfileop/\">详见C语言文件操作</a></p>\n<h1 id=\"Linux系统调用接口\"><a href=\"#Linux系统调用接口\" class=\"headerlink\" title=\"Linux系统调用接口\"></a>Linux系统调用接口</h1><h2 id=\"fd-文件描述符-与访问文件的本质\"><a href=\"#fd-文件描述符-与访问文件的本质\" class=\"headerlink\" title=\"fd 文件描述符 与访问文件的本质\"></a>fd 文件描述符 与访问文件的本质</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_17-10-26.png\"></p>\n<p><code>fd</code>(<em>file descriptor</em>),即文件描述符,下文的系统调用接口经常以<code>fd</code>命名变量，<code>fd</code>是整形变量，作为数组下标，用于管理<strong>打开的文件</strong></p>\n<p>可以看到,一个进程通过<code>struct files _struct</code>里的指针数组，管理多个同时打开的文件</p>\n<p>且每个进程启动时，会默认打开三个文件,且默认<code>fd</code>固定</p>\n<ol>\n<li>stdout</li>\n</ol>\n<h2 id=\"read\"><a href=\"#read\" class=\"headerlink\" title=\"read\"></a>read</h2><p><strong>所需头文件</strong><br><code>#include &lt;unistd.h&gt;</code><br><strong>声明</strong><br><code>ssize_t read(int fd, void *buf, size_t count);</code></p>\n<p><strong>参数</strong></p>\n<ul>\n<li><code>fd</code>即为目标文件的文件描述符</li>\n<li><code>buf</code>为要从文件读取字节到的内存地址</li>\n<li><code>count</code>为最大读取字节数</li>\n</ul>\n<p><strong>返回值</strong></p>\n<ul>\n<li>若成功，返回读取文件的字节数,类型为<code>ssize_t</code>,是层层封装的<code>long int</code></li>\n<li>若失败，返回<code>-1</code>,并设置<code>errno</code>的值</li>\n</ul>\n<h2 id=\"write\"><a href=\"#write\" class=\"headerlink\" title=\"write\"></a>write</h2><p><strong>所需头文件</strong><br><code>#include &lt;unistd.h&gt;</code><br><strong>声明</strong><br><code>ssize_t write(int fd, const void *buf, size_t count);</code></p>\n<p><strong>参数</strong></p>\n<ul>\n<li><code>fd</code> 为目标文件的文件描述符</li>\n<li><code>buf</code>为要写入文件的<code>源内存地址</code>,输入字节数量取决于<code>count</code>形参</li>\n<li><code>count</code>为要输入的字节数量,若要输入为字符串，且要输入字符串的全部内容，建议使用<code>strlen(buf)</code>，防止输入<code>\\0</code>,因为对于<strong>文件</strong>来说，<code>\\0</code>是<strong>非法字符</strong></li>\n</ul>\n<p><strong>返回值</strong></p>\n<ul>\n<li>若成功，返回写入文件的字节数,类型为<code>ssize_t</code>,是层层封装的<code>long int</code></li>\n<li>若失败，返回<code>-1</code>,并设置<code>errno</code>的值</li>\n</ul>\n<p><strong>特别的</strong><br><code>read</code>函数从文件中读取的是<code>字节</code>内容，不把读取的内容看作字符串，因此，<strong>不会自动</strong>添加<code>\\0</code>在写入<code>buf</code>内容的结尾</p>\n<p><em>用法见后文对<code>open</code>的介绍</em></p>\n<h2 id=\"open\"><a href=\"#open\" class=\"headerlink\" title=\"open\"></a>open</h2><p><strong>所需头文件</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>声明</strong><br><code>int open(const char *pathname, int flags);</code><br><code>int open(const char *pathname, int flags，mode_t mode);</code></p>\n<p><strong>参数</strong>:</p>\n<ul>\n<li><code>pathname</code>为文件路径，若只有文件名，则默认在当前工作路径搜索</li>\n<li><code>flag</code>则是一个<code>位图</code>,而<strong>不应</strong>看作整型参数，传参时可用<code>|</code>位运算传递多个参数到位图中,例如<code>O_CREAT | O_WRONLY</code></li>\n<li><code>mode</code>则是在<strong>创建</strong>文件时,传入权限信息,这里使用<code>八进制表示法</code>，例如传入<code>0666</code><br><strong>返回值</strong>:</li>\n<li>若成功，返回打开文件的<code>fd</code>值</li>\n<li>若失败，则返回<code>-1</code></li>\n</ul>\n<h3 id=\"写入操作\"><a href=\"#写入操作\" class=\"headerlink\" title=\"写入操作\"></a>写入操作</h3><p>相关的<code>flags</code></p>\n<ul>\n<li><code>O_WRONLY</code> 仅写入</li>\n<li><code>O_CREAT</code> 如果文件不存在，就创建，<strong>注</strong>新文件的权限由<code>open</code>函数传入的<code>mode</code>参数决定</li>\n<li><code>O_TRUNC</code> 如果文件已存在且是<code>常规文件</code>,并且打开的模式组合<strong>支持写入操作</strong>(<code>O_RDWR</code>或<code>O_WRONLY</code>),该文件内容将会被清除。但如果该文件是<code>FIFO</code>(命名管道)文件或<code>终端设备文件</code>，则<code>O_TRUNC</code>将会被<strong>忽略</strong></li>\n<li><code>O_EXCL</code> 保证此次<code>open</code>操作打开新文件。<strong>必须</strong>和<code>O_CREAT</code>联合使用，否则打开<strong>失败</strong>。若<code>pathname</code>存在，即该路径的文件存在时，也会打开<strong>失败</strong></li>\n</ul>\n<h4 id=\"打开已有文件并写入\"><a href=\"#打开已有文件并写入\" class=\"headerlink\" title=\"打开已有文件并写入\"></a>打开已有文件并写入</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//前提是log.txt已存在</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_WRONLY,<span class=\"number\">0666</span>);<span class=\"comment\">//只写模式打开文件</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;this is a msg&quot;</span>;<span class=\"comment\">//准备字符串</span></span><br><span class=\"line\">    write(fd,msg,<span class=\"built_in\">strlen</span>(msg));<span class=\"comment\">//写入</span></span><br><span class=\"line\">    close(fd);<span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当原本<code>log.txt</code>为空文件时</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this is a msg</span><br></pre></td></tr></table></figure>\n<p>当原<code>log.txt</code>不为空且内容长度大于程序输入的<code>msg</code>时，发生<code>部分覆写</code></p>\n<p>例如原内容为<code>0000111100001111</code>时，执行后为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this is a msg111</span><br></pre></td></tr></table></figure>\n<p>可以看到有一部分没有被覆盖</p>\n<h4 id=\"打开空文件-或-创建空文件\"><a href=\"#打开空文件-或-创建空文件\" class=\"headerlink\" title=\"打开空文件 或 创建空文件\"></a>打开空文件 或 创建空文件</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//唯一的区别是这里的参数</span></span><br><span class=\"line\">    <span class=\"comment\">//O_CREAT可以创建空文件</span></span><br><span class=\"line\">    <span class=\"comment\">//O_TRUNC保证打开已有文件时，清空原文内容</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_CREAT|O_WRONLY|O_TRUNC,<span class=\"number\">0666</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">    write(fd,msg,<span class=\"built_in\">strlen</span>(msg));</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"追加写入\"><a href=\"#追加写入\" class=\"headerlink\" title=\"追加写入\"></a>追加写入</h4><p>追加写入只需把<code>O_TRUNC</code>改成<code>O_APPEND</code>即可</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class=\"number\">0666</span>);<span class=\"comment\">//追加模式打开文化</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">    write(fd,msg,<span class=\"built_in\">strlen</span>(msg));</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们事先删除<code>log.txt</code>文件，然后运行两次编译出的程序,可以获得如下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this is a msgthis is a msg</span><br></pre></td></tr></table></figure>\n<p>可以看到内容追加了两次</p>\n<h3 id=\"读取操作\"><a href=\"#读取操作\" class=\"headerlink\" title=\"读取操作\"></a>读取操作</h3><p>相关的<code>flags</code></p>\n<ul>\n<li><code>O_RDONLY</code>只读模式打开文件</li>\n<li><code>O_RDWR</code> 读写模式打开文件</li>\n</ul>\n<h4 id=\"只读模式读取内容\"><a href=\"#只读模式读取内容\" class=\"headerlink\" title=\"只读模式读取内容\"></a>只读模式读取内容</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_RDONLY);</span><br><span class=\"line\">    <span class=\"type\">char</span>* buf[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = read(fd,buf,<span class=\"keyword\">sizeof</span>(buf)<span class=\"number\">-1</span>);<span class=\"comment\">//这里要储存字符串，所以要留一位给\\0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;<span class=\"number\">0</span>) perror(<span class=\"string\">&quot;read&quot;</span>);<span class=\"comment\">//打开失败，输出错误信息</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> buf[n] = <span class=\"string\">&#x27;\\0&#x27;</span>;<span class=\"comment\">//添加结尾</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,buf);<span class=\"comment\">//打印读取到的内容</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现准备内容为<code>123456</code>的<code>log.txt</code>文件</p>\n<p>然后运行<code>./mycmd</code></p>\n<p>得到输出和文件内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">456</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zzz456</span><br></pre></td></tr></table></figure>\n<p>关于<code>read</code>没读取到前面新写入的<code>zzz</code>,是因为<code>wtrite</code>和<code>read</code>操作都是从文件的<code>同一处继续</code>操作的，并不会发生回退</p>\n<h2 id=\"close\"><a href=\"#close\" class=\"headerlink\" title=\"close\"></a>close</h2><p><code>int close(int fd);</code></p>\n<p>用于冲刷缓冲区，并<strong>关闭</strong>一个文件描述符</p>\n<h2 id=\"dup2-文件重定向\"><a href=\"#dup2-文件重定向\" class=\"headerlink\" title=\"dup2 文件重定向\"></a>dup2 文件重定向</h2><p><code>int dup2(int oldfd, int newfd);</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_19-55-30.png\"></p>\n<p>如图所示，<code>dup2</code>能将<code>oldfd</code>对应的数组元素<code>覆盖</code>到<code>newfd</code>对应的数组元素处，完成对<code>newfd</code>对应文件的重定向</p>\n<p>图中就是完成了对<code>标准输出</code>的重定向,像<code>printf</code>之类的函数会直接输出内容到文件中,而不是显示器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class=\"number\">0666</span>);<span class=\"comment\">//打开一个新的空文件</span></span><br><span class=\"line\">    dup2(fd,<span class=\"number\">1</span>);<span class=\"comment\">//标准输出重定向</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;output1\\n&quot;</span>);<span class=\"comment\">//输出</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;output2\\n&quot;</span>);<span class=\"comment\">//输出</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行代码后，可以看到<code>终端</code><strong>没有输出</strong></p>\n<p>而打开<code>log.txt</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output1</span><br><span class=\"line\">output2</span><br></pre></td></tr></table></figure>\n<h1 id=\"子进程-与-父进程的文件关系\"><a href=\"#子进程-与-父进程的文件关系\" class=\"headerlink\" title=\"子进程 与 父进程的文件关系\"></a>子进程 与 父进程的文件关系</h1><h2 id=\"子进程对父进程的拷贝\"><a href=\"#子进程对父进程的拷贝\" class=\"headerlink\" title=\"子进程对父进程的拷贝\"></a>子进程对父进程的拷贝</h2><p>先运行一段代码测试 子进程是否<strong>继承</strong>父进程的打开文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class=\"comment\">//追加模式打开一个新文件</span></span><br><span class=\"line\">    dup2(fd,<span class=\"number\">1</span>);<span class=\"comment\">//在fork前就打开文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();<span class=\"comment\">//创建子进程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child output\\n&quot;</span>);<span class=\"comment\">//子进程输出到文件</span></span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        waitpid(id,<span class=\"number\">0</span>,<span class=\"number\">0</span>);<span class=\"comment\">//阻塞等待子进程</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;parent output\\n&quot;</span>);<span class=\"comment\">//父进程输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码中，我们在<code>fork</code><strong>之前</strong>完成了对标准输出的<strong>重定向</strong>,然后<code>fork</code>之后令父进程和子进程进行不同的标准输出</p>\n<p>运行结果为父进程和子进程的<code>标准输出</code>都<strong>重定向</strong>到了文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child output</span><br><span class=\"line\">parent output</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"子进程和父进程的-独立性\"><a href=\"#子进程和父进程的-独立性\" class=\"headerlink\" title=\"子进程和父进程的 独立性\"></a>子进程和父进程的 独立性</h2><p>接下来一段代码测试 父进程 和 子进程 的打开文件是否独立</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class=\"comment\">//追加模式打开一个新文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();<span class=\"comment\">//创建子进程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dup2(fd,<span class=\"number\">1</span>);<span class=\"comment\">//只有子进程重定向了标准输出</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child output\\n&quot;</span>);<span class=\"comment\">//子进程输出到文件</span></span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        waitpid(id,<span class=\"number\">0</span>,<span class=\"number\">0</span>);<span class=\"comment\">//阻塞等待子进程</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;parent output\\n&quot;</span>);<span class=\"comment\">//父进程输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们在<code>fork</code>之前都不进行重定向，<code>fork</code>后仅对子进程进行了标准输出重定向，而父进程不作任何重定向</p>\n<p>在运行后发现子进程的输出重定向不会影响父进程,二者有<code>独立性</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parent output</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child output</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"进程替换\"><a href=\"#进程替换\" class=\"headerlink\" title=\"进程替换\"></a>进程替换</h1><p>先在同级文件夹准备一个待替换的程序</p>\n<blockquote>\n<p>execute.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;exe output\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后运行<code>gcc -o execute execute.c</code>编译获得一个程序</p>\n<p>然后准备主程序</p>\n<blockquote>\n<p>mycmd.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class=\"comment\">//追加模式打开一个新文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();<span class=\"comment\">//创建子进程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dup2(fd,<span class=\"number\">1</span>);<span class=\"comment\">//只有子进程重定向了标准输出</span></span><br><span class=\"line\">        execvp(<span class=\"string\">&quot;./execute&quot;</span>,<span class=\"literal\">NULL</span>);<span class=\"comment\">//进程替换</span></span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        waitpid(id,<span class=\"number\">0</span>,<span class=\"number\">0</span>);<span class=\"comment\">//阻塞等待子进程</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;parent wait success\\n&quot;</span>);<span class=\"comment\">//父进程输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们使子进程<strong>先</strong>标准输出重定向， <strong>再</strong>进行进程替换，发现替换后的进程，也是标准输出重定向的状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exe output</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>进程替换<strong>不会</strong>改变原进程的文件打开状态和重定向关系</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"共识原理\"><a href=\"#共识原理\" class=\"headerlink\" title=\"共识原理\"></a>共识原理</h1><ul>\n<li>文件 &#x3D; 内容 + 属性</li>\n<li>被打开的文件需要加载到内存中</li>\n<li><strong>内存中</strong>的文件需要被操作系统<strong>管理</strong></li>\n</ul>\n<h1 id=\"用户级文件接口\"><a href=\"#用户级文件接口\" class=\"headerlink\" title=\"用户级文件接口\"></a>用户级文件接口</h1><p><a href=\"https://www.supdriver.top/2024/05/14/cpp-file-op/\">详见C++文件操作</a></p>\n<p><a href=\"https://www.supdriver.top/2024/07/15/cfileop/\">详见C语言文件操作</a></p>\n<h1 id=\"Linux系统调用接口\"><a href=\"#Linux系统调用接口\" class=\"headerlink\" title=\"Linux系统调用接口\"></a>Linux系统调用接口</h1><h2 id=\"fd-文件描述符-与访问文件的本质\"><a href=\"#fd-文件描述符-与访问文件的本质\" class=\"headerlink\" title=\"fd 文件描述符 与访问文件的本质\"></a>fd 文件描述符 与访问文件的本质</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_17-10-26.png\"></p>\n<p><code>fd</code>(<em>file descriptor</em>),即文件描述符,下文的系统调用接口经常以<code>fd</code>命名变量，<code>fd</code>是整形变量，作为数组下标，用于管理<strong>打开的文件</strong></p>\n<p>可以看到,一个进程通过<code>struct files _struct</code>里的指针数组，管理多个同时打开的文件</p>\n<p>且每个进程启动时，会默认打开三个文件,且默认<code>fd</code>固定</p>\n<ol>\n<li>stdout</li>\n</ol>\n<h2 id=\"read\"><a href=\"#read\" class=\"headerlink\" title=\"read\"></a>read</h2><p><strong>所需头文件</strong><br><code>#include &lt;unistd.h&gt;</code><br><strong>声明</strong><br><code>ssize_t read(int fd, void *buf, size_t count);</code></p>\n<p><strong>参数</strong></p>\n<ul>\n<li><code>fd</code>即为目标文件的文件描述符</li>\n<li><code>buf</code>为要从文件读取字节到的内存地址</li>\n<li><code>count</code>为最大读取字节数</li>\n</ul>\n<p><strong>返回值</strong></p>\n<ul>\n<li>若成功，返回读取文件的字节数,类型为<code>ssize_t</code>,是层层封装的<code>long int</code></li>\n<li>若失败，返回<code>-1</code>,并设置<code>errno</code>的值</li>\n</ul>\n<h2 id=\"write\"><a href=\"#write\" class=\"headerlink\" title=\"write\"></a>write</h2><p><strong>所需头文件</strong><br><code>#include &lt;unistd.h&gt;</code><br><strong>声明</strong><br><code>ssize_t write(int fd, const void *buf, size_t count);</code></p>\n<p><strong>参数</strong></p>\n<ul>\n<li><code>fd</code> 为目标文件的文件描述符</li>\n<li><code>buf</code>为要写入文件的<code>源内存地址</code>,输入字节数量取决于<code>count</code>形参</li>\n<li><code>count</code>为要输入的字节数量,若要输入为字符串，且要输入字符串的全部内容，建议使用<code>strlen(buf)</code>，防止输入<code>\\0</code>,因为对于<strong>文件</strong>来说，<code>\\0</code>是<strong>非法字符</strong></li>\n</ul>\n<p><strong>返回值</strong></p>\n<ul>\n<li>若成功，返回写入文件的字节数,类型为<code>ssize_t</code>,是层层封装的<code>long int</code></li>\n<li>若失败，返回<code>-1</code>,并设置<code>errno</code>的值</li>\n</ul>\n<p><strong>特别的</strong><br><code>read</code>函数从文件中读取的是<code>字节</code>内容，不把读取的内容看作字符串，因此，<strong>不会自动</strong>添加<code>\\0</code>在写入<code>buf</code>内容的结尾</p>\n<p><em>用法见后文对<code>open</code>的介绍</em></p>\n<h2 id=\"open\"><a href=\"#open\" class=\"headerlink\" title=\"open\"></a>open</h2><p><strong>所需头文件</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>声明</strong><br><code>int open(const char *pathname, int flags);</code><br><code>int open(const char *pathname, int flags，mode_t mode);</code></p>\n<p><strong>参数</strong>:</p>\n<ul>\n<li><code>pathname</code>为文件路径，若只有文件名，则默认在当前工作路径搜索</li>\n<li><code>flag</code>则是一个<code>位图</code>,而<strong>不应</strong>看作整型参数，传参时可用<code>|</code>位运算传递多个参数到位图中,例如<code>O_CREAT | O_WRONLY</code></li>\n<li><code>mode</code>则是在<strong>创建</strong>文件时,传入权限信息,这里使用<code>八进制表示法</code>，例如传入<code>0666</code><br><strong>返回值</strong>:</li>\n<li>若成功，返回打开文件的<code>fd</code>值</li>\n<li>若失败，则返回<code>-1</code></li>\n</ul>\n<h3 id=\"写入操作\"><a href=\"#写入操作\" class=\"headerlink\" title=\"写入操作\"></a>写入操作</h3><p>相关的<code>flags</code></p>\n<ul>\n<li><code>O_WRONLY</code> 仅写入</li>\n<li><code>O_CREAT</code> 如果文件不存在，就创建，<strong>注</strong>新文件的权限由<code>open</code>函数传入的<code>mode</code>参数决定</li>\n<li><code>O_TRUNC</code> 如果文件已存在且是<code>常规文件</code>,并且打开的模式组合<strong>支持写入操作</strong>(<code>O_RDWR</code>或<code>O_WRONLY</code>),该文件内容将会被清除。但如果该文件是<code>FIFO</code>(命名管道)文件或<code>终端设备文件</code>，则<code>O_TRUNC</code>将会被<strong>忽略</strong></li>\n<li><code>O_EXCL</code> 保证此次<code>open</code>操作打开新文件。<strong>必须</strong>和<code>O_CREAT</code>联合使用，否则打开<strong>失败</strong>。若<code>pathname</code>存在，即该路径的文件存在时，也会打开<strong>失败</strong></li>\n</ul>\n<h4 id=\"打开已有文件并写入\"><a href=\"#打开已有文件并写入\" class=\"headerlink\" title=\"打开已有文件并写入\"></a>打开已有文件并写入</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//前提是log.txt已存在</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_WRONLY,<span class=\"number\">0666</span>);<span class=\"comment\">//只写模式打开文件</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;this is a msg&quot;</span>;<span class=\"comment\">//准备字符串</span></span><br><span class=\"line\">    write(fd,msg,<span class=\"built_in\">strlen</span>(msg));<span class=\"comment\">//写入</span></span><br><span class=\"line\">    close(fd);<span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当原本<code>log.txt</code>为空文件时</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this is a msg</span><br></pre></td></tr></table></figure>\n<p>当原<code>log.txt</code>不为空且内容长度大于程序输入的<code>msg</code>时，发生<code>部分覆写</code></p>\n<p>例如原内容为<code>0000111100001111</code>时，执行后为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this is a msg111</span><br></pre></td></tr></table></figure>\n<p>可以看到有一部分没有被覆盖</p>\n<h4 id=\"打开空文件-或-创建空文件\"><a href=\"#打开空文件-或-创建空文件\" class=\"headerlink\" title=\"打开空文件 或 创建空文件\"></a>打开空文件 或 创建空文件</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//唯一的区别是这里的参数</span></span><br><span class=\"line\">    <span class=\"comment\">//O_CREAT可以创建空文件</span></span><br><span class=\"line\">    <span class=\"comment\">//O_TRUNC保证打开已有文件时，清空原文内容</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_CREAT|O_WRONLY|O_TRUNC,<span class=\"number\">0666</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">    write(fd,msg,<span class=\"built_in\">strlen</span>(msg));</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"追加写入\"><a href=\"#追加写入\" class=\"headerlink\" title=\"追加写入\"></a>追加写入</h4><p>追加写入只需把<code>O_TRUNC</code>改成<code>O_APPEND</code>即可</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class=\"number\">0666</span>);<span class=\"comment\">//追加模式打开文化</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">    write(fd,msg,<span class=\"built_in\">strlen</span>(msg));</span><br><span class=\"line\">    close(fd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们事先删除<code>log.txt</code>文件，然后运行两次编译出的程序,可以获得如下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this is a msgthis is a msg</span><br></pre></td></tr></table></figure>\n<p>可以看到内容追加了两次</p>\n<h3 id=\"读取操作\"><a href=\"#读取操作\" class=\"headerlink\" title=\"读取操作\"></a>读取操作</h3><p>相关的<code>flags</code></p>\n<ul>\n<li><code>O_RDONLY</code>只读模式打开文件</li>\n<li><code>O_RDWR</code> 读写模式打开文件</li>\n</ul>\n<h4 id=\"只读模式读取内容\"><a href=\"#只读模式读取内容\" class=\"headerlink\" title=\"只读模式读取内容\"></a>只读模式读取内容</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_RDONLY);</span><br><span class=\"line\">    <span class=\"type\">char</span>* buf[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> n = read(fd,buf,<span class=\"keyword\">sizeof</span>(buf)<span class=\"number\">-1</span>);<span class=\"comment\">//这里要储存字符串，所以要留一位给\\0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;<span class=\"number\">0</span>) perror(<span class=\"string\">&quot;read&quot;</span>);<span class=\"comment\">//打开失败，输出错误信息</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> buf[n] = <span class=\"string\">&#x27;\\0&#x27;</span>;<span class=\"comment\">//添加结尾</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,buf);<span class=\"comment\">//打印读取到的内容</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现准备内容为<code>123456</code>的<code>log.txt</code>文件</p>\n<p>然后运行<code>./mycmd</code></p>\n<p>得到输出和文件内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">456</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zzz456</span><br></pre></td></tr></table></figure>\n<p>关于<code>read</code>没读取到前面新写入的<code>zzz</code>,是因为<code>wtrite</code>和<code>read</code>操作都是从文件的<code>同一处继续</code>操作的，并不会发生回退</p>\n<h2 id=\"close\"><a href=\"#close\" class=\"headerlink\" title=\"close\"></a>close</h2><p><code>int close(int fd);</code></p>\n<p>用于冲刷缓冲区，并<strong>关闭</strong>一个文件描述符</p>\n<h2 id=\"dup2-文件重定向\"><a href=\"#dup2-文件重定向\" class=\"headerlink\" title=\"dup2 文件重定向\"></a>dup2 文件重定向</h2><p><code>int dup2(int oldfd, int newfd);</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-24_19-55-30.png\"></p>\n<p>如图所示，<code>dup2</code>能将<code>oldfd</code>对应的数组元素<code>覆盖</code>到<code>newfd</code>对应的数组元素处，完成对<code>newfd</code>对应文件的重定向</p>\n<p>图中就是完成了对<code>标准输出</code>的重定向,像<code>printf</code>之类的函数会直接输出内容到文件中,而不是显示器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class=\"number\">0666</span>);<span class=\"comment\">//打开一个新的空文件</span></span><br><span class=\"line\">    dup2(fd,<span class=\"number\">1</span>);<span class=\"comment\">//标准输出重定向</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;output1\\n&quot;</span>);<span class=\"comment\">//输出</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;output2\\n&quot;</span>);<span class=\"comment\">//输出</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行代码后，可以看到<code>终端</code><strong>没有输出</strong></p>\n<p>而打开<code>log.txt</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output1</span><br><span class=\"line\">output2</span><br></pre></td></tr></table></figure>\n<h1 id=\"子进程-与-父进程的文件关系\"><a href=\"#子进程-与-父进程的文件关系\" class=\"headerlink\" title=\"子进程 与 父进程的文件关系\"></a>子进程 与 父进程的文件关系</h1><h2 id=\"子进程对父进程的拷贝\"><a href=\"#子进程对父进程的拷贝\" class=\"headerlink\" title=\"子进程对父进程的拷贝\"></a>子进程对父进程的拷贝</h2><p>先运行一段代码测试 子进程是否<strong>继承</strong>父进程的打开文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class=\"comment\">//追加模式打开一个新文件</span></span><br><span class=\"line\">    dup2(fd,<span class=\"number\">1</span>);<span class=\"comment\">//在fork前就打开文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();<span class=\"comment\">//创建子进程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child output\\n&quot;</span>);<span class=\"comment\">//子进程输出到文件</span></span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        waitpid(id,<span class=\"number\">0</span>,<span class=\"number\">0</span>);<span class=\"comment\">//阻塞等待子进程</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;parent output\\n&quot;</span>);<span class=\"comment\">//父进程输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码中，我们在<code>fork</code><strong>之前</strong>完成了对标准输出的<strong>重定向</strong>,然后<code>fork</code>之后令父进程和子进程进行不同的标准输出</p>\n<p>运行结果为父进程和子进程的<code>标准输出</code>都<strong>重定向</strong>到了文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child output</span><br><span class=\"line\">parent output</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"子进程和父进程的-独立性\"><a href=\"#子进程和父进程的-独立性\" class=\"headerlink\" title=\"子进程和父进程的 独立性\"></a>子进程和父进程的 独立性</h2><p>接下来一段代码测试 父进程 和 子进程 的打开文件是否独立</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class=\"comment\">//追加模式打开一个新文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();<span class=\"comment\">//创建子进程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dup2(fd,<span class=\"number\">1</span>);<span class=\"comment\">//只有子进程重定向了标准输出</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child output\\n&quot;</span>);<span class=\"comment\">//子进程输出到文件</span></span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        waitpid(id,<span class=\"number\">0</span>,<span class=\"number\">0</span>);<span class=\"comment\">//阻塞等待子进程</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;parent output\\n&quot;</span>);<span class=\"comment\">//父进程输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们在<code>fork</code>之前都不进行重定向，<code>fork</code>后仅对子进程进行了标准输出重定向，而父进程不作任何重定向</p>\n<p>在运行后发现子进程的输出重定向不会影响父进程,二者有<code>独立性</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parent output</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child output</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"进程替换\"><a href=\"#进程替换\" class=\"headerlink\" title=\"进程替换\"></a>进程替换</h1><p>先在同级文件夹准备一个待替换的程序</p>\n<blockquote>\n<p>execute.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;exe output\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后运行<code>gcc -o execute execute.c</code>编译获得一个程序</p>\n<p>然后准备主程序</p>\n<blockquote>\n<p>mycmd.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;log.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC|O_APPEND);<span class=\"comment\">//追加模式打开一个新文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();<span class=\"comment\">//创建子进程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dup2(fd,<span class=\"number\">1</span>);<span class=\"comment\">//只有子进程重定向了标准输出</span></span><br><span class=\"line\">        execvp(<span class=\"string\">&quot;./execute&quot;</span>,<span class=\"literal\">NULL</span>);<span class=\"comment\">//进程替换</span></span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        waitpid(id,<span class=\"number\">0</span>,<span class=\"number\">0</span>);<span class=\"comment\">//阻塞等待子进程</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;parent wait success\\n&quot;</span>);<span class=\"comment\">//父进程输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们使子进程<strong>先</strong>标准输出重定向， <strong>再</strong>进行进程替换，发现替换后的进程，也是标准输出重定向的状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exe output</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>进程替换<strong>不会</strong>改变原进程的文件打开状态和重定向关系</p>\n"},{"title":"文件缓冲区","date":"2024-07-26T02:16:19.000Z","_content":"前置博客 [基础IO](https://www.supdriver.top/2024/07/10/basicIO/)\n\n# 为什么有缓冲\n因为`磁盘的读写`与`内存的读写`操作速度相比，磁盘的读写是相差数量级的慢，所以为了提高内存**多次**，**频繁**读写磁盘文件的效率，`缓冲区`被投入使用。尤其是内存内容**写入**磁盘时，常常先写入`内存级缓冲区`，再在特定规则下一次性将`缓冲区`的内容写入磁盘\n\n**本文以`C语言`提供的用户级缓冲区为例介绍缓冲区\n\n# 缓冲区的刷新规则\n首先当一个进程**正常退出**时，会先刷新缓冲区再关闭文件,此时必定有一次刷新\n\n而当进程**运行时**缓冲区的刷新策略主要有以下三种\n\n+ `无缓冲` 内容直接写入文件\n+ `行缓冲` 输入一般内容不刷新，遇到`\\n`时刷新一次缓冲区\n+ `全缓冲` 缓冲区有容量限制，**满了**之后就刷新\n\n# 认识一下C语言的缓冲区\n*这里的系统环境是Linux*\n\n\n## 刷新规则\n运行如下代码\n```C\n#include <stdio.h>\n#include <unistd.h>\n\nint main()\n{\n    FILE* pfile = fopen(\"file.txt\",\"w\");//打开空文件\n\n    fprintf(stdout,\"stdout\");//向标准输出输出\n    fprintf(stderr,\"strerr\");//向标准错误输出输出\n    fprintf(pfile,\"file\");//向文件输出\n    _exit(0);//不刷新缓冲区，直接退出\n    return ;\n}\n```\n\n终端和文件的内容为:\n```SHELL\nstderr\n```\n```file.txt\n\n```\n可以看到只有`标准错误输出`有实际的输出,而`标准输出`和`文件输出`都没有输出\n\n目前可以得出：\n+ `标准错误输出`是`无缓冲`的刷新规则\n\n因此我们再运行如下代码，再输出内容后面加上`\\n`换行\n\n```C\n#include <stdio.h>\n#include <unistd.h>\n\nint main()\n{\n    FILE* pfile = fopen(\"file.txt\",\"w\");//打开空文件\n\n    fprintf(stdout,\"stdout\\n\");//向标准输出输出\n    fprintf(pfile,\"file\\n\");//向文件输出\n    _exit(0);\n    return ;\n}\n```\n终端输出内容为\n```SHELL\nstdout\n\n```\n**而文件依然为空**\n\n由此可得:\n+ `标准输出`遵循`行缓冲`的刷新规则\n+ `文件输出`遵循`全缓冲`的刷新规则\n\n## 缓冲区在fork中的行为\n```C\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nint main()\n{\n    printf(\"hello1 \");//父进程向标准输出打印一句话\n    fprintf(stdout,\"hello2 \");//父进程向标准输出打印一句话\n\n    fork();\n    return 0;\n}\n```\n上段代码的输出内容为\n```SHELL\nhello1 hello2 hello1 hello2 \n```\n可见`fork`前的缓冲区内容被打印了两次（父子进程各一次），所以`fork`也会复制`缓冲区`的内容\n\n实际上`缓冲区`属于进程的一部分，且`fork`时遵循`写时拷贝`\n\n# 模拟封装Linux下C语言的文件接口（包括缓冲区）\n\n## 主要目标\n采用`Mystdio.h`声明，`Mystdio.c`实现的方式，封装`read`,`write`,`close`系统调用接口。并提供用户级缓冲区和缓冲区的刷新等功能\n\n## 声明结构体和接口\n我们先把主要的接口和主要的内容做出来看看封装效果\n```C\n#ifndef __MYSTDIO_H__ //利用预编译防止头文件被重复编译\n#define __MYSTDIO_H__\n\n#include <string.h>\n\n//声明文件结构体\ntypedef struct IO_FILE{\n    int fileno;\n}_FILE;\n\n_FILE * _fopen(const char *filename,const char *flag);\nint _fwrite(_FILE* fp,const char*s, int len);\nvoid _fclose(_FILE* fp);\n\n#endif \n```\n\n## 实现无缓冲区的接口\n实现的部分由`Mystdio.c`完成\n### 头文件\n这里的头文件要能够提供使用系统调用接口,以及调用堆区的接口,所以 头文件如下:\n\n```C\n#include \"Mystdio.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <unistd.h>\n```\n\n### _fopen函数\n我们先模拟实现`fopen`函数的主要功能，主要实现`\"w\"``\"a\"``\"r\"`的打开模式\n\n```C\n#define FILE_MODE 0666 //设置默认的文件权限\n\n_FILE * _fopen(const char *filename,const char *flag)\n{\n    int f = 0;//准备空位图\n    int fd = -1;\n    if(strcmp(flag,\"w\") == 0)\n    {\n        f = (O_CREAT|O_WRONLY|O_TRUNC);\n        fd = open(filename,f,FILE_MODE);//打开文件\n    }\n    else if(strcmp(flag,\"a\") == 0)\n    {\n        f = (O_CREAT|O_WRONLY|O_APPEND);\n        fd = open(filename,f,FILE_MODE);//打开文件\n    }\n    else if(strcmp(flag,\"w\") == 0)\n    {\n        f = O_RDONLY;\n        fd = open(filename,f);//打开文件\n    }\n    else return NULL;//非法的打开模式\n\n    if(fd == -1) return NULL;//打开失败\n    \n    _FILE *fp = (_FILE*)malloc(sizeof(_FILE));//创建_FILE结构体\n    fp->fileno = fp;//设置_FILE结构体\n    return fp;\n}\n```\n\n### _fwrite函数 ————无缓冲区\n然后是先简单地写一个没有缓冲区的`_fwrite`\n\n带缓冲区版本的稍后添加\n```C\nint _fwrite(_FILE *fp,const char* s,int len)\n{\n    return wrtie(fp->fileno,s,len);//无缓冲区的写入版本\n}\n```\n\n### _fclose函数 ————不刷新缓冲区\n这里也是先写个没缓冲区的\n```C\nvoid _fclose(_FILE* fp)\n{\n    if(fp == NULL) return;//防止空指针\n    close(fp->fileno);//关闭文件\n    free(fp);//释放资源\n}\n```\n\n## 为接口适配缓冲区\n\n### 为`_FILE`结构体添加输入输出缓冲区\n`缓冲区`和`刷新规则标志`声明在结构体中，使每个打开的文件都有独立的用户级缓冲区和刷新规则\n```C\n#define SIZE 1024 //定义缓冲区大小\n#define FLUSH_NONE 0 //无缓冲\n#define FLUSH_LINE 1 //行缓冲\n#define FLUSH_ALL 2 //全缓冲\n\ntypedef struct IO_FILE{\n    int fileno;//文件描述符\n    int flag; //刷新规则标志\n    char inbuffer[SIZE];//输入缓冲区\n    int in_pos;//输入缓冲区指针\n    char outbuffer[SIZE];//输出缓冲区\n    int out_pos;//输出缓冲区指针\n}_FILE;\n```\n\n### fopen添加语句\n`fopen`仅需添加几句用于初始化的代码\n```C\n    //_FILE *fp = (_FILE*)malloc(sizeof(_FILE)); //申该语句之前都不变\n    fp->fileno = fd;//储存文件描述符\n    fp->flag = FLUSH_LINE;//设置为行刷新\n    fp->in_pos = 0;//指针置0\n    fp->out_pos = 0;//指针置0\n    //return fp;  //这句也不变\n```\n\n### fwrite重写\n`fwrite`要根据不同的刷新方式进行写入\n\n```C\nint _fwrite(_FILE *fp,const char* s,int len)\n{\n    memcpy(&(fp->outbuffer[fp->out_pos]),s,len);//将内容拷贝至缓冲区指定位置\n    fp->out_pos +=len;//简易偏移out_pos\n    if(fp->fileno == FLUSH_NONE)\n    {\n        write(fp->fileno,s,fp->out_pos);//无缓冲区的写入版本\n    }\n    else if(fp->flag == FLUSH_LINE)\n    {\n        if(fp->outbuffer[fp->out_pos-1] == '\\n')\n        {\n            write(fp->fileno,s,fp->out_pos);//立即刷新\n            fp->out_pos = 0;\n        }\n        else{\n            return len;\n        }\n    }\n    else if(fp->flag == FLUSH_ALL)\n    {\n        if(fp->out_pos == SIZE)\n        {\n            write(fp->fileno,s,fp->out_pos);//立即刷新\n            fp->out_pos = 0;\n        }\n        else{\n            return len;\n        }\n    }\n}\n```\n\n### 添加`_fflush`和修改`_fclose`\n```C\nvoid _fflush(_FILE* fp)\n{\n    if(fp->out_pos > 0)\n    {\n        write(fp->fileno,fp->outbuffer,fp->out_pos);//立即刷新\n        fp->out_pos = 0;\n    }\n}\n\nvoid _fclose(_FILE* fp)\n{\n    if(fp == NULL) return;//防止空指针\n    _fflush(fp);//刷新缓冲区\n    close(fp->fileno);//关闭文件\n    free(fp);//释放资源\n}\n```\n\n## 小结\n至此,我们已经封装了基本的写入功能,更多的细节可自行完善\n\n[戳我去github仓库🔗](https://github.com/sis-shen/Linux_Code/tree/main/mystdio) 查看源文件\n","source":"_posts/c-file-cache.md","raw":"---\ntitle: 文件缓冲区\ndate: 2024-07-26 10:16:19\ntags:\n---\n前置博客 [基础IO](https://www.supdriver.top/2024/07/10/basicIO/)\n\n# 为什么有缓冲\n因为`磁盘的读写`与`内存的读写`操作速度相比，磁盘的读写是相差数量级的慢，所以为了提高内存**多次**，**频繁**读写磁盘文件的效率，`缓冲区`被投入使用。尤其是内存内容**写入**磁盘时，常常先写入`内存级缓冲区`，再在特定规则下一次性将`缓冲区`的内容写入磁盘\n\n**本文以`C语言`提供的用户级缓冲区为例介绍缓冲区\n\n# 缓冲区的刷新规则\n首先当一个进程**正常退出**时，会先刷新缓冲区再关闭文件,此时必定有一次刷新\n\n而当进程**运行时**缓冲区的刷新策略主要有以下三种\n\n+ `无缓冲` 内容直接写入文件\n+ `行缓冲` 输入一般内容不刷新，遇到`\\n`时刷新一次缓冲区\n+ `全缓冲` 缓冲区有容量限制，**满了**之后就刷新\n\n# 认识一下C语言的缓冲区\n*这里的系统环境是Linux*\n\n\n## 刷新规则\n运行如下代码\n```C\n#include <stdio.h>\n#include <unistd.h>\n\nint main()\n{\n    FILE* pfile = fopen(\"file.txt\",\"w\");//打开空文件\n\n    fprintf(stdout,\"stdout\");//向标准输出输出\n    fprintf(stderr,\"strerr\");//向标准错误输出输出\n    fprintf(pfile,\"file\");//向文件输出\n    _exit(0);//不刷新缓冲区，直接退出\n    return ;\n}\n```\n\n终端和文件的内容为:\n```SHELL\nstderr\n```\n```file.txt\n\n```\n可以看到只有`标准错误输出`有实际的输出,而`标准输出`和`文件输出`都没有输出\n\n目前可以得出：\n+ `标准错误输出`是`无缓冲`的刷新规则\n\n因此我们再运行如下代码，再输出内容后面加上`\\n`换行\n\n```C\n#include <stdio.h>\n#include <unistd.h>\n\nint main()\n{\n    FILE* pfile = fopen(\"file.txt\",\"w\");//打开空文件\n\n    fprintf(stdout,\"stdout\\n\");//向标准输出输出\n    fprintf(pfile,\"file\\n\");//向文件输出\n    _exit(0);\n    return ;\n}\n```\n终端输出内容为\n```SHELL\nstdout\n\n```\n**而文件依然为空**\n\n由此可得:\n+ `标准输出`遵循`行缓冲`的刷新规则\n+ `文件输出`遵循`全缓冲`的刷新规则\n\n## 缓冲区在fork中的行为\n```C\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nint main()\n{\n    printf(\"hello1 \");//父进程向标准输出打印一句话\n    fprintf(stdout,\"hello2 \");//父进程向标准输出打印一句话\n\n    fork();\n    return 0;\n}\n```\n上段代码的输出内容为\n```SHELL\nhello1 hello2 hello1 hello2 \n```\n可见`fork`前的缓冲区内容被打印了两次（父子进程各一次），所以`fork`也会复制`缓冲区`的内容\n\n实际上`缓冲区`属于进程的一部分，且`fork`时遵循`写时拷贝`\n\n# 模拟封装Linux下C语言的文件接口（包括缓冲区）\n\n## 主要目标\n采用`Mystdio.h`声明，`Mystdio.c`实现的方式，封装`read`,`write`,`close`系统调用接口。并提供用户级缓冲区和缓冲区的刷新等功能\n\n## 声明结构体和接口\n我们先把主要的接口和主要的内容做出来看看封装效果\n```C\n#ifndef __MYSTDIO_H__ //利用预编译防止头文件被重复编译\n#define __MYSTDIO_H__\n\n#include <string.h>\n\n//声明文件结构体\ntypedef struct IO_FILE{\n    int fileno;\n}_FILE;\n\n_FILE * _fopen(const char *filename,const char *flag);\nint _fwrite(_FILE* fp,const char*s, int len);\nvoid _fclose(_FILE* fp);\n\n#endif \n```\n\n## 实现无缓冲区的接口\n实现的部分由`Mystdio.c`完成\n### 头文件\n这里的头文件要能够提供使用系统调用接口,以及调用堆区的接口,所以 头文件如下:\n\n```C\n#include \"Mystdio.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <unistd.h>\n```\n\n### _fopen函数\n我们先模拟实现`fopen`函数的主要功能，主要实现`\"w\"``\"a\"``\"r\"`的打开模式\n\n```C\n#define FILE_MODE 0666 //设置默认的文件权限\n\n_FILE * _fopen(const char *filename,const char *flag)\n{\n    int f = 0;//准备空位图\n    int fd = -1;\n    if(strcmp(flag,\"w\") == 0)\n    {\n        f = (O_CREAT|O_WRONLY|O_TRUNC);\n        fd = open(filename,f,FILE_MODE);//打开文件\n    }\n    else if(strcmp(flag,\"a\") == 0)\n    {\n        f = (O_CREAT|O_WRONLY|O_APPEND);\n        fd = open(filename,f,FILE_MODE);//打开文件\n    }\n    else if(strcmp(flag,\"w\") == 0)\n    {\n        f = O_RDONLY;\n        fd = open(filename,f);//打开文件\n    }\n    else return NULL;//非法的打开模式\n\n    if(fd == -1) return NULL;//打开失败\n    \n    _FILE *fp = (_FILE*)malloc(sizeof(_FILE));//创建_FILE结构体\n    fp->fileno = fp;//设置_FILE结构体\n    return fp;\n}\n```\n\n### _fwrite函数 ————无缓冲区\n然后是先简单地写一个没有缓冲区的`_fwrite`\n\n带缓冲区版本的稍后添加\n```C\nint _fwrite(_FILE *fp,const char* s,int len)\n{\n    return wrtie(fp->fileno,s,len);//无缓冲区的写入版本\n}\n```\n\n### _fclose函数 ————不刷新缓冲区\n这里也是先写个没缓冲区的\n```C\nvoid _fclose(_FILE* fp)\n{\n    if(fp == NULL) return;//防止空指针\n    close(fp->fileno);//关闭文件\n    free(fp);//释放资源\n}\n```\n\n## 为接口适配缓冲区\n\n### 为`_FILE`结构体添加输入输出缓冲区\n`缓冲区`和`刷新规则标志`声明在结构体中，使每个打开的文件都有独立的用户级缓冲区和刷新规则\n```C\n#define SIZE 1024 //定义缓冲区大小\n#define FLUSH_NONE 0 //无缓冲\n#define FLUSH_LINE 1 //行缓冲\n#define FLUSH_ALL 2 //全缓冲\n\ntypedef struct IO_FILE{\n    int fileno;//文件描述符\n    int flag; //刷新规则标志\n    char inbuffer[SIZE];//输入缓冲区\n    int in_pos;//输入缓冲区指针\n    char outbuffer[SIZE];//输出缓冲区\n    int out_pos;//输出缓冲区指针\n}_FILE;\n```\n\n### fopen添加语句\n`fopen`仅需添加几句用于初始化的代码\n```C\n    //_FILE *fp = (_FILE*)malloc(sizeof(_FILE)); //申该语句之前都不变\n    fp->fileno = fd;//储存文件描述符\n    fp->flag = FLUSH_LINE;//设置为行刷新\n    fp->in_pos = 0;//指针置0\n    fp->out_pos = 0;//指针置0\n    //return fp;  //这句也不变\n```\n\n### fwrite重写\n`fwrite`要根据不同的刷新方式进行写入\n\n```C\nint _fwrite(_FILE *fp,const char* s,int len)\n{\n    memcpy(&(fp->outbuffer[fp->out_pos]),s,len);//将内容拷贝至缓冲区指定位置\n    fp->out_pos +=len;//简易偏移out_pos\n    if(fp->fileno == FLUSH_NONE)\n    {\n        write(fp->fileno,s,fp->out_pos);//无缓冲区的写入版本\n    }\n    else if(fp->flag == FLUSH_LINE)\n    {\n        if(fp->outbuffer[fp->out_pos-1] == '\\n')\n        {\n            write(fp->fileno,s,fp->out_pos);//立即刷新\n            fp->out_pos = 0;\n        }\n        else{\n            return len;\n        }\n    }\n    else if(fp->flag == FLUSH_ALL)\n    {\n        if(fp->out_pos == SIZE)\n        {\n            write(fp->fileno,s,fp->out_pos);//立即刷新\n            fp->out_pos = 0;\n        }\n        else{\n            return len;\n        }\n    }\n}\n```\n\n### 添加`_fflush`和修改`_fclose`\n```C\nvoid _fflush(_FILE* fp)\n{\n    if(fp->out_pos > 0)\n    {\n        write(fp->fileno,fp->outbuffer,fp->out_pos);//立即刷新\n        fp->out_pos = 0;\n    }\n}\n\nvoid _fclose(_FILE* fp)\n{\n    if(fp == NULL) return;//防止空指针\n    _fflush(fp);//刷新缓冲区\n    close(fp->fileno);//关闭文件\n    free(fp);//释放资源\n}\n```\n\n## 小结\n至此,我们已经封装了基本的写入功能,更多的细节可自行完善\n\n[戳我去github仓库🔗](https://github.com/sis-shen/Linux_Code/tree/main/mystdio) 查看源文件\n","slug":"c-file-cache","published":1,"updated":"2024-08-06T02:42:07.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p086000g4sp59rriavbl","content":"<p>前置博客 <a href=\"https://www.supdriver.top/2024/07/10/basicIO/\">基础IO</a></p>\n<h1 id=\"为什么有缓冲\"><a href=\"#为什么有缓冲\" class=\"headerlink\" title=\"为什么有缓冲\"></a>为什么有缓冲</h1><p>因为<code>磁盘的读写</code>与<code>内存的读写</code>操作速度相比，磁盘的读写是相差数量级的慢，所以为了提高内存<strong>多次</strong>，<strong>频繁</strong>读写磁盘文件的效率，<code>缓冲区</code>被投入使用。尤其是内存内容<strong>写入</strong>磁盘时，常常先写入<code>内存级缓冲区</code>，再在特定规则下一次性将<code>缓冲区</code>的内容写入磁盘</p>\n<p>**本文以<code>C语言</code>提供的用户级缓冲区为例介绍缓冲区</p>\n<h1 id=\"缓冲区的刷新规则\"><a href=\"#缓冲区的刷新规则\" class=\"headerlink\" title=\"缓冲区的刷新规则\"></a>缓冲区的刷新规则</h1><p>首先当一个进程<strong>正常退出</strong>时，会先刷新缓冲区再关闭文件,此时必定有一次刷新</p>\n<p>而当进程<strong>运行时</strong>缓冲区的刷新策略主要有以下三种</p>\n<ul>\n<li><code>无缓冲</code> 内容直接写入文件</li>\n<li><code>行缓冲</code> 输入一般内容不刷新，遇到<code>\\n</code>时刷新一次缓冲区</li>\n<li><code>全缓冲</code> 缓冲区有容量限制，<strong>满了</strong>之后就刷新</li>\n</ul>\n<h1 id=\"认识一下C语言的缓冲区\"><a href=\"#认识一下C语言的缓冲区\" class=\"headerlink\" title=\"认识一下C语言的缓冲区\"></a>认识一下C语言的缓冲区</h1><p><em>这里的系统环境是Linux</em></p>\n<h2 id=\"刷新规则\"><a href=\"#刷新规则\" class=\"headerlink\" title=\"刷新规则\"></a>刷新规则</h2><p>运行如下代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//打开空文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>,<span class=\"string\">&quot;stdout&quot;</span>);<span class=\"comment\">//向标准输出输出</span></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>,<span class=\"string\">&quot;strerr&quot;</span>);<span class=\"comment\">//向标准错误输出输出</span></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(pfile,<span class=\"string\">&quot;file&quot;</span>);<span class=\"comment\">//向文件输出</span></span><br><span class=\"line\">    _exit(<span class=\"number\">0</span>);<span class=\"comment\">//不刷新缓冲区，直接退出</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>终端和文件的内容为:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stderr</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以看到只有<code>标准错误输出</code>有实际的输出,而<code>标准输出</code>和<code>文件输出</code>都没有输出</p>\n<p>目前可以得出：</p>\n<ul>\n<li><code>标准错误输出</code>是<code>无缓冲</code>的刷新规则</li>\n</ul>\n<p>因此我们再运行如下代码，再输出内容后面加上<code>\\n</code>换行</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//打开空文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>,<span class=\"string\">&quot;stdout\\n&quot;</span>);<span class=\"comment\">//向标准输出输出</span></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(pfile,<span class=\"string\">&quot;file\\n&quot;</span>);<span class=\"comment\">//向文件输出</span></span><br><span class=\"line\">    _exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>终端输出内容为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stdout</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>而文件依然为空</strong></p>\n<p>由此可得:</p>\n<ul>\n<li><code>标准输出</code>遵循<code>行缓冲</code>的刷新规则</li>\n<li><code>文件输出</code>遵循<code>全缓冲</code>的刷新规则</li>\n</ul>\n<h2 id=\"缓冲区在fork中的行为\"><a href=\"#缓冲区在fork中的行为\" class=\"headerlink\" title=\"缓冲区在fork中的行为\"></a>缓冲区在fork中的行为</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello1 &quot;</span>);<span class=\"comment\">//父进程向标准输出打印一句话</span></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>,<span class=\"string\">&quot;hello2 &quot;</span>);<span class=\"comment\">//父进程向标准输出打印一句话</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fork();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上段代码的输出内容为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello1 hello2 hello1 hello2 </span><br></pre></td></tr></table></figure>\n<p>可见<code>fork</code>前的缓冲区内容被打印了两次（父子进程各一次），所以<code>fork</code>也会复制<code>缓冲区</code>的内容</p>\n<p>实际上<code>缓冲区</code>属于进程的一部分，且<code>fork</code>时遵循<code>写时拷贝</code></p>\n<h1 id=\"模拟封装Linux下C语言的文件接口（包括缓冲区）\"><a href=\"#模拟封装Linux下C语言的文件接口（包括缓冲区）\" class=\"headerlink\" title=\"模拟封装Linux下C语言的文件接口（包括缓冲区）\"></a>模拟封装Linux下C语言的文件接口（包括缓冲区）</h1><h2 id=\"主要目标\"><a href=\"#主要目标\" class=\"headerlink\" title=\"主要目标\"></a>主要目标</h2><p>采用<code>Mystdio.h</code>声明，<code>Mystdio.c</code>实现的方式，封装<code>read</code>,<code>write</code>,<code>close</code>系统调用接口。并提供用户级缓冲区和缓冲区的刷新等功能</p>\n<h2 id=\"声明结构体和接口\"><a href=\"#声明结构体和接口\" class=\"headerlink\" title=\"声明结构体和接口\"></a>声明结构体和接口</h2><p>我们先把主要的接口和主要的内容做出来看看封装效果</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __MYSTDIO_H__ <span class=\"comment\">//利用预编译防止头文件被重复编译</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __MYSTDIO_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明文件结构体</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IO_FILE</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fileno;</span><br><span class=\"line\">&#125;_FILE;</span><br><span class=\"line\"></span><br><span class=\"line\">_FILE * _fopen(<span class=\"type\">const</span> <span class=\"type\">char</span> *filename,<span class=\"type\">const</span> <span class=\"type\">char</span> *flag);</span><br><span class=\"line\"><span class=\"type\">int</span> _fwrite(_FILE* fp,<span class=\"type\">const</span> <span class=\"type\">char</span>*s, <span class=\"type\">int</span> len);</span><br><span class=\"line\"><span class=\"type\">void</span> _fclose(_FILE* fp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> </span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现无缓冲区的接口\"><a href=\"#实现无缓冲区的接口\" class=\"headerlink\" title=\"实现无缓冲区的接口\"></a>实现无缓冲区的接口</h2><p>实现的部分由<code>Mystdio.c</code>完成</p>\n<h3 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h3><p>这里的头文件要能够提供使用系统调用接口,以及调用堆区的接口,所以 头文件如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;Mystdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fopen函数\"><a href=\"#fopen函数\" class=\"headerlink\" title=\"_fopen函数\"></a>_fopen函数</h3><p>我们先模拟实现<code>fopen</code>函数的主要功能，主要实现<code>&quot;w&quot;``&quot;a&quot;``&quot;r&quot;</code>的打开模式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_MODE 0666 <span class=\"comment\">//设置默认的文件权限</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">_FILE * _fopen(<span class=\"type\">const</span> <span class=\"type\">char</span> *filename,<span class=\"type\">const</span> <span class=\"type\">char</span> *flag)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> f = <span class=\"number\">0</span>;<span class=\"comment\">//准备空位图</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(flag,<span class=\"string\">&quot;w&quot;</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        f = (O_CREAT|O_WRONLY|O_TRUNC);</span><br><span class=\"line\">        fd = open(filename,f,FILE_MODE);<span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(flag,<span class=\"string\">&quot;a&quot;</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        f = (O_CREAT|O_WRONLY|O_APPEND);</span><br><span class=\"line\">        fd = open(filename,f,FILE_MODE);<span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(flag,<span class=\"string\">&quot;w&quot;</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        f = O_RDONLY;</span><br><span class=\"line\">        fd = open(filename,f);<span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;<span class=\"comment\">//非法的打开模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;<span class=\"comment\">//打开失败</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    _FILE *fp = (_FILE*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(_FILE));<span class=\"comment\">//创建_FILE结构体</span></span><br><span class=\"line\">    fp-&gt;fileno = fp;<span class=\"comment\">//设置_FILE结构体</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fwrite函数-————无缓冲区\"><a href=\"#fwrite函数-————无缓冲区\" class=\"headerlink\" title=\"_fwrite函数 ————无缓冲区\"></a>_fwrite函数 ————无缓冲区</h3><p>然后是先简单地写一个没有缓冲区的<code>_fwrite</code></p>\n<p>带缓冲区版本的稍后添加</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _fwrite(_FILE *fp,<span class=\"type\">const</span> <span class=\"type\">char</span>* s,<span class=\"type\">int</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrtie(fp-&gt;fileno,s,len);<span class=\"comment\">//无缓冲区的写入版本</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fclose函数-————不刷新缓冲区\"><a href=\"#fclose函数-————不刷新缓冲区\" class=\"headerlink\" title=\"_fclose函数 ————不刷新缓冲区\"></a>_fclose函数 ————不刷新缓冲区</h3><p>这里也是先写个没缓冲区的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _fclose(_FILE* fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fp == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;<span class=\"comment\">//防止空指针</span></span><br><span class=\"line\">    close(fp-&gt;fileno);<span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(fp);<span class=\"comment\">//释放资源</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"为接口适配缓冲区\"><a href=\"#为接口适配缓冲区\" class=\"headerlink\" title=\"为接口适配缓冲区\"></a>为接口适配缓冲区</h2><h3 id=\"为-FILE结构体添加输入输出缓冲区\"><a href=\"#为-FILE结构体添加输入输出缓冲区\" class=\"headerlink\" title=\"为_FILE结构体添加输入输出缓冲区\"></a>为<code>_FILE</code>结构体添加输入输出缓冲区</h3><p><code>缓冲区</code>和<code>刷新规则标志</code>声明在结构体中，使每个打开的文件都有独立的用户级缓冲区和刷新规则</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE 1024 <span class=\"comment\">//定义缓冲区大小</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FLUSH_NONE 0 <span class=\"comment\">//无缓冲</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FLUSH_LINE 1 <span class=\"comment\">//行缓冲</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FLUSH_ALL 2 <span class=\"comment\">//全缓冲</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IO_FILE</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fileno;<span class=\"comment\">//文件描述符</span></span><br><span class=\"line\">    <span class=\"type\">int</span> flag; <span class=\"comment\">//刷新规则标志</span></span><br><span class=\"line\">    <span class=\"type\">char</span> inbuffer[SIZE];<span class=\"comment\">//输入缓冲区</span></span><br><span class=\"line\">    <span class=\"type\">int</span> in_pos;<span class=\"comment\">//输入缓冲区指针</span></span><br><span class=\"line\">    <span class=\"type\">char</span> outbuffer[SIZE];<span class=\"comment\">//输出缓冲区</span></span><br><span class=\"line\">    <span class=\"type\">int</span> out_pos;<span class=\"comment\">//输出缓冲区指针</span></span><br><span class=\"line\">&#125;_FILE;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fopen添加语句\"><a href=\"#fopen添加语句\" class=\"headerlink\" title=\"fopen添加语句\"></a>fopen添加语句</h3><p><code>fopen</code>仅需添加几句用于初始化的代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//_FILE *fp = (_FILE*)malloc(sizeof(_FILE)); //申该语句之前都不变</span></span><br><span class=\"line\">fp-&gt;fileno = fd;<span class=\"comment\">//储存文件描述符</span></span><br><span class=\"line\">fp-&gt;flag = FLUSH_LINE;<span class=\"comment\">//设置为行刷新</span></span><br><span class=\"line\">fp-&gt;in_pos = <span class=\"number\">0</span>;<span class=\"comment\">//指针置0</span></span><br><span class=\"line\">fp-&gt;out_pos = <span class=\"number\">0</span>;<span class=\"comment\">//指针置0</span></span><br><span class=\"line\"><span class=\"comment\">//return fp;  //这句也不变</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fwrite重写\"><a href=\"#fwrite重写\" class=\"headerlink\" title=\"fwrite重写\"></a>fwrite重写</h3><p><code>fwrite</code>要根据不同的刷新方式进行写入</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _fwrite(_FILE *fp,<span class=\"type\">const</span> <span class=\"type\">char</span>* s,<span class=\"type\">int</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;(fp-&gt;outbuffer[fp-&gt;out_pos]),s,len);<span class=\"comment\">//将内容拷贝至缓冲区指定位置</span></span><br><span class=\"line\">    fp-&gt;out_pos +=len;<span class=\"comment\">//简易偏移out_pos</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fp-&gt;fileno == FLUSH_NONE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        write(fp-&gt;fileno,s,fp-&gt;out_pos);<span class=\"comment\">//无缓冲区的写入版本</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(fp-&gt;flag == FLUSH_LINE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fp-&gt;outbuffer[fp-&gt;out_pos<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            write(fp-&gt;fileno,s,fp-&gt;out_pos);<span class=\"comment\">//立即刷新</span></span><br><span class=\"line\">            fp-&gt;out_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(fp-&gt;flag == FLUSH_ALL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fp-&gt;out_pos == SIZE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            write(fp-&gt;fileno,s,fp-&gt;out_pos);<span class=\"comment\">//立即刷新</span></span><br><span class=\"line\">            fp-&gt;out_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加-fflush和修改-fclose\"><a href=\"#添加-fflush和修改-fclose\" class=\"headerlink\" title=\"添加_fflush和修改_fclose\"></a>添加<code>_fflush</code>和修改<code>_fclose</code></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _fflush(_FILE* fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fp-&gt;out_pos &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        write(fp-&gt;fileno,fp-&gt;outbuffer,fp-&gt;out_pos);<span class=\"comment\">//立即刷新</span></span><br><span class=\"line\">        fp-&gt;out_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> _fclose(_FILE* fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fp == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;<span class=\"comment\">//防止空指针</span></span><br><span class=\"line\">    _fflush(fp);<span class=\"comment\">//刷新缓冲区</span></span><br><span class=\"line\">    close(fp-&gt;fileno);<span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(fp);<span class=\"comment\">//释放资源</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>至此,我们已经封装了基本的写入功能,更多的细节可自行完善</p>\n<p><a href=\"https://github.com/sis-shen/Linux_Code/tree/main/mystdio\">戳我去github仓库🔗</a> 查看源文件</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409052348139.jpg","cover_type":"img","excerpt":"","more":"<p>前置博客 <a href=\"https://www.supdriver.top/2024/07/10/basicIO/\">基础IO</a></p>\n<h1 id=\"为什么有缓冲\"><a href=\"#为什么有缓冲\" class=\"headerlink\" title=\"为什么有缓冲\"></a>为什么有缓冲</h1><p>因为<code>磁盘的读写</code>与<code>内存的读写</code>操作速度相比，磁盘的读写是相差数量级的慢，所以为了提高内存<strong>多次</strong>，<strong>频繁</strong>读写磁盘文件的效率，<code>缓冲区</code>被投入使用。尤其是内存内容<strong>写入</strong>磁盘时，常常先写入<code>内存级缓冲区</code>，再在特定规则下一次性将<code>缓冲区</code>的内容写入磁盘</p>\n<p>**本文以<code>C语言</code>提供的用户级缓冲区为例介绍缓冲区</p>\n<h1 id=\"缓冲区的刷新规则\"><a href=\"#缓冲区的刷新规则\" class=\"headerlink\" title=\"缓冲区的刷新规则\"></a>缓冲区的刷新规则</h1><p>首先当一个进程<strong>正常退出</strong>时，会先刷新缓冲区再关闭文件,此时必定有一次刷新</p>\n<p>而当进程<strong>运行时</strong>缓冲区的刷新策略主要有以下三种</p>\n<ul>\n<li><code>无缓冲</code> 内容直接写入文件</li>\n<li><code>行缓冲</code> 输入一般内容不刷新，遇到<code>\\n</code>时刷新一次缓冲区</li>\n<li><code>全缓冲</code> 缓冲区有容量限制，<strong>满了</strong>之后就刷新</li>\n</ul>\n<h1 id=\"认识一下C语言的缓冲区\"><a href=\"#认识一下C语言的缓冲区\" class=\"headerlink\" title=\"认识一下C语言的缓冲区\"></a>认识一下C语言的缓冲区</h1><p><em>这里的系统环境是Linux</em></p>\n<h2 id=\"刷新规则\"><a href=\"#刷新规则\" class=\"headerlink\" title=\"刷新规则\"></a>刷新规则</h2><p>运行如下代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//打开空文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>,<span class=\"string\">&quot;stdout&quot;</span>);<span class=\"comment\">//向标准输出输出</span></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>,<span class=\"string\">&quot;strerr&quot;</span>);<span class=\"comment\">//向标准错误输出输出</span></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(pfile,<span class=\"string\">&quot;file&quot;</span>);<span class=\"comment\">//向文件输出</span></span><br><span class=\"line\">    _exit(<span class=\"number\">0</span>);<span class=\"comment\">//不刷新缓冲区，直接退出</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>终端和文件的内容为:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stderr</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以看到只有<code>标准错误输出</code>有实际的输出,而<code>标准输出</code>和<code>文件输出</code>都没有输出</p>\n<p>目前可以得出：</p>\n<ul>\n<li><code>标准错误输出</code>是<code>无缓冲</code>的刷新规则</li>\n</ul>\n<p>因此我们再运行如下代码，再输出内容后面加上<code>\\n</code>换行</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//打开空文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>,<span class=\"string\">&quot;stdout\\n&quot;</span>);<span class=\"comment\">//向标准输出输出</span></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(pfile,<span class=\"string\">&quot;file\\n&quot;</span>);<span class=\"comment\">//向文件输出</span></span><br><span class=\"line\">    _exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>终端输出内容为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stdout</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>而文件依然为空</strong></p>\n<p>由此可得:</p>\n<ul>\n<li><code>标准输出</code>遵循<code>行缓冲</code>的刷新规则</li>\n<li><code>文件输出</code>遵循<code>全缓冲</code>的刷新规则</li>\n</ul>\n<h2 id=\"缓冲区在fork中的行为\"><a href=\"#缓冲区在fork中的行为\" class=\"headerlink\" title=\"缓冲区在fork中的行为\"></a>缓冲区在fork中的行为</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello1 &quot;</span>);<span class=\"comment\">//父进程向标准输出打印一句话</span></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>,<span class=\"string\">&quot;hello2 &quot;</span>);<span class=\"comment\">//父进程向标准输出打印一句话</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fork();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上段代码的输出内容为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello1 hello2 hello1 hello2 </span><br></pre></td></tr></table></figure>\n<p>可见<code>fork</code>前的缓冲区内容被打印了两次（父子进程各一次），所以<code>fork</code>也会复制<code>缓冲区</code>的内容</p>\n<p>实际上<code>缓冲区</code>属于进程的一部分，且<code>fork</code>时遵循<code>写时拷贝</code></p>\n<h1 id=\"模拟封装Linux下C语言的文件接口（包括缓冲区）\"><a href=\"#模拟封装Linux下C语言的文件接口（包括缓冲区）\" class=\"headerlink\" title=\"模拟封装Linux下C语言的文件接口（包括缓冲区）\"></a>模拟封装Linux下C语言的文件接口（包括缓冲区）</h1><h2 id=\"主要目标\"><a href=\"#主要目标\" class=\"headerlink\" title=\"主要目标\"></a>主要目标</h2><p>采用<code>Mystdio.h</code>声明，<code>Mystdio.c</code>实现的方式，封装<code>read</code>,<code>write</code>,<code>close</code>系统调用接口。并提供用户级缓冲区和缓冲区的刷新等功能</p>\n<h2 id=\"声明结构体和接口\"><a href=\"#声明结构体和接口\" class=\"headerlink\" title=\"声明结构体和接口\"></a>声明结构体和接口</h2><p>我们先把主要的接口和主要的内容做出来看看封装效果</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __MYSTDIO_H__ <span class=\"comment\">//利用预编译防止头文件被重复编译</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __MYSTDIO_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明文件结构体</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IO_FILE</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fileno;</span><br><span class=\"line\">&#125;_FILE;</span><br><span class=\"line\"></span><br><span class=\"line\">_FILE * _fopen(<span class=\"type\">const</span> <span class=\"type\">char</span> *filename,<span class=\"type\">const</span> <span class=\"type\">char</span> *flag);</span><br><span class=\"line\"><span class=\"type\">int</span> _fwrite(_FILE* fp,<span class=\"type\">const</span> <span class=\"type\">char</span>*s, <span class=\"type\">int</span> len);</span><br><span class=\"line\"><span class=\"type\">void</span> _fclose(_FILE* fp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> </span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现无缓冲区的接口\"><a href=\"#实现无缓冲区的接口\" class=\"headerlink\" title=\"实现无缓冲区的接口\"></a>实现无缓冲区的接口</h2><p>实现的部分由<code>Mystdio.c</code>完成</p>\n<h3 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h3><p>这里的头文件要能够提供使用系统调用接口,以及调用堆区的接口,所以 头文件如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;Mystdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fopen函数\"><a href=\"#fopen函数\" class=\"headerlink\" title=\"_fopen函数\"></a>_fopen函数</h3><p>我们先模拟实现<code>fopen</code>函数的主要功能，主要实现<code>&quot;w&quot;``&quot;a&quot;``&quot;r&quot;</code>的打开模式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_MODE 0666 <span class=\"comment\">//设置默认的文件权限</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">_FILE * _fopen(<span class=\"type\">const</span> <span class=\"type\">char</span> *filename,<span class=\"type\">const</span> <span class=\"type\">char</span> *flag)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> f = <span class=\"number\">0</span>;<span class=\"comment\">//准备空位图</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(flag,<span class=\"string\">&quot;w&quot;</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        f = (O_CREAT|O_WRONLY|O_TRUNC);</span><br><span class=\"line\">        fd = open(filename,f,FILE_MODE);<span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(flag,<span class=\"string\">&quot;a&quot;</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        f = (O_CREAT|O_WRONLY|O_APPEND);</span><br><span class=\"line\">        fd = open(filename,f,FILE_MODE);<span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(flag,<span class=\"string\">&quot;w&quot;</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        f = O_RDONLY;</span><br><span class=\"line\">        fd = open(filename,f);<span class=\"comment\">//打开文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;<span class=\"comment\">//非法的打开模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;<span class=\"comment\">//打开失败</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    _FILE *fp = (_FILE*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(_FILE));<span class=\"comment\">//创建_FILE结构体</span></span><br><span class=\"line\">    fp-&gt;fileno = fp;<span class=\"comment\">//设置_FILE结构体</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fwrite函数-————无缓冲区\"><a href=\"#fwrite函数-————无缓冲区\" class=\"headerlink\" title=\"_fwrite函数 ————无缓冲区\"></a>_fwrite函数 ————无缓冲区</h3><p>然后是先简单地写一个没有缓冲区的<code>_fwrite</code></p>\n<p>带缓冲区版本的稍后添加</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _fwrite(_FILE *fp,<span class=\"type\">const</span> <span class=\"type\">char</span>* s,<span class=\"type\">int</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrtie(fp-&gt;fileno,s,len);<span class=\"comment\">//无缓冲区的写入版本</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fclose函数-————不刷新缓冲区\"><a href=\"#fclose函数-————不刷新缓冲区\" class=\"headerlink\" title=\"_fclose函数 ————不刷新缓冲区\"></a>_fclose函数 ————不刷新缓冲区</h3><p>这里也是先写个没缓冲区的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _fclose(_FILE* fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fp == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;<span class=\"comment\">//防止空指针</span></span><br><span class=\"line\">    close(fp-&gt;fileno);<span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(fp);<span class=\"comment\">//释放资源</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"为接口适配缓冲区\"><a href=\"#为接口适配缓冲区\" class=\"headerlink\" title=\"为接口适配缓冲区\"></a>为接口适配缓冲区</h2><h3 id=\"为-FILE结构体添加输入输出缓冲区\"><a href=\"#为-FILE结构体添加输入输出缓冲区\" class=\"headerlink\" title=\"为_FILE结构体添加输入输出缓冲区\"></a>为<code>_FILE</code>结构体添加输入输出缓冲区</h3><p><code>缓冲区</code>和<code>刷新规则标志</code>声明在结构体中，使每个打开的文件都有独立的用户级缓冲区和刷新规则</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE 1024 <span class=\"comment\">//定义缓冲区大小</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FLUSH_NONE 0 <span class=\"comment\">//无缓冲</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FLUSH_LINE 1 <span class=\"comment\">//行缓冲</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FLUSH_ALL 2 <span class=\"comment\">//全缓冲</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IO_FILE</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fileno;<span class=\"comment\">//文件描述符</span></span><br><span class=\"line\">    <span class=\"type\">int</span> flag; <span class=\"comment\">//刷新规则标志</span></span><br><span class=\"line\">    <span class=\"type\">char</span> inbuffer[SIZE];<span class=\"comment\">//输入缓冲区</span></span><br><span class=\"line\">    <span class=\"type\">int</span> in_pos;<span class=\"comment\">//输入缓冲区指针</span></span><br><span class=\"line\">    <span class=\"type\">char</span> outbuffer[SIZE];<span class=\"comment\">//输出缓冲区</span></span><br><span class=\"line\">    <span class=\"type\">int</span> out_pos;<span class=\"comment\">//输出缓冲区指针</span></span><br><span class=\"line\">&#125;_FILE;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fopen添加语句\"><a href=\"#fopen添加语句\" class=\"headerlink\" title=\"fopen添加语句\"></a>fopen添加语句</h3><p><code>fopen</code>仅需添加几句用于初始化的代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//_FILE *fp = (_FILE*)malloc(sizeof(_FILE)); //申该语句之前都不变</span></span><br><span class=\"line\">fp-&gt;fileno = fd;<span class=\"comment\">//储存文件描述符</span></span><br><span class=\"line\">fp-&gt;flag = FLUSH_LINE;<span class=\"comment\">//设置为行刷新</span></span><br><span class=\"line\">fp-&gt;in_pos = <span class=\"number\">0</span>;<span class=\"comment\">//指针置0</span></span><br><span class=\"line\">fp-&gt;out_pos = <span class=\"number\">0</span>;<span class=\"comment\">//指针置0</span></span><br><span class=\"line\"><span class=\"comment\">//return fp;  //这句也不变</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fwrite重写\"><a href=\"#fwrite重写\" class=\"headerlink\" title=\"fwrite重写\"></a>fwrite重写</h3><p><code>fwrite</code>要根据不同的刷新方式进行写入</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _fwrite(_FILE *fp,<span class=\"type\">const</span> <span class=\"type\">char</span>* s,<span class=\"type\">int</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;(fp-&gt;outbuffer[fp-&gt;out_pos]),s,len);<span class=\"comment\">//将内容拷贝至缓冲区指定位置</span></span><br><span class=\"line\">    fp-&gt;out_pos +=len;<span class=\"comment\">//简易偏移out_pos</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fp-&gt;fileno == FLUSH_NONE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        write(fp-&gt;fileno,s,fp-&gt;out_pos);<span class=\"comment\">//无缓冲区的写入版本</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(fp-&gt;flag == FLUSH_LINE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fp-&gt;outbuffer[fp-&gt;out_pos<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            write(fp-&gt;fileno,s,fp-&gt;out_pos);<span class=\"comment\">//立即刷新</span></span><br><span class=\"line\">            fp-&gt;out_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(fp-&gt;flag == FLUSH_ALL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fp-&gt;out_pos == SIZE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            write(fp-&gt;fileno,s,fp-&gt;out_pos);<span class=\"comment\">//立即刷新</span></span><br><span class=\"line\">            fp-&gt;out_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加-fflush和修改-fclose\"><a href=\"#添加-fflush和修改-fclose\" class=\"headerlink\" title=\"添加_fflush和修改_fclose\"></a>添加<code>_fflush</code>和修改<code>_fclose</code></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _fflush(_FILE* fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fp-&gt;out_pos &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        write(fp-&gt;fileno,fp-&gt;outbuffer,fp-&gt;out_pos);<span class=\"comment\">//立即刷新</span></span><br><span class=\"line\">        fp-&gt;out_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> _fclose(_FILE* fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fp == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;<span class=\"comment\">//防止空指针</span></span><br><span class=\"line\">    _fflush(fp);<span class=\"comment\">//刷新缓冲区</span></span><br><span class=\"line\">    close(fp-&gt;fileno);<span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(fp);<span class=\"comment\">//释放资源</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>至此,我们已经封装了基本的写入功能,更多的细节可自行完善</p>\n<p><a href=\"https://github.com/sis-shen/Linux_Code/tree/main/mystdio\">戳我去github仓库🔗</a> 查看源文件</p>\n"},{"title":"C语言编译器demo","date":"2024-09-02T07:27:58.000Z","_content":"\n\n\n\n\n","source":"_posts/compier.md","raw":"---\ntitle: C语言编译器demo\ndate: 2024-09-02 15:27:58\ntags:\n---\n\n\n\n\n\n","slug":"compier","published":1,"updated":"2024-09-03T00:29:52.506Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p087000i4sp50swe7yrn","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409052352864.jpg","cover_type":"img","excerpt":"","more":""},{"title":"C语言文件操作","date":"2024-07-15T12:32:12.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-25_12-56-36.png","_content":"\n# 用户级文件操作\n`C语言`的文件操作也是用户级的文件操作，通过`FILE`对象来**管理**每一个`被打开的文件`，以及提供了**用户级**文件缓冲区，因此还涉及到冲刷缓冲区等问题\n\n## `FILE` 类\n`FILE`类描述了一个文件流。里面存储了**文件控制**所需的信息:\n\n+ 指向自身缓冲区的的`指针`\n+ 位置指示器\n+ 状态指示器\n\n所以`C语言`中对文件的管理就是对`FILE`对象的管理\n# 基础操作 - 针对一般文件\n\n## 基础示例\n```C\n#include <stdio.h>\n\nint main()\n{\n\tFILE* pfile = fopen(\"file.txt\", \"w\");//\"w\"模式打开文件file.txt\n\tint code = 1;\n\tconst char* msg = \"this is a msg\";\n\tfprintf(pfile, \"get msg : %s code:%d\", msg, code);//格式化输出字符串\n\tfclose(pfile);//冲刷缓冲区并关闭文件\n\treturn 0;\n}\n```\n以上代码创建了一个`file.txt`文件，输入`格式化字符串`(就和使用printf打印一样)。然后用`flcose`关闭文件流\n\n## fopen 打开文件\n`fopen`能够打开以各种`模式`磁盘上的文件\n\n`FILE* fopen( const char * filename, const char * mode );`\n\n**返回值**:\n+ 成功时，返回一个不为空的`FILE*`指针，用于控制该文件\n+ 失败时，返回`NULL`空指针并设置了全局变量`errno`\n\n### 常见模式\n| 模式 | 简述 |\n| === | === |\n| `\"w\"` | 创建一个**新的空文件**用于输出操作。如果已存在`同名文件`,清除原文件并当作新文件处理 |\n| `\"r\"` | 只读模式打开文件。且该文件必须存在 |\n| `\"a\"` | 打开已有文件时，仅用于在文件末尾`追加`新的内容。并且重定位函数`(fseek,fsetpos,reweind)`会被忽略，即使成功调用，也没有效果；当文件不存在时，会创建一个新的空文件 |\n| \"`r+`\" | 读写模式打开已有文件，**不会清除**原文件内容,并且读写时均从文件开头开始。打开后第一次操作为写入时，从文件头部开始逐字符覆盖原文件。**注**读写模式同时只能`读`或`写`的一种，第一次取决于先进行哪种操作，可以用`fseek`函数转换读写模式 |\n| \"`w+`\" | 读写模式打开新文件，若存在，则清除原文件内容;读写模式的切换和`\"r+\"`模式相同，唯一的区别就是打开时是否清除原文件内容 |\n| \"`a+`\" | 从文件末尾打开读写模式，**不会清除原文件内容**，若打开后第一次操作为写，则从文件末尾开始；若第一次操作为读，则从头开始；读写模式的切换同上 |\n\n### 二进制模式\n如果要以二进制模式打开文件，只需要在上面的模式末尾加上字符`b`\n\n若有`+`,则`b`既可以放在末尾也可以放在中间\n\n+ `r+b` `w+b` `a+b`\n+ `rb+` `wb+` `ab+`\n\n### 强制新建文件\n新的C语言标准,`C2011`(不是C++11),添加了一种新的说明符`w`,可以被添加在任意`\"w\"`后面\n\n+ `\"wx\"` `\"wbx\"` `\"w+x\"`  `\"w+bx\"`/`\"wb+x\"`\n\n当文件**存在**时,`w`会**强制**`fopen`函数失败,返回一个`NULL`空指针\n\n## freopen 重定向文件流\n`FILE* freopen ( const char *filename, const char *mode, FILE * pFile );`\n\n+ 如果传入了新的文件名(与`pFile`控制的文件相比),该函数会**关闭**`pFile`原本指向的文件流，并取消关联。然后**不论**是否成功关闭，`freopen`会用和`fopen`同样的方式打开该文件\n+ 如果文件名还是原文件，则只会改变打开模式\n\n**返回值**:\n+ 成功时，返回`pFile`内储存的地址\n+ 失败时，返回`NULL`\n\n### 特别的\n`freopen`用于进程的输入输出重定向会特别有用\n\n```C\nfreopen (\"outfile.txt\",\"w\",stdout);//标准输出重定向到文件\n\nfreopen (\"readfile.txt\",\"w\",stdin);//标准输入重定向到文件\n\nfreopen (\"errdfile.txt\",\"w\",stderr);//标准错误输出重定向到文件\n```\n\n## 重定位 文件流位置指示器(stream position indicator)\n\n### 文件的抽象内存结构\n首先我们要明确一下文件的内存结构，如下图\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-20_21-23-32.png)\n\n这里及下文用图中的`ptr`代指标题的中的 `文件流位置指示器`,这个`ptr`决定了每一次对文件的`读/写`操作的**起点**,同时每一次`读/写`操作都会使`ptr`自动往后走，因此要显示控制`ptr`，就得使用`fseek,fsetpos`等接口\n\n## fseek 重定位\n`int fseek ( FILE *pFile, long int offset, int origin );`\n\n`fseek`能过直接重定位`ptr`所指的\n\n### 参数\n+ `pFile`：用于控制文件的`FILE*`类型指针\n+ `offset`：则是**偏移量**，长整型，表示偏移多少字节\n+ `origin`：该形参标注了**偏移量**相对于哪个位置计算**实际位置**\n\n`origin`有三个宏可以选\n| 宏 | 实际位置 |\n| `SEEK_SET` | 偏移量从`文件头`开始算 |\n| `SEEK_CUR` | 偏移量从`当前文件指针ptr(上文介绍的)所在位置`开始算 |\n| `SEEK_END` | 偏移量从`文件尾`开始算 |\n\n### 返回值\n\n+ 成功时,返回`0`\n+ 失败时，返回`非零值`，同时，**这条语句失效**,上文说的`ptr`没有改变\n\n## fgetpos 和 fsetpos 设置 ptr\n可以用`fgetpos`获取`ptr`的当前位置，并使用`输出型参数`输出一个`fpos_t`类型的变量，而`fsetpos`可以用`fpos_t`类型的形参设置`ptr`的当前位置\n\n就好比`ptr`是当前坐标，每次`fgetpos`得到一个传送点信息，而`fsetpos`就可以用这个传送点信息传送`ptr`过去\n\n*示例如下*\n```C\n#include <stdio.h>\n\nint main()\n{\n\t//准备一个文件\n\tFILE* pfile = fopen(\"file.txt\", \"w\");//\"w\"模式打开文件file.txt\n\tint code = 1;\n\tconst char* msg = \"this is a msg\";\n\tfprintf(pfile, \"get msg : %s code:%d\", msg, code);\n\tfclose(pfile);\n\t//===========\n\n\tfpos_t pos1,pos2;\n\tpfile = fopen(\"file.txt\", \"r\");\n\n\tfgetpos(pfile, &pos1);\n\tfgetc(pfile);\n\tfgetpos(pfile, &pos2);\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tfsetpos(pfile, &pos2);//循环令ptr指向第二个字符\n\t\tprintf(\"第2个字符为: %c\\n\", fgetc(pfile));\n\t}                                                     \n\tfsetpos(pfile, &pos1);//令ptr指向第一个字符\n\tprintf(\"第1个字符为: %c\\n\", fgetc(pfile));\n\n\tfclose(pfile);\n\n\treturn 0;\n}\n```\n```输出\n第2个字符为: e\n第2个字符为: e\n第2个字符为: e\n第1个字符为: g\n```\n\n## fclose 关闭文件流\n可以用`fclose`显式地关闭文件流\n\n用法为`fclose(pFile);`\n\n进程正常退出时，也会自动关闭文件流\n\n## fprintf 格式化输出字符串\n`fprintf`能格式化输出字符串到指定文件流，除了要**指定**文件流，格式化字符串的方式和`printf`一样\n\n+ 且`fprintf(stdout,format,...)`和`printf(format,...)`效果一样\n\n## fputs 输出字符串\n`int fputs ( const char * str, FILE * stream );`\n\n`fputs`能将`C语言`的字符串输入到指定文件流中\n\n## fwrite 输出内存数据块\n`size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);`\n\n+ `ptr`是指向`内存数据块`的指针\n+ `size`是每个`数组元素`的大小\n+ `nmemb`是元素数量\n+ `stream`是文件流\n\nfwrite可以向指定文件流输入特定大小的内存数据块\n\n```C\nint main()\n{\n\tFILE* pfile = fopen(\"file.txt\", \"w\");//\"w\"模式打开文件file.txt\n\tchar msg[] = \"this is a msg\";\n\tfwrite(msg, sizeof(char), strlen(msg), pfile);\n\n\tfclose(pfile);\n\n\treturn 0;\n}\n```\n\n## fscanf 格式化输入\n`fscanf`能像`scanf`读取标准输入流一样,读取指定文件流\n\n+ 且`scanf(stdin,format,...)`和`printf(format,...)`效果一样\n\n## fegts 获取一行\n`char * fgets (char *str, int num, FILE *stream );`\n### 行为\n`fegts`会一直读取直到`换行符`或`EOF文件结尾`结束读取，但`换行符`作为**非法**字符不会被拷贝到形参`str`中\n\n+ 字符串结尾的`\\0`会被自动添加,且**计算**在读入的**最大字符数**\n+ `fgets`和`gets`有很大差别，它需要**指定**最大的读入字符数\n\n### 形参\n+ `str`为传入的字符数组作为缓冲区\n+ `num`为拷贝的最大字符数，**包括**自动添加的结尾`\\0`\n+ `stream`为指定的文件流\n\n### 返回值\n+ 成功时，返回`str`的值\n+ 失败时，返回`NULL`\n\n### 示例\n```C\n#include <stdio.h>\n\nint main()\n{\n\t//准备一个文件\n\tFILE* pfile = fopen(\"file.txt\", \"w\");//\"w\"模式打开文件file.txt\n\tint code = 1;\n\tconst char* msg = \"this is a msg\";\n\tfprintf(pfile, \"get msg : %s code:%d\", msg, code);\n\tfclose(pfile);\n\t//=====\n\n\tpfile = fopen(\"file.txt\", \"r\");\n\tchar str[5] = { 0 };\n\tfgets(str, sizeof(str), pfile);//除去自动添加的\\0,最多从文件里读入4个字符\n\tprintf(str);\n\tprintf(\"|\");\n\treturn 0;\n}\n```\n```输出\nget |\n```\n","source":"_posts/cfileop.md","raw":"---\ntitle: C语言文件操作\ndate: 2024-07-15 20:32:12\ntags:\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-25_12-56-36.png\n---\n\n# 用户级文件操作\n`C语言`的文件操作也是用户级的文件操作，通过`FILE`对象来**管理**每一个`被打开的文件`，以及提供了**用户级**文件缓冲区，因此还涉及到冲刷缓冲区等问题\n\n## `FILE` 类\n`FILE`类描述了一个文件流。里面存储了**文件控制**所需的信息:\n\n+ 指向自身缓冲区的的`指针`\n+ 位置指示器\n+ 状态指示器\n\n所以`C语言`中对文件的管理就是对`FILE`对象的管理\n# 基础操作 - 针对一般文件\n\n## 基础示例\n```C\n#include <stdio.h>\n\nint main()\n{\n\tFILE* pfile = fopen(\"file.txt\", \"w\");//\"w\"模式打开文件file.txt\n\tint code = 1;\n\tconst char* msg = \"this is a msg\";\n\tfprintf(pfile, \"get msg : %s code:%d\", msg, code);//格式化输出字符串\n\tfclose(pfile);//冲刷缓冲区并关闭文件\n\treturn 0;\n}\n```\n以上代码创建了一个`file.txt`文件，输入`格式化字符串`(就和使用printf打印一样)。然后用`flcose`关闭文件流\n\n## fopen 打开文件\n`fopen`能够打开以各种`模式`磁盘上的文件\n\n`FILE* fopen( const char * filename, const char * mode );`\n\n**返回值**:\n+ 成功时，返回一个不为空的`FILE*`指针，用于控制该文件\n+ 失败时，返回`NULL`空指针并设置了全局变量`errno`\n\n### 常见模式\n| 模式 | 简述 |\n| === | === |\n| `\"w\"` | 创建一个**新的空文件**用于输出操作。如果已存在`同名文件`,清除原文件并当作新文件处理 |\n| `\"r\"` | 只读模式打开文件。且该文件必须存在 |\n| `\"a\"` | 打开已有文件时，仅用于在文件末尾`追加`新的内容。并且重定位函数`(fseek,fsetpos,reweind)`会被忽略，即使成功调用，也没有效果；当文件不存在时，会创建一个新的空文件 |\n| \"`r+`\" | 读写模式打开已有文件，**不会清除**原文件内容,并且读写时均从文件开头开始。打开后第一次操作为写入时，从文件头部开始逐字符覆盖原文件。**注**读写模式同时只能`读`或`写`的一种，第一次取决于先进行哪种操作，可以用`fseek`函数转换读写模式 |\n| \"`w+`\" | 读写模式打开新文件，若存在，则清除原文件内容;读写模式的切换和`\"r+\"`模式相同，唯一的区别就是打开时是否清除原文件内容 |\n| \"`a+`\" | 从文件末尾打开读写模式，**不会清除原文件内容**，若打开后第一次操作为写，则从文件末尾开始；若第一次操作为读，则从头开始；读写模式的切换同上 |\n\n### 二进制模式\n如果要以二进制模式打开文件，只需要在上面的模式末尾加上字符`b`\n\n若有`+`,则`b`既可以放在末尾也可以放在中间\n\n+ `r+b` `w+b` `a+b`\n+ `rb+` `wb+` `ab+`\n\n### 强制新建文件\n新的C语言标准,`C2011`(不是C++11),添加了一种新的说明符`w`,可以被添加在任意`\"w\"`后面\n\n+ `\"wx\"` `\"wbx\"` `\"w+x\"`  `\"w+bx\"`/`\"wb+x\"`\n\n当文件**存在**时,`w`会**强制**`fopen`函数失败,返回一个`NULL`空指针\n\n## freopen 重定向文件流\n`FILE* freopen ( const char *filename, const char *mode, FILE * pFile );`\n\n+ 如果传入了新的文件名(与`pFile`控制的文件相比),该函数会**关闭**`pFile`原本指向的文件流，并取消关联。然后**不论**是否成功关闭，`freopen`会用和`fopen`同样的方式打开该文件\n+ 如果文件名还是原文件，则只会改变打开模式\n\n**返回值**:\n+ 成功时，返回`pFile`内储存的地址\n+ 失败时，返回`NULL`\n\n### 特别的\n`freopen`用于进程的输入输出重定向会特别有用\n\n```C\nfreopen (\"outfile.txt\",\"w\",stdout);//标准输出重定向到文件\n\nfreopen (\"readfile.txt\",\"w\",stdin);//标准输入重定向到文件\n\nfreopen (\"errdfile.txt\",\"w\",stderr);//标准错误输出重定向到文件\n```\n\n## 重定位 文件流位置指示器(stream position indicator)\n\n### 文件的抽象内存结构\n首先我们要明确一下文件的内存结构，如下图\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-20_21-23-32.png)\n\n这里及下文用图中的`ptr`代指标题的中的 `文件流位置指示器`,这个`ptr`决定了每一次对文件的`读/写`操作的**起点**,同时每一次`读/写`操作都会使`ptr`自动往后走，因此要显示控制`ptr`，就得使用`fseek,fsetpos`等接口\n\n## fseek 重定位\n`int fseek ( FILE *pFile, long int offset, int origin );`\n\n`fseek`能过直接重定位`ptr`所指的\n\n### 参数\n+ `pFile`：用于控制文件的`FILE*`类型指针\n+ `offset`：则是**偏移量**，长整型，表示偏移多少字节\n+ `origin`：该形参标注了**偏移量**相对于哪个位置计算**实际位置**\n\n`origin`有三个宏可以选\n| 宏 | 实际位置 |\n| `SEEK_SET` | 偏移量从`文件头`开始算 |\n| `SEEK_CUR` | 偏移量从`当前文件指针ptr(上文介绍的)所在位置`开始算 |\n| `SEEK_END` | 偏移量从`文件尾`开始算 |\n\n### 返回值\n\n+ 成功时,返回`0`\n+ 失败时，返回`非零值`，同时，**这条语句失效**,上文说的`ptr`没有改变\n\n## fgetpos 和 fsetpos 设置 ptr\n可以用`fgetpos`获取`ptr`的当前位置，并使用`输出型参数`输出一个`fpos_t`类型的变量，而`fsetpos`可以用`fpos_t`类型的形参设置`ptr`的当前位置\n\n就好比`ptr`是当前坐标，每次`fgetpos`得到一个传送点信息，而`fsetpos`就可以用这个传送点信息传送`ptr`过去\n\n*示例如下*\n```C\n#include <stdio.h>\n\nint main()\n{\n\t//准备一个文件\n\tFILE* pfile = fopen(\"file.txt\", \"w\");//\"w\"模式打开文件file.txt\n\tint code = 1;\n\tconst char* msg = \"this is a msg\";\n\tfprintf(pfile, \"get msg : %s code:%d\", msg, code);\n\tfclose(pfile);\n\t//===========\n\n\tfpos_t pos1,pos2;\n\tpfile = fopen(\"file.txt\", \"r\");\n\n\tfgetpos(pfile, &pos1);\n\tfgetc(pfile);\n\tfgetpos(pfile, &pos2);\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tfsetpos(pfile, &pos2);//循环令ptr指向第二个字符\n\t\tprintf(\"第2个字符为: %c\\n\", fgetc(pfile));\n\t}                                                     \n\tfsetpos(pfile, &pos1);//令ptr指向第一个字符\n\tprintf(\"第1个字符为: %c\\n\", fgetc(pfile));\n\n\tfclose(pfile);\n\n\treturn 0;\n}\n```\n```输出\n第2个字符为: e\n第2个字符为: e\n第2个字符为: e\n第1个字符为: g\n```\n\n## fclose 关闭文件流\n可以用`fclose`显式地关闭文件流\n\n用法为`fclose(pFile);`\n\n进程正常退出时，也会自动关闭文件流\n\n## fprintf 格式化输出字符串\n`fprintf`能格式化输出字符串到指定文件流，除了要**指定**文件流，格式化字符串的方式和`printf`一样\n\n+ 且`fprintf(stdout,format,...)`和`printf(format,...)`效果一样\n\n## fputs 输出字符串\n`int fputs ( const char * str, FILE * stream );`\n\n`fputs`能将`C语言`的字符串输入到指定文件流中\n\n## fwrite 输出内存数据块\n`size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);`\n\n+ `ptr`是指向`内存数据块`的指针\n+ `size`是每个`数组元素`的大小\n+ `nmemb`是元素数量\n+ `stream`是文件流\n\nfwrite可以向指定文件流输入特定大小的内存数据块\n\n```C\nint main()\n{\n\tFILE* pfile = fopen(\"file.txt\", \"w\");//\"w\"模式打开文件file.txt\n\tchar msg[] = \"this is a msg\";\n\tfwrite(msg, sizeof(char), strlen(msg), pfile);\n\n\tfclose(pfile);\n\n\treturn 0;\n}\n```\n\n## fscanf 格式化输入\n`fscanf`能像`scanf`读取标准输入流一样,读取指定文件流\n\n+ 且`scanf(stdin,format,...)`和`printf(format,...)`效果一样\n\n## fegts 获取一行\n`char * fgets (char *str, int num, FILE *stream );`\n### 行为\n`fegts`会一直读取直到`换行符`或`EOF文件结尾`结束读取，但`换行符`作为**非法**字符不会被拷贝到形参`str`中\n\n+ 字符串结尾的`\\0`会被自动添加,且**计算**在读入的**最大字符数**\n+ `fgets`和`gets`有很大差别，它需要**指定**最大的读入字符数\n\n### 形参\n+ `str`为传入的字符数组作为缓冲区\n+ `num`为拷贝的最大字符数，**包括**自动添加的结尾`\\0`\n+ `stream`为指定的文件流\n\n### 返回值\n+ 成功时，返回`str`的值\n+ 失败时，返回`NULL`\n\n### 示例\n```C\n#include <stdio.h>\n\nint main()\n{\n\t//准备一个文件\n\tFILE* pfile = fopen(\"file.txt\", \"w\");//\"w\"模式打开文件file.txt\n\tint code = 1;\n\tconst char* msg = \"this is a msg\";\n\tfprintf(pfile, \"get msg : %s code:%d\", msg, code);\n\tfclose(pfile);\n\t//=====\n\n\tpfile = fopen(\"file.txt\", \"r\");\n\tchar str[5] = { 0 };\n\tfgets(str, sizeof(str), pfile);//除去自动添加的\\0,最多从文件里读入4个字符\n\tprintf(str);\n\tprintf(\"|\");\n\treturn 0;\n}\n```\n```输出\nget |\n```\n","slug":"cfileop","published":1,"updated":"2024-07-26T13:44:16.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p087000k4sp512jh65ce","content":"<h1 id=\"用户级文件操作\"><a href=\"#用户级文件操作\" class=\"headerlink\" title=\"用户级文件操作\"></a>用户级文件操作</h1><p><code>C语言</code>的文件操作也是用户级的文件操作，通过<code>FILE</code>对象来<strong>管理</strong>每一个<code>被打开的文件</code>，以及提供了<strong>用户级</strong>文件缓冲区，因此还涉及到冲刷缓冲区等问题</p>\n<h2 id=\"FILE-类\"><a href=\"#FILE-类\" class=\"headerlink\" title=\"FILE 类\"></a><code>FILE</code> 类</h2><p><code>FILE</code>类描述了一个文件流。里面存储了<strong>文件控制</strong>所需的信息:</p>\n<ul>\n<li>指向自身缓冲区的的<code>指针</code></li>\n<li>位置指示器</li>\n<li>状态指示器</li>\n</ul>\n<p>所以<code>C语言</code>中对文件的管理就是对<code>FILE</code>对象的管理</p>\n<h1 id=\"基础操作-针对一般文件\"><a href=\"#基础操作-针对一般文件\" class=\"headerlink\" title=\"基础操作 - 针对一般文件\"></a>基础操作 - 针对一般文件</h1><h2 id=\"基础示例\"><a href=\"#基础示例\" class=\"headerlink\" title=\"基础示例\"></a>基础示例</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tFILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> code = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>* msg = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">fprintf</span>(pfile, <span class=\"string\">&quot;get msg : %s code:%d&quot;</span>, msg, code);<span class=\"comment\">//格式化输出字符串</span></span><br><span class=\"line\">\tfclose(pfile);<span class=\"comment\">//冲刷缓冲区并关闭文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码创建了一个<code>file.txt</code>文件，输入<code>格式化字符串</code>(就和使用printf打印一样)。然后用<code>flcose</code>关闭文件流</p>\n<h2 id=\"fopen-打开文件\"><a href=\"#fopen-打开文件\" class=\"headerlink\" title=\"fopen 打开文件\"></a>fopen 打开文件</h2><p><code>fopen</code>能够打开以各种<code>模式</code>磁盘上的文件</p>\n<p><code>FILE* fopen( const char * filename, const char * mode );</code></p>\n<p><strong>返回值</strong>:</p>\n<ul>\n<li>成功时，返回一个不为空的<code>FILE*</code>指针，用于控制该文件</li>\n<li>失败时，返回<code>NULL</code>空指针并设置了全局变量<code>errno</code></li>\n</ul>\n<h3 id=\"常见模式\"><a href=\"#常见模式\" class=\"headerlink\" title=\"常见模式\"></a>常见模式</h3><p>| 模式 | 简述 |<br>| &#x3D;&#x3D;&#x3D; | &#x3D;&#x3D;&#x3D; |<br>| <code>&quot;w&quot;</code> | 创建一个<strong>新的空文件</strong>用于输出操作。如果已存在<code>同名文件</code>,清除原文件并当作新文件处理 |<br>| <code>&quot;r&quot;</code> | 只读模式打开文件。且该文件必须存在 |<br>| <code>&quot;a&quot;</code> | 打开已有文件时，仅用于在文件末尾<code>追加</code>新的内容。并且重定位函数<code>(fseek,fsetpos,reweind)</code>会被忽略，即使成功调用，也没有效果；当文件不存在时，会创建一个新的空文件 |<br>| “<code>r+</code>“ | 读写模式打开已有文件，<strong>不会清除</strong>原文件内容,并且读写时均从文件开头开始。打开后第一次操作为写入时，从文件头部开始逐字符覆盖原文件。<strong>注</strong>读写模式同时只能<code>读</code>或<code>写</code>的一种，第一次取决于先进行哪种操作，可以用<code>fseek</code>函数转换读写模式 |<br>| “<code>w+</code>“ | 读写模式打开新文件，若存在，则清除原文件内容;读写模式的切换和<code>&quot;r+&quot;</code>模式相同，唯一的区别就是打开时是否清除原文件内容 |<br>| “<code>a+</code>“ | 从文件末尾打开读写模式，<strong>不会清除原文件内容</strong>，若打开后第一次操作为写，则从文件末尾开始；若第一次操作为读，则从头开始；读写模式的切换同上 |</p>\n<h3 id=\"二进制模式\"><a href=\"#二进制模式\" class=\"headerlink\" title=\"二进制模式\"></a>二进制模式</h3><p>如果要以二进制模式打开文件，只需要在上面的模式末尾加上字符<code>b</code></p>\n<p>若有<code>+</code>,则<code>b</code>既可以放在末尾也可以放在中间</p>\n<ul>\n<li><code>r+b</code> <code>w+b</code> <code>a+b</code></li>\n<li><code>rb+</code> <code>wb+</code> <code>ab+</code></li>\n</ul>\n<h3 id=\"强制新建文件\"><a href=\"#强制新建文件\" class=\"headerlink\" title=\"强制新建文件\"></a>强制新建文件</h3><p>新的C语言标准,<code>C2011</code>(不是C++11),添加了一种新的说明符<code>w</code>,可以被添加在任意<code>&quot;w&quot;</code>后面</p>\n<ul>\n<li><code>&quot;wx&quot;</code> <code>&quot;wbx&quot;</code> <code>&quot;w+x&quot;</code>  <code>&quot;w+bx&quot;</code>&#x2F;<code>&quot;wb+x&quot;</code></li>\n</ul>\n<p>当文件<strong>存在</strong>时,<code>w</code>会<strong>强制</strong><code>fopen</code>函数失败,返回一个<code>NULL</code>空指针</p>\n<h2 id=\"freopen-重定向文件流\"><a href=\"#freopen-重定向文件流\" class=\"headerlink\" title=\"freopen 重定向文件流\"></a>freopen 重定向文件流</h2><p><code>FILE* freopen ( const char *filename, const char *mode, FILE * pFile );</code></p>\n<ul>\n<li>如果传入了新的文件名(与<code>pFile</code>控制的文件相比),该函数会<strong>关闭</strong><code>pFile</code>原本指向的文件流，并取消关联。然后<strong>不论</strong>是否成功关闭，<code>freopen</code>会用和<code>fopen</code>同样的方式打开该文件</li>\n<li>如果文件名还是原文件，则只会改变打开模式</li>\n</ul>\n<p><strong>返回值</strong>:</p>\n<ul>\n<li>成功时，返回<code>pFile</code>内储存的地址</li>\n<li>失败时，返回<code>NULL</code></li>\n</ul>\n<h3 id=\"特别的\"><a href=\"#特别的\" class=\"headerlink\" title=\"特别的\"></a>特别的</h3><p><code>freopen</code>用于进程的输入输出重定向会特别有用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">freopen (<span class=\"string\">&quot;outfile.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,<span class=\"built_in\">stdout</span>);<span class=\"comment\">//标准输出重定向到文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">freopen (<span class=\"string\">&quot;readfile.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,<span class=\"built_in\">stdin</span>);<span class=\"comment\">//标准输入重定向到文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">freopen (<span class=\"string\">&quot;errdfile.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,<span class=\"built_in\">stderr</span>);<span class=\"comment\">//标准错误输出重定向到文件</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重定位-文件流位置指示器-stream-position-indicator\"><a href=\"#重定位-文件流位置指示器-stream-position-indicator\" class=\"headerlink\" title=\"重定位 文件流位置指示器(stream position indicator)\"></a>重定位 文件流位置指示器(stream position indicator)</h2><h3 id=\"文件的抽象内存结构\"><a href=\"#文件的抽象内存结构\" class=\"headerlink\" title=\"文件的抽象内存结构\"></a>文件的抽象内存结构</h3><p>首先我们要明确一下文件的内存结构，如下图</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-20_21-23-32.png\"></p>\n<p>这里及下文用图中的<code>ptr</code>代指标题的中的 <code>文件流位置指示器</code>,这个<code>ptr</code>决定了每一次对文件的<code>读/写</code>操作的<strong>起点</strong>,同时每一次<code>读/写</code>操作都会使<code>ptr</code>自动往后走，因此要显示控制<code>ptr</code>，就得使用<code>fseek,fsetpos</code>等接口</p>\n<h2 id=\"fseek-重定位\"><a href=\"#fseek-重定位\" class=\"headerlink\" title=\"fseek 重定位\"></a>fseek 重定位</h2><p><code>int fseek ( FILE *pFile, long int offset, int origin );</code></p>\n<p><code>fseek</code>能过直接重定位<code>ptr</code>所指的</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><ul>\n<li><code>pFile</code>：用于控制文件的<code>FILE*</code>类型指针</li>\n<li><code>offset</code>：则是<strong>偏移量</strong>，长整型，表示偏移多少字节</li>\n<li><code>origin</code>：该形参标注了<strong>偏移量</strong>相对于哪个位置计算<strong>实际位置</strong></li>\n</ul>\n<p><code>origin</code>有三个宏可以选<br>| 宏 | 实际位置 |<br>| <code>SEEK_SET</code> | 偏移量从<code>文件头</code>开始算 |<br>| <code>SEEK_CUR</code> | 偏移量从<code>当前文件指针ptr(上文介绍的)所在位置</code>开始算 |<br>| <code>SEEK_END</code> | 偏移量从<code>文件尾</code>开始算 |</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><ul>\n<li>成功时,返回<code>0</code></li>\n<li>失败时，返回<code>非零值</code>，同时，<strong>这条语句失效</strong>,上文说的<code>ptr</code>没有改变</li>\n</ul>\n<h2 id=\"fgetpos-和-fsetpos-设置-ptr\"><a href=\"#fgetpos-和-fsetpos-设置-ptr\" class=\"headerlink\" title=\"fgetpos 和 fsetpos 设置 ptr\"></a>fgetpos 和 fsetpos 设置 ptr</h2><p>可以用<code>fgetpos</code>获取<code>ptr</code>的当前位置，并使用<code>输出型参数</code>输出一个<code>fpos_t</code>类型的变量，而<code>fsetpos</code>可以用<code>fpos_t</code>类型的形参设置<code>ptr</code>的当前位置</p>\n<p>就好比<code>ptr</code>是当前坐标，每次<code>fgetpos</code>得到一个传送点信息，而<code>fsetpos</code>就可以用这个传送点信息传送<code>ptr</code>过去</p>\n<p><em>示例如下</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//准备一个文件</span></span><br><span class=\"line\">\tFILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> code = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>* msg = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">fprintf</span>(pfile, <span class=\"string\">&quot;get msg : %s code:%d&quot;</span>, msg, code);</span><br><span class=\"line\">\tfclose(pfile);</span><br><span class=\"line\">\t<span class=\"comment\">//===========</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">fpos_t</span> pos1,pos2;</span><br><span class=\"line\">\tpfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfgetpos(pfile, &amp;pos1);</span><br><span class=\"line\">\tfgetc(pfile);</span><br><span class=\"line\">\tfgetpos(pfile, &amp;pos2);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tfsetpos(pfile, &amp;pos2);<span class=\"comment\">//循环令ptr指向第二个字符</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;第2个字符为: %c\\n&quot;</span>, fgetc(pfile));</span><br><span class=\"line\">\t&#125;                                                     </span><br><span class=\"line\">\tfsetpos(pfile, &amp;pos1);<span class=\"comment\">//令ptr指向第一个字符</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;第1个字符为: %c\\n&quot;</span>, fgetc(pfile));</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(pfile);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第2个字符为: e</span><br><span class=\"line\">第2个字符为: e</span><br><span class=\"line\">第2个字符为: e</span><br><span class=\"line\">第1个字符为: g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"fclose-关闭文件流\"><a href=\"#fclose-关闭文件流\" class=\"headerlink\" title=\"fclose 关闭文件流\"></a>fclose 关闭文件流</h2><p>可以用<code>fclose</code>显式地关闭文件流</p>\n<p>用法为<code>fclose(pFile);</code></p>\n<p>进程正常退出时，也会自动关闭文件流</p>\n<h2 id=\"fprintf-格式化输出字符串\"><a href=\"#fprintf-格式化输出字符串\" class=\"headerlink\" title=\"fprintf 格式化输出字符串\"></a>fprintf 格式化输出字符串</h2><p><code>fprintf</code>能格式化输出字符串到指定文件流，除了要<strong>指定</strong>文件流，格式化字符串的方式和<code>printf</code>一样</p>\n<ul>\n<li>且<code>fprintf(stdout,format,...)</code>和<code>printf(format,...)</code>效果一样</li>\n</ul>\n<h2 id=\"fputs-输出字符串\"><a href=\"#fputs-输出字符串\" class=\"headerlink\" title=\"fputs 输出字符串\"></a>fputs 输出字符串</h2><p><code>int fputs ( const char * str, FILE * stream );</code></p>\n<p><code>fputs</code>能将<code>C语言</code>的字符串输入到指定文件流中</p>\n<h2 id=\"fwrite-输出内存数据块\"><a href=\"#fwrite-输出内存数据块\" class=\"headerlink\" title=\"fwrite 输出内存数据块\"></a>fwrite 输出内存数据块</h2><p><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code></p>\n<ul>\n<li><code>ptr</code>是指向<code>内存数据块</code>的指针</li>\n<li><code>size</code>是每个<code>数组元素</code>的大小</li>\n<li><code>nmemb</code>是元素数量</li>\n<li><code>stream</code>是文件流</li>\n</ul>\n<p>fwrite可以向指定文件流输入特定大小的内存数据块</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tFILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">\tfwrite(msg, <span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>), <span class=\"built_in\">strlen</span>(msg), pfile);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(pfile);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"fscanf-格式化输入\"><a href=\"#fscanf-格式化输入\" class=\"headerlink\" title=\"fscanf 格式化输入\"></a>fscanf 格式化输入</h2><p><code>fscanf</code>能像<code>scanf</code>读取标准输入流一样,读取指定文件流</p>\n<ul>\n<li>且<code>scanf(stdin,format,...)</code>和<code>printf(format,...)</code>效果一样</li>\n</ul>\n<h2 id=\"fegts-获取一行\"><a href=\"#fegts-获取一行\" class=\"headerlink\" title=\"fegts 获取一行\"></a>fegts 获取一行</h2><p><code>char * fgets (char *str, int num, FILE *stream );</code></p>\n<h3 id=\"行为\"><a href=\"#行为\" class=\"headerlink\" title=\"行为\"></a>行为</h3><p><code>fegts</code>会一直读取直到<code>换行符</code>或<code>EOF文件结尾</code>结束读取，但<code>换行符</code>作为<strong>非法</strong>字符不会被拷贝到形参<code>str</code>中</p>\n<ul>\n<li>字符串结尾的<code>\\0</code>会被自动添加,且<strong>计算</strong>在读入的<strong>最大字符数</strong></li>\n<li><code>fgets</code>和<code>gets</code>有很大差别，它需要<strong>指定</strong>最大的读入字符数</li>\n</ul>\n<h3 id=\"形参\"><a href=\"#形参\" class=\"headerlink\" title=\"形参\"></a>形参</h3><ul>\n<li><code>str</code>为传入的字符数组作为缓冲区</li>\n<li><code>num</code>为拷贝的最大字符数，<strong>包括</strong>自动添加的结尾<code>\\0</code></li>\n<li><code>stream</code>为指定的文件流</li>\n</ul>\n<h3 id=\"返回值-1\"><a href=\"#返回值-1\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><ul>\n<li>成功时，返回<code>str</code>的值</li>\n<li>失败时，返回<code>NULL</code></li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//准备一个文件</span></span><br><span class=\"line\">\tFILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> code = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>* msg = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">fprintf</span>(pfile, <span class=\"string\">&quot;get msg : %s code:%d&quot;</span>, msg, code);</span><br><span class=\"line\">\tfclose(pfile);</span><br><span class=\"line\">\t<span class=\"comment\">//=====</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tpfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">char</span> str[<span class=\"number\">5</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\tfgets(str, <span class=\"keyword\">sizeof</span>(str), pfile);<span class=\"comment\">//除去自动添加的\\0,最多从文件里读入4个字符</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(str);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;|&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get |</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"用户级文件操作\"><a href=\"#用户级文件操作\" class=\"headerlink\" title=\"用户级文件操作\"></a>用户级文件操作</h1><p><code>C语言</code>的文件操作也是用户级的文件操作，通过<code>FILE</code>对象来<strong>管理</strong>每一个<code>被打开的文件</code>，以及提供了<strong>用户级</strong>文件缓冲区，因此还涉及到冲刷缓冲区等问题</p>\n<h2 id=\"FILE-类\"><a href=\"#FILE-类\" class=\"headerlink\" title=\"FILE 类\"></a><code>FILE</code> 类</h2><p><code>FILE</code>类描述了一个文件流。里面存储了<strong>文件控制</strong>所需的信息:</p>\n<ul>\n<li>指向自身缓冲区的的<code>指针</code></li>\n<li>位置指示器</li>\n<li>状态指示器</li>\n</ul>\n<p>所以<code>C语言</code>中对文件的管理就是对<code>FILE</code>对象的管理</p>\n<h1 id=\"基础操作-针对一般文件\"><a href=\"#基础操作-针对一般文件\" class=\"headerlink\" title=\"基础操作 - 针对一般文件\"></a>基础操作 - 针对一般文件</h1><h2 id=\"基础示例\"><a href=\"#基础示例\" class=\"headerlink\" title=\"基础示例\"></a>基础示例</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tFILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> code = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>* msg = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">fprintf</span>(pfile, <span class=\"string\">&quot;get msg : %s code:%d&quot;</span>, msg, code);<span class=\"comment\">//格式化输出字符串</span></span><br><span class=\"line\">\tfclose(pfile);<span class=\"comment\">//冲刷缓冲区并关闭文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码创建了一个<code>file.txt</code>文件，输入<code>格式化字符串</code>(就和使用printf打印一样)。然后用<code>flcose</code>关闭文件流</p>\n<h2 id=\"fopen-打开文件\"><a href=\"#fopen-打开文件\" class=\"headerlink\" title=\"fopen 打开文件\"></a>fopen 打开文件</h2><p><code>fopen</code>能够打开以各种<code>模式</code>磁盘上的文件</p>\n<p><code>FILE* fopen( const char * filename, const char * mode );</code></p>\n<p><strong>返回值</strong>:</p>\n<ul>\n<li>成功时，返回一个不为空的<code>FILE*</code>指针，用于控制该文件</li>\n<li>失败时，返回<code>NULL</code>空指针并设置了全局变量<code>errno</code></li>\n</ul>\n<h3 id=\"常见模式\"><a href=\"#常见模式\" class=\"headerlink\" title=\"常见模式\"></a>常见模式</h3><p>| 模式 | 简述 |<br>| &#x3D;&#x3D;&#x3D; | &#x3D;&#x3D;&#x3D; |<br>| <code>&quot;w&quot;</code> | 创建一个<strong>新的空文件</strong>用于输出操作。如果已存在<code>同名文件</code>,清除原文件并当作新文件处理 |<br>| <code>&quot;r&quot;</code> | 只读模式打开文件。且该文件必须存在 |<br>| <code>&quot;a&quot;</code> | 打开已有文件时，仅用于在文件末尾<code>追加</code>新的内容。并且重定位函数<code>(fseek,fsetpos,reweind)</code>会被忽略，即使成功调用，也没有效果；当文件不存在时，会创建一个新的空文件 |<br>| “<code>r+</code>“ | 读写模式打开已有文件，<strong>不会清除</strong>原文件内容,并且读写时均从文件开头开始。打开后第一次操作为写入时，从文件头部开始逐字符覆盖原文件。<strong>注</strong>读写模式同时只能<code>读</code>或<code>写</code>的一种，第一次取决于先进行哪种操作，可以用<code>fseek</code>函数转换读写模式 |<br>| “<code>w+</code>“ | 读写模式打开新文件，若存在，则清除原文件内容;读写模式的切换和<code>&quot;r+&quot;</code>模式相同，唯一的区别就是打开时是否清除原文件内容 |<br>| “<code>a+</code>“ | 从文件末尾打开读写模式，<strong>不会清除原文件内容</strong>，若打开后第一次操作为写，则从文件末尾开始；若第一次操作为读，则从头开始；读写模式的切换同上 |</p>\n<h3 id=\"二进制模式\"><a href=\"#二进制模式\" class=\"headerlink\" title=\"二进制模式\"></a>二进制模式</h3><p>如果要以二进制模式打开文件，只需要在上面的模式末尾加上字符<code>b</code></p>\n<p>若有<code>+</code>,则<code>b</code>既可以放在末尾也可以放在中间</p>\n<ul>\n<li><code>r+b</code> <code>w+b</code> <code>a+b</code></li>\n<li><code>rb+</code> <code>wb+</code> <code>ab+</code></li>\n</ul>\n<h3 id=\"强制新建文件\"><a href=\"#强制新建文件\" class=\"headerlink\" title=\"强制新建文件\"></a>强制新建文件</h3><p>新的C语言标准,<code>C2011</code>(不是C++11),添加了一种新的说明符<code>w</code>,可以被添加在任意<code>&quot;w&quot;</code>后面</p>\n<ul>\n<li><code>&quot;wx&quot;</code> <code>&quot;wbx&quot;</code> <code>&quot;w+x&quot;</code>  <code>&quot;w+bx&quot;</code>&#x2F;<code>&quot;wb+x&quot;</code></li>\n</ul>\n<p>当文件<strong>存在</strong>时,<code>w</code>会<strong>强制</strong><code>fopen</code>函数失败,返回一个<code>NULL</code>空指针</p>\n<h2 id=\"freopen-重定向文件流\"><a href=\"#freopen-重定向文件流\" class=\"headerlink\" title=\"freopen 重定向文件流\"></a>freopen 重定向文件流</h2><p><code>FILE* freopen ( const char *filename, const char *mode, FILE * pFile );</code></p>\n<ul>\n<li>如果传入了新的文件名(与<code>pFile</code>控制的文件相比),该函数会<strong>关闭</strong><code>pFile</code>原本指向的文件流，并取消关联。然后<strong>不论</strong>是否成功关闭，<code>freopen</code>会用和<code>fopen</code>同样的方式打开该文件</li>\n<li>如果文件名还是原文件，则只会改变打开模式</li>\n</ul>\n<p><strong>返回值</strong>:</p>\n<ul>\n<li>成功时，返回<code>pFile</code>内储存的地址</li>\n<li>失败时，返回<code>NULL</code></li>\n</ul>\n<h3 id=\"特别的\"><a href=\"#特别的\" class=\"headerlink\" title=\"特别的\"></a>特别的</h3><p><code>freopen</code>用于进程的输入输出重定向会特别有用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">freopen (<span class=\"string\">&quot;outfile.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,<span class=\"built_in\">stdout</span>);<span class=\"comment\">//标准输出重定向到文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">freopen (<span class=\"string\">&quot;readfile.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,<span class=\"built_in\">stdin</span>);<span class=\"comment\">//标准输入重定向到文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">freopen (<span class=\"string\">&quot;errdfile.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,<span class=\"built_in\">stderr</span>);<span class=\"comment\">//标准错误输出重定向到文件</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重定位-文件流位置指示器-stream-position-indicator\"><a href=\"#重定位-文件流位置指示器-stream-position-indicator\" class=\"headerlink\" title=\"重定位 文件流位置指示器(stream position indicator)\"></a>重定位 文件流位置指示器(stream position indicator)</h2><h3 id=\"文件的抽象内存结构\"><a href=\"#文件的抽象内存结构\" class=\"headerlink\" title=\"文件的抽象内存结构\"></a>文件的抽象内存结构</h3><p>首先我们要明确一下文件的内存结构，如下图</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-20_21-23-32.png\"></p>\n<p>这里及下文用图中的<code>ptr</code>代指标题的中的 <code>文件流位置指示器</code>,这个<code>ptr</code>决定了每一次对文件的<code>读/写</code>操作的<strong>起点</strong>,同时每一次<code>读/写</code>操作都会使<code>ptr</code>自动往后走，因此要显示控制<code>ptr</code>，就得使用<code>fseek,fsetpos</code>等接口</p>\n<h2 id=\"fseek-重定位\"><a href=\"#fseek-重定位\" class=\"headerlink\" title=\"fseek 重定位\"></a>fseek 重定位</h2><p><code>int fseek ( FILE *pFile, long int offset, int origin );</code></p>\n<p><code>fseek</code>能过直接重定位<code>ptr</code>所指的</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><ul>\n<li><code>pFile</code>：用于控制文件的<code>FILE*</code>类型指针</li>\n<li><code>offset</code>：则是<strong>偏移量</strong>，长整型，表示偏移多少字节</li>\n<li><code>origin</code>：该形参标注了<strong>偏移量</strong>相对于哪个位置计算<strong>实际位置</strong></li>\n</ul>\n<p><code>origin</code>有三个宏可以选<br>| 宏 | 实际位置 |<br>| <code>SEEK_SET</code> | 偏移量从<code>文件头</code>开始算 |<br>| <code>SEEK_CUR</code> | 偏移量从<code>当前文件指针ptr(上文介绍的)所在位置</code>开始算 |<br>| <code>SEEK_END</code> | 偏移量从<code>文件尾</code>开始算 |</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><ul>\n<li>成功时,返回<code>0</code></li>\n<li>失败时，返回<code>非零值</code>，同时，<strong>这条语句失效</strong>,上文说的<code>ptr</code>没有改变</li>\n</ul>\n<h2 id=\"fgetpos-和-fsetpos-设置-ptr\"><a href=\"#fgetpos-和-fsetpos-设置-ptr\" class=\"headerlink\" title=\"fgetpos 和 fsetpos 设置 ptr\"></a>fgetpos 和 fsetpos 设置 ptr</h2><p>可以用<code>fgetpos</code>获取<code>ptr</code>的当前位置，并使用<code>输出型参数</code>输出一个<code>fpos_t</code>类型的变量，而<code>fsetpos</code>可以用<code>fpos_t</code>类型的形参设置<code>ptr</code>的当前位置</p>\n<p>就好比<code>ptr</code>是当前坐标，每次<code>fgetpos</code>得到一个传送点信息，而<code>fsetpos</code>就可以用这个传送点信息传送<code>ptr</code>过去</p>\n<p><em>示例如下</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//准备一个文件</span></span><br><span class=\"line\">\tFILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> code = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>* msg = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">fprintf</span>(pfile, <span class=\"string\">&quot;get msg : %s code:%d&quot;</span>, msg, code);</span><br><span class=\"line\">\tfclose(pfile);</span><br><span class=\"line\">\t<span class=\"comment\">//===========</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">fpos_t</span> pos1,pos2;</span><br><span class=\"line\">\tpfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfgetpos(pfile, &amp;pos1);</span><br><span class=\"line\">\tfgetc(pfile);</span><br><span class=\"line\">\tfgetpos(pfile, &amp;pos2);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tfsetpos(pfile, &amp;pos2);<span class=\"comment\">//循环令ptr指向第二个字符</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;第2个字符为: %c\\n&quot;</span>, fgetc(pfile));</span><br><span class=\"line\">\t&#125;                                                     </span><br><span class=\"line\">\tfsetpos(pfile, &amp;pos1);<span class=\"comment\">//令ptr指向第一个字符</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;第1个字符为: %c\\n&quot;</span>, fgetc(pfile));</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(pfile);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第2个字符为: e</span><br><span class=\"line\">第2个字符为: e</span><br><span class=\"line\">第2个字符为: e</span><br><span class=\"line\">第1个字符为: g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"fclose-关闭文件流\"><a href=\"#fclose-关闭文件流\" class=\"headerlink\" title=\"fclose 关闭文件流\"></a>fclose 关闭文件流</h2><p>可以用<code>fclose</code>显式地关闭文件流</p>\n<p>用法为<code>fclose(pFile);</code></p>\n<p>进程正常退出时，也会自动关闭文件流</p>\n<h2 id=\"fprintf-格式化输出字符串\"><a href=\"#fprintf-格式化输出字符串\" class=\"headerlink\" title=\"fprintf 格式化输出字符串\"></a>fprintf 格式化输出字符串</h2><p><code>fprintf</code>能格式化输出字符串到指定文件流，除了要<strong>指定</strong>文件流，格式化字符串的方式和<code>printf</code>一样</p>\n<ul>\n<li>且<code>fprintf(stdout,format,...)</code>和<code>printf(format,...)</code>效果一样</li>\n</ul>\n<h2 id=\"fputs-输出字符串\"><a href=\"#fputs-输出字符串\" class=\"headerlink\" title=\"fputs 输出字符串\"></a>fputs 输出字符串</h2><p><code>int fputs ( const char * str, FILE * stream );</code></p>\n<p><code>fputs</code>能将<code>C语言</code>的字符串输入到指定文件流中</p>\n<h2 id=\"fwrite-输出内存数据块\"><a href=\"#fwrite-输出内存数据块\" class=\"headerlink\" title=\"fwrite 输出内存数据块\"></a>fwrite 输出内存数据块</h2><p><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code></p>\n<ul>\n<li><code>ptr</code>是指向<code>内存数据块</code>的指针</li>\n<li><code>size</code>是每个<code>数组元素</code>的大小</li>\n<li><code>nmemb</code>是元素数量</li>\n<li><code>stream</code>是文件流</li>\n</ul>\n<p>fwrite可以向指定文件流输入特定大小的内存数据块</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tFILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">\tfwrite(msg, <span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>), <span class=\"built_in\">strlen</span>(msg), pfile);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(pfile);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"fscanf-格式化输入\"><a href=\"#fscanf-格式化输入\" class=\"headerlink\" title=\"fscanf 格式化输入\"></a>fscanf 格式化输入</h2><p><code>fscanf</code>能像<code>scanf</code>读取标准输入流一样,读取指定文件流</p>\n<ul>\n<li>且<code>scanf(stdin,format,...)</code>和<code>printf(format,...)</code>效果一样</li>\n</ul>\n<h2 id=\"fegts-获取一行\"><a href=\"#fegts-获取一行\" class=\"headerlink\" title=\"fegts 获取一行\"></a>fegts 获取一行</h2><p><code>char * fgets (char *str, int num, FILE *stream );</code></p>\n<h3 id=\"行为\"><a href=\"#行为\" class=\"headerlink\" title=\"行为\"></a>行为</h3><p><code>fegts</code>会一直读取直到<code>换行符</code>或<code>EOF文件结尾</code>结束读取，但<code>换行符</code>作为<strong>非法</strong>字符不会被拷贝到形参<code>str</code>中</p>\n<ul>\n<li>字符串结尾的<code>\\0</code>会被自动添加,且<strong>计算</strong>在读入的<strong>最大字符数</strong></li>\n<li><code>fgets</code>和<code>gets</code>有很大差别，它需要<strong>指定</strong>最大的读入字符数</li>\n</ul>\n<h3 id=\"形参\"><a href=\"#形参\" class=\"headerlink\" title=\"形参\"></a>形参</h3><ul>\n<li><code>str</code>为传入的字符数组作为缓冲区</li>\n<li><code>num</code>为拷贝的最大字符数，<strong>包括</strong>自动添加的结尾<code>\\0</code></li>\n<li><code>stream</code>为指定的文件流</li>\n</ul>\n<h3 id=\"返回值-1\"><a href=\"#返回值-1\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><ul>\n<li>成功时，返回<code>str</code>的值</li>\n<li>失败时，返回<code>NULL</code></li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//准备一个文件</span></span><br><span class=\"line\">\tFILE* pfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//&quot;w&quot;模式打开文件file.txt</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> code = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>* msg = <span class=\"string\">&quot;this is a msg&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">fprintf</span>(pfile, <span class=\"string\">&quot;get msg : %s code:%d&quot;</span>, msg, code);</span><br><span class=\"line\">\tfclose(pfile);</span><br><span class=\"line\">\t<span class=\"comment\">//=====</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tpfile = fopen(<span class=\"string\">&quot;file.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">char</span> str[<span class=\"number\">5</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\tfgets(str, <span class=\"keyword\">sizeof</span>(str), pfile);<span class=\"comment\">//除去自动添加的\\0,最多从文件里读入4个字符</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(str);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;|&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get |</span><br></pre></td></tr></table></figure>\n"},{"title":"=C++= sizeof关键字详解","date":"2024-07-10T07:30:19.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-11_16-05-28.png","_content":"## 简介\n`sizeof`作为C/C++关键字,基本用法是求`字节大小`，但仅仅这一项用法在细节上就有很多说法了\n\n## 求内置类型变量的大小\n有两种写法，以`int a = 0`的变量`a`为例\n\n+ `sizeof a`\n+ `sizeof(a)`\n\n都可以求变量`a`的大小，但**注意**，该变量的大小仅与`变量类型`有关，而与值无关\n\n## 求内置类型的大小\n求类型大小时必须**加上括号**\n\n例如`sizeof(int)`\n\n## 求数组的大小\n+ 当数组声明在`全局`或`sizeof`处于数组声明语句的`局部作用范围`时,能够用`sizeof(<数组名>)`求数组大小\n+ 当数组名经过**函数传参**或`加减常量运算`后，退化为`指针变量`,类型大小在`32位机器`中为`4`,`64位机器`中为`8`\n\n```C\n#include <iostream>\n\nusing namespace std;\n\nint g_arr[10] = { 0 };\n\nvoid func(int st_arr[])\n{\n\tcout << sizeof(st_arr) << endl;//此处退化为指针变量，输出4或8\n}\n\nint main()\n{\n\tint arr[10] = { 0 };\n\tcout << sizeof(g_arr) << endl;//输出40\n\tcout << sizeof(arr) << endl; //输出40\n\tfunc(arr);//输出4/8\n\treturn 0;\n}\n```\n\n## 求类/对象的大小\n\n### 一般情况的内存对齐\n为了访问效率问题，类的大小遵循`内存对齐`规则，计算理论大小时需考虑`成员变量的大小`和`内存对齐`,而不考虑普通成员函数,这里不详细讨论\n\n## 含有虚函数\nC++的编译器一旦发现一个类型中**有虚函数**，就会为该类型生成`虚函数表`，每一个实例化出的`对象`都含有一个`指向虚函数表的指针`。所以`sizeof`求出来的值还要考虑`该指针`以及`内存对齐`等因素\n\n### 没有成员变量的特殊情况\n\n#### 没有成员函数\n这样的类型可以称为`空类型`,因为这样的类型实例化后不含任何信息,本来求`sizeof`应该是`O`，但考虑实际使用时，我们需将类**实例化**为对象，它必须在内存中占有一定的空间，否则无法使用或管理这些实例。至于分配内存，由编译器决定。但出于节省不必要的内存占用原则，理应分配最小内存单元，即`1字节`。正好在`VisualStudio`中，每个空类型的实例占用`1字节`的空间。\n\n```C++\nclass A\n{\n    //空类型\n};\nsizeof(A);//visual studio 中值为1\n```\n\n#### 只有普通的成员函数\n和上一条一样也是`1字节`。因为考虑实例化时，调用这些普通成员函数只需知道`函数地址`即可，而这些函数地址只与用户自定义的`类`有关，而与实例化出来的`对象`无关，所以不会在`对象`中存储相关信息，不会改变其大小。\n\n#### 含有虚函数\n实例化出的`对象`含有了指向虚函数的`指针`,所以`sizeof`求出来的大小为一个`指针`的大小，`32位机器`求得`4`字节,`64位机器`求得`8`字节","source":"_posts/cppsizeof.md","raw":"---\ntitle: =C++= sizeof关键字详解\ndate: 2024-07-10 15:30:19\ntags:\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-11_16-05-28.png\n---\n## 简介\n`sizeof`作为C/C++关键字,基本用法是求`字节大小`，但仅仅这一项用法在细节上就有很多说法了\n\n## 求内置类型变量的大小\n有两种写法，以`int a = 0`的变量`a`为例\n\n+ `sizeof a`\n+ `sizeof(a)`\n\n都可以求变量`a`的大小，但**注意**，该变量的大小仅与`变量类型`有关，而与值无关\n\n## 求内置类型的大小\n求类型大小时必须**加上括号**\n\n例如`sizeof(int)`\n\n## 求数组的大小\n+ 当数组声明在`全局`或`sizeof`处于数组声明语句的`局部作用范围`时,能够用`sizeof(<数组名>)`求数组大小\n+ 当数组名经过**函数传参**或`加减常量运算`后，退化为`指针变量`,类型大小在`32位机器`中为`4`,`64位机器`中为`8`\n\n```C\n#include <iostream>\n\nusing namespace std;\n\nint g_arr[10] = { 0 };\n\nvoid func(int st_arr[])\n{\n\tcout << sizeof(st_arr) << endl;//此处退化为指针变量，输出4或8\n}\n\nint main()\n{\n\tint arr[10] = { 0 };\n\tcout << sizeof(g_arr) << endl;//输出40\n\tcout << sizeof(arr) << endl; //输出40\n\tfunc(arr);//输出4/8\n\treturn 0;\n}\n```\n\n## 求类/对象的大小\n\n### 一般情况的内存对齐\n为了访问效率问题，类的大小遵循`内存对齐`规则，计算理论大小时需考虑`成员变量的大小`和`内存对齐`,而不考虑普通成员函数,这里不详细讨论\n\n## 含有虚函数\nC++的编译器一旦发现一个类型中**有虚函数**，就会为该类型生成`虚函数表`，每一个实例化出的`对象`都含有一个`指向虚函数表的指针`。所以`sizeof`求出来的值还要考虑`该指针`以及`内存对齐`等因素\n\n### 没有成员变量的特殊情况\n\n#### 没有成员函数\n这样的类型可以称为`空类型`,因为这样的类型实例化后不含任何信息,本来求`sizeof`应该是`O`，但考虑实际使用时，我们需将类**实例化**为对象，它必须在内存中占有一定的空间，否则无法使用或管理这些实例。至于分配内存，由编译器决定。但出于节省不必要的内存占用原则，理应分配最小内存单元，即`1字节`。正好在`VisualStudio`中，每个空类型的实例占用`1字节`的空间。\n\n```C++\nclass A\n{\n    //空类型\n};\nsizeof(A);//visual studio 中值为1\n```\n\n#### 只有普通的成员函数\n和上一条一样也是`1字节`。因为考虑实例化时，调用这些普通成员函数只需知道`函数地址`即可，而这些函数地址只与用户自定义的`类`有关，而与实例化出来的`对象`无关，所以不会在`对象`中存储相关信息，不会改变其大小。\n\n#### 含有虚函数\n实例化出的`对象`含有了指向虚函数的`指针`,所以`sizeof`求出来的大小为一个`指针`的大小，`32位机器`求得`4`字节,`64位机器`求得`8`字节","slug":"cppsizeof","published":1,"updated":"2024-07-11T08:06:02.500Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p088000m4sp5e4sf41g3","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><code>sizeof</code>作为C&#x2F;C++关键字,基本用法是求<code>字节大小</code>，但仅仅这一项用法在细节上就有很多说法了</p>\n<h2 id=\"求内置类型变量的大小\"><a href=\"#求内置类型变量的大小\" class=\"headerlink\" title=\"求内置类型变量的大小\"></a>求内置类型变量的大小</h2><p>有两种写法，以<code>int a = 0</code>的变量<code>a</code>为例</p>\n<ul>\n<li><code>sizeof a</code></li>\n<li><code>sizeof(a)</code></li>\n</ul>\n<p>都可以求变量<code>a</code>的大小，但<strong>注意</strong>，该变量的大小仅与<code>变量类型</code>有关，而与值无关</p>\n<h2 id=\"求内置类型的大小\"><a href=\"#求内置类型的大小\" class=\"headerlink\" title=\"求内置类型的大小\"></a>求内置类型的大小</h2><p>求类型大小时必须<strong>加上括号</strong></p>\n<p>例如<code>sizeof(int)</code></p>\n<h2 id=\"求数组的大小\"><a href=\"#求数组的大小\" class=\"headerlink\" title=\"求数组的大小\"></a>求数组的大小</h2><ul>\n<li>当数组声明在<code>全局</code>或<code>sizeof</code>处于数组声明语句的<code>局部作用范围</code>时,能够用<code>sizeof(&lt;数组名&gt;)</code>求数组大小</li>\n<li>当数组名经过<strong>函数传参</strong>或<code>加减常量运算</code>后，退化为<code>指针变量</code>,类型大小在<code>32位机器</code>中为<code>4</code>,<code>64位机器</code>中为<code>8</code></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> g_arr[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> st_arr[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(st_arr) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//此处退化为指针变量，输出4或8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(g_arr) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//输出40</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(arr) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//输出40</span></span><br><span class=\"line\">\tfunc(arr);<span class=\"comment\">//输出4/8</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求类-对象的大小\"><a href=\"#求类-对象的大小\" class=\"headerlink\" title=\"求类&#x2F;对象的大小\"></a>求类&#x2F;对象的大小</h2><h3 id=\"一般情况的内存对齐\"><a href=\"#一般情况的内存对齐\" class=\"headerlink\" title=\"一般情况的内存对齐\"></a>一般情况的内存对齐</h3><p>为了访问效率问题，类的大小遵循<code>内存对齐</code>规则，计算理论大小时需考虑<code>成员变量的大小</code>和<code>内存对齐</code>,而不考虑普通成员函数,这里不详细讨论</p>\n<h2 id=\"含有虚函数\"><a href=\"#含有虚函数\" class=\"headerlink\" title=\"含有虚函数\"></a>含有虚函数</h2><p>C++的编译器一旦发现一个类型中<strong>有虚函数</strong>，就会为该类型生成<code>虚函数表</code>，每一个实例化出的<code>对象</code>都含有一个<code>指向虚函数表的指针</code>。所以<code>sizeof</code>求出来的值还要考虑<code>该指针</code>以及<code>内存对齐</code>等因素</p>\n<h3 id=\"没有成员变量的特殊情况\"><a href=\"#没有成员变量的特殊情况\" class=\"headerlink\" title=\"没有成员变量的特殊情况\"></a>没有成员变量的特殊情况</h3><h4 id=\"没有成员函数\"><a href=\"#没有成员函数\" class=\"headerlink\" title=\"没有成员函数\"></a>没有成员函数</h4><p>这样的类型可以称为<code>空类型</code>,因为这样的类型实例化后不含任何信息,本来求<code>sizeof</code>应该是<code>O</code>，但考虑实际使用时，我们需将类<strong>实例化</strong>为对象，它必须在内存中占有一定的空间，否则无法使用或管理这些实例。至于分配内存，由编译器决定。但出于节省不必要的内存占用原则，理应分配最小内存单元，即<code>1字节</code>。正好在<code>VisualStudio</code>中，每个空类型的实例占用<code>1字节</code>的空间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//空类型</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">sizeof</span>(A);<span class=\"comment\">//visual studio 中值为1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"只有普通的成员函数\"><a href=\"#只有普通的成员函数\" class=\"headerlink\" title=\"只有普通的成员函数\"></a>只有普通的成员函数</h4><p>和上一条一样也是<code>1字节</code>。因为考虑实例化时，调用这些普通成员函数只需知道<code>函数地址</code>即可，而这些函数地址只与用户自定义的<code>类</code>有关，而与实例化出来的<code>对象</code>无关，所以不会在<code>对象</code>中存储相关信息，不会改变其大小。</p>\n<h4 id=\"含有虚函数-1\"><a href=\"#含有虚函数-1\" class=\"headerlink\" title=\"含有虚函数\"></a>含有虚函数</h4><p>实例化出的<code>对象</code>含有了指向虚函数的<code>指针</code>,所以<code>sizeof</code>求出来的大小为一个<code>指针</code>的大小，<code>32位机器</code>求得<code>4</code>字节,<code>64位机器</code>求得<code>8</code>字节</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><code>sizeof</code>作为C&#x2F;C++关键字,基本用法是求<code>字节大小</code>，但仅仅这一项用法在细节上就有很多说法了</p>\n<h2 id=\"求内置类型变量的大小\"><a href=\"#求内置类型变量的大小\" class=\"headerlink\" title=\"求内置类型变量的大小\"></a>求内置类型变量的大小</h2><p>有两种写法，以<code>int a = 0</code>的变量<code>a</code>为例</p>\n<ul>\n<li><code>sizeof a</code></li>\n<li><code>sizeof(a)</code></li>\n</ul>\n<p>都可以求变量<code>a</code>的大小，但<strong>注意</strong>，该变量的大小仅与<code>变量类型</code>有关，而与值无关</p>\n<h2 id=\"求内置类型的大小\"><a href=\"#求内置类型的大小\" class=\"headerlink\" title=\"求内置类型的大小\"></a>求内置类型的大小</h2><p>求类型大小时必须<strong>加上括号</strong></p>\n<p>例如<code>sizeof(int)</code></p>\n<h2 id=\"求数组的大小\"><a href=\"#求数组的大小\" class=\"headerlink\" title=\"求数组的大小\"></a>求数组的大小</h2><ul>\n<li>当数组声明在<code>全局</code>或<code>sizeof</code>处于数组声明语句的<code>局部作用范围</code>时,能够用<code>sizeof(&lt;数组名&gt;)</code>求数组大小</li>\n<li>当数组名经过<strong>函数传参</strong>或<code>加减常量运算</code>后，退化为<code>指针变量</code>,类型大小在<code>32位机器</code>中为<code>4</code>,<code>64位机器</code>中为<code>8</code></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> g_arr[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> st_arr[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(st_arr) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//此处退化为指针变量，输出4或8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(g_arr) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">//输出40</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(arr) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//输出40</span></span><br><span class=\"line\">\tfunc(arr);<span class=\"comment\">//输出4/8</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求类-对象的大小\"><a href=\"#求类-对象的大小\" class=\"headerlink\" title=\"求类&#x2F;对象的大小\"></a>求类&#x2F;对象的大小</h2><h3 id=\"一般情况的内存对齐\"><a href=\"#一般情况的内存对齐\" class=\"headerlink\" title=\"一般情况的内存对齐\"></a>一般情况的内存对齐</h3><p>为了访问效率问题，类的大小遵循<code>内存对齐</code>规则，计算理论大小时需考虑<code>成员变量的大小</code>和<code>内存对齐</code>,而不考虑普通成员函数,这里不详细讨论</p>\n<h2 id=\"含有虚函数\"><a href=\"#含有虚函数\" class=\"headerlink\" title=\"含有虚函数\"></a>含有虚函数</h2><p>C++的编译器一旦发现一个类型中<strong>有虚函数</strong>，就会为该类型生成<code>虚函数表</code>，每一个实例化出的<code>对象</code>都含有一个<code>指向虚函数表的指针</code>。所以<code>sizeof</code>求出来的值还要考虑<code>该指针</code>以及<code>内存对齐</code>等因素</p>\n<h3 id=\"没有成员变量的特殊情况\"><a href=\"#没有成员变量的特殊情况\" class=\"headerlink\" title=\"没有成员变量的特殊情况\"></a>没有成员变量的特殊情况</h3><h4 id=\"没有成员函数\"><a href=\"#没有成员函数\" class=\"headerlink\" title=\"没有成员函数\"></a>没有成员函数</h4><p>这样的类型可以称为<code>空类型</code>,因为这样的类型实例化后不含任何信息,本来求<code>sizeof</code>应该是<code>O</code>，但考虑实际使用时，我们需将类<strong>实例化</strong>为对象，它必须在内存中占有一定的空间，否则无法使用或管理这些实例。至于分配内存，由编译器决定。但出于节省不必要的内存占用原则，理应分配最小内存单元，即<code>1字节</code>。正好在<code>VisualStudio</code>中，每个空类型的实例占用<code>1字节</code>的空间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//空类型</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">sizeof</span>(A);<span class=\"comment\">//visual studio 中值为1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"只有普通的成员函数\"><a href=\"#只有普通的成员函数\" class=\"headerlink\" title=\"只有普通的成员函数\"></a>只有普通的成员函数</h4><p>和上一条一样也是<code>1字节</code>。因为考虑实例化时，调用这些普通成员函数只需知道<code>函数地址</code>即可，而这些函数地址只与用户自定义的<code>类</code>有关，而与实例化出来的<code>对象</code>无关，所以不会在<code>对象</code>中存储相关信息，不会改变其大小。</p>\n<h4 id=\"含有虚函数-1\"><a href=\"#含有虚函数-1\" class=\"headerlink\" title=\"含有虚函数\"></a>含有虚函数</h4><p>实例化出的<code>对象</code>含有了指向虚函数的<code>指针</code>,所以<code>sizeof</code>求出来的大小为一个<code>指针</code>的大小，<code>32位机器</code>求得<code>4</code>字节,<code>64位机器</code>求得<code>8</code>字节</p>\n"},{"title":"从构建一个Date类入门C++类与对象","date":"2023-12-06T23:42:59.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Date.jpg","_content":"# 类的定义 #\n```C++\nclass Date\n{\npublic:\n    void Init(int year = 1,int month = 1,int day = 1)\n    {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n\n    void Print()\n    {\n        cout << _year << \":\" << _month << \":\" << _day << endl;\n    }\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n```\n## 抽象数据类型(类) #\n通过如上代码，我们就在源代码中通过`class`声明了一个抽象数据类型`Date`,简称`类`，那么封装一个类有什么好处呢？\n好处是类把相关的操作分为**两类**:\n\n- 类的**设计者**:负责考虑类的具体实现，提供类的接口，成员变量等\n- 类的**使用者**:只关心类**提供**了哪些功能，而不关心具体实现，从而简化思路\n  \n以上面的`Date`类为例\n>对设计者\n- 要考虑实现`Date`,就需要声明**成员变量**`_year` `_month` `_day`,以及声明及实现**成员函数**`Init`和`Print`\n  \n>对使用者\n- 只需知道可以调用`Date`的**成员函数**`Init`和`Print`,以及知道它们的用处即可\n\n## 实例化 -- 将类真正投入使用 ##\n类也可以用于声明变量，例如`Date d`就声明了一个变量`d`,但由于是由`类`声明的,我们将这一过程称为`实例化`,其中`Date`这样的抽象数据类型称为`类`，像`d`这样的变量称为`对象`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-16_11-19-21.png)\n\n实例化后的对象拥有**私有**的`成员变量`和整个类**公有**的`成员函数`,接下来对`对象`的操作都是对`成员变量`和`成员函数`的操作\n\n## 访问成员函数/变量\n\n### 在`类的内部`\n对于类的成员函数，除了显式声明的`函数参数`外,还有**隐式**传入的`this`指针，这是个**默认`非const`修饰**的,指向调用该成员函数的**对象的指针**,编译器可以通过这个指针访问该对象的`成员变量`和`成员函数`。\n\n\n而我们作为类的**设计者**，既然语法都**隐式**地传入`this`指针了，自然也可以**隐式**地调用`成员`,即**直接写**变量名/函数名调用\n\n*当然，手动显式调用this指针也是可以的*\n\n>以`Date`为例\n```C++\n//该函数声明在Date类中，成员变量见文章开头\nvoid TestPrint()\n{\n    _year = 2024;//隐式调用this访问成员变量\n    this->_month = 4;//显式调用this\n    _day = 1;\n    Print();//隐式调用this来调用成员函数Print()\n    this->Print();//显式调用this，效果与上一句相同\n}\n```\n但由于`const`修饰的`对象`传出的是`const`修饰的`this`指针，普通的`this`形参无法接收。\n那么如何让`成员函数`传入`const`修饰的`this`指针,来使`const`修饰的`对象`有成员函数可调用呢？\n\n语法规定，在函数的参数列表(*圆括号后面*)紧跟一个`const`可使函数传入`const`修饰的`this`指针\n\n*这种函数称为常量成员函数*\n\n>*举个例子*\n```C++\n//示例代码\n//该函数声明在类中\nvoid constPrint() const\n{\n    //....\n}\n```\n\n### 在`类的外部`\n和C语言的结构体一样，访问对象内的成员有两种方式\n\n- *对象名* + `.` + 成员名 ： 用`.`操作符访问对应成员\n- *对象的指针* + `->` + 成员名 : 用`->`操作符访问指针**指向对象**的对应成员\n\n>以`Date`实例化一个`d`为例\n\n```C++\n// class Date\n// {\n//     ....\n// };\n\nvoid test1()\n{\n    Date d;\n    Date* pd = &d;\n    d.Init(2024,4,1);// . 操作符调用Init成员函数来初始化对象\n    pd->Print();//->操作符调用Print成员函数来打印内容\n}\n\nvoid test2()\n{\n    Date d;\n    d._year = 2024;//试图访问成员变量_year,但是访问权限冲突\n}\n```\n```C++\n//test1输出\n2024:4:1\n//test2输出\n报错，无输出，因为访问权限冲突\n```\n\n代码如上，`test1`运行的很好，但`test2`报错了，原因在于`test2`作为**非成员函数**访问了访问限定符`private`控制的成员`_year`,权限冲突，就会报错。\n\n由此，C++类和对象还有一个重要概念需要强调--**访问控制**\n\n## 访问权限控制与封装 ##\n使用类和对象编程的一大优点就是类可以`封装`代码，让使用者只能使用公有的接口和成员变量，而对内部的具体实现不可见，来提高类的`易用性`和`安全性`\n\n所以C++语法提供了三种`访问说明符`(*access specifiers*)\n\n- public: 该说明符之后的成员在整个程序内可被访问\n- private: 之后的成员仅可被该类的的类域里（*如成员函数*）访问\n- protected: 一般同`private`,主要特点体现在类的继承，这里**不作讨论**\n\n### 作用范围 #\n\n某一`访问说明符`的作用范围开始于它的`冒号`,终止于下一个`访问说明符`或`类的结尾`,而`类的开始`到第一个`访问说明符`前的访问权限取决于**声明**类的`关键字`,分类如下\n\n- `class`默认为`private`权限\n- `struct`默认为`public`权限\n\n> 图例如下\n> \n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-18_14-15-40.png)\n\n\n实际上`class`和`struct`除了默认权限不一样，基本**没有差别**。\n\n所以为了防止误读，**提高可读性**,**不建议**在`默认区`写代码,而是保证每段语句前都有合适的`访问限定符`\n\n### 封装 #\n作为类的设计者，一个类按`访问权限`可以分为两个区\n\n- `public`: 将提供给`使用者`的`接口（函数）`和`成员变量`声明在此，用于外部调用接口和修改非私有的成员函数\n- `private`: 用于存放**受保护**的`成员变量`和`成员函数`,防止外部使用者*意外*或*恶意*调用或修改,造成类的内部结构被破坏等**安全问题**,所以特别重要的成员变量，和不希望被外部调用的函数声明在这里\n\n>例如在声明`Date`类时，我们将`Init`和`Print`接口提供给使用者，用`public`控制；`_year`等成员变量不希望被外部随意修改，就用`private`控制\n\n\n# 进阶 #\n学完以上内容，不过是会写个高级点的`结构体`而已，要写一个完整的类，还需要学习更多的语法知识\n\n## 构造函数 #\n像本篇的`Date`类那样显式地调用`Init`函数来初始化是非常挫的，既然语言本身的`内置类型`可以在声明的时候初始化，那么类的设计者设计出来的类也应当提供`初始化的接口`,而支持这一功能的接口便是`构造函数`\n\n按语法规定，`构造函数`的函数名必须是`类名`,**没有返回值**，`const`修饰的成员变量必须位于`初始化列表`,其它则可省略。*关于初始化列表，稍后详细解释*\n\n>以`Date`类为例\n```C++\nclass Date\n{\npublic:\n    //一个普通的构造函数\n    Date(int year,int month,int day)\n    {\n        //进入括号时成员变量已经声明，且未初始化\n        _year = year;//这是一个赋值操作，而不是初始化\n        _month = month;\n        _day = day;\n    }\n\nprivate:\n    int _year;\n    int _month;\n    int _day;\n}\n\nint main()\n{\n    Date d(2024,4,1);//使用构造函数声明了一个d对象\n    return 0;\n}\n\n```\n\n以上的构造函数基本能用了,但还有两个问题\n\n- 构造函数没有初始化成员变量，而是采用赋值操作,无法初始化`const`修饰的成员变量\n- 使用`Date d`是会报错的，因为没有提供`默认构造函数`\n\n对于**第一个问题**，就要引入`初始化列表`这一概念，让初始化函数直接拥有`初始化成员变量`的功能\n\n初始化列表位于构造函数的参数列表之后，花括号之前，以`:`开头，用`,`分隔成员变量\n\n>以`Date`为例\n```C++\nDate(int year,int month,int day):_year(year) , _month(month) , _day(day) {}\n//或者换个书写格式（二者完全等价）\nDate(int year,int month,int day):_year(year) \n, _month(month) \n, _day(day) \n{}\n```\n通过这样`初始化列表`,便能在声明对象时，**直接**初始化成员变量\n\n对于**问题二**，我们开启另一个个小专题\n\n### 构造函数的重载和缺省参数 #\n没错，构造函数和函数一样，也是能`重载`和给参数传`缺省值`的\n\n*也就是说我们能写好几个构造函数*\n\n下面特别说明几个**特殊**的构造函数\n\n#### 默认构造函数 #\n原则上对于每一个类，都应该提供**有且仅有一个**默认构造函数（*多个`默认构造函数`会报错!*）\n\n而要**声明**默认构造函数，只需声明`无参数`构造函数，或者`全缺省参数`构造函数即可\n\n>以`Date`为例\n```C++\nDate():_year(2024),_month(4),_day(1){}\n//====分割线=======\n//或者全缺省，两个函数不能同时声明\nDate(int year = 2024,int month = 4,int day = 1): _year(year),_month(month),_day(day){}\n\n```\n\n以上就是两种默认构造函数的声明形式\n\n#### 拷贝构造函数 #\n有时候我们会希望用**现有的**的对象去初始化一个**新**对象,此时对应的构造函数就称为`拷贝构造（函数）`\n\n`拷贝构造`的声明方式为`构造函数`+参数类型为`类本身的引用传参`,不加`&`的话就会死递归报错,有无`const`皆可，但由于是实现`拷贝功能`，一般是加`const`的\n\n>以`Date`为例\n```C++\nDate(const Date& d):_year(d._year),_month(d._month),_day(d._day){}\n\n//使用示例\nDate d(2024,4,1);\nDate copy1(d);//调用方式一\nDate copy2 = d;//调用方式二,此时不会调用operator=()\n\ncopy1 = copy2;//这种并不会调用拷贝构造,而是调用operator=()\n\n```\n\n#### 使用模板的类的函数缺省值 #\n有时我们在使用类模板来设计类时，需要给`模版类`类型的形参提供一个缺省值，有些人可能会写个`0`,但是其实是**错的**，正确的做法是传一个`临时变量`\n\n但此时要求`模板参数中的类`有可用的`默认构造函数`和`拷贝构造`用于调用\n\n>以链表节点`Node`为例\n```C++\ntemplate<class value_type>\nstruct Node\n{\n    value_type _val;\n    Node<value_type>* _next;\n\n    Node(const value_type& val = value_type()):_val(val),_next(nullptr){}\n}\n\n//以用本文的Date实例化为例\nNode<Date> node;\n//通过输出会发现node中的val已经调用了默认构造函数\nnode.val.TestPrint();\n```\n\n## 析构函数 #\n对于声明在`栈区`或`静态区`的成员函数，程序完全可以自动销毁，\n但如果`成员变量`有指向在`堆区`声明的某段`内存块`,在该如果只是仍由程序自动\n销毁这个指针，那么那段`内存块`就会一直处于**未释放**的状态，也就是造成内存泄漏，\n也就是说此时编译器自动生成的`析构函数`已经不能满足需求,编译器并不知道如何处理声明在`堆区`上的数据,\n这部分操作应由类的设计者来规划\n\n所以我们应当**显式**地声明一个合理的`析构函数`\n\n`析构函数`的函数名也是由语法规定的，为`~`+`类名`,并且**不能**声明形参\n\n>以一个`指针类`为例\n```C++\nclass Ptr\n{\npublic:\n    Ptr()//构造函数\n    { \n        _ptr = new int(1); \n    }\n\n    ~Ptr()//析构函数\n    {\n        delete _ptr;//手动delte堆区上的数据\n        _ptr = nullptr;\n    }\n\nprivate:\n    int* _ptr;\n}\n```\n\n## 类的重载操作符 #\nC++语法提供了重载操作符的函数，而由于`this`指针的存在，在类的`内部声明`重载操作符函数会稍有不同\n\n-对于一元操作符，`[]`,`->`之类的重载，不再需要`显式传参`\n-对于二元操作符，`+`,`>`之类只需要传`右操作数`\n\n>以`Date`类为例\n```C++\n//在类的内部,重构一个 ==\npublic:\n    bool operator==(const Date& date) const\n    {\n        return _year == date._year\n            && _month == date._month\n            && _day == date._day;\n    }\n```\n\n# 小结\n至此，C++类和对象已基本入门，再进阶的`迭代器`,`继承`,`虚继承`等将单独出博客。\n\n\n","source":"_posts/cpp-class.md","raw":"---\ntitle: 从构建一个Date类入门C++类与对象\ndate: 2023-12-07 07:42:59\ntags: C++ 类和对象\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Date.jpg\n---\n# 类的定义 #\n```C++\nclass Date\n{\npublic:\n    void Init(int year = 1,int month = 1,int day = 1)\n    {\n        _year = year;\n        _month = month;\n        _day = day;\n    }\n\n    void Print()\n    {\n        cout << _year << \":\" << _month << \":\" << _day << endl;\n    }\nprivate:\n    int _year;\n    int _month;\n    int _day;\n};\n```\n## 抽象数据类型(类) #\n通过如上代码，我们就在源代码中通过`class`声明了一个抽象数据类型`Date`,简称`类`，那么封装一个类有什么好处呢？\n好处是类把相关的操作分为**两类**:\n\n- 类的**设计者**:负责考虑类的具体实现，提供类的接口，成员变量等\n- 类的**使用者**:只关心类**提供**了哪些功能，而不关心具体实现，从而简化思路\n  \n以上面的`Date`类为例\n>对设计者\n- 要考虑实现`Date`,就需要声明**成员变量**`_year` `_month` `_day`,以及声明及实现**成员函数**`Init`和`Print`\n  \n>对使用者\n- 只需知道可以调用`Date`的**成员函数**`Init`和`Print`,以及知道它们的用处即可\n\n## 实例化 -- 将类真正投入使用 ##\n类也可以用于声明变量，例如`Date d`就声明了一个变量`d`,但由于是由`类`声明的,我们将这一过程称为`实例化`,其中`Date`这样的抽象数据类型称为`类`，像`d`这样的变量称为`对象`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-16_11-19-21.png)\n\n实例化后的对象拥有**私有**的`成员变量`和整个类**公有**的`成员函数`,接下来对`对象`的操作都是对`成员变量`和`成员函数`的操作\n\n## 访问成员函数/变量\n\n### 在`类的内部`\n对于类的成员函数，除了显式声明的`函数参数`外,还有**隐式**传入的`this`指针，这是个**默认`非const`修饰**的,指向调用该成员函数的**对象的指针**,编译器可以通过这个指针访问该对象的`成员变量`和`成员函数`。\n\n\n而我们作为类的**设计者**，既然语法都**隐式**地传入`this`指针了，自然也可以**隐式**地调用`成员`,即**直接写**变量名/函数名调用\n\n*当然，手动显式调用this指针也是可以的*\n\n>以`Date`为例\n```C++\n//该函数声明在Date类中，成员变量见文章开头\nvoid TestPrint()\n{\n    _year = 2024;//隐式调用this访问成员变量\n    this->_month = 4;//显式调用this\n    _day = 1;\n    Print();//隐式调用this来调用成员函数Print()\n    this->Print();//显式调用this，效果与上一句相同\n}\n```\n但由于`const`修饰的`对象`传出的是`const`修饰的`this`指针，普通的`this`形参无法接收。\n那么如何让`成员函数`传入`const`修饰的`this`指针,来使`const`修饰的`对象`有成员函数可调用呢？\n\n语法规定，在函数的参数列表(*圆括号后面*)紧跟一个`const`可使函数传入`const`修饰的`this`指针\n\n*这种函数称为常量成员函数*\n\n>*举个例子*\n```C++\n//示例代码\n//该函数声明在类中\nvoid constPrint() const\n{\n    //....\n}\n```\n\n### 在`类的外部`\n和C语言的结构体一样，访问对象内的成员有两种方式\n\n- *对象名* + `.` + 成员名 ： 用`.`操作符访问对应成员\n- *对象的指针* + `->` + 成员名 : 用`->`操作符访问指针**指向对象**的对应成员\n\n>以`Date`实例化一个`d`为例\n\n```C++\n// class Date\n// {\n//     ....\n// };\n\nvoid test1()\n{\n    Date d;\n    Date* pd = &d;\n    d.Init(2024,4,1);// . 操作符调用Init成员函数来初始化对象\n    pd->Print();//->操作符调用Print成员函数来打印内容\n}\n\nvoid test2()\n{\n    Date d;\n    d._year = 2024;//试图访问成员变量_year,但是访问权限冲突\n}\n```\n```C++\n//test1输出\n2024:4:1\n//test2输出\n报错，无输出，因为访问权限冲突\n```\n\n代码如上，`test1`运行的很好，但`test2`报错了，原因在于`test2`作为**非成员函数**访问了访问限定符`private`控制的成员`_year`,权限冲突，就会报错。\n\n由此，C++类和对象还有一个重要概念需要强调--**访问控制**\n\n## 访问权限控制与封装 ##\n使用类和对象编程的一大优点就是类可以`封装`代码，让使用者只能使用公有的接口和成员变量，而对内部的具体实现不可见，来提高类的`易用性`和`安全性`\n\n所以C++语法提供了三种`访问说明符`(*access specifiers*)\n\n- public: 该说明符之后的成员在整个程序内可被访问\n- private: 之后的成员仅可被该类的的类域里（*如成员函数*）访问\n- protected: 一般同`private`,主要特点体现在类的继承，这里**不作讨论**\n\n### 作用范围 #\n\n某一`访问说明符`的作用范围开始于它的`冒号`,终止于下一个`访问说明符`或`类的结尾`,而`类的开始`到第一个`访问说明符`前的访问权限取决于**声明**类的`关键字`,分类如下\n\n- `class`默认为`private`权限\n- `struct`默认为`public`权限\n\n> 图例如下\n> \n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-18_14-15-40.png)\n\n\n实际上`class`和`struct`除了默认权限不一样，基本**没有差别**。\n\n所以为了防止误读，**提高可读性**,**不建议**在`默认区`写代码,而是保证每段语句前都有合适的`访问限定符`\n\n### 封装 #\n作为类的设计者，一个类按`访问权限`可以分为两个区\n\n- `public`: 将提供给`使用者`的`接口（函数）`和`成员变量`声明在此，用于外部调用接口和修改非私有的成员函数\n- `private`: 用于存放**受保护**的`成员变量`和`成员函数`,防止外部使用者*意外*或*恶意*调用或修改,造成类的内部结构被破坏等**安全问题**,所以特别重要的成员变量，和不希望被外部调用的函数声明在这里\n\n>例如在声明`Date`类时，我们将`Init`和`Print`接口提供给使用者，用`public`控制；`_year`等成员变量不希望被外部随意修改，就用`private`控制\n\n\n# 进阶 #\n学完以上内容，不过是会写个高级点的`结构体`而已，要写一个完整的类，还需要学习更多的语法知识\n\n## 构造函数 #\n像本篇的`Date`类那样显式地调用`Init`函数来初始化是非常挫的，既然语言本身的`内置类型`可以在声明的时候初始化，那么类的设计者设计出来的类也应当提供`初始化的接口`,而支持这一功能的接口便是`构造函数`\n\n按语法规定，`构造函数`的函数名必须是`类名`,**没有返回值**，`const`修饰的成员变量必须位于`初始化列表`,其它则可省略。*关于初始化列表，稍后详细解释*\n\n>以`Date`类为例\n```C++\nclass Date\n{\npublic:\n    //一个普通的构造函数\n    Date(int year,int month,int day)\n    {\n        //进入括号时成员变量已经声明，且未初始化\n        _year = year;//这是一个赋值操作，而不是初始化\n        _month = month;\n        _day = day;\n    }\n\nprivate:\n    int _year;\n    int _month;\n    int _day;\n}\n\nint main()\n{\n    Date d(2024,4,1);//使用构造函数声明了一个d对象\n    return 0;\n}\n\n```\n\n以上的构造函数基本能用了,但还有两个问题\n\n- 构造函数没有初始化成员变量，而是采用赋值操作,无法初始化`const`修饰的成员变量\n- 使用`Date d`是会报错的，因为没有提供`默认构造函数`\n\n对于**第一个问题**，就要引入`初始化列表`这一概念，让初始化函数直接拥有`初始化成员变量`的功能\n\n初始化列表位于构造函数的参数列表之后，花括号之前，以`:`开头，用`,`分隔成员变量\n\n>以`Date`为例\n```C++\nDate(int year,int month,int day):_year(year) , _month(month) , _day(day) {}\n//或者换个书写格式（二者完全等价）\nDate(int year,int month,int day):_year(year) \n, _month(month) \n, _day(day) \n{}\n```\n通过这样`初始化列表`,便能在声明对象时，**直接**初始化成员变量\n\n对于**问题二**，我们开启另一个个小专题\n\n### 构造函数的重载和缺省参数 #\n没错，构造函数和函数一样，也是能`重载`和给参数传`缺省值`的\n\n*也就是说我们能写好几个构造函数*\n\n下面特别说明几个**特殊**的构造函数\n\n#### 默认构造函数 #\n原则上对于每一个类，都应该提供**有且仅有一个**默认构造函数（*多个`默认构造函数`会报错!*）\n\n而要**声明**默认构造函数，只需声明`无参数`构造函数，或者`全缺省参数`构造函数即可\n\n>以`Date`为例\n```C++\nDate():_year(2024),_month(4),_day(1){}\n//====分割线=======\n//或者全缺省，两个函数不能同时声明\nDate(int year = 2024,int month = 4,int day = 1): _year(year),_month(month),_day(day){}\n\n```\n\n以上就是两种默认构造函数的声明形式\n\n#### 拷贝构造函数 #\n有时候我们会希望用**现有的**的对象去初始化一个**新**对象,此时对应的构造函数就称为`拷贝构造（函数）`\n\n`拷贝构造`的声明方式为`构造函数`+参数类型为`类本身的引用传参`,不加`&`的话就会死递归报错,有无`const`皆可，但由于是实现`拷贝功能`，一般是加`const`的\n\n>以`Date`为例\n```C++\nDate(const Date& d):_year(d._year),_month(d._month),_day(d._day){}\n\n//使用示例\nDate d(2024,4,1);\nDate copy1(d);//调用方式一\nDate copy2 = d;//调用方式二,此时不会调用operator=()\n\ncopy1 = copy2;//这种并不会调用拷贝构造,而是调用operator=()\n\n```\n\n#### 使用模板的类的函数缺省值 #\n有时我们在使用类模板来设计类时，需要给`模版类`类型的形参提供一个缺省值，有些人可能会写个`0`,但是其实是**错的**，正确的做法是传一个`临时变量`\n\n但此时要求`模板参数中的类`有可用的`默认构造函数`和`拷贝构造`用于调用\n\n>以链表节点`Node`为例\n```C++\ntemplate<class value_type>\nstruct Node\n{\n    value_type _val;\n    Node<value_type>* _next;\n\n    Node(const value_type& val = value_type()):_val(val),_next(nullptr){}\n}\n\n//以用本文的Date实例化为例\nNode<Date> node;\n//通过输出会发现node中的val已经调用了默认构造函数\nnode.val.TestPrint();\n```\n\n## 析构函数 #\n对于声明在`栈区`或`静态区`的成员函数，程序完全可以自动销毁，\n但如果`成员变量`有指向在`堆区`声明的某段`内存块`,在该如果只是仍由程序自动\n销毁这个指针，那么那段`内存块`就会一直处于**未释放**的状态，也就是造成内存泄漏，\n也就是说此时编译器自动生成的`析构函数`已经不能满足需求,编译器并不知道如何处理声明在`堆区`上的数据,\n这部分操作应由类的设计者来规划\n\n所以我们应当**显式**地声明一个合理的`析构函数`\n\n`析构函数`的函数名也是由语法规定的，为`~`+`类名`,并且**不能**声明形参\n\n>以一个`指针类`为例\n```C++\nclass Ptr\n{\npublic:\n    Ptr()//构造函数\n    { \n        _ptr = new int(1); \n    }\n\n    ~Ptr()//析构函数\n    {\n        delete _ptr;//手动delte堆区上的数据\n        _ptr = nullptr;\n    }\n\nprivate:\n    int* _ptr;\n}\n```\n\n## 类的重载操作符 #\nC++语法提供了重载操作符的函数，而由于`this`指针的存在，在类的`内部声明`重载操作符函数会稍有不同\n\n-对于一元操作符，`[]`,`->`之类的重载，不再需要`显式传参`\n-对于二元操作符，`+`,`>`之类只需要传`右操作数`\n\n>以`Date`类为例\n```C++\n//在类的内部,重构一个 ==\npublic:\n    bool operator==(const Date& date) const\n    {\n        return _year == date._year\n            && _month == date._month\n            && _day == date._day;\n    }\n```\n\n# 小结\n至此，C++类和对象已基本入门，再进阶的`迭代器`,`继承`,`虚继承`等将单独出博客。\n\n\n","slug":"cpp-class","published":1,"updated":"2024-05-14T02:20:47.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p088000o4sp510an6p9m","content":"<h1 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Init</span><span class=\"params\">(<span class=\"type\">int</span> year = <span class=\"number\">1</span>,<span class=\"type\">int</span> month = <span class=\"number\">1</span>,<span class=\"type\">int</span> day = <span class=\"number\">1</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _year = year;</span><br><span class=\"line\">        _month = month;</span><br><span class=\"line\">        _day = day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Print</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; _year &lt;&lt; <span class=\"string\">&quot;:&quot;</span> &lt;&lt; _month &lt;&lt; <span class=\"string\">&quot;:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _year;</span><br><span class=\"line\">    <span class=\"type\">int</span> _month;</span><br><span class=\"line\">    <span class=\"type\">int</span> _day;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"抽象数据类型-类\"><a href=\"#抽象数据类型-类\" class=\"headerlink\" title=\"抽象数据类型(类)\"></a>抽象数据类型(类)</h2><p>通过如上代码，我们就在源代码中通过<code>class</code>声明了一个抽象数据类型<code>Date</code>,简称<code>类</code>，那么封装一个类有什么好处呢？<br>好处是类把相关的操作分为<strong>两类</strong>:</p>\n<ul>\n<li>类的<strong>设计者</strong>:负责考虑类的具体实现，提供类的接口，成员变量等</li>\n<li>类的<strong>使用者</strong>:只关心类<strong>提供</strong>了哪些功能，而不关心具体实现，从而简化思路</li>\n</ul>\n<p>以上面的<code>Date</code>类为例</p>\n<blockquote>\n<p>对设计者</p>\n</blockquote>\n<ul>\n<li>要考虑实现<code>Date</code>,就需要声明<strong>成员变量</strong><code>_year</code> <code>_month</code> <code>_day</code>,以及声明及实现<strong>成员函数</strong><code>Init</code>和<code>Print</code></li>\n</ul>\n<blockquote>\n<p>对使用者</p>\n</blockquote>\n<ul>\n<li>只需知道可以调用<code>Date</code>的<strong>成员函数</strong><code>Init</code>和<code>Print</code>,以及知道它们的用处即可</li>\n</ul>\n<h2 id=\"实例化-–-将类真正投入使用\"><a href=\"#实例化-–-将类真正投入使用\" class=\"headerlink\" title=\"实例化 – 将类真正投入使用\"></a>实例化 – 将类真正投入使用</h2><p>类也可以用于声明变量，例如<code>Date d</code>就声明了一个变量<code>d</code>,但由于是由<code>类</code>声明的,我们将这一过程称为<code>实例化</code>,其中<code>Date</code>这样的抽象数据类型称为<code>类</code>，像<code>d</code>这样的变量称为<code>对象</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-16_11-19-21.png\"></p>\n<p>实例化后的对象拥有<strong>私有</strong>的<code>成员变量</code>和整个类<strong>公有</strong>的<code>成员函数</code>,接下来对<code>对象</code>的操作都是对<code>成员变量</code>和<code>成员函数</code>的操作</p>\n<h2 id=\"访问成员函数-变量\"><a href=\"#访问成员函数-变量\" class=\"headerlink\" title=\"访问成员函数&#x2F;变量\"></a>访问成员函数&#x2F;变量</h2><h3 id=\"在类的内部\"><a href=\"#在类的内部\" class=\"headerlink\" title=\"在类的内部\"></a>在<code>类的内部</code></h3><p>对于类的成员函数，除了显式声明的<code>函数参数</code>外,还有<strong>隐式</strong>传入的<code>this</code>指针，这是个<strong>默认<code>非const</code>修饰</strong>的,指向调用该成员函数的<strong>对象的指针</strong>,编译器可以通过这个指针访问该对象的<code>成员变量</code>和<code>成员函数</code>。</p>\n<p>而我们作为类的<strong>设计者</strong>，既然语法都<strong>隐式</strong>地传入<code>this</code>指针了，自然也可以<strong>隐式</strong>地调用<code>成员</code>,即<strong>直接写</strong>变量名&#x2F;函数名调用</p>\n<p><em>当然，手动显式调用this指针也是可以的</em></p>\n<blockquote>\n<p>以<code>Date</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//该函数声明在Date类中，成员变量见文章开头</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TestPrint</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    _year = <span class=\"number\">2024</span>;<span class=\"comment\">//隐式调用this访问成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;_month = <span class=\"number\">4</span>;<span class=\"comment\">//显式调用this</span></span><br><span class=\"line\">    _day = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Print</span>();<span class=\"comment\">//隐式调用this来调用成员函数Print()</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">Print</span>();<span class=\"comment\">//显式调用this，效果与上一句相同</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但由于<code>const</code>修饰的<code>对象</code>传出的是<code>const</code>修饰的<code>this</code>指针，普通的<code>this</code>形参无法接收。<br>那么如何让<code>成员函数</code>传入<code>const</code>修饰的<code>this</code>指针,来使<code>const</code>修饰的<code>对象</code>有成员函数可调用呢？</p>\n<p>语法规定，在函数的参数列表(<em>圆括号后面</em>)紧跟一个<code>const</code>可使函数传入<code>const</code>修饰的<code>this</code>指针</p>\n<p><em>这种函数称为常量成员函数</em></p>\n<blockquote>\n<p><em>举个例子</em></p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例代码</span></span><br><span class=\"line\"><span class=\"comment\">//该函数声明在类中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">constPrint</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在类的外部\"><a href=\"#在类的外部\" class=\"headerlink\" title=\"在类的外部\"></a>在<code>类的外部</code></h3><p>和C语言的结构体一样，访问对象内的成员有两种方式</p>\n<ul>\n<li><em>对象名</em> + <code>.</code> + 成员名 ： 用<code>.</code>操作符访问对应成员</li>\n<li><em>对象的指针</em> + <code>-&gt;</code> + 成员名 : 用<code>-&gt;</code>操作符访问指针<strong>指向对象</strong>的对应成员</li>\n</ul>\n<blockquote>\n<p>以<code>Date</code>实例化一个<code>d</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class Date</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     ....</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Date d;</span><br><span class=\"line\">    Date* pd = &amp;d;</span><br><span class=\"line\">    d.<span class=\"built_in\">Init</span>(<span class=\"number\">2024</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>);<span class=\"comment\">// . 操作符调用Init成员函数来初始化对象</span></span><br><span class=\"line\">    pd-&gt;<span class=\"built_in\">Print</span>();<span class=\"comment\">//-&gt;操作符调用Print成员函数来打印内容</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Date d;</span><br><span class=\"line\">    d._year = <span class=\"number\">2024</span>;<span class=\"comment\">//试图访问成员变量_year,但是访问权限冲突</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//test1输出</span></span><br><span class=\"line\"><span class=\"number\">2024</span>:<span class=\"number\">4</span>:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">//test2输出</span></span><br><span class=\"line\">报错，无输出，因为访问权限冲突</span><br></pre></td></tr></table></figure>\n\n<p>代码如上，<code>test1</code>运行的很好，但<code>test2</code>报错了，原因在于<code>test2</code>作为<strong>非成员函数</strong>访问了访问限定符<code>private</code>控制的成员<code>_year</code>,权限冲突，就会报错。</p>\n<p>由此，C++类和对象还有一个重要概念需要强调–<strong>访问控制</strong></p>\n<h2 id=\"访问权限控制与封装\"><a href=\"#访问权限控制与封装\" class=\"headerlink\" title=\"访问权限控制与封装\"></a>访问权限控制与封装</h2><p>使用类和对象编程的一大优点就是类可以<code>封装</code>代码，让使用者只能使用公有的接口和成员变量，而对内部的具体实现不可见，来提高类的<code>易用性</code>和<code>安全性</code></p>\n<p>所以C++语法提供了三种<code>访问说明符</code>(<em>access specifiers</em>)</p>\n<ul>\n<li>public: 该说明符之后的成员在整个程序内可被访问</li>\n<li>private: 之后的成员仅可被该类的的类域里（<em>如成员函数</em>）访问</li>\n<li>protected: 一般同<code>private</code>,主要特点体现在类的继承，这里<strong>不作讨论</strong></li>\n</ul>\n<h3 id=\"作用范围\"><a href=\"#作用范围\" class=\"headerlink\" title=\"作用范围\"></a>作用范围</h3><p>某一<code>访问说明符</code>的作用范围开始于它的<code>冒号</code>,终止于下一个<code>访问说明符</code>或<code>类的结尾</code>,而<code>类的开始</code>到第一个<code>访问说明符</code>前的访问权限取决于<strong>声明</strong>类的<code>关键字</code>,分类如下</p>\n<ul>\n<li><code>class</code>默认为<code>private</code>权限</li>\n<li><code>struct</code>默认为<code>public</code>权限</li>\n</ul>\n<blockquote>\n<p>图例如下</p>\n</blockquote>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-18_14-15-40.png\"></p>\n<p>实际上<code>class</code>和<code>struct</code>除了默认权限不一样，基本<strong>没有差别</strong>。</p>\n<p>所以为了防止误读，<strong>提高可读性</strong>,<strong>不建议</strong>在<code>默认区</code>写代码,而是保证每段语句前都有合适的<code>访问限定符</code></p>\n<h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><p>作为类的设计者，一个类按<code>访问权限</code>可以分为两个区</p>\n<ul>\n<li><code>public</code>: 将提供给<code>使用者</code>的<code>接口（函数）</code>和<code>成员变量</code>声明在此，用于外部调用接口和修改非私有的成员函数</li>\n<li><code>private</code>: 用于存放<strong>受保护</strong>的<code>成员变量</code>和<code>成员函数</code>,防止外部使用者<em>意外</em>或<em>恶意</em>调用或修改,造成类的内部结构被破坏等<strong>安全问题</strong>,所以特别重要的成员变量，和不希望被外部调用的函数声明在这里</li>\n</ul>\n<blockquote>\n<p>例如在声明<code>Date</code>类时，我们将<code>Init</code>和<code>Print</code>接口提供给使用者，用<code>public</code>控制；<code>_year</code>等成员变量不希望被外部随意修改，就用<code>private</code>控制</p>\n</blockquote>\n<h1 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h1><p>学完以上内容，不过是会写个高级点的<code>结构体</code>而已，要写一个完整的类，还需要学习更多的语法知识</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>像本篇的<code>Date</code>类那样显式地调用<code>Init</code>函数来初始化是非常挫的，既然语言本身的<code>内置类型</code>可以在声明的时候初始化，那么类的设计者设计出来的类也应当提供<code>初始化的接口</code>,而支持这一功能的接口便是<code>构造函数</code></p>\n<p>按语法规定，<code>构造函数</code>的函数名必须是<code>类名</code>,<strong>没有返回值</strong>，<code>const</code>修饰的成员变量必须位于<code>初始化列表</code>,其它则可省略。<em>关于初始化列表，稍后详细解释</em></p>\n<blockquote>\n<p>以<code>Date</code>类为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//一个普通的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year,<span class=\"type\">int</span> month,<span class=\"type\">int</span> day)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//进入括号时成员变量已经声明，且未初始化</span></span><br><span class=\"line\">        _year = year;<span class=\"comment\">//这是一个赋值操作，而不是初始化</span></span><br><span class=\"line\">        _month = month;</span><br><span class=\"line\">        _day = day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _year;</span><br><span class=\"line\">    <span class=\"type\">int</span> _month;</span><br><span class=\"line\">    <span class=\"type\">int</span> _day;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Date <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">2024</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>)</span></span>;<span class=\"comment\">//使用构造函数声明了一个d对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上的构造函数基本能用了,但还有两个问题</p>\n<ul>\n<li>构造函数没有初始化成员变量，而是采用赋值操作,无法初始化<code>const</code>修饰的成员变量</li>\n<li>使用<code>Date d</code>是会报错的，因为没有提供<code>默认构造函数</code></li>\n</ul>\n<p>对于<strong>第一个问题</strong>，就要引入<code>初始化列表</code>这一概念，让初始化函数直接拥有<code>初始化成员变量</code>的功能</p>\n<p>初始化列表位于构造函数的参数列表之后，花括号之前，以<code>:</code>开头，用<code>,</code>分隔成员变量</p>\n<blockquote>\n<p>以<code>Date</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year,<span class=\"type\">int</span> month,<span class=\"type\">int</span> day):_year(year) , _month(month) , _day(day) &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//或者换个书写格式（二者完全等价）</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year,<span class=\"type\">int</span> month,<span class=\"type\">int</span> day):_year(year) </span><br><span class=\"line\">, _month(month) </span><br><span class=\"line\">, _day(day) </span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这样<code>初始化列表</code>,便能在声明对象时，<strong>直接</strong>初始化成员变量</p>\n<p>对于<strong>问题二</strong>，我们开启另一个个小专题</p>\n<h3 id=\"构造函数的重载和缺省参数\"><a href=\"#构造函数的重载和缺省参数\" class=\"headerlink\" title=\"构造函数的重载和缺省参数\"></a>构造函数的重载和缺省参数</h3><p>没错，构造函数和函数一样，也是能<code>重载</code>和给参数传<code>缺省值</code>的</p>\n<p><em>也就是说我们能写好几个构造函数</em></p>\n<p>下面特别说明几个<strong>特殊</strong>的构造函数</p>\n<h4 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h4><p>原则上对于每一个类，都应该提供<strong>有且仅有一个</strong>默认构造函数（*多个<code>默认构造函数</code>会报错!*）</p>\n<p>而要<strong>声明</strong>默认构造函数，只需声明<code>无参数</code>构造函数，或者<code>全缺省参数</code>构造函数即可</p>\n<blockquote>\n<p>以<code>Date</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>():_year(<span class=\"number\">2024</span>),_month(<span class=\"number\">4</span>),_day(<span class=\"number\">1</span>)&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//====分割线=======</span></span><br><span class=\"line\"><span class=\"comment\">//或者全缺省，两个函数不能同时声明</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year = <span class=\"number\">2024</span>,<span class=\"type\">int</span> month = <span class=\"number\">4</span>,<span class=\"type\">int</span> day = <span class=\"number\">1</span>): _year(year),_month(month),_day(day)&#123;&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上就是两种默认构造函数的声明形式</p>\n<h4 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h4><p>有时候我们会希望用<strong>现有的</strong>的对象去初始化一个<strong>新</strong>对象,此时对应的构造函数就称为<code>拷贝构造（函数）</code></p>\n<p><code>拷贝构造</code>的声明方式为<code>构造函数</code>+参数类型为<code>类本身的引用传参</code>,不加<code>&amp;</code>的话就会死递归报错,有无<code>const</code>皆可，但由于是实现<code>拷贝功能</code>，一般是加<code>const</code>的</p>\n<blockquote>\n<p>以<code>Date</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>(<span class=\"type\">const</span> Date&amp; d):_year(d._year),_month(d._month),_day(d._day)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用示例</span></span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">2024</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">copy1</span><span class=\"params\">(d)</span></span>;<span class=\"comment\">//调用方式一</span></span><br><span class=\"line\">Date copy2 = d;<span class=\"comment\">//调用方式二,此时不会调用operator=()</span></span><br><span class=\"line\"></span><br><span class=\"line\">copy1 = copy2;<span class=\"comment\">//这种并不会调用拷贝构造,而是调用operator=()</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用模板的类的函数缺省值\"><a href=\"#使用模板的类的函数缺省值\" class=\"headerlink\" title=\"使用模板的类的函数缺省值\"></a>使用模板的类的函数缺省值</h4><p>有时我们在使用类模板来设计类时，需要给<code>模版类</code>类型的形参提供一个缺省值，有些人可能会写个<code>0</code>,但是其实是<strong>错的</strong>，正确的做法是传一个<code>临时变量</code></p>\n<p>但此时要求<code>模板参数中的类</code>有可用的<code>默认构造函数</code>和<code>拷贝构造</code>用于调用</p>\n<blockquote>\n<p>以链表节点<code>Node</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">value_type</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    value_type _val;</span><br><span class=\"line\">    Node&lt;value_type&gt;* _next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">const</span> value_type&amp; val = <span class=\"built_in\">value_type</span>()):_val(val),_next(<span class=\"literal\">nullptr</span>)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以用本文的Date实例化为例</span></span><br><span class=\"line\">Node&lt;Date&gt; node;</span><br><span class=\"line\"><span class=\"comment\">//通过输出会发现node中的val已经调用了默认构造函数</span></span><br><span class=\"line\">node.val.<span class=\"built_in\">TestPrint</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h2><p>对于声明在<code>栈区</code>或<code>静态区</code>的成员函数，程序完全可以自动销毁，<br>但如果<code>成员变量</code>有指向在<code>堆区</code>声明的某段<code>内存块</code>,在该如果只是仍由程序自动<br>销毁这个指针，那么那段<code>内存块</code>就会一直处于<strong>未释放</strong>的状态，也就是造成内存泄漏，<br>也就是说此时编译器自动生成的<code>析构函数</code>已经不能满足需求,编译器并不知道如何处理声明在<code>堆区</code>上的数据,<br>这部分操作应由类的设计者来规划</p>\n<p>所以我们应当<strong>显式</strong>地声明一个合理的<code>析构函数</code></p>\n<p><code>析构函数</code>的函数名也是由语法规定的，为<code>~</code>+<code>类名</code>,并且<strong>不能</strong>声明形参</p>\n<blockquote>\n<p>以一个<code>指针类</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ptr</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Ptr</span>()<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        _ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">1</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Ptr</span>()<span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> _ptr;<span class=\"comment\">//手动delte堆区上的数据</span></span><br><span class=\"line\">        _ptr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span>* _ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类的重载操作符\"><a href=\"#类的重载操作符\" class=\"headerlink\" title=\"类的重载操作符\"></a>类的重载操作符</h2><p>C++语法提供了重载操作符的函数，而由于<code>this</code>指针的存在，在类的<code>内部声明</code>重载操作符函数会稍有不同</p>\n<p>-对于一元操作符，<code>[]</code>,<code>-&gt;</code>之类的重载，不再需要<code>显式传参</code><br>-对于二元操作符，<code>+</code>,<code>&gt;</code>之类只需要传<code>右操作数</code></p>\n<blockquote>\n<p>以<code>Date</code>类为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在类的内部,重构一个 ==</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"type\">const</span> Date&amp; date) <span class=\"type\">const</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _year == date._year</span><br><span class=\"line\">            &amp;&amp; _month == date._month</span><br><span class=\"line\">            &amp;&amp; _day == date._day;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>至此，C++类和对象已基本入门，再进阶的<code>迭代器</code>,<code>继承</code>,<code>虚继承</code>等将单独出博客。</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Init</span><span class=\"params\">(<span class=\"type\">int</span> year = <span class=\"number\">1</span>,<span class=\"type\">int</span> month = <span class=\"number\">1</span>,<span class=\"type\">int</span> day = <span class=\"number\">1</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _year = year;</span><br><span class=\"line\">        _month = month;</span><br><span class=\"line\">        _day = day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Print</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; _year &lt;&lt; <span class=\"string\">&quot;:&quot;</span> &lt;&lt; _month &lt;&lt; <span class=\"string\">&quot;:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _year;</span><br><span class=\"line\">    <span class=\"type\">int</span> _month;</span><br><span class=\"line\">    <span class=\"type\">int</span> _day;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"抽象数据类型-类\"><a href=\"#抽象数据类型-类\" class=\"headerlink\" title=\"抽象数据类型(类)\"></a>抽象数据类型(类)</h2><p>通过如上代码，我们就在源代码中通过<code>class</code>声明了一个抽象数据类型<code>Date</code>,简称<code>类</code>，那么封装一个类有什么好处呢？<br>好处是类把相关的操作分为<strong>两类</strong>:</p>\n<ul>\n<li>类的<strong>设计者</strong>:负责考虑类的具体实现，提供类的接口，成员变量等</li>\n<li>类的<strong>使用者</strong>:只关心类<strong>提供</strong>了哪些功能，而不关心具体实现，从而简化思路</li>\n</ul>\n<p>以上面的<code>Date</code>类为例</p>\n<blockquote>\n<p>对设计者</p>\n</blockquote>\n<ul>\n<li>要考虑实现<code>Date</code>,就需要声明<strong>成员变量</strong><code>_year</code> <code>_month</code> <code>_day</code>,以及声明及实现<strong>成员函数</strong><code>Init</code>和<code>Print</code></li>\n</ul>\n<blockquote>\n<p>对使用者</p>\n</blockquote>\n<ul>\n<li>只需知道可以调用<code>Date</code>的<strong>成员函数</strong><code>Init</code>和<code>Print</code>,以及知道它们的用处即可</li>\n</ul>\n<h2 id=\"实例化-–-将类真正投入使用\"><a href=\"#实例化-–-将类真正投入使用\" class=\"headerlink\" title=\"实例化 – 将类真正投入使用\"></a>实例化 – 将类真正投入使用</h2><p>类也可以用于声明变量，例如<code>Date d</code>就声明了一个变量<code>d</code>,但由于是由<code>类</code>声明的,我们将这一过程称为<code>实例化</code>,其中<code>Date</code>这样的抽象数据类型称为<code>类</code>，像<code>d</code>这样的变量称为<code>对象</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-16_11-19-21.png\"></p>\n<p>实例化后的对象拥有<strong>私有</strong>的<code>成员变量</code>和整个类<strong>公有</strong>的<code>成员函数</code>,接下来对<code>对象</code>的操作都是对<code>成员变量</code>和<code>成员函数</code>的操作</p>\n<h2 id=\"访问成员函数-变量\"><a href=\"#访问成员函数-变量\" class=\"headerlink\" title=\"访问成员函数&#x2F;变量\"></a>访问成员函数&#x2F;变量</h2><h3 id=\"在类的内部\"><a href=\"#在类的内部\" class=\"headerlink\" title=\"在类的内部\"></a>在<code>类的内部</code></h3><p>对于类的成员函数，除了显式声明的<code>函数参数</code>外,还有<strong>隐式</strong>传入的<code>this</code>指针，这是个<strong>默认<code>非const</code>修饰</strong>的,指向调用该成员函数的<strong>对象的指针</strong>,编译器可以通过这个指针访问该对象的<code>成员变量</code>和<code>成员函数</code>。</p>\n<p>而我们作为类的<strong>设计者</strong>，既然语法都<strong>隐式</strong>地传入<code>this</code>指针了，自然也可以<strong>隐式</strong>地调用<code>成员</code>,即<strong>直接写</strong>变量名&#x2F;函数名调用</p>\n<p><em>当然，手动显式调用this指针也是可以的</em></p>\n<blockquote>\n<p>以<code>Date</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//该函数声明在Date类中，成员变量见文章开头</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TestPrint</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    _year = <span class=\"number\">2024</span>;<span class=\"comment\">//隐式调用this访问成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;_month = <span class=\"number\">4</span>;<span class=\"comment\">//显式调用this</span></span><br><span class=\"line\">    _day = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Print</span>();<span class=\"comment\">//隐式调用this来调用成员函数Print()</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">Print</span>();<span class=\"comment\">//显式调用this，效果与上一句相同</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但由于<code>const</code>修饰的<code>对象</code>传出的是<code>const</code>修饰的<code>this</code>指针，普通的<code>this</code>形参无法接收。<br>那么如何让<code>成员函数</code>传入<code>const</code>修饰的<code>this</code>指针,来使<code>const</code>修饰的<code>对象</code>有成员函数可调用呢？</p>\n<p>语法规定，在函数的参数列表(<em>圆括号后面</em>)紧跟一个<code>const</code>可使函数传入<code>const</code>修饰的<code>this</code>指针</p>\n<p><em>这种函数称为常量成员函数</em></p>\n<blockquote>\n<p><em>举个例子</em></p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例代码</span></span><br><span class=\"line\"><span class=\"comment\">//该函数声明在类中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">constPrint</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在类的外部\"><a href=\"#在类的外部\" class=\"headerlink\" title=\"在类的外部\"></a>在<code>类的外部</code></h3><p>和C语言的结构体一样，访问对象内的成员有两种方式</p>\n<ul>\n<li><em>对象名</em> + <code>.</code> + 成员名 ： 用<code>.</code>操作符访问对应成员</li>\n<li><em>对象的指针</em> + <code>-&gt;</code> + 成员名 : 用<code>-&gt;</code>操作符访问指针<strong>指向对象</strong>的对应成员</li>\n</ul>\n<blockquote>\n<p>以<code>Date</code>实例化一个<code>d</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class Date</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     ....</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Date d;</span><br><span class=\"line\">    Date* pd = &amp;d;</span><br><span class=\"line\">    d.<span class=\"built_in\">Init</span>(<span class=\"number\">2024</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>);<span class=\"comment\">// . 操作符调用Init成员函数来初始化对象</span></span><br><span class=\"line\">    pd-&gt;<span class=\"built_in\">Print</span>();<span class=\"comment\">//-&gt;操作符调用Print成员函数来打印内容</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Date d;</span><br><span class=\"line\">    d._year = <span class=\"number\">2024</span>;<span class=\"comment\">//试图访问成员变量_year,但是访问权限冲突</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//test1输出</span></span><br><span class=\"line\"><span class=\"number\">2024</span>:<span class=\"number\">4</span>:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">//test2输出</span></span><br><span class=\"line\">报错，无输出，因为访问权限冲突</span><br></pre></td></tr></table></figure>\n\n<p>代码如上，<code>test1</code>运行的很好，但<code>test2</code>报错了，原因在于<code>test2</code>作为<strong>非成员函数</strong>访问了访问限定符<code>private</code>控制的成员<code>_year</code>,权限冲突，就会报错。</p>\n<p>由此，C++类和对象还有一个重要概念需要强调–<strong>访问控制</strong></p>\n<h2 id=\"访问权限控制与封装\"><a href=\"#访问权限控制与封装\" class=\"headerlink\" title=\"访问权限控制与封装\"></a>访问权限控制与封装</h2><p>使用类和对象编程的一大优点就是类可以<code>封装</code>代码，让使用者只能使用公有的接口和成员变量，而对内部的具体实现不可见，来提高类的<code>易用性</code>和<code>安全性</code></p>\n<p>所以C++语法提供了三种<code>访问说明符</code>(<em>access specifiers</em>)</p>\n<ul>\n<li>public: 该说明符之后的成员在整个程序内可被访问</li>\n<li>private: 之后的成员仅可被该类的的类域里（<em>如成员函数</em>）访问</li>\n<li>protected: 一般同<code>private</code>,主要特点体现在类的继承，这里<strong>不作讨论</strong></li>\n</ul>\n<h3 id=\"作用范围\"><a href=\"#作用范围\" class=\"headerlink\" title=\"作用范围\"></a>作用范围</h3><p>某一<code>访问说明符</code>的作用范围开始于它的<code>冒号</code>,终止于下一个<code>访问说明符</code>或<code>类的结尾</code>,而<code>类的开始</code>到第一个<code>访问说明符</code>前的访问权限取决于<strong>声明</strong>类的<code>关键字</code>,分类如下</p>\n<ul>\n<li><code>class</code>默认为<code>private</code>权限</li>\n<li><code>struct</code>默认为<code>public</code>权限</li>\n</ul>\n<blockquote>\n<p>图例如下</p>\n</blockquote>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-04-18_14-15-40.png\"></p>\n<p>实际上<code>class</code>和<code>struct</code>除了默认权限不一样，基本<strong>没有差别</strong>。</p>\n<p>所以为了防止误读，<strong>提高可读性</strong>,<strong>不建议</strong>在<code>默认区</code>写代码,而是保证每段语句前都有合适的<code>访问限定符</code></p>\n<h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><p>作为类的设计者，一个类按<code>访问权限</code>可以分为两个区</p>\n<ul>\n<li><code>public</code>: 将提供给<code>使用者</code>的<code>接口（函数）</code>和<code>成员变量</code>声明在此，用于外部调用接口和修改非私有的成员函数</li>\n<li><code>private</code>: 用于存放<strong>受保护</strong>的<code>成员变量</code>和<code>成员函数</code>,防止外部使用者<em>意外</em>或<em>恶意</em>调用或修改,造成类的内部结构被破坏等<strong>安全问题</strong>,所以特别重要的成员变量，和不希望被外部调用的函数声明在这里</li>\n</ul>\n<blockquote>\n<p>例如在声明<code>Date</code>类时，我们将<code>Init</code>和<code>Print</code>接口提供给使用者，用<code>public</code>控制；<code>_year</code>等成员变量不希望被外部随意修改，就用<code>private</code>控制</p>\n</blockquote>\n<h1 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h1><p>学完以上内容，不过是会写个高级点的<code>结构体</code>而已，要写一个完整的类，还需要学习更多的语法知识</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>像本篇的<code>Date</code>类那样显式地调用<code>Init</code>函数来初始化是非常挫的，既然语言本身的<code>内置类型</code>可以在声明的时候初始化，那么类的设计者设计出来的类也应当提供<code>初始化的接口</code>,而支持这一功能的接口便是<code>构造函数</code></p>\n<p>按语法规定，<code>构造函数</code>的函数名必须是<code>类名</code>,<strong>没有返回值</strong>，<code>const</code>修饰的成员变量必须位于<code>初始化列表</code>,其它则可省略。<em>关于初始化列表，稍后详细解释</em></p>\n<blockquote>\n<p>以<code>Date</code>类为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//一个普通的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year,<span class=\"type\">int</span> month,<span class=\"type\">int</span> day)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//进入括号时成员变量已经声明，且未初始化</span></span><br><span class=\"line\">        _year = year;<span class=\"comment\">//这是一个赋值操作，而不是初始化</span></span><br><span class=\"line\">        _month = month;</span><br><span class=\"line\">        _day = day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _year;</span><br><span class=\"line\">    <span class=\"type\">int</span> _month;</span><br><span class=\"line\">    <span class=\"type\">int</span> _day;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Date <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">2024</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>)</span></span>;<span class=\"comment\">//使用构造函数声明了一个d对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上的构造函数基本能用了,但还有两个问题</p>\n<ul>\n<li>构造函数没有初始化成员变量，而是采用赋值操作,无法初始化<code>const</code>修饰的成员变量</li>\n<li>使用<code>Date d</code>是会报错的，因为没有提供<code>默认构造函数</code></li>\n</ul>\n<p>对于<strong>第一个问题</strong>，就要引入<code>初始化列表</code>这一概念，让初始化函数直接拥有<code>初始化成员变量</code>的功能</p>\n<p>初始化列表位于构造函数的参数列表之后，花括号之前，以<code>:</code>开头，用<code>,</code>分隔成员变量</p>\n<blockquote>\n<p>以<code>Date</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year,<span class=\"type\">int</span> month,<span class=\"type\">int</span> day):_year(year) , _month(month) , _day(day) &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//或者换个书写格式（二者完全等价）</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year,<span class=\"type\">int</span> month,<span class=\"type\">int</span> day):_year(year) </span><br><span class=\"line\">, _month(month) </span><br><span class=\"line\">, _day(day) </span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这样<code>初始化列表</code>,便能在声明对象时，<strong>直接</strong>初始化成员变量</p>\n<p>对于<strong>问题二</strong>，我们开启另一个个小专题</p>\n<h3 id=\"构造函数的重载和缺省参数\"><a href=\"#构造函数的重载和缺省参数\" class=\"headerlink\" title=\"构造函数的重载和缺省参数\"></a>构造函数的重载和缺省参数</h3><p>没错，构造函数和函数一样，也是能<code>重载</code>和给参数传<code>缺省值</code>的</p>\n<p><em>也就是说我们能写好几个构造函数</em></p>\n<p>下面特别说明几个<strong>特殊</strong>的构造函数</p>\n<h4 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h4><p>原则上对于每一个类，都应该提供<strong>有且仅有一个</strong>默认构造函数（*多个<code>默认构造函数</code>会报错!*）</p>\n<p>而要<strong>声明</strong>默认构造函数，只需声明<code>无参数</code>构造函数，或者<code>全缺省参数</code>构造函数即可</p>\n<blockquote>\n<p>以<code>Date</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>():_year(<span class=\"number\">2024</span>),_month(<span class=\"number\">4</span>),_day(<span class=\"number\">1</span>)&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//====分割线=======</span></span><br><span class=\"line\"><span class=\"comment\">//或者全缺省，两个函数不能同时声明</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year = <span class=\"number\">2024</span>,<span class=\"type\">int</span> month = <span class=\"number\">4</span>,<span class=\"type\">int</span> day = <span class=\"number\">1</span>): _year(year),_month(month),_day(day)&#123;&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上就是两种默认构造函数的声明形式</p>\n<h4 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h4><p>有时候我们会希望用<strong>现有的</strong>的对象去初始化一个<strong>新</strong>对象,此时对应的构造函数就称为<code>拷贝构造（函数）</code></p>\n<p><code>拷贝构造</code>的声明方式为<code>构造函数</code>+参数类型为<code>类本身的引用传参</code>,不加<code>&amp;</code>的话就会死递归报错,有无<code>const</code>皆可，但由于是实现<code>拷贝功能</code>，一般是加<code>const</code>的</p>\n<blockquote>\n<p>以<code>Date</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>(<span class=\"type\">const</span> Date&amp; d):_year(d._year),_month(d._month),_day(d._day)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用示例</span></span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">2024</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">copy1</span><span class=\"params\">(d)</span></span>;<span class=\"comment\">//调用方式一</span></span><br><span class=\"line\">Date copy2 = d;<span class=\"comment\">//调用方式二,此时不会调用operator=()</span></span><br><span class=\"line\"></span><br><span class=\"line\">copy1 = copy2;<span class=\"comment\">//这种并不会调用拷贝构造,而是调用operator=()</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用模板的类的函数缺省值\"><a href=\"#使用模板的类的函数缺省值\" class=\"headerlink\" title=\"使用模板的类的函数缺省值\"></a>使用模板的类的函数缺省值</h4><p>有时我们在使用类模板来设计类时，需要给<code>模版类</code>类型的形参提供一个缺省值，有些人可能会写个<code>0</code>,但是其实是<strong>错的</strong>，正确的做法是传一个<code>临时变量</code></p>\n<p>但此时要求<code>模板参数中的类</code>有可用的<code>默认构造函数</code>和<code>拷贝构造</code>用于调用</p>\n<blockquote>\n<p>以链表节点<code>Node</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">value_type</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    value_type _val;</span><br><span class=\"line\">    Node&lt;value_type&gt;* _next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">const</span> value_type&amp; val = <span class=\"built_in\">value_type</span>()):_val(val),_next(<span class=\"literal\">nullptr</span>)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以用本文的Date实例化为例</span></span><br><span class=\"line\">Node&lt;Date&gt; node;</span><br><span class=\"line\"><span class=\"comment\">//通过输出会发现node中的val已经调用了默认构造函数</span></span><br><span class=\"line\">node.val.<span class=\"built_in\">TestPrint</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h2><p>对于声明在<code>栈区</code>或<code>静态区</code>的成员函数，程序完全可以自动销毁，<br>但如果<code>成员变量</code>有指向在<code>堆区</code>声明的某段<code>内存块</code>,在该如果只是仍由程序自动<br>销毁这个指针，那么那段<code>内存块</code>就会一直处于<strong>未释放</strong>的状态，也就是造成内存泄漏，<br>也就是说此时编译器自动生成的<code>析构函数</code>已经不能满足需求,编译器并不知道如何处理声明在<code>堆区</code>上的数据,<br>这部分操作应由类的设计者来规划</p>\n<p>所以我们应当<strong>显式</strong>地声明一个合理的<code>析构函数</code></p>\n<p><code>析构函数</code>的函数名也是由语法规定的，为<code>~</code>+<code>类名</code>,并且<strong>不能</strong>声明形参</p>\n<blockquote>\n<p>以一个<code>指针类</code>为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ptr</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Ptr</span>()<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        _ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">1</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Ptr</span>()<span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> _ptr;<span class=\"comment\">//手动delte堆区上的数据</span></span><br><span class=\"line\">        _ptr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span>* _ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类的重载操作符\"><a href=\"#类的重载操作符\" class=\"headerlink\" title=\"类的重载操作符\"></a>类的重载操作符</h2><p>C++语法提供了重载操作符的函数，而由于<code>this</code>指针的存在，在类的<code>内部声明</code>重载操作符函数会稍有不同</p>\n<p>-对于一元操作符，<code>[]</code>,<code>-&gt;</code>之类的重载，不再需要<code>显式传参</code><br>-对于二元操作符，<code>+</code>,<code>&gt;</code>之类只需要传<code>右操作数</code></p>\n<blockquote>\n<p>以<code>Date</code>类为例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在类的内部,重构一个 ==</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"type\">const</span> Date&amp; date) <span class=\"type\">const</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _year == date._year</span><br><span class=\"line\">            &amp;&amp; _month == date._month</span><br><span class=\"line\">            &amp;&amp; _day == date._day;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>至此，C++类和对象已基本入门，再进阶的<code>迭代器</code>,<code>继承</code>,<code>虚继承</code>等将单独出博客。</p>\n"},{"title":"C++文件操作","date":"2024-05-14T02:19:32.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-59-20.png","_content":"\n*注:追求代码简洁,有一致的C++风格，可参阅本篇博客，若追求更高的读写效率，建议参阅C语言篇* [但文章还没写]()\n\n本篇文章主要研究头文件`fstream`中的**函数**和**类**\n\n目前C++文件操作主要有两种流派,一种是声明`fstream`对象,另一种是分开声明`ifstream`和`ofstream`\n\n**注意，本文代码为了简洁，都是在展开std命名空间的前提下书写**\n\n# fstream的使用\n先写一段示例代码\n```C++\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint main()\n{\n\tfstream f(\"file.txt\", ios::out);//调用构造函数以out模式打开文件file.txt 注:out模式下file.txt 会自动创建\n\tstring str = \"This is a sentence\";//在内存中准备一段字符串\n\tf << str;//将字符串从内存写入文件\n\tf.close();//关闭文件流\n\n\t//f对象可以复用\n\tf.open(\"file.txt\", ios::in);//以in模式打开file.txt\n\tstring content;//声明变量\n\tf >> content;//从文件流读取数据写入变量(内存)\n\tcout << content;//打印出来看一眼\n    f.close();\n\n\treturn 0;\n}\n\n```\n*输出结果*\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-14_18-49-56.png)\n\n这一小段代码完成了文件的两种模式的打开和读写，已经体现了`fstream`的基本功能,接下来分别详细介绍`成员函数`和`操作符重载`\n\n## fstreanm::open()\n函数声明:`void open(const char* filename, ios_base::openmode mode)`\n\n特别的,**C++11**增加了一个函数重载，第一个形参变为`const string& filename`\n\n实际上，也可以通过`fstream`类的构造函数来打开文件，参数与`open()`函数相同\n\n```C++\nfstream f(\"filename\",ios::out);\n```\n\n接下来分别介绍两个形参\n### filename\n**一般**第一个形参是文件名，可以传`字符串`/`char*`指针，C++11还支持传`string`对象\n\n文件名没什么好说的，就是有后缀的文件要**注意后缀**,以及文件名要写对，勤检查\n\n**但实际上**,第一个形参是`文件路径`,且支持`相对路径`,~~绝对路径我测不出来~~\n\n*代码示例如下*\n```C++\nf.open(\"this,txt\",ios::in);///打开当前文件夹的文件,this.txt是文件名\nf.open(\"../father.txt\",ios::in);//打开父级文件夹的文件,father.txt是文件名\nf.open(\"./dir/child.txt\",ios::in);//打开子级文件夹的文件(dir是文件夹名称)child.txt是文件名\n```\n\n### mode\n\n**用前须知**:这些`mode`都存在于`ios_base`的类域中,但由于`ios`继承自`ios_base`,混用二者皆可，本文为了简洁，指定类域时，使用`ios`，如`f.open(\"file.txt\",ios::out)`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-16_19-22-46.png)\n\n*上图是继承关系图，箭头指向父类*\n\n\n这里依然统一使用`fstream`类声明一个`f`对象\n\n```C++\nfstream f;\n```\n\n打开模式比较多，下面先放一张表\n\n| mode | stands for | 描述 |\n| --- | --- | --- |\n| out | output | 打开文件用于`写入`,即`内存->文件`,且会**完全覆盖**原文件,内置的流缓存(`internal stream buffer`)支持输出操作(类似`cout`)|\n| in  | input | 打开文件用于读取,即`文件->内存`,内置的流缓存支持输入操作(`类似cin`)|\n| app | append | 所有的输出操作都**追加在文件末尾**,向已有内容追加文本 |\n| trunc | truncate | 在打文件**前**,**清除所有内容** |\n| binary | binary | 所有操作都以`二进制`的形式，而不是文本 |\n| ate | at end | 输出操作在文件末尾开始 |\n\n*注*,这些`mode`能用`|`操作符连接,**同时**使用这些`mode`\n\n**但是**\n\n-使用`trunc | app`会打开失败\n-使用`trunc`而未使用`|`连接`out`,也会失败\n\n接下来逐一介绍这些`mode`\n\n#### out 和 in\n`out`是最常用的模式之一,用于`覆盖`写入文件,而且当文件不存在时，会按文件名**新建**一个文件并执行写入操作(哪怕是空文件)\n\n`in`也是最常用的模式之一，用于`只读`地读取文件，且当文件不存在时，会**抛异常**(*这里挖个坑*)\n\n\n\n- 使用`out`时，`f`对象支持`<<`流插入操作符\n\n```C++\nstring str(\"123456\");\nf<<str<<endl;//和输出内容到终端(cout)是一样的\n```\n\n- 使用`in`时,`f`对象支持`>>`流提取和作为`getline`函数的参数\n\n```C++\nstring s1,s2;\nf>>s1>>s2;//和从终端提取内容(cin)是一样的\n\nstring line;\ngetline(f,line);//从文件流中提取一行,存入line对象\n\nwhile(getline(f,line))//逐行提取至文件末尾\n{\n\t//....\n}\n```\n\n- 使用`in | out`时，`f`同时支持以上操作\n\n但是`写入`操作又和单一个`out`不一样，`单out`是完全覆盖，不考虑原文件内容,而`in | out`时，是**不完全**覆盖：从头开始覆盖，新写入的内容没有原文件长时，剩下的原文件**依然保留**\n\n>*示例代码*\n```C++\nint main()\n{\n\tfstream f;\n\tf.open(\"ff.txt\", ios::out);\n\tf << \"LongWord\";//准备一个有内容的原文件\n\tf.close();\n\n\tf.open(\"ff.txt\", ios::in | ios::out);\n\tf << \"1234\";//写入1234\n\tf.close();\n\t//最后ff.txt的内容为\"1234Word\",不完全覆盖\n\treturn 0;\n}\n\n```\n\n但是，同时进行流插入和流提取时，文件的操作结果会比较诡异，所以并不建议对**同一个文件流**同时进行读写操作。\n\n在一段`f.open()`和`f.close()`之间依然还是只进行读取**或**写入中的**一种**，而不要混合操作\n\n**缺省参数**：其实`mode`形参是有缺省参数的，正是`ios_base::in | ios_base::out`,也就是说在明确只使用`out`或`in`的情况下，且执行覆盖写入操作时，单写一个`f.open(文件名)`即可\n\n#### 其它mode\n\n##### app\n正如表格里描述的，使用`app`时，写入时不会覆盖远内容，而是`追加`到文件末尾。其中与`out`一样，当文件不存在时，会自动创建并写入内容。(即使没内容，也会创建空文件)\n```C++\nint main()\n{\n\tfstream f;\n\n\tf.open(\"file.txt\",ios::out);\n\tf << \"111\";//准备一个内容为111的文件\n\tf.close();\n\tf.open(\"file.txt\", ios::app);\n\tf << \"222\";//111后面追加222\n\tf.close();\n\t//文件内容为111222\n\treturn 0;\n}\n```\n\n##### trunc\n因为不加`out`会打开失败，所以`trunc`算是个`out`的修正,在以`out`模式打开前，清空原文件的内容\n\n乍一看，因为`单out`是`完全覆盖写入`,似乎`trunc`没什么用\n\n但是使用`ios::out | ios::in | ios::trunc`时是不完全覆盖写入，所以提前清空内容还是很有意义的。~~(那为啥不用单out呢)~~\n\n##### ate\n全称`at end`,单用`ate`也会打开失败,当然，`ios::ate | ios::out`没有意义，因为还是完全覆盖写入,`ate`在`ios::in | ios::out | ios::in`更加有用，可以从文件末尾追加内容\n\n##### binary\n虽然表格里是那么说了，有没有用`binary`我是真测不出差别(~~真要用的话，另寻高就把~~)\n\n但是单用`binary`依然会打开失败,需要再连个`out`或`in`\n\n---\n\n# ifstream 和 ofstream\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-29.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-48.png)\n\n上图分别为二者的继承关系,实际上二者用起来和`fstream`是基本一样的，只不过在打开文件时，一个始终自带`ios::in`,另一个始终自带`ios::out`\n\n# 读取文件流的一些方法\n\n## `>>`操作符\n这是最容易理解的方式，和从终端读取`数据`到变量里是一样的,只要类型匹配，不一定要存到字符串里\n\n## `getline()`函数\n用`getline`可以读取一行(即读到`\\n`或文件末尾`EOF`)\n\n但`getline`主要有两种，存在于不同的头文件中，且参数不同\n\n### &lt;string&gt;中的getline\n`istream& getline (istream& is, string& str);`\n\n函数声明如上，第一个参数是文件流(`fstream`类或`istream`类都可以),第二个参数就是个`string`对象\n\n下面是一个逐行提取的例子\n```C++\n#include <iostream>\n#include <fstream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n\t//提前准备一个待提取文件\n\tfstream f;\n\tf.open(\"ff.txt\", ios::out);\n\tf << \"line 1\" << endl << \"line 2\" << endl;\n\tf.close();\n\t//================\n\tf.open(\"ff.txt\");\n\tstring str;\n\twhile (getline(f, str))//当f为空时，循环停止\n\t{\n\t\tcout << str << endl;//打印每行,str内不含换行符\n\t}\n\tf.close();\n\treturn 0;\n}\n```\n\n### 成员函数中的getline\n`std::istream::getline`\n\n根据继承关系,`fstream`继承了来自`istream`的`getline`成员函数,也就是说它们的对象都能调用这一成员函数\n\n`istream& getline (char* s, streamsize n );`\n\n函数声明如上，可以看到，第一个参数是`char*`，要传给它一个`字符数组`,第二个则是读入字符数的最大值,当实际读入的字符数**小于**`n`时，会自动在结尾加一个`\\0`\n\n~~讲真这个函数更像是来自C语言的函数~~\n\n示例代码\n```C++\nint main()\n{\n\tfstream f;\n\tf.open(\"ff.txt\", ios::out);\n\tf << \"line 1\" << endl << \"line 2\" << endl;\n\tf.close();\n\n\tf.open(\"ff.txt\");\n\tchar str[256] = { 0 };\n\tf.getline(str, 256);//str里存了line 1\\0\n\tf.close();\n\tcout << str;\n\treturn 0;\n}\n```\n\n## get() 函数\n```C++\nint get();\nistream& get (char& c);\n```\n\n如上是两种常用的函数重载,均为继承来的`成员函数`,逐字符提取的话就能提取到`\\n``\\r`之类的转义字符\n\n代码示例\n```C++\nint main()\n{\n\t//提前准备一个待提取文件\n\tfstream f;\n\tf.open(\"ff.txt\", ios::out);\n\tf << \"line 1\" << endl << \"line 2\" << endl;\n\tf.close();\n\t//================\n\t//方法1\n\tf.open(\"ff.txt\");\n\tchar ch;\n\twhile (f.get(ch))//获取字符\n\t{\n\t\tcout << ch;//打印字符\n\t}\n\tf.close();\n\t//方法2\n\tf.open(\"ff.txt\");\n\twhile ((ch = f.get()) != EOF)//因为优先级的问题，必须加括号\n\t{\n\t\tcout << ch;//打印字符\n\t}\n\tf.close();\n\treturn 0;\n}\n```\n\n# 小结\n以上就是C++文件操作的大部分常用内容了。挖一挖确实也不少内容了,值得总结。\n\n","source":"_posts/cpp-file-op.md","raw":"---\ntitle: C++文件操作\ndate: 2024-05-14 10:19:32\ntags: C++ 文件\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-59-20.png\n---\n\n*注:追求代码简洁,有一致的C++风格，可参阅本篇博客，若追求更高的读写效率，建议参阅C语言篇* [但文章还没写]()\n\n本篇文章主要研究头文件`fstream`中的**函数**和**类**\n\n目前C++文件操作主要有两种流派,一种是声明`fstream`对象,另一种是分开声明`ifstream`和`ofstream`\n\n**注意，本文代码为了简洁，都是在展开std命名空间的前提下书写**\n\n# fstream的使用\n先写一段示例代码\n```C++\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint main()\n{\n\tfstream f(\"file.txt\", ios::out);//调用构造函数以out模式打开文件file.txt 注:out模式下file.txt 会自动创建\n\tstring str = \"This is a sentence\";//在内存中准备一段字符串\n\tf << str;//将字符串从内存写入文件\n\tf.close();//关闭文件流\n\n\t//f对象可以复用\n\tf.open(\"file.txt\", ios::in);//以in模式打开file.txt\n\tstring content;//声明变量\n\tf >> content;//从文件流读取数据写入变量(内存)\n\tcout << content;//打印出来看一眼\n    f.close();\n\n\treturn 0;\n}\n\n```\n*输出结果*\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-14_18-49-56.png)\n\n这一小段代码完成了文件的两种模式的打开和读写，已经体现了`fstream`的基本功能,接下来分别详细介绍`成员函数`和`操作符重载`\n\n## fstreanm::open()\n函数声明:`void open(const char* filename, ios_base::openmode mode)`\n\n特别的,**C++11**增加了一个函数重载，第一个形参变为`const string& filename`\n\n实际上，也可以通过`fstream`类的构造函数来打开文件，参数与`open()`函数相同\n\n```C++\nfstream f(\"filename\",ios::out);\n```\n\n接下来分别介绍两个形参\n### filename\n**一般**第一个形参是文件名，可以传`字符串`/`char*`指针，C++11还支持传`string`对象\n\n文件名没什么好说的，就是有后缀的文件要**注意后缀**,以及文件名要写对，勤检查\n\n**但实际上**,第一个形参是`文件路径`,且支持`相对路径`,~~绝对路径我测不出来~~\n\n*代码示例如下*\n```C++\nf.open(\"this,txt\",ios::in);///打开当前文件夹的文件,this.txt是文件名\nf.open(\"../father.txt\",ios::in);//打开父级文件夹的文件,father.txt是文件名\nf.open(\"./dir/child.txt\",ios::in);//打开子级文件夹的文件(dir是文件夹名称)child.txt是文件名\n```\n\n### mode\n\n**用前须知**:这些`mode`都存在于`ios_base`的类域中,但由于`ios`继承自`ios_base`,混用二者皆可，本文为了简洁，指定类域时，使用`ios`，如`f.open(\"file.txt\",ios::out)`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-16_19-22-46.png)\n\n*上图是继承关系图，箭头指向父类*\n\n\n这里依然统一使用`fstream`类声明一个`f`对象\n\n```C++\nfstream f;\n```\n\n打开模式比较多，下面先放一张表\n\n| mode | stands for | 描述 |\n| --- | --- | --- |\n| out | output | 打开文件用于`写入`,即`内存->文件`,且会**完全覆盖**原文件,内置的流缓存(`internal stream buffer`)支持输出操作(类似`cout`)|\n| in  | input | 打开文件用于读取,即`文件->内存`,内置的流缓存支持输入操作(`类似cin`)|\n| app | append | 所有的输出操作都**追加在文件末尾**,向已有内容追加文本 |\n| trunc | truncate | 在打文件**前**,**清除所有内容** |\n| binary | binary | 所有操作都以`二进制`的形式，而不是文本 |\n| ate | at end | 输出操作在文件末尾开始 |\n\n*注*,这些`mode`能用`|`操作符连接,**同时**使用这些`mode`\n\n**但是**\n\n-使用`trunc | app`会打开失败\n-使用`trunc`而未使用`|`连接`out`,也会失败\n\n接下来逐一介绍这些`mode`\n\n#### out 和 in\n`out`是最常用的模式之一,用于`覆盖`写入文件,而且当文件不存在时，会按文件名**新建**一个文件并执行写入操作(哪怕是空文件)\n\n`in`也是最常用的模式之一，用于`只读`地读取文件，且当文件不存在时，会**抛异常**(*这里挖个坑*)\n\n\n\n- 使用`out`时，`f`对象支持`<<`流插入操作符\n\n```C++\nstring str(\"123456\");\nf<<str<<endl;//和输出内容到终端(cout)是一样的\n```\n\n- 使用`in`时,`f`对象支持`>>`流提取和作为`getline`函数的参数\n\n```C++\nstring s1,s2;\nf>>s1>>s2;//和从终端提取内容(cin)是一样的\n\nstring line;\ngetline(f,line);//从文件流中提取一行,存入line对象\n\nwhile(getline(f,line))//逐行提取至文件末尾\n{\n\t//....\n}\n```\n\n- 使用`in | out`时，`f`同时支持以上操作\n\n但是`写入`操作又和单一个`out`不一样，`单out`是完全覆盖，不考虑原文件内容,而`in | out`时，是**不完全**覆盖：从头开始覆盖，新写入的内容没有原文件长时，剩下的原文件**依然保留**\n\n>*示例代码*\n```C++\nint main()\n{\n\tfstream f;\n\tf.open(\"ff.txt\", ios::out);\n\tf << \"LongWord\";//准备一个有内容的原文件\n\tf.close();\n\n\tf.open(\"ff.txt\", ios::in | ios::out);\n\tf << \"1234\";//写入1234\n\tf.close();\n\t//最后ff.txt的内容为\"1234Word\",不完全覆盖\n\treturn 0;\n}\n\n```\n\n但是，同时进行流插入和流提取时，文件的操作结果会比较诡异，所以并不建议对**同一个文件流**同时进行读写操作。\n\n在一段`f.open()`和`f.close()`之间依然还是只进行读取**或**写入中的**一种**，而不要混合操作\n\n**缺省参数**：其实`mode`形参是有缺省参数的，正是`ios_base::in | ios_base::out`,也就是说在明确只使用`out`或`in`的情况下，且执行覆盖写入操作时，单写一个`f.open(文件名)`即可\n\n#### 其它mode\n\n##### app\n正如表格里描述的，使用`app`时，写入时不会覆盖远内容，而是`追加`到文件末尾。其中与`out`一样，当文件不存在时，会自动创建并写入内容。(即使没内容，也会创建空文件)\n```C++\nint main()\n{\n\tfstream f;\n\n\tf.open(\"file.txt\",ios::out);\n\tf << \"111\";//准备一个内容为111的文件\n\tf.close();\n\tf.open(\"file.txt\", ios::app);\n\tf << \"222\";//111后面追加222\n\tf.close();\n\t//文件内容为111222\n\treturn 0;\n}\n```\n\n##### trunc\n因为不加`out`会打开失败，所以`trunc`算是个`out`的修正,在以`out`模式打开前，清空原文件的内容\n\n乍一看，因为`单out`是`完全覆盖写入`,似乎`trunc`没什么用\n\n但是使用`ios::out | ios::in | ios::trunc`时是不完全覆盖写入，所以提前清空内容还是很有意义的。~~(那为啥不用单out呢)~~\n\n##### ate\n全称`at end`,单用`ate`也会打开失败,当然，`ios::ate | ios::out`没有意义，因为还是完全覆盖写入,`ate`在`ios::in | ios::out | ios::in`更加有用，可以从文件末尾追加内容\n\n##### binary\n虽然表格里是那么说了，有没有用`binary`我是真测不出差别(~~真要用的话，另寻高就把~~)\n\n但是单用`binary`依然会打开失败,需要再连个`out`或`in`\n\n---\n\n# ifstream 和 ofstream\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-29.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-48.png)\n\n上图分别为二者的继承关系,实际上二者用起来和`fstream`是基本一样的，只不过在打开文件时，一个始终自带`ios::in`,另一个始终自带`ios::out`\n\n# 读取文件流的一些方法\n\n## `>>`操作符\n这是最容易理解的方式，和从终端读取`数据`到变量里是一样的,只要类型匹配，不一定要存到字符串里\n\n## `getline()`函数\n用`getline`可以读取一行(即读到`\\n`或文件末尾`EOF`)\n\n但`getline`主要有两种，存在于不同的头文件中，且参数不同\n\n### &lt;string&gt;中的getline\n`istream& getline (istream& is, string& str);`\n\n函数声明如上，第一个参数是文件流(`fstream`类或`istream`类都可以),第二个参数就是个`string`对象\n\n下面是一个逐行提取的例子\n```C++\n#include <iostream>\n#include <fstream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n\t//提前准备一个待提取文件\n\tfstream f;\n\tf.open(\"ff.txt\", ios::out);\n\tf << \"line 1\" << endl << \"line 2\" << endl;\n\tf.close();\n\t//================\n\tf.open(\"ff.txt\");\n\tstring str;\n\twhile (getline(f, str))//当f为空时，循环停止\n\t{\n\t\tcout << str << endl;//打印每行,str内不含换行符\n\t}\n\tf.close();\n\treturn 0;\n}\n```\n\n### 成员函数中的getline\n`std::istream::getline`\n\n根据继承关系,`fstream`继承了来自`istream`的`getline`成员函数,也就是说它们的对象都能调用这一成员函数\n\n`istream& getline (char* s, streamsize n );`\n\n函数声明如上，可以看到，第一个参数是`char*`，要传给它一个`字符数组`,第二个则是读入字符数的最大值,当实际读入的字符数**小于**`n`时，会自动在结尾加一个`\\0`\n\n~~讲真这个函数更像是来自C语言的函数~~\n\n示例代码\n```C++\nint main()\n{\n\tfstream f;\n\tf.open(\"ff.txt\", ios::out);\n\tf << \"line 1\" << endl << \"line 2\" << endl;\n\tf.close();\n\n\tf.open(\"ff.txt\");\n\tchar str[256] = { 0 };\n\tf.getline(str, 256);//str里存了line 1\\0\n\tf.close();\n\tcout << str;\n\treturn 0;\n}\n```\n\n## get() 函数\n```C++\nint get();\nistream& get (char& c);\n```\n\n如上是两种常用的函数重载,均为继承来的`成员函数`,逐字符提取的话就能提取到`\\n``\\r`之类的转义字符\n\n代码示例\n```C++\nint main()\n{\n\t//提前准备一个待提取文件\n\tfstream f;\n\tf.open(\"ff.txt\", ios::out);\n\tf << \"line 1\" << endl << \"line 2\" << endl;\n\tf.close();\n\t//================\n\t//方法1\n\tf.open(\"ff.txt\");\n\tchar ch;\n\twhile (f.get(ch))//获取字符\n\t{\n\t\tcout << ch;//打印字符\n\t}\n\tf.close();\n\t//方法2\n\tf.open(\"ff.txt\");\n\twhile ((ch = f.get()) != EOF)//因为优先级的问题，必须加括号\n\t{\n\t\tcout << ch;//打印字符\n\t}\n\tf.close();\n\treturn 0;\n}\n```\n\n# 小结\n以上就是C++文件操作的大部分常用内容了。挖一挖确实也不少内容了,值得总结。\n\n","slug":"cpp-file-op","published":1,"updated":"2024-05-22T04:09:13.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p089000p4sp5fyj19yjb","content":"<p><em>注:追求代码简洁,有一致的C++风格，可参阅本篇博客，若追求更高的读写效率，建议参阅C语言篇</em> <a href=\"\">但文章还没写</a></p>\n<p>本篇文章主要研究头文件<code>fstream</code>中的<strong>函数</strong>和<strong>类</strong></p>\n<p>目前C++文件操作主要有两种流派,一种是声明<code>fstream</code>对象,另一种是分开声明<code>ifstream</code>和<code>ofstream</code></p>\n<p><strong>注意，本文代码为了简洁，都是在展开std命名空间的前提下书写</strong></p>\n<h1 id=\"fstream的使用\"><a href=\"#fstream的使用\" class=\"headerlink\" title=\"fstream的使用\"></a>fstream的使用</h1><p>先写一段示例代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">fstream <span class=\"title\">f</span><span class=\"params\">(<span class=\"string\">&quot;file.txt&quot;</span>, ios::out)</span></span>;<span class=\"comment\">//调用构造函数以out模式打开文件file.txt 注:out模式下file.txt 会自动创建</span></span><br><span class=\"line\">\tstring str = <span class=\"string\">&quot;This is a sentence&quot;</span>;<span class=\"comment\">//在内存中准备一段字符串</span></span><br><span class=\"line\">\tf &lt;&lt; str;<span class=\"comment\">//将字符串从内存写入文件</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();<span class=\"comment\">//关闭文件流</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//f对象可以复用</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.txt&quot;</span>, ios::in);<span class=\"comment\">//以in模式打开file.txt</span></span><br><span class=\"line\">\tstring content;<span class=\"comment\">//声明变量</span></span><br><span class=\"line\">\tf &gt;&gt; content;<span class=\"comment\">//从文件流读取数据写入变量(内存)</span></span><br><span class=\"line\">\tcout &lt;&lt; content;<span class=\"comment\">//打印出来看一眼</span></span><br><span class=\"line\">    f.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em>输出结果</em><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-14_18-49-56.png\"></p>\n<p>这一小段代码完成了文件的两种模式的打开和读写，已经体现了<code>fstream</code>的基本功能,接下来分别详细介绍<code>成员函数</code>和<code>操作符重载</code></p>\n<h2 id=\"fstreanm-open\"><a href=\"#fstreanm-open\" class=\"headerlink\" title=\"fstreanm::open()\"></a>fstreanm::open()</h2><p>函数声明:<code>void open(const char* filename, ios_base::openmode mode)</code></p>\n<p>特别的,<strong>C++11</strong>增加了一个函数重载，第一个形参变为<code>const string&amp; filename</code></p>\n<p>实际上，也可以通过<code>fstream</code>类的构造函数来打开文件，参数与<code>open()</code>函数相同</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">fstream <span class=\"title\">f</span><span class=\"params\">(<span class=\"string\">&quot;filename&quot;</span>,ios::out)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>接下来分别介绍两个形参</p>\n<h3 id=\"filename\"><a href=\"#filename\" class=\"headerlink\" title=\"filename\"></a>filename</h3><p><strong>一般</strong>第一个形参是文件名，可以传<code>字符串</code>&#x2F;<code>char*</code>指针，C++11还支持传<code>string</code>对象</p>\n<p>文件名没什么好说的，就是有后缀的文件要<strong>注意后缀</strong>,以及文件名要写对，勤检查</p>\n<p><strong>但实际上</strong>,第一个形参是<code>文件路径</code>,且支持<code>相对路径</code>,<del>绝对路径我测不出来</del></p>\n<p><em>代码示例如下</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;this,txt&quot;</span>,ios::in);<span class=\"comment\">///打开当前文件夹的文件,this.txt是文件名</span></span><br><span class=\"line\">f.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;../father.txt&quot;</span>,ios::in);<span class=\"comment\">//打开父级文件夹的文件,father.txt是文件名</span></span><br><span class=\"line\">f.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;./dir/child.txt&quot;</span>,ios::in);<span class=\"comment\">//打开子级文件夹的文件(dir是文件夹名称)child.txt是文件名</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h3><p><strong>用前须知</strong>:这些<code>mode</code>都存在于<code>ios_base</code>的类域中,但由于<code>ios</code>继承自<code>ios_base</code>,混用二者皆可，本文为了简洁，指定类域时，使用<code>ios</code>，如<code>f.open(&quot;file.txt&quot;,ios::out)</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-16_19-22-46.png\"></p>\n<p><em>上图是继承关系图，箭头指向父类</em></p>\n<p>这里依然统一使用<code>fstream</code>类声明一个<code>f</code>对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fstream f;</span><br></pre></td></tr></table></figure>\n\n<p>打开模式比较多，下面先放一张表</p>\n<table>\n<thead>\n<tr>\n<th>mode</th>\n<th>stands for</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>out</td>\n<td>output</td>\n<td>打开文件用于<code>写入</code>,即<code>内存-&gt;文件</code>,且会<strong>完全覆盖</strong>原文件,内置的流缓存(<code>internal stream buffer</code>)支持输出操作(类似<code>cout</code>)</td>\n</tr>\n<tr>\n<td>in</td>\n<td>input</td>\n<td>打开文件用于读取,即<code>文件-&gt;内存</code>,内置的流缓存支持输入操作(<code>类似cin</code>)</td>\n</tr>\n<tr>\n<td>app</td>\n<td>append</td>\n<td>所有的输出操作都<strong>追加在文件末尾</strong>,向已有内容追加文本</td>\n</tr>\n<tr>\n<td>trunc</td>\n<td>truncate</td>\n<td>在打文件<strong>前</strong>,<strong>清除所有内容</strong></td>\n</tr>\n<tr>\n<td>binary</td>\n<td>binary</td>\n<td>所有操作都以<code>二进制</code>的形式，而不是文本</td>\n</tr>\n<tr>\n<td>ate</td>\n<td>at end</td>\n<td>输出操作在文件末尾开始</td>\n</tr>\n</tbody></table>\n<p><em>注</em>,这些<code>mode</code>能用<code>|</code>操作符连接,<strong>同时</strong>使用这些<code>mode</code></p>\n<p><strong>但是</strong></p>\n<p>-使用<code>trunc | app</code>会打开失败<br>-使用<code>trunc</code>而未使用<code>|</code>连接<code>out</code>,也会失败</p>\n<p>接下来逐一介绍这些<code>mode</code></p>\n<h4 id=\"out-和-in\"><a href=\"#out-和-in\" class=\"headerlink\" title=\"out 和 in\"></a>out 和 in</h4><p><code>out</code>是最常用的模式之一,用于<code>覆盖</code>写入文件,而且当文件不存在时，会按文件名<strong>新建</strong>一个文件并执行写入操作(哪怕是空文件)</p>\n<p><code>in</code>也是最常用的模式之一，用于<code>只读</code>地读取文件，且当文件不存在时，会<strong>抛异常</strong>(<em>这里挖个坑</em>)</p>\n<ul>\n<li>使用<code>out</code>时，<code>f</code>对象支持<code>&lt;&lt;</code>流插入操作符</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">str</span><span class=\"params\">(<span class=\"string\">&quot;123456&quot;</span>)</span></span>;</span><br><span class=\"line\">f&lt;&lt;str&lt;&lt;endl;<span class=\"comment\">//和输出内容到终端(cout)是一样的</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用<code>in</code>时,<code>f</code>对象支持<code>&gt;&gt;</code>流提取和作为<code>getline</code>函数的参数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s1,s2;</span><br><span class=\"line\">f&gt;&gt;s1&gt;&gt;s2;<span class=\"comment\">//和从终端提取内容(cin)是一样的</span></span><br><span class=\"line\"></span><br><span class=\"line\">string line;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(f,line);<span class=\"comment\">//从文件流中提取一行,存入line对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">getline</span>(f,line))<span class=\"comment\">//逐行提取至文件末尾</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用<code>in | out</code>时，<code>f</code>同时支持以上操作</li>\n</ul>\n<p>但是<code>写入</code>操作又和单一个<code>out</code>不一样，<code>单out</code>是完全覆盖，不考虑原文件内容,而<code>in | out</code>时，是<strong>不完全</strong>覆盖：从头开始覆盖，新写入的内容没有原文件长时，剩下的原文件<strong>依然保留</strong></p>\n<blockquote>\n<p><em>示例代码</em></p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tfstream f;</span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;LongWord&quot;</span>;<span class=\"comment\">//准备一个有内容的原文件</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>, ios::in | ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;1234&quot;</span>;<span class=\"comment\">//写入1234</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//最后ff.txt的内容为&quot;1234Word&quot;,不完全覆盖</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>但是，同时进行流插入和流提取时，文件的操作结果会比较诡异，所以并不建议对<strong>同一个文件流</strong>同时进行读写操作。</p>\n<p>在一段<code>f.open()</code>和<code>f.close()</code>之间依然还是只进行读取<strong>或</strong>写入中的<strong>一种</strong>，而不要混合操作</p>\n<p><strong>缺省参数</strong>：其实<code>mode</code>形参是有缺省参数的，正是<code>ios_base::in | ios_base::out</code>,也就是说在明确只使用<code>out</code>或<code>in</code>的情况下，且执行覆盖写入操作时，单写一个<code>f.open(文件名)</code>即可</p>\n<h4 id=\"其它mode\"><a href=\"#其它mode\" class=\"headerlink\" title=\"其它mode\"></a>其它mode</h4><h5 id=\"app\"><a href=\"#app\" class=\"headerlink\" title=\"app\"></a>app</h5><p>正如表格里描述的，使用<code>app</code>时，写入时不会覆盖远内容，而是<code>追加</code>到文件末尾。其中与<code>out</code>一样，当文件不存在时，会自动创建并写入内容。(即使没内容，也会创建空文件)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tfstream f;</span><br><span class=\"line\"></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.txt&quot;</span>,ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;111&quot;</span>;<span class=\"comment\">//准备一个内容为111的文件</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.txt&quot;</span>, ios::app);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;222&quot;</span>;<span class=\"comment\">//111后面追加222</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//文件内容为111222</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"trunc\"><a href=\"#trunc\" class=\"headerlink\" title=\"trunc\"></a>trunc</h5><p>因为不加<code>out</code>会打开失败，所以<code>trunc</code>算是个<code>out</code>的修正,在以<code>out</code>模式打开前，清空原文件的内容</p>\n<p>乍一看，因为<code>单out</code>是<code>完全覆盖写入</code>,似乎<code>trunc</code>没什么用</p>\n<p>但是使用<code>ios::out | ios::in | ios::trunc</code>时是不完全覆盖写入，所以提前清空内容还是很有意义的。<del>(那为啥不用单out呢)</del></p>\n<h5 id=\"ate\"><a href=\"#ate\" class=\"headerlink\" title=\"ate\"></a>ate</h5><p>全称<code>at end</code>,单用<code>ate</code>也会打开失败,当然，<code>ios::ate | ios::out</code>没有意义，因为还是完全覆盖写入,<code>ate</code>在<code>ios::in | ios::out | ios::in</code>更加有用，可以从文件末尾追加内容</p>\n<h5 id=\"binary\"><a href=\"#binary\" class=\"headerlink\" title=\"binary\"></a>binary</h5><p>虽然表格里是那么说了，有没有用<code>binary</code>我是真测不出差别(<del>真要用的话，另寻高就把</del>)</p>\n<p>但是单用<code>binary</code>依然会打开失败,需要再连个<code>out</code>或<code>in</code></p>\n<hr>\n<h1 id=\"ifstream-和-ofstream\"><a href=\"#ifstream-和-ofstream\" class=\"headerlink\" title=\"ifstream 和 ofstream\"></a>ifstream 和 ofstream</h1><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-29.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-48.png\"></p>\n<p>上图分别为二者的继承关系,实际上二者用起来和<code>fstream</code>是基本一样的，只不过在打开文件时，一个始终自带<code>ios::in</code>,另一个始终自带<code>ios::out</code></p>\n<h1 id=\"读取文件流的一些方法\"><a href=\"#读取文件流的一些方法\" class=\"headerlink\" title=\"读取文件流的一些方法\"></a>读取文件流的一些方法</h1><h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"&gt;&gt;操作符\"></a><code>&gt;&gt;</code>操作符</h2><p>这是最容易理解的方式，和从终端读取<code>数据</code>到变量里是一样的,只要类型匹配，不一定要存到字符串里</p>\n<h2 id=\"getline-函数\"><a href=\"#getline-函数\" class=\"headerlink\" title=\"getline()函数\"></a><code>getline()</code>函数</h2><p>用<code>getline</code>可以读取一行(即读到<code>\\n</code>或文件末尾<code>EOF</code>)</p>\n<p>但<code>getline</code>主要有两种，存在于不同的头文件中，且参数不同</p>\n<h3 id=\"中的getline\"><a href=\"#中的getline\" class=\"headerlink\" title=\"&lt;string&gt;中的getline\"></a>&lt;string&gt;中的getline</h3><p><code>istream&amp; getline (istream&amp; is, string&amp; str);</code></p>\n<p>函数声明如上，第一个参数是文件流(<code>fstream</code>类或<code>istream</code>类都可以),第二个参数就是个<code>string</code>对象</p>\n<p>下面是一个逐行提取的例子</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//提前准备一个待提取文件</span></span><br><span class=\"line\">\tfstream f;</span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class=\"string\">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//================</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>);</span><br><span class=\"line\">\tstring str;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">getline</span>(f, str))<span class=\"comment\">//当f为空时，循环停止</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; str &lt;&lt; endl;<span class=\"comment\">//打印每行,str内不含换行符</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"成员函数中的getline\"><a href=\"#成员函数中的getline\" class=\"headerlink\" title=\"成员函数中的getline\"></a>成员函数中的getline</h3><p><code>std::istream::getline</code></p>\n<p>根据继承关系,<code>fstream</code>继承了来自<code>istream</code>的<code>getline</code>成员函数,也就是说它们的对象都能调用这一成员函数</p>\n<p><code>istream&amp; getline (char* s, streamsize n );</code></p>\n<p>函数声明如上，可以看到，第一个参数是<code>char*</code>，要传给它一个<code>字符数组</code>,第二个则是读入字符数的最大值,当实际读入的字符数<strong>小于</strong><code>n</code>时，会自动在结尾加一个<code>\\0</code></p>\n<p><del>讲真这个函数更像是来自C语言的函数</del></p>\n<p>示例代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tfstream f;</span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class=\"string\">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">char</span> str[<span class=\"number\">256</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\tf.<span class=\"built_in\">getline</span>(str, <span class=\"number\">256</span>);<span class=\"comment\">//str里存了line 1\\0</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\tcout &lt;&lt; str;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"get-函数\"><a href=\"#get-函数\" class=\"headerlink\" title=\"get() 函数\"></a>get() 函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">get</span> <span class=\"params\">(<span class=\"type\">char</span>&amp; c)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>如上是两种常用的函数重载,均为继承来的<code>成员函数</code>,逐字符提取的话就能提取到<code>\\n``\\r</code>之类的转义字符</p>\n<p>代码示例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//提前准备一个待提取文件</span></span><br><span class=\"line\">\tfstream f;</span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class=\"string\">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//================</span></span><br><span class=\"line\">\t<span class=\"comment\">//方法1</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (f.<span class=\"built_in\">get</span>(ch))<span class=\"comment\">//获取字符</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; ch;<span class=\"comment\">//打印字符</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//方法2</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((ch = f.<span class=\"built_in\">get</span>()) != EOF)<span class=\"comment\">//因为优先级的问题，必须加括号</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; ch;<span class=\"comment\">//打印字符</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>以上就是C++文件操作的大部分常用内容了。挖一挖确实也不少内容了,值得总结。</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<p><em>注:追求代码简洁,有一致的C++风格，可参阅本篇博客，若追求更高的读写效率，建议参阅C语言篇</em> <a href=\"\">但文章还没写</a></p>\n<p>本篇文章主要研究头文件<code>fstream</code>中的<strong>函数</strong>和<strong>类</strong></p>\n<p>目前C++文件操作主要有两种流派,一种是声明<code>fstream</code>对象,另一种是分开声明<code>ifstream</code>和<code>ofstream</code></p>\n<p><strong>注意，本文代码为了简洁，都是在展开std命名空间的前提下书写</strong></p>\n<h1 id=\"fstream的使用\"><a href=\"#fstream的使用\" class=\"headerlink\" title=\"fstream的使用\"></a>fstream的使用</h1><p>先写一段示例代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">fstream <span class=\"title\">f</span><span class=\"params\">(<span class=\"string\">&quot;file.txt&quot;</span>, ios::out)</span></span>;<span class=\"comment\">//调用构造函数以out模式打开文件file.txt 注:out模式下file.txt 会自动创建</span></span><br><span class=\"line\">\tstring str = <span class=\"string\">&quot;This is a sentence&quot;</span>;<span class=\"comment\">//在内存中准备一段字符串</span></span><br><span class=\"line\">\tf &lt;&lt; str;<span class=\"comment\">//将字符串从内存写入文件</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();<span class=\"comment\">//关闭文件流</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//f对象可以复用</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.txt&quot;</span>, ios::in);<span class=\"comment\">//以in模式打开file.txt</span></span><br><span class=\"line\">\tstring content;<span class=\"comment\">//声明变量</span></span><br><span class=\"line\">\tf &gt;&gt; content;<span class=\"comment\">//从文件流读取数据写入变量(内存)</span></span><br><span class=\"line\">\tcout &lt;&lt; content;<span class=\"comment\">//打印出来看一眼</span></span><br><span class=\"line\">    f.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em>输出结果</em><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-14_18-49-56.png\"></p>\n<p>这一小段代码完成了文件的两种模式的打开和读写，已经体现了<code>fstream</code>的基本功能,接下来分别详细介绍<code>成员函数</code>和<code>操作符重载</code></p>\n<h2 id=\"fstreanm-open\"><a href=\"#fstreanm-open\" class=\"headerlink\" title=\"fstreanm::open()\"></a>fstreanm::open()</h2><p>函数声明:<code>void open(const char* filename, ios_base::openmode mode)</code></p>\n<p>特别的,<strong>C++11</strong>增加了一个函数重载，第一个形参变为<code>const string&amp; filename</code></p>\n<p>实际上，也可以通过<code>fstream</code>类的构造函数来打开文件，参数与<code>open()</code>函数相同</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">fstream <span class=\"title\">f</span><span class=\"params\">(<span class=\"string\">&quot;filename&quot;</span>,ios::out)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>接下来分别介绍两个形参</p>\n<h3 id=\"filename\"><a href=\"#filename\" class=\"headerlink\" title=\"filename\"></a>filename</h3><p><strong>一般</strong>第一个形参是文件名，可以传<code>字符串</code>&#x2F;<code>char*</code>指针，C++11还支持传<code>string</code>对象</p>\n<p>文件名没什么好说的，就是有后缀的文件要<strong>注意后缀</strong>,以及文件名要写对，勤检查</p>\n<p><strong>但实际上</strong>,第一个形参是<code>文件路径</code>,且支持<code>相对路径</code>,<del>绝对路径我测不出来</del></p>\n<p><em>代码示例如下</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;this,txt&quot;</span>,ios::in);<span class=\"comment\">///打开当前文件夹的文件,this.txt是文件名</span></span><br><span class=\"line\">f.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;../father.txt&quot;</span>,ios::in);<span class=\"comment\">//打开父级文件夹的文件,father.txt是文件名</span></span><br><span class=\"line\">f.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;./dir/child.txt&quot;</span>,ios::in);<span class=\"comment\">//打开子级文件夹的文件(dir是文件夹名称)child.txt是文件名</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h3><p><strong>用前须知</strong>:这些<code>mode</code>都存在于<code>ios_base</code>的类域中,但由于<code>ios</code>继承自<code>ios_base</code>,混用二者皆可，本文为了简洁，指定类域时，使用<code>ios</code>，如<code>f.open(&quot;file.txt&quot;,ios::out)</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-16_19-22-46.png\"></p>\n<p><em>上图是继承关系图，箭头指向父类</em></p>\n<p>这里依然统一使用<code>fstream</code>类声明一个<code>f</code>对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fstream f;</span><br></pre></td></tr></table></figure>\n\n<p>打开模式比较多，下面先放一张表</p>\n<table>\n<thead>\n<tr>\n<th>mode</th>\n<th>stands for</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>out</td>\n<td>output</td>\n<td>打开文件用于<code>写入</code>,即<code>内存-&gt;文件</code>,且会<strong>完全覆盖</strong>原文件,内置的流缓存(<code>internal stream buffer</code>)支持输出操作(类似<code>cout</code>)</td>\n</tr>\n<tr>\n<td>in</td>\n<td>input</td>\n<td>打开文件用于读取,即<code>文件-&gt;内存</code>,内置的流缓存支持输入操作(<code>类似cin</code>)</td>\n</tr>\n<tr>\n<td>app</td>\n<td>append</td>\n<td>所有的输出操作都<strong>追加在文件末尾</strong>,向已有内容追加文本</td>\n</tr>\n<tr>\n<td>trunc</td>\n<td>truncate</td>\n<td>在打文件<strong>前</strong>,<strong>清除所有内容</strong></td>\n</tr>\n<tr>\n<td>binary</td>\n<td>binary</td>\n<td>所有操作都以<code>二进制</code>的形式，而不是文本</td>\n</tr>\n<tr>\n<td>ate</td>\n<td>at end</td>\n<td>输出操作在文件末尾开始</td>\n</tr>\n</tbody></table>\n<p><em>注</em>,这些<code>mode</code>能用<code>|</code>操作符连接,<strong>同时</strong>使用这些<code>mode</code></p>\n<p><strong>但是</strong></p>\n<p>-使用<code>trunc | app</code>会打开失败<br>-使用<code>trunc</code>而未使用<code>|</code>连接<code>out</code>,也会失败</p>\n<p>接下来逐一介绍这些<code>mode</code></p>\n<h4 id=\"out-和-in\"><a href=\"#out-和-in\" class=\"headerlink\" title=\"out 和 in\"></a>out 和 in</h4><p><code>out</code>是最常用的模式之一,用于<code>覆盖</code>写入文件,而且当文件不存在时，会按文件名<strong>新建</strong>一个文件并执行写入操作(哪怕是空文件)</p>\n<p><code>in</code>也是最常用的模式之一，用于<code>只读</code>地读取文件，且当文件不存在时，会<strong>抛异常</strong>(<em>这里挖个坑</em>)</p>\n<ul>\n<li>使用<code>out</code>时，<code>f</code>对象支持<code>&lt;&lt;</code>流插入操作符</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">str</span><span class=\"params\">(<span class=\"string\">&quot;123456&quot;</span>)</span></span>;</span><br><span class=\"line\">f&lt;&lt;str&lt;&lt;endl;<span class=\"comment\">//和输出内容到终端(cout)是一样的</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用<code>in</code>时,<code>f</code>对象支持<code>&gt;&gt;</code>流提取和作为<code>getline</code>函数的参数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s1,s2;</span><br><span class=\"line\">f&gt;&gt;s1&gt;&gt;s2;<span class=\"comment\">//和从终端提取内容(cin)是一样的</span></span><br><span class=\"line\"></span><br><span class=\"line\">string line;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(f,line);<span class=\"comment\">//从文件流中提取一行,存入line对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">getline</span>(f,line))<span class=\"comment\">//逐行提取至文件末尾</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用<code>in | out</code>时，<code>f</code>同时支持以上操作</li>\n</ul>\n<p>但是<code>写入</code>操作又和单一个<code>out</code>不一样，<code>单out</code>是完全覆盖，不考虑原文件内容,而<code>in | out</code>时，是<strong>不完全</strong>覆盖：从头开始覆盖，新写入的内容没有原文件长时，剩下的原文件<strong>依然保留</strong></p>\n<blockquote>\n<p><em>示例代码</em></p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tfstream f;</span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;LongWord&quot;</span>;<span class=\"comment\">//准备一个有内容的原文件</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>, ios::in | ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;1234&quot;</span>;<span class=\"comment\">//写入1234</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//最后ff.txt的内容为&quot;1234Word&quot;,不完全覆盖</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>但是，同时进行流插入和流提取时，文件的操作结果会比较诡异，所以并不建议对<strong>同一个文件流</strong>同时进行读写操作。</p>\n<p>在一段<code>f.open()</code>和<code>f.close()</code>之间依然还是只进行读取<strong>或</strong>写入中的<strong>一种</strong>，而不要混合操作</p>\n<p><strong>缺省参数</strong>：其实<code>mode</code>形参是有缺省参数的，正是<code>ios_base::in | ios_base::out</code>,也就是说在明确只使用<code>out</code>或<code>in</code>的情况下，且执行覆盖写入操作时，单写一个<code>f.open(文件名)</code>即可</p>\n<h4 id=\"其它mode\"><a href=\"#其它mode\" class=\"headerlink\" title=\"其它mode\"></a>其它mode</h4><h5 id=\"app\"><a href=\"#app\" class=\"headerlink\" title=\"app\"></a>app</h5><p>正如表格里描述的，使用<code>app</code>时，写入时不会覆盖远内容，而是<code>追加</code>到文件末尾。其中与<code>out</code>一样，当文件不存在时，会自动创建并写入内容。(即使没内容，也会创建空文件)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tfstream f;</span><br><span class=\"line\"></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.txt&quot;</span>,ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;111&quot;</span>;<span class=\"comment\">//准备一个内容为111的文件</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.txt&quot;</span>, ios::app);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;222&quot;</span>;<span class=\"comment\">//111后面追加222</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//文件内容为111222</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"trunc\"><a href=\"#trunc\" class=\"headerlink\" title=\"trunc\"></a>trunc</h5><p>因为不加<code>out</code>会打开失败，所以<code>trunc</code>算是个<code>out</code>的修正,在以<code>out</code>模式打开前，清空原文件的内容</p>\n<p>乍一看，因为<code>单out</code>是<code>完全覆盖写入</code>,似乎<code>trunc</code>没什么用</p>\n<p>但是使用<code>ios::out | ios::in | ios::trunc</code>时是不完全覆盖写入，所以提前清空内容还是很有意义的。<del>(那为啥不用单out呢)</del></p>\n<h5 id=\"ate\"><a href=\"#ate\" class=\"headerlink\" title=\"ate\"></a>ate</h5><p>全称<code>at end</code>,单用<code>ate</code>也会打开失败,当然，<code>ios::ate | ios::out</code>没有意义，因为还是完全覆盖写入,<code>ate</code>在<code>ios::in | ios::out | ios::in</code>更加有用，可以从文件末尾追加内容</p>\n<h5 id=\"binary\"><a href=\"#binary\" class=\"headerlink\" title=\"binary\"></a>binary</h5><p>虽然表格里是那么说了，有没有用<code>binary</code>我是真测不出差别(<del>真要用的话，另寻高就把</del>)</p>\n<p>但是单用<code>binary</code>依然会打开失败,需要再连个<code>out</code>或<code>in</code></p>\n<hr>\n<h1 id=\"ifstream-和-ofstream\"><a href=\"#ifstream-和-ofstream\" class=\"headerlink\" title=\"ifstream 和 ofstream\"></a>ifstream 和 ofstream</h1><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-29.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-17_11-18-48.png\"></p>\n<p>上图分别为二者的继承关系,实际上二者用起来和<code>fstream</code>是基本一样的，只不过在打开文件时，一个始终自带<code>ios::in</code>,另一个始终自带<code>ios::out</code></p>\n<h1 id=\"读取文件流的一些方法\"><a href=\"#读取文件流的一些方法\" class=\"headerlink\" title=\"读取文件流的一些方法\"></a>读取文件流的一些方法</h1><h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"&gt;&gt;操作符\"></a><code>&gt;&gt;</code>操作符</h2><p>这是最容易理解的方式，和从终端读取<code>数据</code>到变量里是一样的,只要类型匹配，不一定要存到字符串里</p>\n<h2 id=\"getline-函数\"><a href=\"#getline-函数\" class=\"headerlink\" title=\"getline()函数\"></a><code>getline()</code>函数</h2><p>用<code>getline</code>可以读取一行(即读到<code>\\n</code>或文件末尾<code>EOF</code>)</p>\n<p>但<code>getline</code>主要有两种，存在于不同的头文件中，且参数不同</p>\n<h3 id=\"中的getline\"><a href=\"#中的getline\" class=\"headerlink\" title=\"&lt;string&gt;中的getline\"></a>&lt;string&gt;中的getline</h3><p><code>istream&amp; getline (istream&amp; is, string&amp; str);</code></p>\n<p>函数声明如上，第一个参数是文件流(<code>fstream</code>类或<code>istream</code>类都可以),第二个参数就是个<code>string</code>对象</p>\n<p>下面是一个逐行提取的例子</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//提前准备一个待提取文件</span></span><br><span class=\"line\">\tfstream f;</span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class=\"string\">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//================</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>);</span><br><span class=\"line\">\tstring str;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">getline</span>(f, str))<span class=\"comment\">//当f为空时，循环停止</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; str &lt;&lt; endl;<span class=\"comment\">//打印每行,str内不含换行符</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"成员函数中的getline\"><a href=\"#成员函数中的getline\" class=\"headerlink\" title=\"成员函数中的getline\"></a>成员函数中的getline</h3><p><code>std::istream::getline</code></p>\n<p>根据继承关系,<code>fstream</code>继承了来自<code>istream</code>的<code>getline</code>成员函数,也就是说它们的对象都能调用这一成员函数</p>\n<p><code>istream&amp; getline (char* s, streamsize n );</code></p>\n<p>函数声明如上，可以看到，第一个参数是<code>char*</code>，要传给它一个<code>字符数组</code>,第二个则是读入字符数的最大值,当实际读入的字符数<strong>小于</strong><code>n</code>时，会自动在结尾加一个<code>\\0</code></p>\n<p><del>讲真这个函数更像是来自C语言的函数</del></p>\n<p>示例代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tfstream f;</span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class=\"string\">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">char</span> str[<span class=\"number\">256</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\tf.<span class=\"built_in\">getline</span>(str, <span class=\"number\">256</span>);<span class=\"comment\">//str里存了line 1\\0</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\tcout &lt;&lt; str;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"get-函数\"><a href=\"#get-函数\" class=\"headerlink\" title=\"get() 函数\"></a>get() 函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">get</span> <span class=\"params\">(<span class=\"type\">char</span>&amp; c)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>如上是两种常用的函数重载,均为继承来的<code>成员函数</code>,逐字符提取的话就能提取到<code>\\n``\\r</code>之类的转义字符</p>\n<p>代码示例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//提前准备一个待提取文件</span></span><br><span class=\"line\">\tfstream f;</span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>, ios::out);</span><br><span class=\"line\">\tf &lt;&lt; <span class=\"string\">&quot;line 1&quot;</span> &lt;&lt; endl &lt;&lt; <span class=\"string\">&quot;line 2&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//================</span></span><br><span class=\"line\">\t<span class=\"comment\">//方法1</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (f.<span class=\"built_in\">get</span>(ch))<span class=\"comment\">//获取字符</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; ch;<span class=\"comment\">//打印字符</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//方法2</span></span><br><span class=\"line\">\tf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;ff.txt&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((ch = f.<span class=\"built_in\">get</span>()) != EOF)<span class=\"comment\">//因为优先级的问题，必须加括号</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; ch;<span class=\"comment\">//打印字符</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>以上就是C++文件操作的大部分常用内容了。挖一挖确实也不少内容了,值得总结。</p>\n"},{"title":"通过设计list类深入理解iterator迭代器","date":"2024-04-26T08:10:11.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Date.jpg","_content":"\n前置博客:**[从构建一个Date类入门C++类与对象](https://www.supdriver.top/2023/12/07/cpp-class/ '点击跳转')**\n\n>下面先迅速地搓一个`list`类\n```C++\ntemplate <class T>//先用模板创建一个节点类\nstruct ListNode\n{\n\tT _val;\n\tListNode<T>* _next;\n\tListNode<T>* _prev;\n\n\t//提供全缺省的默认构造函数\n\tListNode(const T& val = T()) :_val(val), _next(nullptr), _prev(nullptr) {}\n};\n\n//用ListNode构造list类\n\ntemplate <class T>\nclass list\n{\n\ttypedef ListNode<T> Node;//用typedef简化代码\npublic:\n\tlist()//默认构造函数\n\t{\n\t\t_head = new Node;\n\t\t//维护两个指针\n\t\t_head->_next = _head;\n\t\t_head->_prev = _head;\n\t}\n\n\tvoid push_front(const T& val)//头插\n\t{\n\t\tNode* newnode = new Node(val);\n\t\tNode* next = _head->_next;//额外的指针，简化代码\n\n\t\t_head->_next = newnode;\n\t\tnewnode->_prev = _head;\n\t\tnewnode->_next = next;\n\t\tnext->_prev = newnode;\n\t}\n\n\tvoid pop_front()//尾插\n\t{\n\t\tif (empty()) return;\n\n\t\tNode* cur = _head->_next;\n\t\t\n\t\t_head->_next = cur->_next;\n\t\tcur->_next->_prev = _head;\n\t\tdelete cur;\n\t}\n\n\tbool empty() //判空\n\t{\n\t\treturn _head->_next == _head;\n\t}\n\n\t//剩余代码自行补全\n    //......\nprivate:\n\tNode* _head;\n};\n\n```\n\n# list的迭代器 #\n\n不同于`vector`底层的数据在内存中**连续**存储,可以用`原生指针`充当迭代器,例如`typedef T* iterator`\n\n`list`的底层是链表,在内存中**分散***存储，是**不能**用`原生指针`来**连续**访问的,所以为了解决这一复杂问题，\n需要自己写一个`iterator`类\n\n## 普通迭代器 #\n\n```C++\ntemplate<class T>//迭代器也得用模板\nstruct __list_iterator\n{\n\ttypedef __list_iterator<T> Self;//简化代码\n\ttypedef ListNode<T> Node;\n\tNode* _node;\n\n\t__list_iterator(Node* node) :_node(node) {}\n\n\tSelf& operator++()//重载operator++\n\t{\n\t\t_node = _node->_next;\n\t\treturn *this;\n\t}\n\n\tbool operator!=(const Self& it) const //重载!==,比较操作符记得加const\n\t{\n\t\treturn _node != it._node;\n\t}\n\n\tT& operator*()//重载 *\n\t{\n\t\treturn _node->_val;\n\t}\n};\n\n```\n*`list`类中添加如下代码*\n```C++\npublic:\n\ttypedef __list_iterator<T> iterator;\n\n    iterator begin()\n\t{\n\t\treturn iterator(_head->_next);\n\t}\n\n\titerator end()\n\t{\n\t\treturn iterator(_head);\n\t}\n```\n\n通过如上修改,`list`已经支持`普通迭代器`,并且非`const`修饰的`list`已经支持`范围for`了\n\n>测试代码如下\n```C++\nint main()\n{\n\tlist<int> lst;\n\tlst.push_front(5);\n\tlst.push_front(4);\n\tlst.push_front(3);\n\tlst.push_front(2);\n\tlst.push_front(1);\n\n\tfor (auto e : lst)\n\t{\n\t\tcout << e << \" \";\n\t}\n\treturn 0;\n}\n```\n\n## const迭代器\n`const list`要能提供`const_iterator`，因此我们还要写一个`const_iterator`类...吗？\n\n其实**并不用**，要利用好C++中的`模板语法`来大大提高代码的复用性,尤其像`iterator`和`const_iterator`这种差别不大的类,没必要每个都单独写一段代码\n\n为此我们的`__list_iterator`只需要能用`模板`解决好二者的差异即可。而目前最大的问题是什么？是`operator*()`的返回值问题,一个是返回`T&`,另一个是`const T&`,其他的成员函数则基本没差别,所以不妨扩充一下`模板参数`,添加一个`Ref`类。\n\n>有变化的代码如下\n```C++\ntemplate<class T,class Ref>//增加一个Ref参数\nstruct __list_iterator\n{\n\ttypedef __list_iterator<T,Ref> Self;//Self这里的原类也要加\n\ttypedef ListNode<T> Node;\n\tNode* _node;\n\n\t__list_iterator(Node* node) :_node(node) {}\n\n\tRef operator*()//直接返回Ref类\n\t{\n\t\treturn _node->_val;\n\t}\n};\n```\n*`list`类也有相应变化*\n```C++\npublic:\n\ttypedef __list_iterator<T,T&> iterator;//普通迭代器\n\ttypedef __list_iterator<T,const T&> const_iterator;//const迭代器\n\n    const_iterator begin() const //针对const指针的\n\t{\n\t\treturn const_iterator(_head->_next);\n\t}\n\n\tconst_iterator end() const\n\t{\n\t\treturn const_iterator(_head);\n\t}\n```\n\n这样通过增加一个`Ref`模板参数,完成了对`iterator`和`const_iterator`的代码级统一(*当然模板实例化出来是不一样的*)\n\n但别忘了迭代器还要提供`->`操作符的重载,而`operator->()`函数要返回不同的指针，所以我们如法炮制，再增加一个`Ptr`模板参数\n\n>有变化的代码如下\n```C++\ntemplate<class T,class Ref,class Ptr>//增加一个Ptr参数\nstruct __list_iterator\n{\n\ttypedef __list_iterator<T,Ref,Ptr> Self;//Self相应更改\n\n\tPtr operator->()//重载->\n\t{\n\t\treturn &(_node->_val);\n\t}\n};\n\n```\n*`list`类也有相应变化*\n```C++\npublic:\n\ttypedef __list_iterator<T,T&,T*> iterator;//普通迭代器\n\ttypedef __list_iterator<T,const T&,const T*> const_iterator;//const迭代器\n```\n\n至此，`list`和`__list_iterator`的基本功能已基本完成，本篇的重点`__list_iterator`主要解决了两点问题\n\n-为了应对`list`的迭代器的复杂性，单独为其构建一个`__list_iterator`类，并提供一系列的操作符重载\n-为了提高代码的**复用性**,仅用一个`__list_iterator`类来`typedef`普通迭代器和`const`迭代器,我们增加了模板参数,最终模板变为`template<class T, class Ref, class Ptr>`\n\n## 用普通迭代器构造const迭代器\n有时候我们需要用普通迭代器构造`const`迭代器,于是可以给`__list_iterator`提供一个比较有意思的`构造函数`,\n可以实现时而充当拷贝构造，时而充当满足上述的构造\n\n>代码如下\n```C++\ntypedef __list_iterator<T,Ref,Ptr> Self;//再展示一遍Self的代码，便于下文对比\ntypedef __list_iterator<T,T&,T*> iterator;//指定普通迭代器，并用typedef简化代码\n\n__list_iterator(iterator it) :_node(it._node) {}\n\n```\n-当模板参数为`<T,T&,T*>`时，`Self`和`iterator`相同，上段代码中的构造函数相当于`拷贝构造`\n\n-当模板参数为`<T,const T&,const T*>`时，`Self`和`iterator`不同,`Slef`是`const`迭代器,`iterator`**始终**是普通迭代器，这个构造函数便能用普通迭代器构造`const`迭代器\n\n# 小结\n通过构造一个`list`类，我们使用到了更复杂的迭代器，使用了带`3个模板参数`的`__list_iterator`类定义普通迭代器和`const`迭代器，学习了如何利用模板参数提高代码的复用性，如何提供额外的`构造函数`使`__list_iterator`支持用普通迭代器构造`const`迭代器","source":"_posts/create-mylist.md","raw":"---\ntitle: 通过设计list类深入理解iterator迭代器\ndate: 2024-04-26 16:10:11\ntags: C++ 类和对象\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Date.jpg\n---\n\n前置博客:**[从构建一个Date类入门C++类与对象](https://www.supdriver.top/2023/12/07/cpp-class/ '点击跳转')**\n\n>下面先迅速地搓一个`list`类\n```C++\ntemplate <class T>//先用模板创建一个节点类\nstruct ListNode\n{\n\tT _val;\n\tListNode<T>* _next;\n\tListNode<T>* _prev;\n\n\t//提供全缺省的默认构造函数\n\tListNode(const T& val = T()) :_val(val), _next(nullptr), _prev(nullptr) {}\n};\n\n//用ListNode构造list类\n\ntemplate <class T>\nclass list\n{\n\ttypedef ListNode<T> Node;//用typedef简化代码\npublic:\n\tlist()//默认构造函数\n\t{\n\t\t_head = new Node;\n\t\t//维护两个指针\n\t\t_head->_next = _head;\n\t\t_head->_prev = _head;\n\t}\n\n\tvoid push_front(const T& val)//头插\n\t{\n\t\tNode* newnode = new Node(val);\n\t\tNode* next = _head->_next;//额外的指针，简化代码\n\n\t\t_head->_next = newnode;\n\t\tnewnode->_prev = _head;\n\t\tnewnode->_next = next;\n\t\tnext->_prev = newnode;\n\t}\n\n\tvoid pop_front()//尾插\n\t{\n\t\tif (empty()) return;\n\n\t\tNode* cur = _head->_next;\n\t\t\n\t\t_head->_next = cur->_next;\n\t\tcur->_next->_prev = _head;\n\t\tdelete cur;\n\t}\n\n\tbool empty() //判空\n\t{\n\t\treturn _head->_next == _head;\n\t}\n\n\t//剩余代码自行补全\n    //......\nprivate:\n\tNode* _head;\n};\n\n```\n\n# list的迭代器 #\n\n不同于`vector`底层的数据在内存中**连续**存储,可以用`原生指针`充当迭代器,例如`typedef T* iterator`\n\n`list`的底层是链表,在内存中**分散***存储，是**不能**用`原生指针`来**连续**访问的,所以为了解决这一复杂问题，\n需要自己写一个`iterator`类\n\n## 普通迭代器 #\n\n```C++\ntemplate<class T>//迭代器也得用模板\nstruct __list_iterator\n{\n\ttypedef __list_iterator<T> Self;//简化代码\n\ttypedef ListNode<T> Node;\n\tNode* _node;\n\n\t__list_iterator(Node* node) :_node(node) {}\n\n\tSelf& operator++()//重载operator++\n\t{\n\t\t_node = _node->_next;\n\t\treturn *this;\n\t}\n\n\tbool operator!=(const Self& it) const //重载!==,比较操作符记得加const\n\t{\n\t\treturn _node != it._node;\n\t}\n\n\tT& operator*()//重载 *\n\t{\n\t\treturn _node->_val;\n\t}\n};\n\n```\n*`list`类中添加如下代码*\n```C++\npublic:\n\ttypedef __list_iterator<T> iterator;\n\n    iterator begin()\n\t{\n\t\treturn iterator(_head->_next);\n\t}\n\n\titerator end()\n\t{\n\t\treturn iterator(_head);\n\t}\n```\n\n通过如上修改,`list`已经支持`普通迭代器`,并且非`const`修饰的`list`已经支持`范围for`了\n\n>测试代码如下\n```C++\nint main()\n{\n\tlist<int> lst;\n\tlst.push_front(5);\n\tlst.push_front(4);\n\tlst.push_front(3);\n\tlst.push_front(2);\n\tlst.push_front(1);\n\n\tfor (auto e : lst)\n\t{\n\t\tcout << e << \" \";\n\t}\n\treturn 0;\n}\n```\n\n## const迭代器\n`const list`要能提供`const_iterator`，因此我们还要写一个`const_iterator`类...吗？\n\n其实**并不用**，要利用好C++中的`模板语法`来大大提高代码的复用性,尤其像`iterator`和`const_iterator`这种差别不大的类,没必要每个都单独写一段代码\n\n为此我们的`__list_iterator`只需要能用`模板`解决好二者的差异即可。而目前最大的问题是什么？是`operator*()`的返回值问题,一个是返回`T&`,另一个是`const T&`,其他的成员函数则基本没差别,所以不妨扩充一下`模板参数`,添加一个`Ref`类。\n\n>有变化的代码如下\n```C++\ntemplate<class T,class Ref>//增加一个Ref参数\nstruct __list_iterator\n{\n\ttypedef __list_iterator<T,Ref> Self;//Self这里的原类也要加\n\ttypedef ListNode<T> Node;\n\tNode* _node;\n\n\t__list_iterator(Node* node) :_node(node) {}\n\n\tRef operator*()//直接返回Ref类\n\t{\n\t\treturn _node->_val;\n\t}\n};\n```\n*`list`类也有相应变化*\n```C++\npublic:\n\ttypedef __list_iterator<T,T&> iterator;//普通迭代器\n\ttypedef __list_iterator<T,const T&> const_iterator;//const迭代器\n\n    const_iterator begin() const //针对const指针的\n\t{\n\t\treturn const_iterator(_head->_next);\n\t}\n\n\tconst_iterator end() const\n\t{\n\t\treturn const_iterator(_head);\n\t}\n```\n\n这样通过增加一个`Ref`模板参数,完成了对`iterator`和`const_iterator`的代码级统一(*当然模板实例化出来是不一样的*)\n\n但别忘了迭代器还要提供`->`操作符的重载,而`operator->()`函数要返回不同的指针，所以我们如法炮制，再增加一个`Ptr`模板参数\n\n>有变化的代码如下\n```C++\ntemplate<class T,class Ref,class Ptr>//增加一个Ptr参数\nstruct __list_iterator\n{\n\ttypedef __list_iterator<T,Ref,Ptr> Self;//Self相应更改\n\n\tPtr operator->()//重载->\n\t{\n\t\treturn &(_node->_val);\n\t}\n};\n\n```\n*`list`类也有相应变化*\n```C++\npublic:\n\ttypedef __list_iterator<T,T&,T*> iterator;//普通迭代器\n\ttypedef __list_iterator<T,const T&,const T*> const_iterator;//const迭代器\n```\n\n至此，`list`和`__list_iterator`的基本功能已基本完成，本篇的重点`__list_iterator`主要解决了两点问题\n\n-为了应对`list`的迭代器的复杂性，单独为其构建一个`__list_iterator`类，并提供一系列的操作符重载\n-为了提高代码的**复用性**,仅用一个`__list_iterator`类来`typedef`普通迭代器和`const`迭代器,我们增加了模板参数,最终模板变为`template<class T, class Ref, class Ptr>`\n\n## 用普通迭代器构造const迭代器\n有时候我们需要用普通迭代器构造`const`迭代器,于是可以给`__list_iterator`提供一个比较有意思的`构造函数`,\n可以实现时而充当拷贝构造，时而充当满足上述的构造\n\n>代码如下\n```C++\ntypedef __list_iterator<T,Ref,Ptr> Self;//再展示一遍Self的代码，便于下文对比\ntypedef __list_iterator<T,T&,T*> iterator;//指定普通迭代器，并用typedef简化代码\n\n__list_iterator(iterator it) :_node(it._node) {}\n\n```\n-当模板参数为`<T,T&,T*>`时，`Self`和`iterator`相同，上段代码中的构造函数相当于`拷贝构造`\n\n-当模板参数为`<T,const T&,const T*>`时，`Self`和`iterator`不同,`Slef`是`const`迭代器,`iterator`**始终**是普通迭代器，这个构造函数便能用普通迭代器构造`const`迭代器\n\n# 小结\n通过构造一个`list`类，我们使用到了更复杂的迭代器，使用了带`3个模板参数`的`__list_iterator`类定义普通迭代器和`const`迭代器，学习了如何利用模板参数提高代码的复用性，如何提供额外的`构造函数`使`__list_iterator`支持用普通迭代器构造`const`迭代器","slug":"create-mylist","published":1,"updated":"2024-05-14T02:20:26.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p089000s4sp57c05hhha","content":"<p>前置博客:<strong><a href=\"https://www.supdriver.top/2023/12/07/cpp-class/\" title=\"点击跳转\">从构建一个Date类入门C++类与对象</a></strong></p>\n<blockquote>\n<p>下面先迅速地搓一个<code>list</code>类</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;<span class=\"comment\">//先用模板创建一个节点类</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT _val;</span><br><span class=\"line\">\tListNode&lt;T&gt;* _next;</span><br><span class=\"line\">\tListNode&lt;T&gt;* _prev;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//提供全缺省的默认构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">ListNode</span>(<span class=\"type\">const</span> T&amp; val = <span class=\"built_in\">T</span>()) :_val(val), _next(<span class=\"literal\">nullptr</span>), _prev(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用ListNode构造list类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">list</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> ListNode&lt;T&gt; Node;<span class=\"comment\">//用typedef简化代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">list</span>()<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_head = <span class=\"keyword\">new</span> Node;</span><br><span class=\"line\">\t\t<span class=\"comment\">//维护两个指针</span></span><br><span class=\"line\">\t\t_head-&gt;_next = _head;</span><br><span class=\"line\">\t\t_head-&gt;_prev = _head;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_front</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; val)</span><span class=\"comment\">//头插</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* newnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(val);</span><br><span class=\"line\">\t\tNode* next = _head-&gt;_next;<span class=\"comment\">//额外的指针，简化代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t_head-&gt;_next = newnode;</span><br><span class=\"line\">\t\tnewnode-&gt;_prev = _head;</span><br><span class=\"line\">\t\tnewnode-&gt;_next = next;</span><br><span class=\"line\">\t\tnext-&gt;_prev = newnode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop_front</span><span class=\"params\">()</span><span class=\"comment\">//尾插</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tNode* cur = _head-&gt;_next;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t_head-&gt;_next = cur-&gt;_next;</span><br><span class=\"line\">\t\tcur-&gt;_next-&gt;_prev = _head;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> cur;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"comment\">//判空</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _head-&gt;_next == _head;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//剩余代码自行补全</span></span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode* _head;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"list的迭代器\"><a href=\"#list的迭代器\" class=\"headerlink\" title=\"list的迭代器\"></a>list的迭代器</h1><p>不同于<code>vector</code>底层的数据在内存中<strong>连续</strong>存储,可以用<code>原生指针</code>充当迭代器,例如<code>typedef T* iterator</code></p>\n<p><code>list</code>的底层是链表,在内存中<strong>分散</strong>*存储，是<strong>不能</strong>用<code>原生指针</code>来<strong>连续</strong>访问的,所以为了解决这一复杂问题，<br>需要自己写一个<code>iterator</code>类</p>\n<h2 id=\"普通迭代器\"><a href=\"#普通迭代器\" class=\"headerlink\" title=\"普通迭代器\"></a>普通迭代器</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;<span class=\"comment\">//迭代器也得用模板</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__list_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T&gt; Self;<span class=\"comment\">//简化代码</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class=\"line\">\tNode* _node;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__list_iterator(Node* node) :_node(node) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSelf&amp; <span class=\"keyword\">operator</span>++()<span class=\"comment\">//重载operator++</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_node = _node-&gt;_next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"type\">const</span> Self&amp; it) <span class=\"type\">const</span> <span class=\"comment\">//重载!==,比较操作符记得加const</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _node != it._node;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tT&amp; <span class=\"keyword\">operator</span>*()<span class=\"comment\">//重载 *</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _node-&gt;_val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em><code>list</code>类中添加如下代码</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T&gt; iterator;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">iterator <span class=\"title\">begin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">iterator</span>(_head-&gt;_next);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">iterator <span class=\"title\">end</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">iterator</span>(_head);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过如上修改,<code>list</code>已经支持<code>普通迭代器</code>,并且非<code>const</code>修饰的<code>list</code>已经支持<code>范围for</code>了</p>\n<blockquote>\n<p>测试代码如下</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tlist&lt;<span class=\"type\">int</span>&gt; lst;</span><br><span class=\"line\">\tlst.<span class=\"built_in\">push_front</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">\tlst.<span class=\"built_in\">push_front</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">\tlst.<span class=\"built_in\">push_front</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">\tlst.<span class=\"built_in\">push_front</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">\tlst.<span class=\"built_in\">push_front</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : lst)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; e &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"const迭代器\"><a href=\"#const迭代器\" class=\"headerlink\" title=\"const迭代器\"></a>const迭代器</h2><p><code>const list</code>要能提供<code>const_iterator</code>，因此我们还要写一个<code>const_iterator</code>类…吗？</p>\n<p>其实<strong>并不用</strong>，要利用好C++中的<code>模板语法</code>来大大提高代码的复用性,尤其像<code>iterator</code>和<code>const_iterator</code>这种差别不大的类,没必要每个都单独写一段代码</p>\n<p>为此我们的<code>__list_iterator</code>只需要能用<code>模板</code>解决好二者的差异即可。而目前最大的问题是什么？是<code>operator*()</code>的返回值问题,一个是返回<code>T&amp;</code>,另一个是<code>const T&amp;</code>,其他的成员函数则基本没差别,所以不妨扩充一下<code>模板参数</code>,添加一个<code>Ref</code>类。</p>\n<blockquote>\n<p>有变化的代码如下</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ref</span>&gt;<span class=\"comment\">//增加一个Ref参数</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__list_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,Ref&gt; Self;<span class=\"comment\">//Self这里的原类也要加</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class=\"line\">\tNode* _node;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__list_iterator(Node* node) :_node(node) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRef <span class=\"keyword\">operator</span>*()<span class=\"comment\">//直接返回Ref类</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _node-&gt;_val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><em><code>list</code>类也有相应变化</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,T&amp;&gt; iterator;<span class=\"comment\">//普通迭代器</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,<span class=\"type\">const</span> T&amp;&gt; const_iterator;<span class=\"comment\">//const迭代器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">const_iterator <span class=\"title\">begin</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"comment\">//针对const指针的</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">const_iterator</span>(_head-&gt;_next);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">const_iterator <span class=\"title\">end</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">const_iterator</span>(_head);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样通过增加一个<code>Ref</code>模板参数,完成了对<code>iterator</code>和<code>const_iterator</code>的代码级统一(<em>当然模板实例化出来是不一样的</em>)</p>\n<p>但别忘了迭代器还要提供<code>-&gt;</code>操作符的重载,而<code>operator-&gt;()</code>函数要返回不同的指针，所以我们如法炮制，再增加一个<code>Ptr</code>模板参数</p>\n<blockquote>\n<p>有变化的代码如下</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ref</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ptr</span>&gt;<span class=\"comment\">//增加一个Ptr参数</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__list_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; Self;<span class=\"comment\">//Self相应更改</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tPtr <span class=\"keyword\">operator</span>-&gt;()<span class=\"comment\">//重载-&gt;</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;(_node-&gt;_val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em><code>list</code>类也有相应变化</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;<span class=\"comment\">//普通迭代器</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,<span class=\"type\">const</span> T&amp;,<span class=\"type\">const</span> T*&gt; const_iterator;<span class=\"comment\">//const迭代器</span></span><br></pre></td></tr></table></figure>\n\n<p>至此，<code>list</code>和<code>__list_iterator</code>的基本功能已基本完成，本篇的重点<code>__list_iterator</code>主要解决了两点问题</p>\n<p>-为了应对<code>list</code>的迭代器的复杂性，单独为其构建一个<code>__list_iterator</code>类，并提供一系列的操作符重载<br>-为了提高代码的<strong>复用性</strong>,仅用一个<code>__list_iterator</code>类来<code>typedef</code>普通迭代器和<code>const</code>迭代器,我们增加了模板参数,最终模板变为<code>template&lt;class T, class Ref, class Ptr&gt;</code></p>\n<h2 id=\"用普通迭代器构造const迭代器\"><a href=\"#用普通迭代器构造const迭代器\" class=\"headerlink\" title=\"用普通迭代器构造const迭代器\"></a>用普通迭代器构造const迭代器</h2><p>有时候我们需要用普通迭代器构造<code>const</code>迭代器,于是可以给<code>__list_iterator</code>提供一个比较有意思的<code>构造函数</code>,<br>可以实现时而充当拷贝构造，时而充当满足上述的构造</p>\n<blockquote>\n<p>代码如下</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; Self;<span class=\"comment\">//再展示一遍Self的代码，便于下文对比</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;<span class=\"comment\">//指定普通迭代器，并用typedef简化代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">__list_iterator(iterator it) :_node(it._node) &#123;&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>-当模板参数为<code>&lt;T,T&amp;,T*&gt;</code>时，<code>Self</code>和<code>iterator</code>相同，上段代码中的构造函数相当于<code>拷贝构造</code></p>\n<p>-当模板参数为<code>&lt;T,const T&amp;,const T*&gt;</code>时，<code>Self</code>和<code>iterator</code>不同,<code>Slef</code>是<code>const</code>迭代器,<code>iterator</code><strong>始终</strong>是普通迭代器，这个构造函数便能用普通迭代器构造<code>const</code>迭代器</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>通过构造一个<code>list</code>类，我们使用到了更复杂的迭代器，使用了带<code>3个模板参数</code>的<code>__list_iterator</code>类定义普通迭代器和<code>const</code>迭代器，学习了如何利用模板参数提高代码的复用性，如何提供额外的<code>构造函数</code>使<code>__list_iterator</code>支持用普通迭代器构造<code>const</code>迭代器</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<p>前置博客:<strong><a href=\"https://www.supdriver.top/2023/12/07/cpp-class/\" title=\"点击跳转\">从构建一个Date类入门C++类与对象</a></strong></p>\n<blockquote>\n<p>下面先迅速地搓一个<code>list</code>类</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;<span class=\"comment\">//先用模板创建一个节点类</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tT _val;</span><br><span class=\"line\">\tListNode&lt;T&gt;* _next;</span><br><span class=\"line\">\tListNode&lt;T&gt;* _prev;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//提供全缺省的默认构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">ListNode</span>(<span class=\"type\">const</span> T&amp; val = <span class=\"built_in\">T</span>()) :_val(val), _next(<span class=\"literal\">nullptr</span>), _prev(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用ListNode构造list类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">list</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> ListNode&lt;T&gt; Node;<span class=\"comment\">//用typedef简化代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">list</span>()<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_head = <span class=\"keyword\">new</span> Node;</span><br><span class=\"line\">\t\t<span class=\"comment\">//维护两个指针</span></span><br><span class=\"line\">\t\t_head-&gt;_next = _head;</span><br><span class=\"line\">\t\t_head-&gt;_prev = _head;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_front</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; val)</span><span class=\"comment\">//头插</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tNode* newnode = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(val);</span><br><span class=\"line\">\t\tNode* next = _head-&gt;_next;<span class=\"comment\">//额外的指针，简化代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t_head-&gt;_next = newnode;</span><br><span class=\"line\">\t\tnewnode-&gt;_prev = _head;</span><br><span class=\"line\">\t\tnewnode-&gt;_next = next;</span><br><span class=\"line\">\t\tnext-&gt;_prev = newnode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop_front</span><span class=\"params\">()</span><span class=\"comment\">//尾插</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tNode* cur = _head-&gt;_next;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t_head-&gt;_next = cur-&gt;_next;</span><br><span class=\"line\">\t\tcur-&gt;_next-&gt;_prev = _head;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> cur;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"comment\">//判空</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _head-&gt;_next == _head;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//剩余代码自行补全</span></span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode* _head;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"list的迭代器\"><a href=\"#list的迭代器\" class=\"headerlink\" title=\"list的迭代器\"></a>list的迭代器</h1><p>不同于<code>vector</code>底层的数据在内存中<strong>连续</strong>存储,可以用<code>原生指针</code>充当迭代器,例如<code>typedef T* iterator</code></p>\n<p><code>list</code>的底层是链表,在内存中<strong>分散</strong>*存储，是<strong>不能</strong>用<code>原生指针</code>来<strong>连续</strong>访问的,所以为了解决这一复杂问题，<br>需要自己写一个<code>iterator</code>类</p>\n<h2 id=\"普通迭代器\"><a href=\"#普通迭代器\" class=\"headerlink\" title=\"普通迭代器\"></a>普通迭代器</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;<span class=\"comment\">//迭代器也得用模板</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__list_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T&gt; Self;<span class=\"comment\">//简化代码</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class=\"line\">\tNode* _node;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__list_iterator(Node* node) :_node(node) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSelf&amp; <span class=\"keyword\">operator</span>++()<span class=\"comment\">//重载operator++</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_node = _node-&gt;_next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"type\">const</span> Self&amp; it) <span class=\"type\">const</span> <span class=\"comment\">//重载!==,比较操作符记得加const</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _node != it._node;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tT&amp; <span class=\"keyword\">operator</span>*()<span class=\"comment\">//重载 *</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _node-&gt;_val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em><code>list</code>类中添加如下代码</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T&gt; iterator;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">iterator <span class=\"title\">begin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">iterator</span>(_head-&gt;_next);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">iterator <span class=\"title\">end</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">iterator</span>(_head);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过如上修改,<code>list</code>已经支持<code>普通迭代器</code>,并且非<code>const</code>修饰的<code>list</code>已经支持<code>范围for</code>了</p>\n<blockquote>\n<p>测试代码如下</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tlist&lt;<span class=\"type\">int</span>&gt; lst;</span><br><span class=\"line\">\tlst.<span class=\"built_in\">push_front</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">\tlst.<span class=\"built_in\">push_front</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">\tlst.<span class=\"built_in\">push_front</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">\tlst.<span class=\"built_in\">push_front</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">\tlst.<span class=\"built_in\">push_front</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : lst)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; e &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"const迭代器\"><a href=\"#const迭代器\" class=\"headerlink\" title=\"const迭代器\"></a>const迭代器</h2><p><code>const list</code>要能提供<code>const_iterator</code>，因此我们还要写一个<code>const_iterator</code>类…吗？</p>\n<p>其实<strong>并不用</strong>，要利用好C++中的<code>模板语法</code>来大大提高代码的复用性,尤其像<code>iterator</code>和<code>const_iterator</code>这种差别不大的类,没必要每个都单独写一段代码</p>\n<p>为此我们的<code>__list_iterator</code>只需要能用<code>模板</code>解决好二者的差异即可。而目前最大的问题是什么？是<code>operator*()</code>的返回值问题,一个是返回<code>T&amp;</code>,另一个是<code>const T&amp;</code>,其他的成员函数则基本没差别,所以不妨扩充一下<code>模板参数</code>,添加一个<code>Ref</code>类。</p>\n<blockquote>\n<p>有变化的代码如下</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ref</span>&gt;<span class=\"comment\">//增加一个Ref参数</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__list_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,Ref&gt; Self;<span class=\"comment\">//Self这里的原类也要加</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class=\"line\">\tNode* _node;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__list_iterator(Node* node) :_node(node) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRef <span class=\"keyword\">operator</span>*()<span class=\"comment\">//直接返回Ref类</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _node-&gt;_val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><em><code>list</code>类也有相应变化</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,T&amp;&gt; iterator;<span class=\"comment\">//普通迭代器</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,<span class=\"type\">const</span> T&amp;&gt; const_iterator;<span class=\"comment\">//const迭代器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">const_iterator <span class=\"title\">begin</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"comment\">//针对const指针的</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">const_iterator</span>(_head-&gt;_next);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">const_iterator <span class=\"title\">end</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">const_iterator</span>(_head);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样通过增加一个<code>Ref</code>模板参数,完成了对<code>iterator</code>和<code>const_iterator</code>的代码级统一(<em>当然模板实例化出来是不一样的</em>)</p>\n<p>但别忘了迭代器还要提供<code>-&gt;</code>操作符的重载,而<code>operator-&gt;()</code>函数要返回不同的指针，所以我们如法炮制，再增加一个<code>Ptr</code>模板参数</p>\n<blockquote>\n<p>有变化的代码如下</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ref</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Ptr</span>&gt;<span class=\"comment\">//增加一个Ptr参数</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">__list_iterator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; Self;<span class=\"comment\">//Self相应更改</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tPtr <span class=\"keyword\">operator</span>-&gt;()<span class=\"comment\">//重载-&gt;</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;(_node-&gt;_val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em><code>list</code>类也有相应变化</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;<span class=\"comment\">//普通迭代器</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> __list_iterator&lt;T,<span class=\"type\">const</span> T&amp;,<span class=\"type\">const</span> T*&gt; const_iterator;<span class=\"comment\">//const迭代器</span></span><br></pre></td></tr></table></figure>\n\n<p>至此，<code>list</code>和<code>__list_iterator</code>的基本功能已基本完成，本篇的重点<code>__list_iterator</code>主要解决了两点问题</p>\n<p>-为了应对<code>list</code>的迭代器的复杂性，单独为其构建一个<code>__list_iterator</code>类，并提供一系列的操作符重载<br>-为了提高代码的<strong>复用性</strong>,仅用一个<code>__list_iterator</code>类来<code>typedef</code>普通迭代器和<code>const</code>迭代器,我们增加了模板参数,最终模板变为<code>template&lt;class T, class Ref, class Ptr&gt;</code></p>\n<h2 id=\"用普通迭代器构造const迭代器\"><a href=\"#用普通迭代器构造const迭代器\" class=\"headerlink\" title=\"用普通迭代器构造const迭代器\"></a>用普通迭代器构造const迭代器</h2><p>有时候我们需要用普通迭代器构造<code>const</code>迭代器,于是可以给<code>__list_iterator</code>提供一个比较有意思的<code>构造函数</code>,<br>可以实现时而充当拷贝构造，时而充当满足上述的构造</p>\n<blockquote>\n<p>代码如下</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; Self;<span class=\"comment\">//再展示一遍Self的代码，便于下文对比</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;<span class=\"comment\">//指定普通迭代器，并用typedef简化代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">__list_iterator(iterator it) :_node(it._node) &#123;&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>-当模板参数为<code>&lt;T,T&amp;,T*&gt;</code>时，<code>Self</code>和<code>iterator</code>相同，上段代码中的构造函数相当于<code>拷贝构造</code></p>\n<p>-当模板参数为<code>&lt;T,const T&amp;,const T*&gt;</code>时，<code>Self</code>和<code>iterator</code>不同,<code>Slef</code>是<code>const</code>迭代器,<code>iterator</code><strong>始终</strong>是普通迭代器，这个构造函数便能用普通迭代器构造<code>const</code>迭代器</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>通过构造一个<code>list</code>类，我们使用到了更复杂的迭代器，使用了带<code>3个模板参数</code>的<code>__list_iterator</code>类定义普通迭代器和<code>const</code>迭代器，学习了如何利用模板参数提高代码的复用性，如何提供额外的<code>构造函数</code>使<code>__list_iterator</code>支持用普通迭代器构造<code>const</code>迭代器</p>\n"},{"title":"环境变量","date":"2024-07-06T13:36:21.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-25_22-38-03.png","_content":"\n# 基本概念\n+ 环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些**参数**\n+ 环境变量通常具有某些特殊用途，还有在系统当中通常具有**全局特性**\n\n**构成**：环境变量是一系列`字符串`的统称,所以一个环境变量由`变量名`和`值`构成\n\n这么说还是太抽象了，我们接下来会举几个具体样例，体会`环境变量`在获取系统全局的变量，系统指令路径等方面的作用\n\n## 常见环境变量\n\n| 变量名 | 功能 |\n| ------- | --------|\n| `PATH` | 指定命令的搜索路径 |\n| `HOME` | 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录) |\n| `USER` | 当前用户名 |\n| `SHELL` | 当前Shell,它的值通常是`/bin/bash` |\n| `PWD` | 当前工作目录\n\n# 操作系统变量\n\n## 查看环境变量\n`echo $NAME` *NAME为变量名*\n\n以`PATH`为例,查看`PATH`的值的指令为\n\n```SHELL\necho $PATH\n```\n\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_12-46-35.png\n\n可以看到`PATH`的内容为多个文件路径，互相以`:`分隔\n\n而若要查看当前的全部环境变量,可以使用`env`指令,将当前所有环境变量打印在终端上\n\n也可以通过`管道`和`grep`将`env`的输出内容过滤\n\n*查看PATH*\n```SHELL\nenv | grep PATH\n```\n\n同时还有个`set` 指令可以显示本地定义的shell变量和环境变量环境变量的组织方式 \n\n\n## 获取进程的环境变量\n+ 在程序中，可以使用`getenv()`接口获取对应`环境变量名`的对应环境变量值\n\n*`getenv`在`<stdlib.h>`中*\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    printf(\"PATH: %s\\n\",getenv(\"PATH\"));//打印PATH的值\n    return 0;\n}\n```\n\n## 环境变量的组织方式\n每个`进程`都有自己的`环境表`,所谓`环境表`就是一个**字符**`指针数组`,每个不为`NULL`的指针指向`环境字符串`\n\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_20-52-19.png\n\n+ 因此也可以使用`main`函数传参来打印所有环境变量的内容\n```C\nint main(int argc,char* argv[],con char* env[])\n{\n    char* str;\n    int i = 0;\n    while(str =env[i++]) printf(\"%s\\n\",str);\n    return 0;\n}\n```\n\n## 导入环境变量\n头文件`unistd.h>`提供了一个全局变量`environ`,因此可以用`extern`导入环境变量\n\n```C\n#include <stdio.h>\n#include <unistd.h>\n\nextern char **environ;//导入换进变量\n\nint main()\n{\n    const char* str;\n    int i = 0;\n    while(str =environ[i++]) printf(\"%s\\n\",str);\n    return 0;\n}\n```\n\n## 添加新的环境变量\n使用`export`命令可以添加新的环境变量\n\n使用方法:`export``=``(变量值)`\n\n例如添加一个值为`supdriver666`,名为`MY_VALUE`的环境变量,最后查看该变量\n\n```SHELL\nexport MY_VALUE=supdriver666\n\nenv | grep MY_VALUE\n```\n\n## 程序内设置换进变量\n使用`<stdlib.h>`提供的`putenv()`接口可以设置环境变量，用法与`export`指令相同\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    putenv(\"MY_VALUE=666\");\n    printf(\"MY_VALUE = %s\",getenv(\"MY_VALUE\"));\n    return 0;\n}\n```\n\n\n## 删除环境变量\n使用`unset`可以删除环境变量\n\n*删除上文的`MY_VALUE`*\n```SHELL\nunset MY_VALUE\n\nenv | grep MY_VALUE\n```\n可以看到没有输出了 \n\n## 添加本地shell变量 和 查看本地变量与环境变量\n添加本地变量: 直接输入`(变量名)``=``(值)`  //*不加空格*/\n\n查看变量: 使用`set`命令查看本地变量与环境变量，但是内容非常多，建议搭配`grep`等使用\n\n*例*\n```SHELL\nmy_value=2024\n\nset\n\nset | grep my_value\n```\n\n## 本地变量与环境变量\n二者最大的差别是`环境变量`可以被子进程**继承**,而`本地变量`只在本BASH内部有效，**不会**被继承\n\n\n","source":"_posts/evn.md","raw":"---\ntitle: 环境变量\ndate: 2024-07-06 21:36:21\ntags: 环境变量\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-25_22-38-03.png\n---\n\n# 基本概念\n+ 环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些**参数**\n+ 环境变量通常具有某些特殊用途，还有在系统当中通常具有**全局特性**\n\n**构成**：环境变量是一系列`字符串`的统称,所以一个环境变量由`变量名`和`值`构成\n\n这么说还是太抽象了，我们接下来会举几个具体样例，体会`环境变量`在获取系统全局的变量，系统指令路径等方面的作用\n\n## 常见环境变量\n\n| 变量名 | 功能 |\n| ------- | --------|\n| `PATH` | 指定命令的搜索路径 |\n| `HOME` | 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录) |\n| `USER` | 当前用户名 |\n| `SHELL` | 当前Shell,它的值通常是`/bin/bash` |\n| `PWD` | 当前工作目录\n\n# 操作系统变量\n\n## 查看环境变量\n`echo $NAME` *NAME为变量名*\n\n以`PATH`为例,查看`PATH`的值的指令为\n\n```SHELL\necho $PATH\n```\n\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_12-46-35.png\n\n可以看到`PATH`的内容为多个文件路径，互相以`:`分隔\n\n而若要查看当前的全部环境变量,可以使用`env`指令,将当前所有环境变量打印在终端上\n\n也可以通过`管道`和`grep`将`env`的输出内容过滤\n\n*查看PATH*\n```SHELL\nenv | grep PATH\n```\n\n同时还有个`set` 指令可以显示本地定义的shell变量和环境变量环境变量的组织方式 \n\n\n## 获取进程的环境变量\n+ 在程序中，可以使用`getenv()`接口获取对应`环境变量名`的对应环境变量值\n\n*`getenv`在`<stdlib.h>`中*\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    printf(\"PATH: %s\\n\",getenv(\"PATH\"));//打印PATH的值\n    return 0;\n}\n```\n\n## 环境变量的组织方式\n每个`进程`都有自己的`环境表`,所谓`环境表`就是一个**字符**`指针数组`,每个不为`NULL`的指针指向`环境字符串`\n\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_20-52-19.png\n\n+ 因此也可以使用`main`函数传参来打印所有环境变量的内容\n```C\nint main(int argc,char* argv[],con char* env[])\n{\n    char* str;\n    int i = 0;\n    while(str =env[i++]) printf(\"%s\\n\",str);\n    return 0;\n}\n```\n\n## 导入环境变量\n头文件`unistd.h>`提供了一个全局变量`environ`,因此可以用`extern`导入环境变量\n\n```C\n#include <stdio.h>\n#include <unistd.h>\n\nextern char **environ;//导入换进变量\n\nint main()\n{\n    const char* str;\n    int i = 0;\n    while(str =environ[i++]) printf(\"%s\\n\",str);\n    return 0;\n}\n```\n\n## 添加新的环境变量\n使用`export`命令可以添加新的环境变量\n\n使用方法:`export``=``(变量值)`\n\n例如添加一个值为`supdriver666`,名为`MY_VALUE`的环境变量,最后查看该变量\n\n```SHELL\nexport MY_VALUE=supdriver666\n\nenv | grep MY_VALUE\n```\n\n## 程序内设置换进变量\n使用`<stdlib.h>`提供的`putenv()`接口可以设置环境变量，用法与`export`指令相同\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    putenv(\"MY_VALUE=666\");\n    printf(\"MY_VALUE = %s\",getenv(\"MY_VALUE\"));\n    return 0;\n}\n```\n\n\n## 删除环境变量\n使用`unset`可以删除环境变量\n\n*删除上文的`MY_VALUE`*\n```SHELL\nunset MY_VALUE\n\nenv | grep MY_VALUE\n```\n可以看到没有输出了 \n\n## 添加本地shell变量 和 查看本地变量与环境变量\n添加本地变量: 直接输入`(变量名)``=``(值)`  //*不加空格*/\n\n查看变量: 使用`set`命令查看本地变量与环境变量，但是内容非常多，建议搭配`grep`等使用\n\n*例*\n```SHELL\nmy_value=2024\n\nset\n\nset | grep my_value\n```\n\n## 本地变量与环境变量\n二者最大的差别是`环境变量`可以被子进程**继承**,而`本地变量`只在本BASH内部有效，**不会**被继承\n\n\n","slug":"evn","published":1,"updated":"2024-07-25T14:38:44.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08a000t4sp5auovesbe","content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ul>\n<li>环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些<strong>参数</strong></li>\n<li>环境变量通常具有某些特殊用途，还有在系统当中通常具有<strong>全局特性</strong></li>\n</ul>\n<p><strong>构成</strong>：环境变量是一系列<code>字符串</code>的统称,所以一个环境变量由<code>变量名</code>和<code>值</code>构成</p>\n<p>这么说还是太抽象了，我们接下来会举几个具体样例，体会<code>环境变量</code>在获取系统全局的变量，系统指令路径等方面的作用</p>\n<h2 id=\"常见环境变量\"><a href=\"#常见环境变量\" class=\"headerlink\" title=\"常见环境变量\"></a>常见环境变量</h2><table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PATH</code></td>\n<td>指定命令的搜索路径</td>\n</tr>\n<tr>\n<td><code>HOME</code></td>\n<td>指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)</td>\n</tr>\n<tr>\n<td><code>USER</code></td>\n<td>当前用户名</td>\n</tr>\n<tr>\n<td><code>SHELL</code></td>\n<td>当前Shell,它的值通常是<code>/bin/bash</code></td>\n</tr>\n<tr>\n<td><code>PWD</code></td>\n<td>当前工作目录</td>\n</tr>\n</tbody></table>\n<h1 id=\"操作系统变量\"><a href=\"#操作系统变量\" class=\"headerlink\" title=\"操作系统变量\"></a>操作系统变量</h1><h2 id=\"查看环境变量\"><a href=\"#查看环境变量\" class=\"headerlink\" title=\"查看环境变量\"></a>查看环境变量</h2><p><code>echo $NAME</code> <em>NAME为变量名</em></p>\n<p>以<code>PATH</code>为例,查看<code>PATH</code>的值的指令为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $PATH</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_12-46-35.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_12-46-35.png</a></p>\n<p>可以看到<code>PATH</code>的内容为多个文件路径，互相以<code>:</code>分隔</p>\n<p>而若要查看当前的全部环境变量,可以使用<code>env</code>指令,将当前所有环境变量打印在终端上</p>\n<p>也可以通过<code>管道</code>和<code>grep</code>将<code>env</code>的输出内容过滤</p>\n<p><em>查看PATH</em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env | grep PATH</span><br></pre></td></tr></table></figure>\n\n<p>同时还有个<code>set</code> 指令可以显示本地定义的shell变量和环境变量环境变量的组织方式 </p>\n<h2 id=\"获取进程的环境变量\"><a href=\"#获取进程的环境变量\" class=\"headerlink\" title=\"获取进程的环境变量\"></a>获取进程的环境变量</h2><ul>\n<li>在程序中，可以使用<code>getenv()</code>接口获取对应<code>环境变量名</code>的对应环境变量值</li>\n</ul>\n<p><em><code>getenv</code>在<code>&lt;stdlib.h&gt;</code>中</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;PATH: %s\\n&quot;</span>,getenv(<span class=\"string\">&quot;PATH&quot;</span>));<span class=\"comment\">//打印PATH的值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"环境变量的组织方式\"><a href=\"#环境变量的组织方式\" class=\"headerlink\" title=\"环境变量的组织方式\"></a>环境变量的组织方式</h2><p>每个<code>进程</code>都有自己的<code>环境表</code>,所谓<code>环境表</code>就是一个<strong>字符</strong><code>指针数组</code>,每个不为<code>NULL</code>的指针指向<code>环境字符串</code></p>\n<p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_20-52-19.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_20-52-19.png</a></p>\n<ul>\n<li>因此也可以使用<code>main</code>函数传参来打印所有环境变量的内容<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc,<span class=\"type\">char</span>* argv[],con <span class=\"type\">char</span>* env[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* str;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str =env[i++]) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"导入环境变量\"><a href=\"#导入环境变量\" class=\"headerlink\" title=\"导入环境变量\"></a>导入环境变量</h2><p>头文件<code>unistd.h&gt;</code>提供了一个全局变量<code>environ</code>,因此可以用<code>extern</code>导入环境变量</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">char</span> **environ;<span class=\"comment\">//导入换进变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* str;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str =environ[i++]) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加新的环境变量\"><a href=\"#添加新的环境变量\" class=\"headerlink\" title=\"添加新的环境变量\"></a>添加新的环境变量</h2><p>使用<code>export</code>命令可以添加新的环境变量</p>\n<p>使用方法:<code>export``=``(变量值)</code></p>\n<p>例如添加一个值为<code>supdriver666</code>,名为<code>MY_VALUE</code>的环境变量,最后查看该变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export MY_VALUE=supdriver666</span><br><span class=\"line\"></span><br><span class=\"line\">env | grep MY_VALUE</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"程序内设置换进变量\"><a href=\"#程序内设置换进变量\" class=\"headerlink\" title=\"程序内设置换进变量\"></a>程序内设置换进变量</h2><p>使用<code>&lt;stdlib.h&gt;</code>提供的<code>putenv()</code>接口可以设置环境变量，用法与<code>export</code>指令相同</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    putenv(<span class=\"string\">&quot;MY_VALUE=666&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;MY_VALUE = %s&quot;</span>,getenv(<span class=\"string\">&quot;MY_VALUE&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"删除环境变量\"><a href=\"#删除环境变量\" class=\"headerlink\" title=\"删除环境变量\"></a>删除环境变量</h2><p>使用<code>unset</code>可以删除环境变量</p>\n<p><em>删除上文的<code>MY_VALUE</code></em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unset MY_VALUE</span><br><span class=\"line\"></span><br><span class=\"line\">env | grep MY_VALUE</span><br></pre></td></tr></table></figure>\n<p>可以看到没有输出了 </p>\n<h2 id=\"添加本地shell变量-和-查看本地变量与环境变量\"><a href=\"#添加本地shell变量-和-查看本地变量与环境变量\" class=\"headerlink\" title=\"添加本地shell变量 和 查看本地变量与环境变量\"></a>添加本地shell变量 和 查看本地变量与环境变量</h2><p>添加本地变量: 直接输入<code>(变量名)``=``(值)</code>  &#x2F;&#x2F;<em>不加空格</em>&#x2F;</p>\n<p>查看变量: 使用<code>set</code>命令查看本地变量与环境变量，但是内容非常多，建议搭配<code>grep</code>等使用</p>\n<p><em>例</em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_value=2024</span><br><span class=\"line\"></span><br><span class=\"line\">set</span><br><span class=\"line\"></span><br><span class=\"line\">set | grep my_value</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"本地变量与环境变量\"><a href=\"#本地变量与环境变量\" class=\"headerlink\" title=\"本地变量与环境变量\"></a>本地变量与环境变量</h2><p>二者最大的差别是<code>环境变量</code>可以被子进程<strong>继承</strong>,而<code>本地变量</code>只在本BASH内部有效，<strong>不会</strong>被继承</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ul>\n<li>环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些<strong>参数</strong></li>\n<li>环境变量通常具有某些特殊用途，还有在系统当中通常具有<strong>全局特性</strong></li>\n</ul>\n<p><strong>构成</strong>：环境变量是一系列<code>字符串</code>的统称,所以一个环境变量由<code>变量名</code>和<code>值</code>构成</p>\n<p>这么说还是太抽象了，我们接下来会举几个具体样例，体会<code>环境变量</code>在获取系统全局的变量，系统指令路径等方面的作用</p>\n<h2 id=\"常见环境变量\"><a href=\"#常见环境变量\" class=\"headerlink\" title=\"常见环境变量\"></a>常见环境变量</h2><table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PATH</code></td>\n<td>指定命令的搜索路径</td>\n</tr>\n<tr>\n<td><code>HOME</code></td>\n<td>指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)</td>\n</tr>\n<tr>\n<td><code>USER</code></td>\n<td>当前用户名</td>\n</tr>\n<tr>\n<td><code>SHELL</code></td>\n<td>当前Shell,它的值通常是<code>/bin/bash</code></td>\n</tr>\n<tr>\n<td><code>PWD</code></td>\n<td>当前工作目录</td>\n</tr>\n</tbody></table>\n<h1 id=\"操作系统变量\"><a href=\"#操作系统变量\" class=\"headerlink\" title=\"操作系统变量\"></a>操作系统变量</h1><h2 id=\"查看环境变量\"><a href=\"#查看环境变量\" class=\"headerlink\" title=\"查看环境变量\"></a>查看环境变量</h2><p><code>echo $NAME</code> <em>NAME为变量名</em></p>\n<p>以<code>PATH</code>为例,查看<code>PATH</code>的值的指令为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $PATH</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_12-46-35.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_12-46-35.png</a></p>\n<p>可以看到<code>PATH</code>的内容为多个文件路径，互相以<code>:</code>分隔</p>\n<p>而若要查看当前的全部环境变量,可以使用<code>env</code>指令,将当前所有环境变量打印在终端上</p>\n<p>也可以通过<code>管道</code>和<code>grep</code>将<code>env</code>的输出内容过滤</p>\n<p><em>查看PATH</em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env | grep PATH</span><br></pre></td></tr></table></figure>\n\n<p>同时还有个<code>set</code> 指令可以显示本地定义的shell变量和环境变量环境变量的组织方式 </p>\n<h2 id=\"获取进程的环境变量\"><a href=\"#获取进程的环境变量\" class=\"headerlink\" title=\"获取进程的环境变量\"></a>获取进程的环境变量</h2><ul>\n<li>在程序中，可以使用<code>getenv()</code>接口获取对应<code>环境变量名</code>的对应环境变量值</li>\n</ul>\n<p><em><code>getenv</code>在<code>&lt;stdlib.h&gt;</code>中</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;PATH: %s\\n&quot;</span>,getenv(<span class=\"string\">&quot;PATH&quot;</span>));<span class=\"comment\">//打印PATH的值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"环境变量的组织方式\"><a href=\"#环境变量的组织方式\" class=\"headerlink\" title=\"环境变量的组织方式\"></a>环境变量的组织方式</h2><p>每个<code>进程</code>都有自己的<code>环境表</code>,所谓<code>环境表</code>就是一个<strong>字符</strong><code>指针数组</code>,每个不为<code>NULL</code>的指针指向<code>环境字符串</code></p>\n<p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_20-52-19.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-08_20-52-19.png</a></p>\n<ul>\n<li>因此也可以使用<code>main</code>函数传参来打印所有环境变量的内容<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc,<span class=\"type\">char</span>* argv[],con <span class=\"type\">char</span>* env[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* str;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str =env[i++]) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"导入环境变量\"><a href=\"#导入环境变量\" class=\"headerlink\" title=\"导入环境变量\"></a>导入环境变量</h2><p>头文件<code>unistd.h&gt;</code>提供了一个全局变量<code>environ</code>,因此可以用<code>extern</code>导入环境变量</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">char</span> **environ;<span class=\"comment\">//导入换进变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* str;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str =environ[i++]) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加新的环境变量\"><a href=\"#添加新的环境变量\" class=\"headerlink\" title=\"添加新的环境变量\"></a>添加新的环境变量</h2><p>使用<code>export</code>命令可以添加新的环境变量</p>\n<p>使用方法:<code>export``=``(变量值)</code></p>\n<p>例如添加一个值为<code>supdriver666</code>,名为<code>MY_VALUE</code>的环境变量,最后查看该变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export MY_VALUE=supdriver666</span><br><span class=\"line\"></span><br><span class=\"line\">env | grep MY_VALUE</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"程序内设置换进变量\"><a href=\"#程序内设置换进变量\" class=\"headerlink\" title=\"程序内设置换进变量\"></a>程序内设置换进变量</h2><p>使用<code>&lt;stdlib.h&gt;</code>提供的<code>putenv()</code>接口可以设置环境变量，用法与<code>export</code>指令相同</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    putenv(<span class=\"string\">&quot;MY_VALUE=666&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;MY_VALUE = %s&quot;</span>,getenv(<span class=\"string\">&quot;MY_VALUE&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"删除环境变量\"><a href=\"#删除环境变量\" class=\"headerlink\" title=\"删除环境变量\"></a>删除环境变量</h2><p>使用<code>unset</code>可以删除环境变量</p>\n<p><em>删除上文的<code>MY_VALUE</code></em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unset MY_VALUE</span><br><span class=\"line\"></span><br><span class=\"line\">env | grep MY_VALUE</span><br></pre></td></tr></table></figure>\n<p>可以看到没有输出了 </p>\n<h2 id=\"添加本地shell变量-和-查看本地变量与环境变量\"><a href=\"#添加本地shell变量-和-查看本地变量与环境变量\" class=\"headerlink\" title=\"添加本地shell变量 和 查看本地变量与环境变量\"></a>添加本地shell变量 和 查看本地变量与环境变量</h2><p>添加本地变量: 直接输入<code>(变量名)``=``(值)</code>  &#x2F;&#x2F;<em>不加空格</em>&#x2F;</p>\n<p>查看变量: 使用<code>set</code>命令查看本地变量与环境变量，但是内容非常多，建议搭配<code>grep</code>等使用</p>\n<p><em>例</em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_value=2024</span><br><span class=\"line\"></span><br><span class=\"line\">set</span><br><span class=\"line\"></span><br><span class=\"line\">set | grep my_value</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"本地变量与环境变量\"><a href=\"#本地变量与环境变量\" class=\"headerlink\" title=\"本地变量与环境变量\"></a>本地变量与环境变量</h2><p>二者最大的差别是<code>环境变量</code>可以被子进程<strong>继承</strong>,而<code>本地变量</code>只在本BASH内部有效，<strong>不会</strong>被继承</p>\n"},{"title":"fork子进程,进程退出与等待","date":"2024-07-07T04:57:17.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-25_22-26-59.png","_content":"# 认识`fork()`\n头文件`<unistd.h>`提供的`fork()`函数用于从已有的`原进程`创建一个新的`子进程`，而原进程在关系式称为`父进程`\n\n## fork()的返回值\n```C\n#include <unistd.h>\npid_t id = fork();\n```\n\n父子进程中`fork()`函数的返回值(此处用变量`id`储存)是不同的:\n\n**父进程**里`id`的值为子进程的`PID`,其值`>0`;**子进程**里`id`值固定为`0`\n\n+ `id > 0` 父进程\n+ `id == 0` 子进程\n+ `id < 0` fork()失败\n\n## 分流\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_13-00-38.png\n\n利用父子进程中`fork()`返回值的不同，可以用`if...else...`进行分流，让父子进程执行不同的代码\n\n## fork()的过程\n进程调用`fork`，当控制转移到**内核**中的fork代码后，**内核**做\n\n+ 分配**新的**内存块和内核数据结构给子进程\n+ 将父进程部分数据结构内容**拷贝**至子进程\n+ 添加子进程到**系统进程列表**当中\n+ `fork`返回，开始调度器调度\n\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_18-54-41.png\n\n当一个进程调用fork之后，就有一对二进制**代码相同**的父子进程。而且它们都运行到相同的地方。但每个进程都可以**独立**地继续运行代码,并按代码分流至不同的代码段\n\n但这两个进程谁先执行**完全**由调度器决定，而谁先结束，则由实际执行情况和调度器决定\n\n## 拷贝的过程 与 写时拷贝\n`fork`时，子进程会将父进程虚拟内存的内容都复制一份在自己的虚拟内存中,但通过页表，二者映射到了同一块物理内存的区域，这样在二者都**没有写入行为**时，减少了物理内存中**冗余**的拷贝行为，有效提高了运行效率\n\n但当父子进程中有一方发生写入行为时，就会触发`写时拷贝`，此时物理内存中发生拷贝行为，但只拷贝进程映射的`数据段`，而由于**不发生进程替换时**父子进程的代码段一定相同，物理内存中,`代码段`映射部分并不发生拷贝\n\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_19-38-58.png\n\n\n# 进程退出\n\n## 进程退出的场景\n+ 代码运行完毕，结果正确\n+ 代码运行完毕，结果不正确\n+ 代码异常终止\n\n## 进程常见退出方法\n+ `main`函数返回\n+ `exit`退出\n+ `_exit`退出\n\n**异常退出**: `ctrl` + `c`\n\n## 查看退出码\n在终端使用命令`echo $?`可以查看退出码\n\n`注`尽管子进程返回的是`int`,父进程只取退出码的最低`8位`,所以以下三种情况\n\n+ `main`函数返回`-1`\n+ `exit(-1)`\n+ `_exit(-1)`\n\n在终端输`echo $?`可得退出码`255`\n\n## `exit` 和 `_eixt` 辨析\n`main`函数返回就不惜说了，来辨析一下头文件`<stdlib.h>`提供的`exit`和`_exit`函数\n\n### `_exit()`\n`_exit`会**直接终止**进程并返回状态码,而**不会**执行用户定义的清理函数，**也不会**清理缓冲区\n\n### `exit()`\n`exit`实际上最后也会调用`_exit`,但它会先执行一系列善后工作,顺序如下:\n\n1. 执行用户通过 atexit或on_exit定义的**清理函数**。\n2. 关闭所有打开的流，所有的**缓存数据**均被写入\n3. 调用`_exit`\n\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_22-10-26.png\n\n`return`退出： 执行`return n`等同于执行`exit(n)`\n\n# 进程等待\n\n## 进程等待的必要性\n+ 子进程退出后需要父进程来**回收**僵尸进程,防止产生其引发内存泄漏等问题\n+ 僵尸进程难以处理,`kill -9`也清理不掉\n+ 父进程通过进程等待的方式，**回收**子进程资源，获取子进程**退出信息**\n\n## 进程等待的方法\n\n### `wait`方法\n> #include<sys/types.h>\n> #include<sys/wait.h>\n>\n> pid_t wait(int*status);\n>\n> `参数`：显然`status`是输出型参数,获取子进程的`退出状态`,若不关心，可传参`NULL`\n>\n> `返回值`: 若**成功**，则返回被等待进程的`pid`,若**失败**，则返回`-1`\n\n### `waitpid`方法\n> 返回值：\n>    当正常返回的时候waitpid返回收集到的子进程的进程ID；\n>    如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；\n>    如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；\n> \n> 参数：\n>    `pid`：\n>        `pid == -1`,等待任一个子进程。与wait等效。\n>        `pid > 0`.等待其进程ID与pid相等的子进程。\n>    `status`:\n>        输出型参数传参`&status`: 将子进程的`状态码`存入`status`\n>        以下两个宏函数用于处理`状态码`:\n>        `WIFEXITED(status)`: 若为**正常终止**子进程返回的状态，则为真。（查看进程是否是**正常退出**）\n>        `WEXITSTATUS(status)`: 若WIFEXITED非零，提取子进程`退出码`。（查看进程的`退出码`）\n>    `options`:\n>        `WNOHANG`: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。\n>        `0`: 阻塞等待指定`pid`的进程\n>\n\n#### 阻塞等待\n`option` == `0`时`waitpid`采用阻塞等待，父进程会阻塞等待到子进程退出\n\n*示例代码*\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main()\n{\n    int status;\n    pid_t id = fork();\n    if(id == 0)\n    {\n        for(int i = 1;i<=5;i++)\n        {\n            printf(\"child running [%d]s\\n\",i);\n            sleep(1);\n        }\n        printf(\"child exited\\n\");\n        exit(0);\n    }\n    else\n    {\n        waitpid(id,&status,0);\n        if(WIFEXITED(status))\n            printf(\"father wait success, exit code: %d\\n\",WEXITSTATUS(status));\n        else\n            printf(\"child failed to exit\\n\");\n    }\n    return 1;\n}\n```\n\n#### 非阻塞轮询\n`option` == `WNOHANG`时,`waitpid`采用非阻塞等待,若等不到子进程退出，就会继续执行后面的代码，所以一般加上`while`等循环用于轮询，二者共同构成`非阻塞轮询`\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n//非阻塞轮询\nint main()\n{\n    int status;\n    pid_t id = fork();\n    if(id == 0)\n    {\n        sleep(5);\n        printf(\"child exited\\n\");\n        exit(0);\n    }\n    else\n    {\n        while(1)//轮询\n        {\n            pid_t rid = waitpid(id,&status,WNOHANG);\n            if(rid > 0)\n            {\n                if(WIFEXITED(status))\n                    printf(\"father wait success, exit code: %d\\n\",WEXITSTATUS(status));\n                else\n                    printf(\"child failed to exit\\n\");\n\n                break;\n            }\n            else if(rid == 0)\n            {\n                printf(\"等待子进程中...\\n\");\n                sleep(1);\n            }\n            else//rid<0\n            {\n                printf(\"wait failed\\n\");\n                break;\n            }\n        }\n    }\n    return 1;\n}\n```","source":"_posts/fork.md","raw":"---\ntitle: fork子进程,进程退出与等待\ndate: 2024-07-07 12:57:17\ntags: fork Linux\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-25_22-26-59.png\n---\n# 认识`fork()`\n头文件`<unistd.h>`提供的`fork()`函数用于从已有的`原进程`创建一个新的`子进程`，而原进程在关系式称为`父进程`\n\n## fork()的返回值\n```C\n#include <unistd.h>\npid_t id = fork();\n```\n\n父子进程中`fork()`函数的返回值(此处用变量`id`储存)是不同的:\n\n**父进程**里`id`的值为子进程的`PID`,其值`>0`;**子进程**里`id`值固定为`0`\n\n+ `id > 0` 父进程\n+ `id == 0` 子进程\n+ `id < 0` fork()失败\n\n## 分流\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_13-00-38.png\n\n利用父子进程中`fork()`返回值的不同，可以用`if...else...`进行分流，让父子进程执行不同的代码\n\n## fork()的过程\n进程调用`fork`，当控制转移到**内核**中的fork代码后，**内核**做\n\n+ 分配**新的**内存块和内核数据结构给子进程\n+ 将父进程部分数据结构内容**拷贝**至子进程\n+ 添加子进程到**系统进程列表**当中\n+ `fork`返回，开始调度器调度\n\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_18-54-41.png\n\n当一个进程调用fork之后，就有一对二进制**代码相同**的父子进程。而且它们都运行到相同的地方。但每个进程都可以**独立**地继续运行代码,并按代码分流至不同的代码段\n\n但这两个进程谁先执行**完全**由调度器决定，而谁先结束，则由实际执行情况和调度器决定\n\n## 拷贝的过程 与 写时拷贝\n`fork`时，子进程会将父进程虚拟内存的内容都复制一份在自己的虚拟内存中,但通过页表，二者映射到了同一块物理内存的区域，这样在二者都**没有写入行为**时，减少了物理内存中**冗余**的拷贝行为，有效提高了运行效率\n\n但当父子进程中有一方发生写入行为时，就会触发`写时拷贝`，此时物理内存中发生拷贝行为，但只拷贝进程映射的`数据段`，而由于**不发生进程替换时**父子进程的代码段一定相同，物理内存中,`代码段`映射部分并不发生拷贝\n\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_19-38-58.png\n\n\n# 进程退出\n\n## 进程退出的场景\n+ 代码运行完毕，结果正确\n+ 代码运行完毕，结果不正确\n+ 代码异常终止\n\n## 进程常见退出方法\n+ `main`函数返回\n+ `exit`退出\n+ `_exit`退出\n\n**异常退出**: `ctrl` + `c`\n\n## 查看退出码\n在终端使用命令`echo $?`可以查看退出码\n\n`注`尽管子进程返回的是`int`,父进程只取退出码的最低`8位`,所以以下三种情况\n\n+ `main`函数返回`-1`\n+ `exit(-1)`\n+ `_exit(-1)`\n\n在终端输`echo $?`可得退出码`255`\n\n## `exit` 和 `_eixt` 辨析\n`main`函数返回就不惜说了，来辨析一下头文件`<stdlib.h>`提供的`exit`和`_exit`函数\n\n### `_exit()`\n`_exit`会**直接终止**进程并返回状态码,而**不会**执行用户定义的清理函数，**也不会**清理缓冲区\n\n### `exit()`\n`exit`实际上最后也会调用`_exit`,但它会先执行一系列善后工作,顺序如下:\n\n1. 执行用户通过 atexit或on_exit定义的**清理函数**。\n2. 关闭所有打开的流，所有的**缓存数据**均被写入\n3. 调用`_exit`\n\nhttps://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_22-10-26.png\n\n`return`退出： 执行`return n`等同于执行`exit(n)`\n\n# 进程等待\n\n## 进程等待的必要性\n+ 子进程退出后需要父进程来**回收**僵尸进程,防止产生其引发内存泄漏等问题\n+ 僵尸进程难以处理,`kill -9`也清理不掉\n+ 父进程通过进程等待的方式，**回收**子进程资源，获取子进程**退出信息**\n\n## 进程等待的方法\n\n### `wait`方法\n> #include<sys/types.h>\n> #include<sys/wait.h>\n>\n> pid_t wait(int*status);\n>\n> `参数`：显然`status`是输出型参数,获取子进程的`退出状态`,若不关心，可传参`NULL`\n>\n> `返回值`: 若**成功**，则返回被等待进程的`pid`,若**失败**，则返回`-1`\n\n### `waitpid`方法\n> 返回值：\n>    当正常返回的时候waitpid返回收集到的子进程的进程ID；\n>    如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；\n>    如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；\n> \n> 参数：\n>    `pid`：\n>        `pid == -1`,等待任一个子进程。与wait等效。\n>        `pid > 0`.等待其进程ID与pid相等的子进程。\n>    `status`:\n>        输出型参数传参`&status`: 将子进程的`状态码`存入`status`\n>        以下两个宏函数用于处理`状态码`:\n>        `WIFEXITED(status)`: 若为**正常终止**子进程返回的状态，则为真。（查看进程是否是**正常退出**）\n>        `WEXITSTATUS(status)`: 若WIFEXITED非零，提取子进程`退出码`。（查看进程的`退出码`）\n>    `options`:\n>        `WNOHANG`: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。\n>        `0`: 阻塞等待指定`pid`的进程\n>\n\n#### 阻塞等待\n`option` == `0`时`waitpid`采用阻塞等待，父进程会阻塞等待到子进程退出\n\n*示例代码*\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main()\n{\n    int status;\n    pid_t id = fork();\n    if(id == 0)\n    {\n        for(int i = 1;i<=5;i++)\n        {\n            printf(\"child running [%d]s\\n\",i);\n            sleep(1);\n        }\n        printf(\"child exited\\n\");\n        exit(0);\n    }\n    else\n    {\n        waitpid(id,&status,0);\n        if(WIFEXITED(status))\n            printf(\"father wait success, exit code: %d\\n\",WEXITSTATUS(status));\n        else\n            printf(\"child failed to exit\\n\");\n    }\n    return 1;\n}\n```\n\n#### 非阻塞轮询\n`option` == `WNOHANG`时,`waitpid`采用非阻塞等待,若等不到子进程退出，就会继续执行后面的代码，所以一般加上`while`等循环用于轮询，二者共同构成`非阻塞轮询`\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n//非阻塞轮询\nint main()\n{\n    int status;\n    pid_t id = fork();\n    if(id == 0)\n    {\n        sleep(5);\n        printf(\"child exited\\n\");\n        exit(0);\n    }\n    else\n    {\n        while(1)//轮询\n        {\n            pid_t rid = waitpid(id,&status,WNOHANG);\n            if(rid > 0)\n            {\n                if(WIFEXITED(status))\n                    printf(\"father wait success, exit code: %d\\n\",WEXITSTATUS(status));\n                else\n                    printf(\"child failed to exit\\n\");\n\n                break;\n            }\n            else if(rid == 0)\n            {\n                printf(\"等待子进程中...\\n\");\n                sleep(1);\n            }\n            else//rid<0\n            {\n                printf(\"wait failed\\n\");\n                break;\n            }\n        }\n    }\n    return 1;\n}\n```","slug":"fork","published":1,"updated":"2024-07-25T14:27:31.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08a000u4sp5572pad7i","content":"<h1 id=\"认识fork\"><a href=\"#认识fork\" class=\"headerlink\" title=\"认识fork()\"></a>认识<code>fork()</code></h1><p>头文件<code>&lt;unistd.h&gt;</code>提供的<code>fork()</code>函数用于从已有的<code>原进程</code>创建一个新的<code>子进程</code>，而原进程在关系式称为<code>父进程</code></p>\n<h2 id=\"fork-的返回值\"><a href=\"#fork-的返回值\" class=\"headerlink\" title=\"fork()的返回值\"></a>fork()的返回值</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">pid_t</span> id = fork();</span><br></pre></td></tr></table></figure>\n\n<p>父子进程中<code>fork()</code>函数的返回值(此处用变量<code>id</code>储存)是不同的:</p>\n<p><strong>父进程</strong>里<code>id</code>的值为子进程的<code>PID</code>,其值<code>&gt;0</code>;<strong>子进程</strong>里<code>id</code>值固定为<code>0</code></p>\n<ul>\n<li><code>id &gt; 0</code> 父进程</li>\n<li><code>id == 0</code> 子进程</li>\n<li><code>id &lt; 0</code> fork()失败</li>\n</ul>\n<h2 id=\"分流\"><a href=\"#分流\" class=\"headerlink\" title=\"分流\"></a>分流</h2><p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_13-00-38.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_13-00-38.png</a></p>\n<p>利用父子进程中<code>fork()</code>返回值的不同，可以用<code>if...else...</code>进行分流，让父子进程执行不同的代码</p>\n<h2 id=\"fork-的过程\"><a href=\"#fork-的过程\" class=\"headerlink\" title=\"fork()的过程\"></a>fork()的过程</h2><p>进程调用<code>fork</code>，当控制转移到<strong>内核</strong>中的fork代码后，<strong>内核</strong>做</p>\n<ul>\n<li>分配<strong>新的</strong>内存块和内核数据结构给子进程</li>\n<li>将父进程部分数据结构内容<strong>拷贝</strong>至子进程</li>\n<li>添加子进程到<strong>系统进程列表</strong>当中</li>\n<li><code>fork</code>返回，开始调度器调度</li>\n</ul>\n<p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_18-54-41.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_18-54-41.png</a></p>\n<p>当一个进程调用fork之后，就有一对二进制<strong>代码相同</strong>的父子进程。而且它们都运行到相同的地方。但每个进程都可以<strong>独立</strong>地继续运行代码,并按代码分流至不同的代码段</p>\n<p>但这两个进程谁先执行<strong>完全</strong>由调度器决定，而谁先结束，则由实际执行情况和调度器决定</p>\n<h2 id=\"拷贝的过程-与-写时拷贝\"><a href=\"#拷贝的过程-与-写时拷贝\" class=\"headerlink\" title=\"拷贝的过程 与 写时拷贝\"></a>拷贝的过程 与 写时拷贝</h2><p><code>fork</code>时，子进程会将父进程虚拟内存的内容都复制一份在自己的虚拟内存中,但通过页表，二者映射到了同一块物理内存的区域，这样在二者都<strong>没有写入行为</strong>时，减少了物理内存中<strong>冗余</strong>的拷贝行为，有效提高了运行效率</p>\n<p>但当父子进程中有一方发生写入行为时，就会触发<code>写时拷贝</code>，此时物理内存中发生拷贝行为，但只拷贝进程映射的<code>数据段</code>，而由于<strong>不发生进程替换时</strong>父子进程的代码段一定相同，物理内存中,<code>代码段</code>映射部分并不发生拷贝</p>\n<p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_19-38-58.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_19-38-58.png</a></p>\n<h1 id=\"进程退出\"><a href=\"#进程退出\" class=\"headerlink\" title=\"进程退出\"></a>进程退出</h1><h2 id=\"进程退出的场景\"><a href=\"#进程退出的场景\" class=\"headerlink\" title=\"进程退出的场景\"></a>进程退出的场景</h2><ul>\n<li>代码运行完毕，结果正确</li>\n<li>代码运行完毕，结果不正确</li>\n<li>代码异常终止</li>\n</ul>\n<h2 id=\"进程常见退出方法\"><a href=\"#进程常见退出方法\" class=\"headerlink\" title=\"进程常见退出方法\"></a>进程常见退出方法</h2><ul>\n<li><code>main</code>函数返回</li>\n<li><code>exit</code>退出</li>\n<li><code>_exit</code>退出</li>\n</ul>\n<p><strong>异常退出</strong>: <code>ctrl</code> + <code>c</code></p>\n<h2 id=\"查看退出码\"><a href=\"#查看退出码\" class=\"headerlink\" title=\"查看退出码\"></a>查看退出码</h2><p>在终端使用命令<code>echo $?</code>可以查看退出码</p>\n<p><code>注</code>尽管子进程返回的是<code>int</code>,父进程只取退出码的最低<code>8位</code>,所以以下三种情况</p>\n<ul>\n<li><code>main</code>函数返回<code>-1</code></li>\n<li><code>exit(-1)</code></li>\n<li><code>_exit(-1)</code></li>\n</ul>\n<p>在终端输<code>echo $?</code>可得退出码<code>255</code></p>\n<h2 id=\"exit-和-eixt-辨析\"><a href=\"#exit-和-eixt-辨析\" class=\"headerlink\" title=\"exit 和 _eixt 辨析\"></a><code>exit</code> 和 <code>_eixt</code> 辨析</h2><p><code>main</code>函数返回就不惜说了，来辨析一下头文件<code>&lt;stdlib.h&gt;</code>提供的<code>exit</code>和<code>_exit</code>函数</p>\n<h3 id=\"exit\"><a href=\"#exit\" class=\"headerlink\" title=\"_exit()\"></a><code>_exit()</code></h3><p><code>_exit</code>会<strong>直接终止</strong>进程并返回状态码,而<strong>不会</strong>执行用户定义的清理函数，<strong>也不会</strong>清理缓冲区</p>\n<h3 id=\"exit-1\"><a href=\"#exit-1\" class=\"headerlink\" title=\"exit()\"></a><code>exit()</code></h3><p><code>exit</code>实际上最后也会调用<code>_exit</code>,但它会先执行一系列善后工作,顺序如下:</p>\n<ol>\n<li>执行用户通过 atexit或on_exit定义的<strong>清理函数</strong>。</li>\n<li>关闭所有打开的流，所有的<strong>缓存数据</strong>均被写入</li>\n<li>调用<code>_exit</code></li>\n</ol>\n<p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_22-10-26.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_22-10-26.png</a></p>\n<p><code>return</code>退出： 执行<code>return n</code>等同于执行<code>exit(n)</code></p>\n<h1 id=\"进程等待\"><a href=\"#进程等待\" class=\"headerlink\" title=\"进程等待\"></a>进程等待</h1><h2 id=\"进程等待的必要性\"><a href=\"#进程等待的必要性\" class=\"headerlink\" title=\"进程等待的必要性\"></a>进程等待的必要性</h2><ul>\n<li>子进程退出后需要父进程来<strong>回收</strong>僵尸进程,防止产生其引发内存泄漏等问题</li>\n<li>僵尸进程难以处理,<code>kill -9</code>也清理不掉</li>\n<li>父进程通过进程等待的方式，<strong>回收</strong>子进程资源，获取子进程<strong>退出信息</strong></li>\n</ul>\n<h2 id=\"进程等待的方法\"><a href=\"#进程等待的方法\" class=\"headerlink\" title=\"进程等待的方法\"></a>进程等待的方法</h2><h3 id=\"wait方法\"><a href=\"#wait方法\" class=\"headerlink\" title=\"wait方法\"></a><code>wait</code>方法</h3><blockquote>\n<p>#include&lt;sys&#x2F;types.h&gt;<br>#include&lt;sys&#x2F;wait.h&gt;</p>\n<p>pid_t wait(int*status);</p>\n<p><code>参数</code>：显然<code>status</code>是输出型参数,获取子进程的<code>退出状态</code>,若不关心，可传参<code>NULL</code></p>\n<p><code>返回值</code>: 若<strong>成功</strong>，则返回被等待进程的<code>pid</code>,若<strong>失败</strong>，则返回<code>-1</code></p>\n</blockquote>\n<h3 id=\"waitpid方法\"><a href=\"#waitpid方法\" class=\"headerlink\" title=\"waitpid方法\"></a><code>waitpid</code>方法</h3><blockquote>\n<p>返回值：<br>   当正常返回的时候waitpid返回收集到的子进程的进程ID；<br>   如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；<br>   如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；</p>\n<p>参数：<br>   <code>pid</code>：<br>       <code>pid == -1</code>,等待任一个子进程。与wait等效。<br>       <code>pid &gt; 0</code>.等待其进程ID与pid相等的子进程。<br>   <code>status</code>:<br>       输出型参数传参<code>&amp;status</code>: 将子进程的<code>状态码</code>存入<code>status</code><br>       以下两个宏函数用于处理<code>状态码</code>:<br>       <code>WIFEXITED(status)</code>: 若为<strong>正常终止</strong>子进程返回的状态，则为真。（查看进程是否是<strong>正常退出</strong>）<br>       <code>WEXITSTATUS(status)</code>: 若WIFEXITED非零，提取子进程<code>退出码</code>。（查看进程的<code>退出码</code>）<br>   <code>options</code>:<br>       <code>WNOHANG</code>: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。<br>       <code>0</code>: 阻塞等待指定<code>pid</code>的进程</p>\n</blockquote>\n<h4 id=\"阻塞等待\"><a href=\"#阻塞等待\" class=\"headerlink\" title=\"阻塞等待\"></a>阻塞等待</h4><p><code>option</code> &#x3D;&#x3D; <code>0</code>时<code>waitpid</code>采用阻塞等待，父进程会阻塞等待到子进程退出</p>\n<p><em>示例代码</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> status;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=<span class=\"number\">5</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child running [%d]s\\n&quot;</span>,i);</span><br><span class=\"line\">            sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child exited\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        waitpid(id,&amp;status,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(WIFEXITED(status))</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father wait success, exit code: %d\\n&quot;</span>,WEXITSTATUS(status));</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child failed to exit\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"非阻塞轮询\"><a href=\"#非阻塞轮询\" class=\"headerlink\" title=\"非阻塞轮询\"></a>非阻塞轮询</h4><p><code>option</code> &#x3D;&#x3D; <code>WNOHANG</code>时,<code>waitpid</code>采用非阻塞等待,若等不到子进程退出，就会继续执行后面的代码，所以一般加上<code>while</code>等循环用于轮询，二者共同构成<code>非阻塞轮询</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非阻塞轮询</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> status;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child exited\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)<span class=\"comment\">//轮询</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">pid_t</span> rid = waitpid(id,&amp;status,WNOHANG);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(rid &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(WIFEXITED(status))</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father wait success, exit code: %d\\n&quot;</span>,WEXITSTATUS(status));</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child failed to exit\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(rid == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;等待子进程中...\\n&quot;</span>);</span><br><span class=\"line\">                sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//rid&lt;0</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;wait failed\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"认识fork\"><a href=\"#认识fork\" class=\"headerlink\" title=\"认识fork()\"></a>认识<code>fork()</code></h1><p>头文件<code>&lt;unistd.h&gt;</code>提供的<code>fork()</code>函数用于从已有的<code>原进程</code>创建一个新的<code>子进程</code>，而原进程在关系式称为<code>父进程</code></p>\n<h2 id=\"fork-的返回值\"><a href=\"#fork-的返回值\" class=\"headerlink\" title=\"fork()的返回值\"></a>fork()的返回值</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">pid_t</span> id = fork();</span><br></pre></td></tr></table></figure>\n\n<p>父子进程中<code>fork()</code>函数的返回值(此处用变量<code>id</code>储存)是不同的:</p>\n<p><strong>父进程</strong>里<code>id</code>的值为子进程的<code>PID</code>,其值<code>&gt;0</code>;<strong>子进程</strong>里<code>id</code>值固定为<code>0</code></p>\n<ul>\n<li><code>id &gt; 0</code> 父进程</li>\n<li><code>id == 0</code> 子进程</li>\n<li><code>id &lt; 0</code> fork()失败</li>\n</ul>\n<h2 id=\"分流\"><a href=\"#分流\" class=\"headerlink\" title=\"分流\"></a>分流</h2><p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_13-00-38.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_13-00-38.png</a></p>\n<p>利用父子进程中<code>fork()</code>返回值的不同，可以用<code>if...else...</code>进行分流，让父子进程执行不同的代码</p>\n<h2 id=\"fork-的过程\"><a href=\"#fork-的过程\" class=\"headerlink\" title=\"fork()的过程\"></a>fork()的过程</h2><p>进程调用<code>fork</code>，当控制转移到<strong>内核</strong>中的fork代码后，<strong>内核</strong>做</p>\n<ul>\n<li>分配<strong>新的</strong>内存块和内核数据结构给子进程</li>\n<li>将父进程部分数据结构内容<strong>拷贝</strong>至子进程</li>\n<li>添加子进程到<strong>系统进程列表</strong>当中</li>\n<li><code>fork</code>返回，开始调度器调度</li>\n</ul>\n<p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_18-54-41.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_18-54-41.png</a></p>\n<p>当一个进程调用fork之后，就有一对二进制<strong>代码相同</strong>的父子进程。而且它们都运行到相同的地方。但每个进程都可以<strong>独立</strong>地继续运行代码,并按代码分流至不同的代码段</p>\n<p>但这两个进程谁先执行<strong>完全</strong>由调度器决定，而谁先结束，则由实际执行情况和调度器决定</p>\n<h2 id=\"拷贝的过程-与-写时拷贝\"><a href=\"#拷贝的过程-与-写时拷贝\" class=\"headerlink\" title=\"拷贝的过程 与 写时拷贝\"></a>拷贝的过程 与 写时拷贝</h2><p><code>fork</code>时，子进程会将父进程虚拟内存的内容都复制一份在自己的虚拟内存中,但通过页表，二者映射到了同一块物理内存的区域，这样在二者都<strong>没有写入行为</strong>时，减少了物理内存中<strong>冗余</strong>的拷贝行为，有效提高了运行效率</p>\n<p>但当父子进程中有一方发生写入行为时，就会触发<code>写时拷贝</code>，此时物理内存中发生拷贝行为，但只拷贝进程映射的<code>数据段</code>，而由于<strong>不发生进程替换时</strong>父子进程的代码段一定相同，物理内存中,<code>代码段</code>映射部分并不发生拷贝</p>\n<p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_19-38-58.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_19-38-58.png</a></p>\n<h1 id=\"进程退出\"><a href=\"#进程退出\" class=\"headerlink\" title=\"进程退出\"></a>进程退出</h1><h2 id=\"进程退出的场景\"><a href=\"#进程退出的场景\" class=\"headerlink\" title=\"进程退出的场景\"></a>进程退出的场景</h2><ul>\n<li>代码运行完毕，结果正确</li>\n<li>代码运行完毕，结果不正确</li>\n<li>代码异常终止</li>\n</ul>\n<h2 id=\"进程常见退出方法\"><a href=\"#进程常见退出方法\" class=\"headerlink\" title=\"进程常见退出方法\"></a>进程常见退出方法</h2><ul>\n<li><code>main</code>函数返回</li>\n<li><code>exit</code>退出</li>\n<li><code>_exit</code>退出</li>\n</ul>\n<p><strong>异常退出</strong>: <code>ctrl</code> + <code>c</code></p>\n<h2 id=\"查看退出码\"><a href=\"#查看退出码\" class=\"headerlink\" title=\"查看退出码\"></a>查看退出码</h2><p>在终端使用命令<code>echo $?</code>可以查看退出码</p>\n<p><code>注</code>尽管子进程返回的是<code>int</code>,父进程只取退出码的最低<code>8位</code>,所以以下三种情况</p>\n<ul>\n<li><code>main</code>函数返回<code>-1</code></li>\n<li><code>exit(-1)</code></li>\n<li><code>_exit(-1)</code></li>\n</ul>\n<p>在终端输<code>echo $?</code>可得退出码<code>255</code></p>\n<h2 id=\"exit-和-eixt-辨析\"><a href=\"#exit-和-eixt-辨析\" class=\"headerlink\" title=\"exit 和 _eixt 辨析\"></a><code>exit</code> 和 <code>_eixt</code> 辨析</h2><p><code>main</code>函数返回就不惜说了，来辨析一下头文件<code>&lt;stdlib.h&gt;</code>提供的<code>exit</code>和<code>_exit</code>函数</p>\n<h3 id=\"exit\"><a href=\"#exit\" class=\"headerlink\" title=\"_exit()\"></a><code>_exit()</code></h3><p><code>_exit</code>会<strong>直接终止</strong>进程并返回状态码,而<strong>不会</strong>执行用户定义的清理函数，<strong>也不会</strong>清理缓冲区</p>\n<h3 id=\"exit-1\"><a href=\"#exit-1\" class=\"headerlink\" title=\"exit()\"></a><code>exit()</code></h3><p><code>exit</code>实际上最后也会调用<code>_exit</code>,但它会先执行一系列善后工作,顺序如下:</p>\n<ol>\n<li>执行用户通过 atexit或on_exit定义的<strong>清理函数</strong>。</li>\n<li>关闭所有打开的流，所有的<strong>缓存数据</strong>均被写入</li>\n<li>调用<code>_exit</code></li>\n</ol>\n<p><a href=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_22-10-26.png\">https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-09_22-10-26.png</a></p>\n<p><code>return</code>退出： 执行<code>return n</code>等同于执行<code>exit(n)</code></p>\n<h1 id=\"进程等待\"><a href=\"#进程等待\" class=\"headerlink\" title=\"进程等待\"></a>进程等待</h1><h2 id=\"进程等待的必要性\"><a href=\"#进程等待的必要性\" class=\"headerlink\" title=\"进程等待的必要性\"></a>进程等待的必要性</h2><ul>\n<li>子进程退出后需要父进程来<strong>回收</strong>僵尸进程,防止产生其引发内存泄漏等问题</li>\n<li>僵尸进程难以处理,<code>kill -9</code>也清理不掉</li>\n<li>父进程通过进程等待的方式，<strong>回收</strong>子进程资源，获取子进程<strong>退出信息</strong></li>\n</ul>\n<h2 id=\"进程等待的方法\"><a href=\"#进程等待的方法\" class=\"headerlink\" title=\"进程等待的方法\"></a>进程等待的方法</h2><h3 id=\"wait方法\"><a href=\"#wait方法\" class=\"headerlink\" title=\"wait方法\"></a><code>wait</code>方法</h3><blockquote>\n<p>#include&lt;sys&#x2F;types.h&gt;<br>#include&lt;sys&#x2F;wait.h&gt;</p>\n<p>pid_t wait(int*status);</p>\n<p><code>参数</code>：显然<code>status</code>是输出型参数,获取子进程的<code>退出状态</code>,若不关心，可传参<code>NULL</code></p>\n<p><code>返回值</code>: 若<strong>成功</strong>，则返回被等待进程的<code>pid</code>,若<strong>失败</strong>，则返回<code>-1</code></p>\n</blockquote>\n<h3 id=\"waitpid方法\"><a href=\"#waitpid方法\" class=\"headerlink\" title=\"waitpid方法\"></a><code>waitpid</code>方法</h3><blockquote>\n<p>返回值：<br>   当正常返回的时候waitpid返回收集到的子进程的进程ID；<br>   如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；<br>   如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；</p>\n<p>参数：<br>   <code>pid</code>：<br>       <code>pid == -1</code>,等待任一个子进程。与wait等效。<br>       <code>pid &gt; 0</code>.等待其进程ID与pid相等的子进程。<br>   <code>status</code>:<br>       输出型参数传参<code>&amp;status</code>: 将子进程的<code>状态码</code>存入<code>status</code><br>       以下两个宏函数用于处理<code>状态码</code>:<br>       <code>WIFEXITED(status)</code>: 若为<strong>正常终止</strong>子进程返回的状态，则为真。（查看进程是否是<strong>正常退出</strong>）<br>       <code>WEXITSTATUS(status)</code>: 若WIFEXITED非零，提取子进程<code>退出码</code>。（查看进程的<code>退出码</code>）<br>   <code>options</code>:<br>       <code>WNOHANG</code>: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。<br>       <code>0</code>: 阻塞等待指定<code>pid</code>的进程</p>\n</blockquote>\n<h4 id=\"阻塞等待\"><a href=\"#阻塞等待\" class=\"headerlink\" title=\"阻塞等待\"></a>阻塞等待</h4><p><code>option</code> &#x3D;&#x3D; <code>0</code>时<code>waitpid</code>采用阻塞等待，父进程会阻塞等待到子进程退出</p>\n<p><em>示例代码</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> status;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=<span class=\"number\">5</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child running [%d]s\\n&quot;</span>,i);</span><br><span class=\"line\">            sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child exited\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        waitpid(id,&amp;status,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(WIFEXITED(status))</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father wait success, exit code: %d\\n&quot;</span>,WEXITSTATUS(status));</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child failed to exit\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"非阻塞轮询\"><a href=\"#非阻塞轮询\" class=\"headerlink\" title=\"非阻塞轮询\"></a>非阻塞轮询</h4><p><code>option</code> &#x3D;&#x3D; <code>WNOHANG</code>时,<code>waitpid</code>采用非阻塞等待,若等不到子进程退出，就会继续执行后面的代码，所以一般加上<code>while</code>等循环用于轮询，二者共同构成<code>非阻塞轮询</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非阻塞轮询</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> status;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child exited\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)<span class=\"comment\">//轮询</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">pid_t</span> rid = waitpid(id,&amp;status,WNOHANG);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(rid &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(WIFEXITED(status))</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father wait success, exit code: %d\\n&quot;</span>,WEXITSTATUS(status));</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child failed to exit\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(rid == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;等待子进程中...\\n&quot;</span>);</span><br><span class=\"line\">                sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//rid&lt;0</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;wait failed\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Linux文件系统","date":"2024-07-26T01:49:27.000Z","_content":"# 文件系统的组织方式\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_14-22-47.png)\n\n这里介绍一下`Block Group`里的分区内容\n\n+ `超级块`(Super Block): **存放文件系统本身的结构信息**。记录的信息主要有：`bolck`(数据块) 和 `inode`(属性块)的总量，\n**未使用**的`block`和`inode`的数量，一个`block`和`inode`的大小，最近一次挂载的时间，最近一次写入数据的\n时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个\n文件系统结构就被破坏了\n+ `GDT`(Group Descriptor Table): 块组描述符，描述块组属性信息。这里不作详细介绍\n+ `块位图`(Block Bitmap):位图中的`比特位`记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用\n+ `inode位图`(inode Bitmap):每个`比特位`表示一个inode是否空闲可用。\n+ `inode表`(inode Table):每一个`inode`存放了各自文件的`属性`，如文件大小，所有者，最近修改时间等\n+ `数据区`：存放文件内容\n\n# Linux系统中文件的增删查改\nLinux中，每一个文件都有自己的inode,而每一个inode有自己的inode编号（按分区为单位）\n\n特别的：尽管inode储存了文件的属性，文件名并不属于inode\n\n## 理解目录文件\n`目录`也是`文件`!目录也有自己的`inode`和数据块\n\n目录的数据块**储存**了该目录下，文件的**文件名**和文件`inode`的映射关系\n\n## 创建文件的过程\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_16-44-21.png)\n\n创建文件主要有以下4个操作\n\n1. `存储属性`:内核先找到一个空闲的`inode`(图中是263467)。**内核**把文件信息记录其中。\n2. `存储数据`:该文件需要存储在三个数据块，**内核**找到了三个空闲块:300,600,800。然后将**内核缓冲区**的第一块数据复制到300，下一块复制到600，依次类推\n3. `记录分配情况`:文件内容按顺序300,600,800存放。内核在inode上的磁盘分布区记录了上述块列表\n4. `添加文件名到目录`:通过写入目录文件，将文件名和inode的建立映射关系(这里是将文件名cab与inode 263467建立联系)\n\n# Linux中的硬链接和软链接\nLinux文件系统中特别**重要***的一点是：文件系统使用`inode`管理文件，**而不是**文件名，所以使用`inode`唯一指定文件。也就是说找到了`inode`才是真正找到了`文件`\n\n基于此理论，我们可以更好地理解`软链接`和`硬链接`\n\n## 软链接\n使用`ln -s <原文件名> <软链接文件名>`指令可以建立软链接,`-s`参数就是指定创建软链接文件\n\n例如在已有`file.txt`的情况下,使用`ln -s file.txt soft-link`在当前文件夹创建软链接文件`soft-link`,指向文件`file.txt`\n\n然后我们输入`ls -li`查看这两个文件\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_21-54-47.png)\n\n可以看到软链接文件和原文件的inode是不同的，且两个文件的硬链接数(第二个框框)都是`1`,说明软链接是一个文件系统意义上的`新文件`\n\n`软链接文件`可类比与`Windows`下的快捷方式\n\n## 硬链接\n\n使用`ln <原文件名> <硬链接文件名>`指令可以建立硬链接。\n\n例如在已有`file.txt`的情况下,使用`ln file.txt hard-link`在当前文件夹创建软链接文件`hard-link`,与文件`file.txt`**等价**\n\n然后我们输入`ls -li`查看这\"两个\"文件\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_22-06-39.png)\n\n可以看到它们的`inode`是完全一样的，那么基于上文文件系统对文件的视角，这\"两个\"文件完全就是**同一个文件!**,或者说`hard-link`是`file.txt`的`别名`，同时我们也能看到`硬链接引用计数`变成了`2`\n\n在引入了`硬链接引用计数`的概念下，删除目录中的一个文件，只是删除该目录下`文件名`和`inode`的映射关系，并使该文件的`引用计数`减去`1`,当其**归零**时，才会真正释放磁盘上的文件资源\n\n### 目录的硬链接数\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_22-36-40.png)\n\n对于每一个普通目录（除了根目录），至少有父目录下自己的`文件名`和该目录下的`.`文件`2`个`硬链接`，而在其内部创建的每个`子目录`又会储存一个名为`..`的硬连接，所以普通目录的硬连接数会`>=2`\n\n因此为了防止文件系统结构混乱，操作系统**不允许**用户对目录建立`硬链接`\n\n### 删除链接文件\n`rm`不一定能删除链接文件，此时可以用`unlink`命令","source":"_posts/filesys.md","raw":"---\ntitle: Linux文件系统\ndate: 2024-07-26 09:49:27\ntags: Linux\n---\n# 文件系统的组织方式\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_14-22-47.png)\n\n这里介绍一下`Block Group`里的分区内容\n\n+ `超级块`(Super Block): **存放文件系统本身的结构信息**。记录的信息主要有：`bolck`(数据块) 和 `inode`(属性块)的总量，\n**未使用**的`block`和`inode`的数量，一个`block`和`inode`的大小，最近一次挂载的时间，最近一次写入数据的\n时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个\n文件系统结构就被破坏了\n+ `GDT`(Group Descriptor Table): 块组描述符，描述块组属性信息。这里不作详细介绍\n+ `块位图`(Block Bitmap):位图中的`比特位`记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用\n+ `inode位图`(inode Bitmap):每个`比特位`表示一个inode是否空闲可用。\n+ `inode表`(inode Table):每一个`inode`存放了各自文件的`属性`，如文件大小，所有者，最近修改时间等\n+ `数据区`：存放文件内容\n\n# Linux系统中文件的增删查改\nLinux中，每一个文件都有自己的inode,而每一个inode有自己的inode编号（按分区为单位）\n\n特别的：尽管inode储存了文件的属性，文件名并不属于inode\n\n## 理解目录文件\n`目录`也是`文件`!目录也有自己的`inode`和数据块\n\n目录的数据块**储存**了该目录下，文件的**文件名**和文件`inode`的映射关系\n\n## 创建文件的过程\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_16-44-21.png)\n\n创建文件主要有以下4个操作\n\n1. `存储属性`:内核先找到一个空闲的`inode`(图中是263467)。**内核**把文件信息记录其中。\n2. `存储数据`:该文件需要存储在三个数据块，**内核**找到了三个空闲块:300,600,800。然后将**内核缓冲区**的第一块数据复制到300，下一块复制到600，依次类推\n3. `记录分配情况`:文件内容按顺序300,600,800存放。内核在inode上的磁盘分布区记录了上述块列表\n4. `添加文件名到目录`:通过写入目录文件，将文件名和inode的建立映射关系(这里是将文件名cab与inode 263467建立联系)\n\n# Linux中的硬链接和软链接\nLinux文件系统中特别**重要***的一点是：文件系统使用`inode`管理文件，**而不是**文件名，所以使用`inode`唯一指定文件。也就是说找到了`inode`才是真正找到了`文件`\n\n基于此理论，我们可以更好地理解`软链接`和`硬链接`\n\n## 软链接\n使用`ln -s <原文件名> <软链接文件名>`指令可以建立软链接,`-s`参数就是指定创建软链接文件\n\n例如在已有`file.txt`的情况下,使用`ln -s file.txt soft-link`在当前文件夹创建软链接文件`soft-link`,指向文件`file.txt`\n\n然后我们输入`ls -li`查看这两个文件\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_21-54-47.png)\n\n可以看到软链接文件和原文件的inode是不同的，且两个文件的硬链接数(第二个框框)都是`1`,说明软链接是一个文件系统意义上的`新文件`\n\n`软链接文件`可类比与`Windows`下的快捷方式\n\n## 硬链接\n\n使用`ln <原文件名> <硬链接文件名>`指令可以建立硬链接。\n\n例如在已有`file.txt`的情况下,使用`ln file.txt hard-link`在当前文件夹创建软链接文件`hard-link`,与文件`file.txt`**等价**\n\n然后我们输入`ls -li`查看这\"两个\"文件\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_22-06-39.png)\n\n可以看到它们的`inode`是完全一样的，那么基于上文文件系统对文件的视角，这\"两个\"文件完全就是**同一个文件!**,或者说`hard-link`是`file.txt`的`别名`，同时我们也能看到`硬链接引用计数`变成了`2`\n\n在引入了`硬链接引用计数`的概念下，删除目录中的一个文件，只是删除该目录下`文件名`和`inode`的映射关系，并使该文件的`引用计数`减去`1`,当其**归零**时，才会真正释放磁盘上的文件资源\n\n### 目录的硬链接数\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_22-36-40.png)\n\n对于每一个普通目录（除了根目录），至少有父目录下自己的`文件名`和该目录下的`.`文件`2`个`硬链接`，而在其内部创建的每个`子目录`又会储存一个名为`..`的硬连接，所以普通目录的硬连接数会`>=2`\n\n因此为了防止文件系统结构混乱，操作系统**不允许**用户对目录建立`硬链接`\n\n### 删除链接文件\n`rm`不一定能删除链接文件，此时可以用`unlink`命令","slug":"filesys","published":1,"updated":"2024-08-06T14:36:59.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08b000x4sp5au7v7dwe","content":"<h1 id=\"文件系统的组织方式\"><a href=\"#文件系统的组织方式\" class=\"headerlink\" title=\"文件系统的组织方式\"></a>文件系统的组织方式</h1><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_14-22-47.png\"></p>\n<p>这里介绍一下<code>Block Group</code>里的分区内容</p>\n<ul>\n<li><code>超级块</code>(Super Block): <strong>存放文件系统本身的结构信息</strong>。记录的信息主要有：<code>bolck</code>(数据块) 和 <code>inode</code>(属性块)的总量，<br><strong>未使用</strong>的<code>block</code>和<code>inode</code>的数量，一个<code>block</code>和<code>inode</code>的大小，最近一次挂载的时间，最近一次写入数据的<br>时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个<br>文件系统结构就被破坏了</li>\n<li><code>GDT</code>(Group Descriptor Table): 块组描述符，描述块组属性信息。这里不作详细介绍</li>\n<li><code>块位图</code>(Block Bitmap):位图中的<code>比特位</code>记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用</li>\n<li><code>inode位图</code>(inode Bitmap):每个<code>比特位</code>表示一个inode是否空闲可用。</li>\n<li><code>inode表</code>(inode Table):每一个<code>inode</code>存放了各自文件的<code>属性</code>，如文件大小，所有者，最近修改时间等</li>\n<li><code>数据区</code>：存放文件内容</li>\n</ul>\n<h1 id=\"Linux系统中文件的增删查改\"><a href=\"#Linux系统中文件的增删查改\" class=\"headerlink\" title=\"Linux系统中文件的增删查改\"></a>Linux系统中文件的增删查改</h1><p>Linux中，每一个文件都有自己的inode,而每一个inode有自己的inode编号（按分区为单位）</p>\n<p>特别的：尽管inode储存了文件的属性，文件名并不属于inode</p>\n<h2 id=\"理解目录文件\"><a href=\"#理解目录文件\" class=\"headerlink\" title=\"理解目录文件\"></a>理解目录文件</h2><p><code>目录</code>也是<code>文件</code>!目录也有自己的<code>inode</code>和数据块</p>\n<p>目录的数据块<strong>储存</strong>了该目录下，文件的<strong>文件名</strong>和文件<code>inode</code>的映射关系</p>\n<h2 id=\"创建文件的过程\"><a href=\"#创建文件的过程\" class=\"headerlink\" title=\"创建文件的过程\"></a>创建文件的过程</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_16-44-21.png\"></p>\n<p>创建文件主要有以下4个操作</p>\n<ol>\n<li><code>存储属性</code>:内核先找到一个空闲的<code>inode</code>(图中是263467)。<strong>内核</strong>把文件信息记录其中。</li>\n<li><code>存储数据</code>:该文件需要存储在三个数据块，<strong>内核</strong>找到了三个空闲块:300,600,800。然后将<strong>内核缓冲区</strong>的第一块数据复制到300，下一块复制到600，依次类推</li>\n<li><code>记录分配情况</code>:文件内容按顺序300,600,800存放。内核在inode上的磁盘分布区记录了上述块列表</li>\n<li><code>添加文件名到目录</code>:通过写入目录文件，将文件名和inode的建立映射关系(这里是将文件名cab与inode 263467建立联系)</li>\n</ol>\n<h1 id=\"Linux中的硬链接和软链接\"><a href=\"#Linux中的硬链接和软链接\" class=\"headerlink\" title=\"Linux中的硬链接和软链接\"></a>Linux中的硬链接和软链接</h1><p>Linux文件系统中特别<strong>重要</strong>*的一点是：文件系统使用<code>inode</code>管理文件，<strong>而不是</strong>文件名，所以使用<code>inode</code>唯一指定文件。也就是说找到了<code>inode</code>才是真正找到了<code>文件</code></p>\n<p>基于此理论，我们可以更好地理解<code>软链接</code>和<code>硬链接</code></p>\n<h2 id=\"软链接\"><a href=\"#软链接\" class=\"headerlink\" title=\"软链接\"></a>软链接</h2><p>使用<code>ln -s &lt;原文件名&gt; &lt;软链接文件名&gt;</code>指令可以建立软链接,<code>-s</code>参数就是指定创建软链接文件</p>\n<p>例如在已有<code>file.txt</code>的情况下,使用<code>ln -s file.txt soft-link</code>在当前文件夹创建软链接文件<code>soft-link</code>,指向文件<code>file.txt</code></p>\n<p>然后我们输入<code>ls -li</code>查看这两个文件</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_21-54-47.png\"></p>\n<p>可以看到软链接文件和原文件的inode是不同的，且两个文件的硬链接数(第二个框框)都是<code>1</code>,说明软链接是一个文件系统意义上的<code>新文件</code></p>\n<p><code>软链接文件</code>可类比与<code>Windows</code>下的快捷方式</p>\n<h2 id=\"硬链接\"><a href=\"#硬链接\" class=\"headerlink\" title=\"硬链接\"></a>硬链接</h2><p>使用<code>ln &lt;原文件名&gt; &lt;硬链接文件名&gt;</code>指令可以建立硬链接。</p>\n<p>例如在已有<code>file.txt</code>的情况下,使用<code>ln file.txt hard-link</code>在当前文件夹创建软链接文件<code>hard-link</code>,与文件<code>file.txt</code><strong>等价</strong></p>\n<p>然后我们输入<code>ls -li</code>查看这”两个”文件</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_22-06-39.png\"></p>\n<p>可以看到它们的<code>inode</code>是完全一样的，那么基于上文文件系统对文件的视角，这”两个”文件完全就是<strong>同一个文件!</strong>,或者说<code>hard-link</code>是<code>file.txt</code>的<code>别名</code>，同时我们也能看到<code>硬链接引用计数</code>变成了<code>2</code></p>\n<p>在引入了<code>硬链接引用计数</code>的概念下，删除目录中的一个文件，只是删除该目录下<code>文件名</code>和<code>inode</code>的映射关系，并使该文件的<code>引用计数</code>减去<code>1</code>,当其<strong>归零</strong>时，才会真正释放磁盘上的文件资源</p>\n<h3 id=\"目录的硬链接数\"><a href=\"#目录的硬链接数\" class=\"headerlink\" title=\"目录的硬链接数\"></a>目录的硬链接数</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_22-36-40.png\"></p>\n<p>对于每一个普通目录（除了根目录），至少有父目录下自己的<code>文件名</code>和该目录下的<code>.</code>文件<code>2</code>个<code>硬链接</code>，而在其内部创建的每个<code>子目录</code>又会储存一个名为<code>..</code>的硬连接，所以普通目录的硬连接数会<code>&gt;=2</code></p>\n<p>因此为了防止文件系统结构混乱，操作系统<strong>不允许</strong>用户对目录建立<code>硬链接</code></p>\n<h3 id=\"删除链接文件\"><a href=\"#删除链接文件\" class=\"headerlink\" title=\"删除链接文件\"></a>删除链接文件</h3><p><code>rm</code>不一定能删除链接文件，此时可以用<code>unlink</code>命令</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/0a175c01fefe6b016d5da64c655b1cee.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"文件系统的组织方式\"><a href=\"#文件系统的组织方式\" class=\"headerlink\" title=\"文件系统的组织方式\"></a>文件系统的组织方式</h1><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_14-22-47.png\"></p>\n<p>这里介绍一下<code>Block Group</code>里的分区内容</p>\n<ul>\n<li><code>超级块</code>(Super Block): <strong>存放文件系统本身的结构信息</strong>。记录的信息主要有：<code>bolck</code>(数据块) 和 <code>inode</code>(属性块)的总量，<br><strong>未使用</strong>的<code>block</code>和<code>inode</code>的数量，一个<code>block</code>和<code>inode</code>的大小，最近一次挂载的时间，最近一次写入数据的<br>时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个<br>文件系统结构就被破坏了</li>\n<li><code>GDT</code>(Group Descriptor Table): 块组描述符，描述块组属性信息。这里不作详细介绍</li>\n<li><code>块位图</code>(Block Bitmap):位图中的<code>比特位</code>记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用</li>\n<li><code>inode位图</code>(inode Bitmap):每个<code>比特位</code>表示一个inode是否空闲可用。</li>\n<li><code>inode表</code>(inode Table):每一个<code>inode</code>存放了各自文件的<code>属性</code>，如文件大小，所有者，最近修改时间等</li>\n<li><code>数据区</code>：存放文件内容</li>\n</ul>\n<h1 id=\"Linux系统中文件的增删查改\"><a href=\"#Linux系统中文件的增删查改\" class=\"headerlink\" title=\"Linux系统中文件的增删查改\"></a>Linux系统中文件的增删查改</h1><p>Linux中，每一个文件都有自己的inode,而每一个inode有自己的inode编号（按分区为单位）</p>\n<p>特别的：尽管inode储存了文件的属性，文件名并不属于inode</p>\n<h2 id=\"理解目录文件\"><a href=\"#理解目录文件\" class=\"headerlink\" title=\"理解目录文件\"></a>理解目录文件</h2><p><code>目录</code>也是<code>文件</code>!目录也有自己的<code>inode</code>和数据块</p>\n<p>目录的数据块<strong>储存</strong>了该目录下，文件的<strong>文件名</strong>和文件<code>inode</code>的映射关系</p>\n<h2 id=\"创建文件的过程\"><a href=\"#创建文件的过程\" class=\"headerlink\" title=\"创建文件的过程\"></a>创建文件的过程</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_16-44-21.png\"></p>\n<p>创建文件主要有以下4个操作</p>\n<ol>\n<li><code>存储属性</code>:内核先找到一个空闲的<code>inode</code>(图中是263467)。<strong>内核</strong>把文件信息记录其中。</li>\n<li><code>存储数据</code>:该文件需要存储在三个数据块，<strong>内核</strong>找到了三个空闲块:300,600,800。然后将<strong>内核缓冲区</strong>的第一块数据复制到300，下一块复制到600，依次类推</li>\n<li><code>记录分配情况</code>:文件内容按顺序300,600,800存放。内核在inode上的磁盘分布区记录了上述块列表</li>\n<li><code>添加文件名到目录</code>:通过写入目录文件，将文件名和inode的建立映射关系(这里是将文件名cab与inode 263467建立联系)</li>\n</ol>\n<h1 id=\"Linux中的硬链接和软链接\"><a href=\"#Linux中的硬链接和软链接\" class=\"headerlink\" title=\"Linux中的硬链接和软链接\"></a>Linux中的硬链接和软链接</h1><p>Linux文件系统中特别<strong>重要</strong>*的一点是：文件系统使用<code>inode</code>管理文件，<strong>而不是</strong>文件名，所以使用<code>inode</code>唯一指定文件。也就是说找到了<code>inode</code>才是真正找到了<code>文件</code></p>\n<p>基于此理论，我们可以更好地理解<code>软链接</code>和<code>硬链接</code></p>\n<h2 id=\"软链接\"><a href=\"#软链接\" class=\"headerlink\" title=\"软链接\"></a>软链接</h2><p>使用<code>ln -s &lt;原文件名&gt; &lt;软链接文件名&gt;</code>指令可以建立软链接,<code>-s</code>参数就是指定创建软链接文件</p>\n<p>例如在已有<code>file.txt</code>的情况下,使用<code>ln -s file.txt soft-link</code>在当前文件夹创建软链接文件<code>soft-link</code>,指向文件<code>file.txt</code></p>\n<p>然后我们输入<code>ls -li</code>查看这两个文件</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_21-54-47.png\"></p>\n<p>可以看到软链接文件和原文件的inode是不同的，且两个文件的硬链接数(第二个框框)都是<code>1</code>,说明软链接是一个文件系统意义上的<code>新文件</code></p>\n<p><code>软链接文件</code>可类比与<code>Windows</code>下的快捷方式</p>\n<h2 id=\"硬链接\"><a href=\"#硬链接\" class=\"headerlink\" title=\"硬链接\"></a>硬链接</h2><p>使用<code>ln &lt;原文件名&gt; &lt;硬链接文件名&gt;</code>指令可以建立硬链接。</p>\n<p>例如在已有<code>file.txt</code>的情况下,使用<code>ln file.txt hard-link</code>在当前文件夹创建软链接文件<code>hard-link</code>,与文件<code>file.txt</code><strong>等价</strong></p>\n<p>然后我们输入<code>ls -li</code>查看这”两个”文件</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_22-06-39.png\"></p>\n<p>可以看到它们的<code>inode</code>是完全一样的，那么基于上文文件系统对文件的视角，这”两个”文件完全就是<strong>同一个文件!</strong>,或者说<code>hard-link</code>是<code>file.txt</code>的<code>别名</code>，同时我们也能看到<code>硬链接引用计数</code>变成了<code>2</code></p>\n<p>在引入了<code>硬链接引用计数</code>的概念下，删除目录中的一个文件，只是删除该目录下<code>文件名</code>和<code>inode</code>的映射关系，并使该文件的<code>引用计数</code>减去<code>1</code>,当其<strong>归零</strong>时，才会真正释放磁盘上的文件资源</p>\n<h3 id=\"目录的硬链接数\"><a href=\"#目录的硬链接数\" class=\"headerlink\" title=\"目录的硬链接数\"></a>目录的硬链接数</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-06_22-36-40.png\"></p>\n<p>对于每一个普通目录（除了根目录），至少有父目录下自己的<code>文件名</code>和该目录下的<code>.</code>文件<code>2</code>个<code>硬链接</code>，而在其内部创建的每个<code>子目录</code>又会储存一个名为<code>..</code>的硬连接，所以普通目录的硬连接数会<code>&gt;=2</code></p>\n<p>因此为了防止文件系统结构混乱，操作系统<strong>不允许</strong>用户对目录建立<code>硬链接</code></p>\n<h3 id=\"删除链接文件\"><a href=\"#删除链接文件\" class=\"headerlink\" title=\"删除链接文件\"></a>删除链接文件</h3><p><code>rm</code>不一定能删除链接文件，此时可以用<code>unlink</code>命令</p>\n"},{"title":"堆排序","date":"2024-05-21T04:26:10.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/heapsort.png","_content":"# 背景知识\n- 知道什么是大堆/小堆\n- 掌握如何将数组与完全二叉树的映射关系\n- 掌握`向上调整法`和`向下调整法`\n\n## 大堆/小堆\n大堆的特性:每一个节点的值都比左右孩子都大,`根`的值是整个大堆中**最大的**\n小堆的特性:每一个节点的值都比左右孩子都小,`根`的值是整个大堆中**最小的**\n\n**后面以大堆为例**\n\n## 数组映射成完全二叉树\n任何一个数组可以看成一个`完全二叉树`,下标0为二叉树的根\n\n而非常方便的是，已知一个节点的下标，可以利用数学关系求出根或孩子的下标\n\n>下标关系如下（变量均为下标）\n\n- `parent = (child-1)/2`\n- `left_child = parent*2+1`\n- `right_child = parent*2+2`\n\n## 建堆方法\n### 向上调整法\n在已有一个大堆的**前提下**,把一个新的数据插入到堆的最后一个节点(此时破坏大堆的结构),再**一路**向上调整,可以重新建堆\n\n```C++\ntemplate<class T>\nvoid adjust_up(vector<T>& arr, int child)\n{\n\tint parent = (child - 1) / 2;\n\twhile (parent != child)//parent == child == 0时\n\t{\n\t\tif (arr[parent] < arr[child])//不满足大堆\n\t\t{\n\t\t\tswap(arr[parent], arr[child]);//交换\n\t\t\tchild = parent;//继续向上调整,迭代child和parent\n\t\t\tparent = (child - 1) / 2;\n\t\t}\n\t\telse//完成建堆，退出循环\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n### 向下调整法\n在已有一个大堆的**前提下**,把根的值改变(此时破坏大堆的结构),再**一路**向下调整，可以重新建堆\n\n上一句也可以等价于,左子树和右子树都是大堆的前提下，将根**一路**向下调整，可以重新建堆\n\n```C++\ntemplate<class T>\nvoid adjust_down(vector<T>& arr,int sz , int parent)\n{\n\tint child = parent * 2 + 1;\n\tif (child + 1 < sz && arr[child + 1] > arr[child]) child++;//取较大的孩子\n\n\twhile (child < sz)\n\t{\n\t\tif (arr[parent] < arr[child])\n\t\t{\n\t\t\tswap(arr[parent], arr[child]);\n\t\t\tparent = child;\n\t\t\tint child = parent * 2 + 1;\n\t\t\tif (child >= sz) break;\n\t\t\tif (child + 1 < sz && arr[child + 1] > arr[child]) child++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n# 主要思路\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_12-40-09.png)\n\n## 建堆\n用`向上调整法`和`向下调整法`都能建堆,不过`向上调整法`建堆思路更简单，也更容易代码实现，只需要把第一个元素当成现成的大堆，然后逐个插入并向上调整。**也就是说只需要写一个循环**\n```C++\n//向上调整法建堆\nfor (int i = 1; i < sz; i++)\n{\n    adjust_up(arr, i);//逐个插入并向上调整建堆\n}\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-09.png)\n\n## 排序\n此时的排序有个特点，那就是我们要**倒着排**\n\n尽管此时数组的第一个元素为`最大值`,似乎只需要把它放在那，整一个`降序`排列，再把剩下的元素建个堆，确定第二大的数...**但是**，此时有个很大的问题，当把剩下的元素看作堆时，会发现前面建堆留下来的关系全被打乱了(原本父子关系,兄弟关系乱套了),也就是说要`完全重新建堆`,极大地浪费了第一次建堆所建立的关系\n\n所以我们要尽可能`保留`原来的堆,既然把下标`0`处的节点除外会极大地影响堆的关系，那就改成把`最后一个叶子节点`除外,这样对原来的堆几乎没有改变。\n\n但建堆选出的`最大的`的值在根处,所以把`根`和`最后一个叶子节点`交换，**交换后**,此时**待排序**的数中的`最大值`以完成排序（即倒着排）,把`最后一个叶子节点`从堆中除外,再从`根`开始一路向下调整即可重新`建堆`,如此循环\n\n```C++\n\tfor (int i = sz-1; i >= 1; i--)//利用i的减小将已排序的元素逐个除外\n\t{\n\t\tswap(arr[0], arr[i]);//选出最大的元素放在末尾\n\t\tadjust_down(arr,i,0);//向下调整建堆,待排序的（待建堆的）数的个数为i,逐个减小\n\t}\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-22.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-47-20.png)\n\n正因为实际上排序时是**倒着排**的,所以当我们要排序时：\n\n- 升序->`大堆`\n- 降序->`小堆`\n\n\n\n# 全部代码\n```C++\n#include <vector>\nusing namespace std;\n\ntemplate<class T>\nvoid adjust_up(vector<T>& arr, int child)\n{\n\tint parent = (child - 1) / 2;\n\twhile (parent != child)//parent == child == 0时\n\t{\n\t\tif (arr[parent] < arr[child])//不满足大堆\n\t\t{\n\t\t\tswap(arr[parent], arr[child]);//交换\n\t\t\tchild = parent;//继续向上调整,迭代child和parent\n\t\t\tparent = (child - 1) / 2;\n\t\t}\n\t\telse//完成建堆，退出循环\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ntemplate<class T>\nvoid adjust_down(vector<T>& arr,int sz , int parent)\n{\n\tint child = parent * 2 + 1;\n\tif (child + 1 < sz && arr[child + 1] > arr[child]) child++;//取较大的孩子\n\n\twhile (child < sz)\n\t{\n\t\tif (arr[parent] < arr[child])\n\t\t{\n\t\t\tswap(arr[parent], arr[child]);\n\t\t\tparent = child;\n\t\t\tint child = parent * 2 + 1;\n\t\t\tif (child >= sz) break;\n\t\t\tif (child + 1 < sz && arr[child + 1] > arr[child]) child++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ntemplate <class T>\nvoid heap_sort(vector<T>& arr)\n{\n\tint sz = arr.size();\n\n\t//建堆\n\tfor (int i = 1; i < sz; i++)\n\t{\n\t\tadjust_up(arr, i);//逐个插入并向上调整建堆\n\t}\n\n\tfor (int i = sz-1; i >= 1; i--)\n\t{\n\t\tswap(arr[0], arr[i]);//选出最大的元素放在末尾\n\t\tadjust_down(arr,i,0);//向下调整建堆\n\t}\n}\n```","source":"_posts/heap-sort.md","raw":"---\ntitle: 堆排序\ndate: 2024-05-21 12:26:10\ntags: 七大排序 堆排序 排序\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/heapsort.png\n---\n# 背景知识\n- 知道什么是大堆/小堆\n- 掌握如何将数组与完全二叉树的映射关系\n- 掌握`向上调整法`和`向下调整法`\n\n## 大堆/小堆\n大堆的特性:每一个节点的值都比左右孩子都大,`根`的值是整个大堆中**最大的**\n小堆的特性:每一个节点的值都比左右孩子都小,`根`的值是整个大堆中**最小的**\n\n**后面以大堆为例**\n\n## 数组映射成完全二叉树\n任何一个数组可以看成一个`完全二叉树`,下标0为二叉树的根\n\n而非常方便的是，已知一个节点的下标，可以利用数学关系求出根或孩子的下标\n\n>下标关系如下（变量均为下标）\n\n- `parent = (child-1)/2`\n- `left_child = parent*2+1`\n- `right_child = parent*2+2`\n\n## 建堆方法\n### 向上调整法\n在已有一个大堆的**前提下**,把一个新的数据插入到堆的最后一个节点(此时破坏大堆的结构),再**一路**向上调整,可以重新建堆\n\n```C++\ntemplate<class T>\nvoid adjust_up(vector<T>& arr, int child)\n{\n\tint parent = (child - 1) / 2;\n\twhile (parent != child)//parent == child == 0时\n\t{\n\t\tif (arr[parent] < arr[child])//不满足大堆\n\t\t{\n\t\t\tswap(arr[parent], arr[child]);//交换\n\t\t\tchild = parent;//继续向上调整,迭代child和parent\n\t\t\tparent = (child - 1) / 2;\n\t\t}\n\t\telse//完成建堆，退出循环\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n### 向下调整法\n在已有一个大堆的**前提下**,把根的值改变(此时破坏大堆的结构),再**一路**向下调整，可以重新建堆\n\n上一句也可以等价于,左子树和右子树都是大堆的前提下，将根**一路**向下调整，可以重新建堆\n\n```C++\ntemplate<class T>\nvoid adjust_down(vector<T>& arr,int sz , int parent)\n{\n\tint child = parent * 2 + 1;\n\tif (child + 1 < sz && arr[child + 1] > arr[child]) child++;//取较大的孩子\n\n\twhile (child < sz)\n\t{\n\t\tif (arr[parent] < arr[child])\n\t\t{\n\t\t\tswap(arr[parent], arr[child]);\n\t\t\tparent = child;\n\t\t\tint child = parent * 2 + 1;\n\t\t\tif (child >= sz) break;\n\t\t\tif (child + 1 < sz && arr[child + 1] > arr[child]) child++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n# 主要思路\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_12-40-09.png)\n\n## 建堆\n用`向上调整法`和`向下调整法`都能建堆,不过`向上调整法`建堆思路更简单，也更容易代码实现，只需要把第一个元素当成现成的大堆，然后逐个插入并向上调整。**也就是说只需要写一个循环**\n```C++\n//向上调整法建堆\nfor (int i = 1; i < sz; i++)\n{\n    adjust_up(arr, i);//逐个插入并向上调整建堆\n}\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-09.png)\n\n## 排序\n此时的排序有个特点，那就是我们要**倒着排**\n\n尽管此时数组的第一个元素为`最大值`,似乎只需要把它放在那，整一个`降序`排列，再把剩下的元素建个堆，确定第二大的数...**但是**，此时有个很大的问题，当把剩下的元素看作堆时，会发现前面建堆留下来的关系全被打乱了(原本父子关系,兄弟关系乱套了),也就是说要`完全重新建堆`,极大地浪费了第一次建堆所建立的关系\n\n所以我们要尽可能`保留`原来的堆,既然把下标`0`处的节点除外会极大地影响堆的关系，那就改成把`最后一个叶子节点`除外,这样对原来的堆几乎没有改变。\n\n但建堆选出的`最大的`的值在根处,所以把`根`和`最后一个叶子节点`交换，**交换后**,此时**待排序**的数中的`最大值`以完成排序（即倒着排）,把`最后一个叶子节点`从堆中除外,再从`根`开始一路向下调整即可重新`建堆`,如此循环\n\n```C++\n\tfor (int i = sz-1; i >= 1; i--)//利用i的减小将已排序的元素逐个除外\n\t{\n\t\tswap(arr[0], arr[i]);//选出最大的元素放在末尾\n\t\tadjust_down(arr,i,0);//向下调整建堆,待排序的（待建堆的）数的个数为i,逐个减小\n\t}\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-22.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-47-20.png)\n\n正因为实际上排序时是**倒着排**的,所以当我们要排序时：\n\n- 升序->`大堆`\n- 降序->`小堆`\n\n\n\n# 全部代码\n```C++\n#include <vector>\nusing namespace std;\n\ntemplate<class T>\nvoid adjust_up(vector<T>& arr, int child)\n{\n\tint parent = (child - 1) / 2;\n\twhile (parent != child)//parent == child == 0时\n\t{\n\t\tif (arr[parent] < arr[child])//不满足大堆\n\t\t{\n\t\t\tswap(arr[parent], arr[child]);//交换\n\t\t\tchild = parent;//继续向上调整,迭代child和parent\n\t\t\tparent = (child - 1) / 2;\n\t\t}\n\t\telse//完成建堆，退出循环\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ntemplate<class T>\nvoid adjust_down(vector<T>& arr,int sz , int parent)\n{\n\tint child = parent * 2 + 1;\n\tif (child + 1 < sz && arr[child + 1] > arr[child]) child++;//取较大的孩子\n\n\twhile (child < sz)\n\t{\n\t\tif (arr[parent] < arr[child])\n\t\t{\n\t\t\tswap(arr[parent], arr[child]);\n\t\t\tparent = child;\n\t\t\tint child = parent * 2 + 1;\n\t\t\tif (child >= sz) break;\n\t\t\tif (child + 1 < sz && arr[child + 1] > arr[child]) child++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ntemplate <class T>\nvoid heap_sort(vector<T>& arr)\n{\n\tint sz = arr.size();\n\n\t//建堆\n\tfor (int i = 1; i < sz; i++)\n\t{\n\t\tadjust_up(arr, i);//逐个插入并向上调整建堆\n\t}\n\n\tfor (int i = sz-1; i >= 1; i--)\n\t{\n\t\tswap(arr[0], arr[i]);//选出最大的元素放在末尾\n\t\tadjust_down(arr,i,0);//向下调整建堆\n\t}\n}\n```","slug":"heap-sort","published":1,"updated":"2024-05-21T15:21:32.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08c000y4sp5atr052kq","content":"<h1 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h1><ul>\n<li>知道什么是大堆&#x2F;小堆</li>\n<li>掌握如何将数组与完全二叉树的映射关系</li>\n<li>掌握<code>向上调整法</code>和<code>向下调整法</code></li>\n</ul>\n<h2 id=\"大堆-小堆\"><a href=\"#大堆-小堆\" class=\"headerlink\" title=\"大堆&#x2F;小堆\"></a>大堆&#x2F;小堆</h2><p>大堆的特性:每一个节点的值都比左右孩子都大,<code>根</code>的值是整个大堆中<strong>最大的</strong><br>小堆的特性:每一个节点的值都比左右孩子都小,<code>根</code>的值是整个大堆中<strong>最小的</strong></p>\n<p><strong>后面以大堆为例</strong></p>\n<h2 id=\"数组映射成完全二叉树\"><a href=\"#数组映射成完全二叉树\" class=\"headerlink\" title=\"数组映射成完全二叉树\"></a>数组映射成完全二叉树</h2><p>任何一个数组可以看成一个<code>完全二叉树</code>,下标0为二叉树的根</p>\n<p>而非常方便的是，已知一个节点的下标，可以利用数学关系求出根或孩子的下标</p>\n<blockquote>\n<p>下标关系如下（变量均为下标）</p>\n</blockquote>\n<ul>\n<li><code>parent = (child-1)/2</code></li>\n<li><code>left_child = parent*2+1</code></li>\n<li><code>right_child = parent*2+2</code></li>\n</ul>\n<h2 id=\"建堆方法\"><a href=\"#建堆方法\" class=\"headerlink\" title=\"建堆方法\"></a>建堆方法</h2><h3 id=\"向上调整法\"><a href=\"#向上调整法\" class=\"headerlink\" title=\"向上调整法\"></a>向上调整法</h3><p>在已有一个大堆的<strong>前提下</strong>,把一个新的数据插入到堆的最后一个节点(此时破坏大堆的结构),再<strong>一路</strong>向上调整,可以重新建堆</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">adjust_up</span><span class=\"params\">(vector&lt;T&gt;&amp; arr, <span class=\"type\">int</span> child)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> parent = (child - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (parent != child)<span class=\"comment\">//parent == child == 0时</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[parent] &lt; arr[child])<span class=\"comment\">//不满足大堆</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(arr[parent], arr[child]);<span class=\"comment\">//交换</span></span><br><span class=\"line\">\t\t\tchild = parent;<span class=\"comment\">//继续向上调整,迭代child和parent</span></span><br><span class=\"line\">\t\t\tparent = (child - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span><span class=\"comment\">//完成建堆，退出循环</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"向下调整法\"><a href=\"#向下调整法\" class=\"headerlink\" title=\"向下调整法\"></a>向下调整法</h3><p>在已有一个大堆的<strong>前提下</strong>,把根的值改变(此时破坏大堆的结构),再<strong>一路</strong>向下调整，可以重新建堆</p>\n<p>上一句也可以等价于,左子树和右子树都是大堆的前提下，将根<strong>一路</strong>向下调整，可以重新建堆</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">adjust_down</span><span class=\"params\">(vector&lt;T&gt;&amp; arr,<span class=\"type\">int</span> sz , <span class=\"type\">int</span> parent)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> child = parent * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (child + <span class=\"number\">1</span> &lt; sz &amp;&amp; arr[child + <span class=\"number\">1</span>] &gt; arr[child]) child++;<span class=\"comment\">//取较大的孩子</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (child &lt; sz)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[parent] &lt; arr[child])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(arr[parent], arr[child]);</span><br><span class=\"line\">\t\t\tparent = child;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> child = parent * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (child &gt;= sz) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (child + <span class=\"number\">1</span> &lt; sz &amp;&amp; arr[child + <span class=\"number\">1</span>] &gt; arr[child]) child++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"主要思路\"><a href=\"#主要思路\" class=\"headerlink\" title=\"主要思路\"></a>主要思路</h1><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_12-40-09.png\"></p>\n<h2 id=\"建堆\"><a href=\"#建堆\" class=\"headerlink\" title=\"建堆\"></a>建堆</h2><p>用<code>向上调整法</code>和<code>向下调整法</code>都能建堆,不过<code>向上调整法</code>建堆思路更简单，也更容易代码实现，只需要把第一个元素当成现成的大堆，然后逐个插入并向上调整。<strong>也就是说只需要写一个循环</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//向上调整法建堆</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; sz; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">adjust_up</span>(arr, i);<span class=\"comment\">//逐个插入并向上调整建堆</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-09.png\"></p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>此时的排序有个特点，那就是我们要<strong>倒着排</strong></p>\n<p>尽管此时数组的第一个元素为<code>最大值</code>,似乎只需要把它放在那，整一个<code>降序</code>排列，再把剩下的元素建个堆，确定第二大的数…<strong>但是</strong>，此时有个很大的问题，当把剩下的元素看作堆时，会发现前面建堆留下来的关系全被打乱了(原本父子关系,兄弟关系乱套了),也就是说要<code>完全重新建堆</code>,极大地浪费了第一次建堆所建立的关系</p>\n<p>所以我们要尽可能<code>保留</code>原来的堆,既然把下标<code>0</code>处的节点除外会极大地影响堆的关系，那就改成把<code>最后一个叶子节点</code>除外,这样对原来的堆几乎没有改变。</p>\n<p>但建堆选出的<code>最大的</code>的值在根处,所以把<code>根</code>和<code>最后一个叶子节点</code>交换，<strong>交换后</strong>,此时<strong>待排序</strong>的数中的<code>最大值</code>以完成排序（即倒着排）,把<code>最后一个叶子节点</code>从堆中除外,再从<code>根</code>开始一路向下调整即可重新<code>建堆</code>,如此循环</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = sz<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">1</span>; i--)<span class=\"comment\">//利用i的减小将已排序的元素逐个除外</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(arr[<span class=\"number\">0</span>], arr[i]);<span class=\"comment\">//选出最大的元素放在末尾</span></span><br><span class=\"line\">\t<span class=\"built_in\">adjust_down</span>(arr,i,<span class=\"number\">0</span>);<span class=\"comment\">//向下调整建堆,待排序的（待建堆的）数的个数为i,逐个减小</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-22.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-47-20.png\"></p>\n<p>正因为实际上排序时是<strong>倒着排</strong>的,所以当我们要排序时：</p>\n<ul>\n<li>升序-&gt;<code>大堆</code></li>\n<li>降序-&gt;<code>小堆</code></li>\n</ul>\n<h1 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">adjust_up</span><span class=\"params\">(vector&lt;T&gt;&amp; arr, <span class=\"type\">int</span> child)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> parent = (child - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (parent != child)<span class=\"comment\">//parent == child == 0时</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[parent] &lt; arr[child])<span class=\"comment\">//不满足大堆</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(arr[parent], arr[child]);<span class=\"comment\">//交换</span></span><br><span class=\"line\">\t\t\tchild = parent;<span class=\"comment\">//继续向上调整,迭代child和parent</span></span><br><span class=\"line\">\t\t\tparent = (child - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span><span class=\"comment\">//完成建堆，退出循环</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">adjust_down</span><span class=\"params\">(vector&lt;T&gt;&amp; arr,<span class=\"type\">int</span> sz , <span class=\"type\">int</span> parent)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> child = parent * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (child + <span class=\"number\">1</span> &lt; sz &amp;&amp; arr[child + <span class=\"number\">1</span>] &gt; arr[child]) child++;<span class=\"comment\">//取较大的孩子</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (child &lt; sz)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[parent] &lt; arr[child])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(arr[parent], arr[child]);</span><br><span class=\"line\">\t\t\tparent = child;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> child = parent * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (child &gt;= sz) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (child + <span class=\"number\">1</span> &lt; sz &amp;&amp; arr[child + <span class=\"number\">1</span>] &gt; arr[child]) child++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heap_sort</span><span class=\"params\">(vector&lt;T&gt;&amp; arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sz = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//建堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; sz; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">adjust_up</span>(arr, i);<span class=\"comment\">//逐个插入并向上调整建堆</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = sz<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">1</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(arr[<span class=\"number\">0</span>], arr[i]);<span class=\"comment\">//选出最大的元素放在末尾</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">adjust_down</span>(arr,i,<span class=\"number\">0</span>);<span class=\"comment\">//向下调整建堆</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h1><ul>\n<li>知道什么是大堆&#x2F;小堆</li>\n<li>掌握如何将数组与完全二叉树的映射关系</li>\n<li>掌握<code>向上调整法</code>和<code>向下调整法</code></li>\n</ul>\n<h2 id=\"大堆-小堆\"><a href=\"#大堆-小堆\" class=\"headerlink\" title=\"大堆&#x2F;小堆\"></a>大堆&#x2F;小堆</h2><p>大堆的特性:每一个节点的值都比左右孩子都大,<code>根</code>的值是整个大堆中<strong>最大的</strong><br>小堆的特性:每一个节点的值都比左右孩子都小,<code>根</code>的值是整个大堆中<strong>最小的</strong></p>\n<p><strong>后面以大堆为例</strong></p>\n<h2 id=\"数组映射成完全二叉树\"><a href=\"#数组映射成完全二叉树\" class=\"headerlink\" title=\"数组映射成完全二叉树\"></a>数组映射成完全二叉树</h2><p>任何一个数组可以看成一个<code>完全二叉树</code>,下标0为二叉树的根</p>\n<p>而非常方便的是，已知一个节点的下标，可以利用数学关系求出根或孩子的下标</p>\n<blockquote>\n<p>下标关系如下（变量均为下标）</p>\n</blockquote>\n<ul>\n<li><code>parent = (child-1)/2</code></li>\n<li><code>left_child = parent*2+1</code></li>\n<li><code>right_child = parent*2+2</code></li>\n</ul>\n<h2 id=\"建堆方法\"><a href=\"#建堆方法\" class=\"headerlink\" title=\"建堆方法\"></a>建堆方法</h2><h3 id=\"向上调整法\"><a href=\"#向上调整法\" class=\"headerlink\" title=\"向上调整法\"></a>向上调整法</h3><p>在已有一个大堆的<strong>前提下</strong>,把一个新的数据插入到堆的最后一个节点(此时破坏大堆的结构),再<strong>一路</strong>向上调整,可以重新建堆</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">adjust_up</span><span class=\"params\">(vector&lt;T&gt;&amp; arr, <span class=\"type\">int</span> child)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> parent = (child - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (parent != child)<span class=\"comment\">//parent == child == 0时</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[parent] &lt; arr[child])<span class=\"comment\">//不满足大堆</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(arr[parent], arr[child]);<span class=\"comment\">//交换</span></span><br><span class=\"line\">\t\t\tchild = parent;<span class=\"comment\">//继续向上调整,迭代child和parent</span></span><br><span class=\"line\">\t\t\tparent = (child - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span><span class=\"comment\">//完成建堆，退出循环</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"向下调整法\"><a href=\"#向下调整法\" class=\"headerlink\" title=\"向下调整法\"></a>向下调整法</h3><p>在已有一个大堆的<strong>前提下</strong>,把根的值改变(此时破坏大堆的结构),再<strong>一路</strong>向下调整，可以重新建堆</p>\n<p>上一句也可以等价于,左子树和右子树都是大堆的前提下，将根<strong>一路</strong>向下调整，可以重新建堆</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">adjust_down</span><span class=\"params\">(vector&lt;T&gt;&amp; arr,<span class=\"type\">int</span> sz , <span class=\"type\">int</span> parent)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> child = parent * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (child + <span class=\"number\">1</span> &lt; sz &amp;&amp; arr[child + <span class=\"number\">1</span>] &gt; arr[child]) child++;<span class=\"comment\">//取较大的孩子</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (child &lt; sz)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[parent] &lt; arr[child])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(arr[parent], arr[child]);</span><br><span class=\"line\">\t\t\tparent = child;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> child = parent * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (child &gt;= sz) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (child + <span class=\"number\">1</span> &lt; sz &amp;&amp; arr[child + <span class=\"number\">1</span>] &gt; arr[child]) child++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"主要思路\"><a href=\"#主要思路\" class=\"headerlink\" title=\"主要思路\"></a>主要思路</h1><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_12-40-09.png\"></p>\n<h2 id=\"建堆\"><a href=\"#建堆\" class=\"headerlink\" title=\"建堆\"></a>建堆</h2><p>用<code>向上调整法</code>和<code>向下调整法</code>都能建堆,不过<code>向上调整法</code>建堆思路更简单，也更容易代码实现，只需要把第一个元素当成现成的大堆，然后逐个插入并向上调整。<strong>也就是说只需要写一个循环</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//向上调整法建堆</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; sz; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">adjust_up</span>(arr, i);<span class=\"comment\">//逐个插入并向上调整建堆</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-09.png\"></p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>此时的排序有个特点，那就是我们要<strong>倒着排</strong></p>\n<p>尽管此时数组的第一个元素为<code>最大值</code>,似乎只需要把它放在那，整一个<code>降序</code>排列，再把剩下的元素建个堆，确定第二大的数…<strong>但是</strong>，此时有个很大的问题，当把剩下的元素看作堆时，会发现前面建堆留下来的关系全被打乱了(原本父子关系,兄弟关系乱套了),也就是说要<code>完全重新建堆</code>,极大地浪费了第一次建堆所建立的关系</p>\n<p>所以我们要尽可能<code>保留</code>原来的堆,既然把下标<code>0</code>处的节点除外会极大地影响堆的关系，那就改成把<code>最后一个叶子节点</code>除外,这样对原来的堆几乎没有改变。</p>\n<p>但建堆选出的<code>最大的</code>的值在根处,所以把<code>根</code>和<code>最后一个叶子节点</code>交换，<strong>交换后</strong>,此时<strong>待排序</strong>的数中的<code>最大值</code>以完成排序（即倒着排）,把<code>最后一个叶子节点</code>从堆中除外,再从<code>根</code>开始一路向下调整即可重新<code>建堆</code>,如此循环</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = sz<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">1</span>; i--)<span class=\"comment\">//利用i的减小将已排序的元素逐个除外</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(arr[<span class=\"number\">0</span>], arr[i]);<span class=\"comment\">//选出最大的元素放在末尾</span></span><br><span class=\"line\">\t<span class=\"built_in\">adjust_down</span>(arr,i,<span class=\"number\">0</span>);<span class=\"comment\">//向下调整建堆,待排序的（待建堆的）数的个数为i,逐个减小</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-45-22.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-05-21_19-47-20.png\"></p>\n<p>正因为实际上排序时是<strong>倒着排</strong>的,所以当我们要排序时：</p>\n<ul>\n<li>升序-&gt;<code>大堆</code></li>\n<li>降序-&gt;<code>小堆</code></li>\n</ul>\n<h1 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">adjust_up</span><span class=\"params\">(vector&lt;T&gt;&amp; arr, <span class=\"type\">int</span> child)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> parent = (child - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (parent != child)<span class=\"comment\">//parent == child == 0时</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[parent] &lt; arr[child])<span class=\"comment\">//不满足大堆</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(arr[parent], arr[child]);<span class=\"comment\">//交换</span></span><br><span class=\"line\">\t\t\tchild = parent;<span class=\"comment\">//继续向上调整,迭代child和parent</span></span><br><span class=\"line\">\t\t\tparent = (child - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span><span class=\"comment\">//完成建堆，退出循环</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">adjust_down</span><span class=\"params\">(vector&lt;T&gt;&amp; arr,<span class=\"type\">int</span> sz , <span class=\"type\">int</span> parent)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> child = parent * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (child + <span class=\"number\">1</span> &lt; sz &amp;&amp; arr[child + <span class=\"number\">1</span>] &gt; arr[child]) child++;<span class=\"comment\">//取较大的孩子</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (child &lt; sz)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[parent] &lt; arr[child])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(arr[parent], arr[child]);</span><br><span class=\"line\">\t\t\tparent = child;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> child = parent * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (child &gt;= sz) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (child + <span class=\"number\">1</span> &lt; sz &amp;&amp; arr[child + <span class=\"number\">1</span>] &gt; arr[child]) child++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heap_sort</span><span class=\"params\">(vector&lt;T&gt;&amp; arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sz = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//建堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; sz; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">adjust_up</span>(arr, i);<span class=\"comment\">//逐个插入并向上调整建堆</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = sz<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">1</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(arr[<span class=\"number\">0</span>], arr[i]);<span class=\"comment\">//选出最大的元素放在末尾</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">adjust_down</span>(arr,i,<span class=\"number\">0</span>);<span class=\"comment\">//向下调整建堆</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"归并排序","date":"2024-06-28T01:13:09.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png","_content":"\n***\n时间复杂度: O(nlogn)\n空间复杂度: O(n)\n稳定性： 稳定\n实现语言: C/C++\n***\n\n# 原理\n\n## 思想\n这里采用的是**分治**的思想，但与`快速排序`相反的是，归并排序采用的是先分治再合并。\n\n已知在有额外空间的情况下，合并两个**有序**数组得到一个新的较长有序数组是很高效的。 所以能不能把一个任意数组分成由左右两个有序数组组成然后合并成有序数组呢？\n\n显然不能，大部分情况并不能分成两个有序数组，但如果在此之前用同样的方法（这里采用递归）事先排序左右两部分呢？大部分情况依然不能，因此这个递归会一直递推下去，最终待排序区间**不断缩小**,到只剩一个或零个元素，此时就可以将其看为有序数组了,也就是说递归在这里停止，可以一路合并有序数组一路回归上去了\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-02_21-29-34.png)\n\n## 分治\n这里使用左右指针**控制待排序区间**（迭代器也行）,并采用递归的方式形象地完成分治操作\n\n```C++\nvoid _MergeSort(vector<int>& arr,int left,int right,vector<int>&tmp)\n{\n    //分治\n    if(left >= right) return;//递归出口\n\n    int mid = (left+right)/2;\n    _MergeSort(arr,left,mid,tmp);//排序左半边\n    _MergeSort(arr,mid+1,right,tmp);//排序右半边\n\n    //合并数组\n    //...\n}\n\nvoid MergeSort(vector<int>& arr)\n{\n    vector<int> tmp(arr.size());//用tmp开辟额外空间用于合并数组\n    _MergeSort(arr,0,arr.size()-1);\n}\n```\n\n## 合并有序数组\n因为合并两个有序数组**难以原地**完成，所以要借助`tmp`数组提供额外空间。\n\n具体做法就是用两个指针分别从两个数组中挑最小值，然后用第三个指针从左向右填到`tmp`中，最后再拷贝至原数组\n\n```C++\nvoid _MergeSort(vector<int>& arr,int left,int right,vector<int>&tmp)\n{\n    //分治\n    if(left >= right) return;//递归出口\n\n    int mid = (left+right)/2;\n    _MergeSort(arr,left,mid,tmp);//排序左半边\n    _MergeSort(arr,mid+1,right,tmp);//排序右半边\n\n    //合并数组\n    \tint cur1 = left;\n\tint cur2 = mid + 1;\n\tint cur = left;\n\n\twhile (cur1 <= mid && cur2 <= right)\n\t{\n\t\tif (arr[cur1] < arr[cur2])\n\t\t{\n\t\t\ttmp[cur++] = arr[cur1++];\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp[cur++] = arr[cur2++];\n\t\t}\n\t}\n\n\twhile (cur1 <= left)\n\t\ttmp[cur++] = arr[cur1++];\n\twhile (cur2 <= right)\n\t\ttmp[cur++] = arr[cur2++];\n\n\tfor (int i = left; i <= right; i++)\n\t\tarr[i] = tmp[i];\n}\n\nvoid MergeSort(vector<int>& arr)\n{\n    vector<int> tmp(arr.size());//用tmp开辟额外空间用于合并数组\n    _MergeSort(arr,0,arr.size()-1);\n}\n```\n\n以上就是C++版的完整代码,下面再提供`C`语言版的\n\n```C\nvoid _MergeSort(int* arr, int sz, int left, int right, int* tmp)\n{\n\tif (left >= right) return;\n\n\tint mid = (left + right) / 2;\n\n\t_MergeSort(arr,sz ,left, mid, tmp);\n\t_MergeSort(arr, sz, mid + 1,right, tmp);\n\tint cur1 = left, cur2 = mid + 1, cur = left;\n\n\twhile (cur1 <= mid && cur2 <= right)\n\t{\n\t\tif (arr[cur1] < arr[cur2])\n\t\t\ttmp[cur++] = arr[cur1++];\n\t\telse\n\t\t\ttmp[cur++] = arr[cur2++];\n\t}\n\n\twhile (cur1 <= mid)\n\t\ttmp[cur++] = arr[cur1++];\n\twhile (cur2 <= right)\n\t\ttmp[cur++] = arr[cur2++];\n\n\tfor (int i = left; i <= right; i++)\n\t\tarr[i] = tmp[i];\n}\n\nvoid MergeSort(int* arr, int sz)\n{\n\tint* tmp = (int*)malloc(sizeof(int) * sz);\n\t_MergeSort(arr, sz, 0, sz - 1, tmp);\n}\n```\n\n# 小结\n归并排序的原理乍一看很吓人，好像很高深的样子，但其实多上手练练，多试着独立敲代码就能掌握其精髓了，之后手撕归并排序不要太简单","source":"_posts/mergesort.md","raw":"---\ntitle: 归并排序\ndate: 2024-06-28 09:13:09\ntags: 排序 算法\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png\n---\n\n***\n时间复杂度: O(nlogn)\n空间复杂度: O(n)\n稳定性： 稳定\n实现语言: C/C++\n***\n\n# 原理\n\n## 思想\n这里采用的是**分治**的思想，但与`快速排序`相反的是，归并排序采用的是先分治再合并。\n\n已知在有额外空间的情况下，合并两个**有序**数组得到一个新的较长有序数组是很高效的。 所以能不能把一个任意数组分成由左右两个有序数组组成然后合并成有序数组呢？\n\n显然不能，大部分情况并不能分成两个有序数组，但如果在此之前用同样的方法（这里采用递归）事先排序左右两部分呢？大部分情况依然不能，因此这个递归会一直递推下去，最终待排序区间**不断缩小**,到只剩一个或零个元素，此时就可以将其看为有序数组了,也就是说递归在这里停止，可以一路合并有序数组一路回归上去了\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-02_21-29-34.png)\n\n## 分治\n这里使用左右指针**控制待排序区间**（迭代器也行）,并采用递归的方式形象地完成分治操作\n\n```C++\nvoid _MergeSort(vector<int>& arr,int left,int right,vector<int>&tmp)\n{\n    //分治\n    if(left >= right) return;//递归出口\n\n    int mid = (left+right)/2;\n    _MergeSort(arr,left,mid,tmp);//排序左半边\n    _MergeSort(arr,mid+1,right,tmp);//排序右半边\n\n    //合并数组\n    //...\n}\n\nvoid MergeSort(vector<int>& arr)\n{\n    vector<int> tmp(arr.size());//用tmp开辟额外空间用于合并数组\n    _MergeSort(arr,0,arr.size()-1);\n}\n```\n\n## 合并有序数组\n因为合并两个有序数组**难以原地**完成，所以要借助`tmp`数组提供额外空间。\n\n具体做法就是用两个指针分别从两个数组中挑最小值，然后用第三个指针从左向右填到`tmp`中，最后再拷贝至原数组\n\n```C++\nvoid _MergeSort(vector<int>& arr,int left,int right,vector<int>&tmp)\n{\n    //分治\n    if(left >= right) return;//递归出口\n\n    int mid = (left+right)/2;\n    _MergeSort(arr,left,mid,tmp);//排序左半边\n    _MergeSort(arr,mid+1,right,tmp);//排序右半边\n\n    //合并数组\n    \tint cur1 = left;\n\tint cur2 = mid + 1;\n\tint cur = left;\n\n\twhile (cur1 <= mid && cur2 <= right)\n\t{\n\t\tif (arr[cur1] < arr[cur2])\n\t\t{\n\t\t\ttmp[cur++] = arr[cur1++];\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp[cur++] = arr[cur2++];\n\t\t}\n\t}\n\n\twhile (cur1 <= left)\n\t\ttmp[cur++] = arr[cur1++];\n\twhile (cur2 <= right)\n\t\ttmp[cur++] = arr[cur2++];\n\n\tfor (int i = left; i <= right; i++)\n\t\tarr[i] = tmp[i];\n}\n\nvoid MergeSort(vector<int>& arr)\n{\n    vector<int> tmp(arr.size());//用tmp开辟额外空间用于合并数组\n    _MergeSort(arr,0,arr.size()-1);\n}\n```\n\n以上就是C++版的完整代码,下面再提供`C`语言版的\n\n```C\nvoid _MergeSort(int* arr, int sz, int left, int right, int* tmp)\n{\n\tif (left >= right) return;\n\n\tint mid = (left + right) / 2;\n\n\t_MergeSort(arr,sz ,left, mid, tmp);\n\t_MergeSort(arr, sz, mid + 1,right, tmp);\n\tint cur1 = left, cur2 = mid + 1, cur = left;\n\n\twhile (cur1 <= mid && cur2 <= right)\n\t{\n\t\tif (arr[cur1] < arr[cur2])\n\t\t\ttmp[cur++] = arr[cur1++];\n\t\telse\n\t\t\ttmp[cur++] = arr[cur2++];\n\t}\n\n\twhile (cur1 <= mid)\n\t\ttmp[cur++] = arr[cur1++];\n\twhile (cur2 <= right)\n\t\ttmp[cur++] = arr[cur2++];\n\n\tfor (int i = left; i <= right; i++)\n\t\tarr[i] = tmp[i];\n}\n\nvoid MergeSort(int* arr, int sz)\n{\n\tint* tmp = (int*)malloc(sizeof(int) * sz);\n\t_MergeSort(arr, sz, 0, sz - 1, tmp);\n}\n```\n\n# 小结\n归并排序的原理乍一看很吓人，好像很高深的样子，但其实多上手练练，多试着独立敲代码就能掌握其精髓了，之后手撕归并排序不要太简单","slug":"mergesort","published":1,"updated":"2024-07-03T07:13:12.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08e00114sp5gxxw4ykc","content":"<hr>\n<p>时间复杂度: O(nlogn)<br>空间复杂度: O(n)<br>稳定性： 稳定<br>实现语言: C&#x2F;C++</p>\n<hr>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>这里采用的是<strong>分治</strong>的思想，但与<code>快速排序</code>相反的是，归并排序采用的是先分治再合并。</p>\n<p>已知在有额外空间的情况下，合并两个<strong>有序</strong>数组得到一个新的较长有序数组是很高效的。 所以能不能把一个任意数组分成由左右两个有序数组组成然后合并成有序数组呢？</p>\n<p>显然不能，大部分情况并不能分成两个有序数组，但如果在此之前用同样的方法（这里采用递归）事先排序左右两部分呢？大部分情况依然不能，因此这个递归会一直递推下去，最终待排序区间<strong>不断缩小</strong>,到只剩一个或零个元素，此时就可以将其看为有序数组了,也就是说递归在这里停止，可以一路合并有序数组一路回归上去了</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-02_21-29-34.png\"></p>\n<h2 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h2><p>这里使用左右指针<strong>控制待排序区间</strong>（迭代器也行）,并采用递归的方式形象地完成分治操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _MergeSort(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right,vector&lt;<span class=\"type\">int</span>&gt;&amp;tmp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//分治</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left &gt;= right) <span class=\"keyword\">return</span>;<span class=\"comment\">//递归出口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mid = (left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    _MergeSort(arr,left,mid,tmp);<span class=\"comment\">//排序左半边</span></span><br><span class=\"line\">    _MergeSort(arr,mid+<span class=\"number\">1</span>,right,tmp);<span class=\"comment\">//排序右半边</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//合并数组</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MergeSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">tmp</span><span class=\"params\">(arr.size())</span></span>;<span class=\"comment\">//用tmp开辟额外空间用于合并数组</span></span><br><span class=\"line\">    _MergeSort(arr,<span class=\"number\">0</span>,arr.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"合并有序数组\"><a href=\"#合并有序数组\" class=\"headerlink\" title=\"合并有序数组\"></a>合并有序数组</h2><p>因为合并两个有序数组<strong>难以原地</strong>完成，所以要借助<code>tmp</code>数组提供额外空间。</p>\n<p>具体做法就是用两个指针分别从两个数组中挑最小值，然后用第三个指针从左向右填到<code>tmp</code>中，最后再拷贝至原数组</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _MergeSort(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right,vector&lt;<span class=\"type\">int</span>&gt;&amp;tmp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//分治</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left &gt;= right) <span class=\"keyword\">return</span>;<span class=\"comment\">//递归出口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mid = (left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    _MergeSort(arr,left,mid,tmp);<span class=\"comment\">//排序左半边</span></span><br><span class=\"line\">    _MergeSort(arr,mid+<span class=\"number\">1</span>,right,tmp);<span class=\"comment\">//排序右半边</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//合并数组</span></span><br><span class=\"line\">    \t<span class=\"type\">int</span> cur1 = left;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cur2 = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cur = left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur1 &lt;= mid &amp;&amp; cur2 &lt;= right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[cur1] &lt; arr[cur2])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp[cur++] = arr[cur1++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp[cur++] = arr[cur2++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur1 &lt;= left)</span><br><span class=\"line\">\t\ttmp[cur++] = arr[cur1++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur2 &lt;= right)</span><br><span class=\"line\">\t\ttmp[cur++] = arr[cur2++];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = left; i &lt;= right; i++)</span><br><span class=\"line\">\t\tarr[i] = tmp[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MergeSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">tmp</span><span class=\"params\">(arr.size())</span></span>;<span class=\"comment\">//用tmp开辟额外空间用于合并数组</span></span><br><span class=\"line\">    _MergeSort(arr,<span class=\"number\">0</span>,arr.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是C++版的完整代码,下面再提供<code>C</code>语言版的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _MergeSort(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> sz, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right, <span class=\"type\">int</span>* tmp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left &gt;= right) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t_MergeSort(arr,sz ,left, mid, tmp);</span><br><span class=\"line\">\t_MergeSort(arr, sz, mid + <span class=\"number\">1</span>,right, tmp);</span><br><span class=\"line\">\t<span class=\"type\">int</span> cur1 = left, cur2 = mid + <span class=\"number\">1</span>, cur = left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur1 &lt;= mid &amp;&amp; cur2 &lt;= right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[cur1] &lt; arr[cur2])</span><br><span class=\"line\">\t\t\ttmp[cur++] = arr[cur1++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ttmp[cur++] = arr[cur2++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur1 &lt;= mid)</span><br><span class=\"line\">\t\ttmp[cur++] = arr[cur1++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur2 &lt;= right)</span><br><span class=\"line\">\t\ttmp[cur++] = arr[cur2++];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = left; i &lt;= right; i++)</span><br><span class=\"line\">\t\tarr[i] = tmp[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MergeSort</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> sz)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span>* tmp = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>) * sz);</span><br><span class=\"line\">\t_MergeSort(arr, sz, <span class=\"number\">0</span>, sz - <span class=\"number\">1</span>, tmp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>归并排序的原理乍一看很吓人，好像很高深的样子，但其实多上手练练，多试着独立敲代码就能掌握其精髓了，之后手撕归并排序不要太简单</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<hr>\n<p>时间复杂度: O(nlogn)<br>空间复杂度: O(n)<br>稳定性： 稳定<br>实现语言: C&#x2F;C++</p>\n<hr>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>这里采用的是<strong>分治</strong>的思想，但与<code>快速排序</code>相反的是，归并排序采用的是先分治再合并。</p>\n<p>已知在有额外空间的情况下，合并两个<strong>有序</strong>数组得到一个新的较长有序数组是很高效的。 所以能不能把一个任意数组分成由左右两个有序数组组成然后合并成有序数组呢？</p>\n<p>显然不能，大部分情况并不能分成两个有序数组，但如果在此之前用同样的方法（这里采用递归）事先排序左右两部分呢？大部分情况依然不能，因此这个递归会一直递推下去，最终待排序区间<strong>不断缩小</strong>,到只剩一个或零个元素，此时就可以将其看为有序数组了,也就是说递归在这里停止，可以一路合并有序数组一路回归上去了</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-02_21-29-34.png\"></p>\n<h2 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h2><p>这里使用左右指针<strong>控制待排序区间</strong>（迭代器也行）,并采用递归的方式形象地完成分治操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _MergeSort(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right,vector&lt;<span class=\"type\">int</span>&gt;&amp;tmp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//分治</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left &gt;= right) <span class=\"keyword\">return</span>;<span class=\"comment\">//递归出口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mid = (left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    _MergeSort(arr,left,mid,tmp);<span class=\"comment\">//排序左半边</span></span><br><span class=\"line\">    _MergeSort(arr,mid+<span class=\"number\">1</span>,right,tmp);<span class=\"comment\">//排序右半边</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//合并数组</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MergeSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">tmp</span><span class=\"params\">(arr.size())</span></span>;<span class=\"comment\">//用tmp开辟额外空间用于合并数组</span></span><br><span class=\"line\">    _MergeSort(arr,<span class=\"number\">0</span>,arr.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"合并有序数组\"><a href=\"#合并有序数组\" class=\"headerlink\" title=\"合并有序数组\"></a>合并有序数组</h2><p>因为合并两个有序数组<strong>难以原地</strong>完成，所以要借助<code>tmp</code>数组提供额外空间。</p>\n<p>具体做法就是用两个指针分别从两个数组中挑最小值，然后用第三个指针从左向右填到<code>tmp</code>中，最后再拷贝至原数组</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _MergeSort(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right,vector&lt;<span class=\"type\">int</span>&gt;&amp;tmp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//分治</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left &gt;= right) <span class=\"keyword\">return</span>;<span class=\"comment\">//递归出口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> mid = (left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    _MergeSort(arr,left,mid,tmp);<span class=\"comment\">//排序左半边</span></span><br><span class=\"line\">    _MergeSort(arr,mid+<span class=\"number\">1</span>,right,tmp);<span class=\"comment\">//排序右半边</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//合并数组</span></span><br><span class=\"line\">    \t<span class=\"type\">int</span> cur1 = left;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cur2 = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cur = left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur1 &lt;= mid &amp;&amp; cur2 &lt;= right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[cur1] &lt; arr[cur2])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp[cur++] = arr[cur1++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp[cur++] = arr[cur2++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur1 &lt;= left)</span><br><span class=\"line\">\t\ttmp[cur++] = arr[cur1++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur2 &lt;= right)</span><br><span class=\"line\">\t\ttmp[cur++] = arr[cur2++];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = left; i &lt;= right; i++)</span><br><span class=\"line\">\t\tarr[i] = tmp[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MergeSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">tmp</span><span class=\"params\">(arr.size())</span></span>;<span class=\"comment\">//用tmp开辟额外空间用于合并数组</span></span><br><span class=\"line\">    _MergeSort(arr,<span class=\"number\">0</span>,arr.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是C++版的完整代码,下面再提供<code>C</code>语言版的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _MergeSort(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> sz, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right, <span class=\"type\">int</span>* tmp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left &gt;= right) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t_MergeSort(arr,sz ,left, mid, tmp);</span><br><span class=\"line\">\t_MergeSort(arr, sz, mid + <span class=\"number\">1</span>,right, tmp);</span><br><span class=\"line\">\t<span class=\"type\">int</span> cur1 = left, cur2 = mid + <span class=\"number\">1</span>, cur = left;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur1 &lt;= mid &amp;&amp; cur2 &lt;= right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[cur1] &lt; arr[cur2])</span><br><span class=\"line\">\t\t\ttmp[cur++] = arr[cur1++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ttmp[cur++] = arr[cur2++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur1 &lt;= mid)</span><br><span class=\"line\">\t\ttmp[cur++] = arr[cur1++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur2 &lt;= right)</span><br><span class=\"line\">\t\ttmp[cur++] = arr[cur2++];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = left; i &lt;= right; i++)</span><br><span class=\"line\">\t\tarr[i] = tmp[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MergeSort</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> sz)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span>* tmp = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>) * sz);</span><br><span class=\"line\">\t_MergeSort(arr, sz, <span class=\"number\">0</span>, sz - <span class=\"number\">1</span>, tmp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>归并排序的原理乍一看很吓人，好像很高深的样子，但其实多上手练练，多试着独立敲代码就能掌握其精髓了，之后手撕归并排序不要太简单</p>\n"},{"title":"初识动静态库","date":"2024-07-08T01:10:13.000Z","_content":"\n# 静态库(.a)\n程序在**编译链接**的时候把库的代码链接到可执行文件中。编译出的程序**运行时不再需要**静态库\n\n## 生成和使用静态库\n这里使用`gcc`编译获得`.o`链接文件，再用`gnu`归档工具中的`ar`指令配合`-rc`选项(replace and create)封装库文件,最后借助`makefile`简化文件目录的封装操作\n\n使用第三方库时,还可以使用`ar -tv`查看库中的目录列表\n+ t:列出静态库中的文件\n+ v:verbose 详细信息\n\n使用静态库：\n\n`gcc`编译时使用第三方静态库必须包含以下选项：\n+ `-I`指定头文件目录\n+ `-L`指定库路径\n+ `-l`指定库名（不加空格）,库名要把`文件名`前面去掉`lib`,后面去掉`.a`才是真正的库名\n\n否则编译器不知道头文件在哪，或者不知道链接哪个库\n\n### 库搜索路径\n库的搜索会按照一定的顺序\n\n1. 从左到右搜索-L指定的目录。\n2. 由环境变量指定的目录 （`LIBRARY_PATH`）\n3. 由系统指定的目录\n   + `/usr/lib`\n   + `/usr/local/lib`\n\n\n### 样例\n测试程序（共`5`个文件）\n```C\n/////////////add.h/////////////////\n #ifndef __ADD_H__\n #define __ADD_H__ \n int add(int a, int b); \n #endif // __ADD_H__\n /////////////add.c/////////////////\n #include \"add.h\"\n int add(int a, int b)\n {\n return a + b;\n }\n /////////////sub.h/////////////////\n #ifndef __SUB_H__\n #define __SUB_H__ \n int sub(int a, int b); \n #endif // __SUB_H__\n /////////////add.c/////////////////\n #include \"add.h\"\n int sub(int a, int b)\n {\n return a - b;\n }\n ///////////main.c////////////////\n #include <stdio.h>\n #include \"add.h\"\n #include \"sub.h\"\n \n int main( void )\n {\n int a = 10;\n int b = 20;\n printf(\"add(10, 20)=%d\\n\", a, b, add(a, b));\n a = 100;\n b = 20;\n printf(\"sub(%d,%d)=%d\\n\", a, b, sub(a, b));\n }\n\n```\n然后我们编写`makefile`文件\n```makefile\nlib = libmymath.a\n\n$(lib):add.o sub.o \n\tar -rc $@ add.o sub.o \n\nadd.o:add.c \n\tgcc -c add.c -o add.o\n\nsub.o:sub.c\n\tgcc -c sub.c -o sub.o\n\n.PHONY:clean\nclean:\n\trm -f *.o *.a \n\n.PHONY:output \noutput:\n\tmkdir -p lib/include\n\tmkdir -p lib/mymathlib\n\tcp *.h lib/include\n\tcp *.a lib/mymathlib\n```\n`lib`作为`makefile`中的变量，储存了`库名`，默认的`make`指令用于打包库文件,其依赖的`add.o`和`sub.o`会自动调用后两句编译产生。\n\n`make output`指令自动准备好目录并拷贝头文件和静态库\n\n然后编译产生可执行程序\n\n```SHELL\ngcc main.c -o mycmd -I ./lib/include -L ./lib/mymathlib -lmymath\n```\n注意,使用第三方库时`-I`,`-L`和`-l`缺一不可\n\n但如果安装了第三方库时，即将`库文件/库文件的软链接`拷贝至`/lib64/`，将`头文件/头文件的软链接`拷贝至`/usr/inlude/`，使`gcc`能够自动搜索到路径，则编译时只需用`-l`指定`库名`即可\n\n\n# 动态库(.so)\n动态库的作用是使程序在**运行时**才去链接动态库的代码，多个程序共享使用库的代码，从而使编译出的可执行文件更小，节省磁盘空间。使用动态库时，动态库也要**加载到内存中**\n\n## 使用动态库底层的过程\n1. 使用动态库编译可执行程序：一个与动态库链接的可执行文件仅仅包含它用到的函数入口地址的一个表，而不是外部函数所在目标文件的整个机器码\n2. 动态链接: 在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的该动态库中复制(加载)到内存中，这个过程称为`动态链接`（dynamic linking）\n3. 运行时调用动态库：调用来自动态库的函数时，实现函数功能的机器码将由动态库提供\n\n## 生成和使用动态库\n这里使用`gcc`加`-fPIC`(产生位置无关码position independent code)和`-c`编译获得`.o`链接文件，再用`gcc`指令配合封装库文件,最后借助`makefile`简化文件目录的封装操作\n\n使用动态库：\n\n`gcc`编译时使用第三方静态库必须包含以下选项：\n+ `-I`指定头文件目录\n+ `-L`指定库路径\n+ `-l`指定库名（不加空格）,库名要把`文件名`前面去掉`lib`,后面去掉`.a`才是真正的库名\n\n否则编译器不知道头文件在哪，或者不知道链接哪个库\n\n特别的，当动静态库同时存在时，`gcc`默认优先使用动态库，除非加`-static`参数\n\n**但是**，仅仅编译出可执行文件还不够，因为可执行文件还**找不到**动态库,所以我们还得告诉系统中的`加载器`，我们的动态库在哪,所以我们要把动态库安装到`/lib64/`,拷贝文件或建立软连接都可以（需要`sudo`或`root`权限）\n\n亦或者修改环境变量`LD_LIBRARY_PATH`\n\n### 示例\n文件代码同上，这里展示`makefile`文件\n\n```makefile\nlib = mymathlib.a\n\n$(lib):add.o sub.o \n\tgcc -shared -o libmymath.so *.o \n\nadd.o:add.c \n\tgcc -fPIC -c add.c -o add.o \n\nsub.o:sub.c\n\tgcc -fPIC -c sub.c -o sub.o\n\n.PHONY:clean\nclean:\n\trm -f *.o *.a \n\n.PHONY:output \noutput:\n\tmkdir -p lib/include\n\tmkdir -p lib/mymathlib\n\tcp *.h lib/include\n\tcp *.so lib/mymathlib\n```\n\n### 库搜索路径\n库的搜索会按照一定的顺序\n\n1. 从左到右搜索-L指定的目录。\n2. 由环境变量指定的目录 （`LIBRARY_PATH`）\n3. 由系统指定的目录\n   + `/usr/lib`\n   + `/usr/local/lib`\n\n# 小结\n库文件命名规则`libxxx.a`/`libxxx.so`\n\n库文件名称->库名：去掉前缀`lib`,去掉后缀`.so`/`.a`\n\n使用动态库的可执行程序需要`安装动态库`或修改环境变量`LD_LIBRARY_PATH`\n","source":"_posts/libs.md","raw":"---\ntitle: 初识动静态库\ndate: 2024-07-08 09:10:13\ntags: 动态库 静态库\n---\n\n# 静态库(.a)\n程序在**编译链接**的时候把库的代码链接到可执行文件中。编译出的程序**运行时不再需要**静态库\n\n## 生成和使用静态库\n这里使用`gcc`编译获得`.o`链接文件，再用`gnu`归档工具中的`ar`指令配合`-rc`选项(replace and create)封装库文件,最后借助`makefile`简化文件目录的封装操作\n\n使用第三方库时,还可以使用`ar -tv`查看库中的目录列表\n+ t:列出静态库中的文件\n+ v:verbose 详细信息\n\n使用静态库：\n\n`gcc`编译时使用第三方静态库必须包含以下选项：\n+ `-I`指定头文件目录\n+ `-L`指定库路径\n+ `-l`指定库名（不加空格）,库名要把`文件名`前面去掉`lib`,后面去掉`.a`才是真正的库名\n\n否则编译器不知道头文件在哪，或者不知道链接哪个库\n\n### 库搜索路径\n库的搜索会按照一定的顺序\n\n1. 从左到右搜索-L指定的目录。\n2. 由环境变量指定的目录 （`LIBRARY_PATH`）\n3. 由系统指定的目录\n   + `/usr/lib`\n   + `/usr/local/lib`\n\n\n### 样例\n测试程序（共`5`个文件）\n```C\n/////////////add.h/////////////////\n #ifndef __ADD_H__\n #define __ADD_H__ \n int add(int a, int b); \n #endif // __ADD_H__\n /////////////add.c/////////////////\n #include \"add.h\"\n int add(int a, int b)\n {\n return a + b;\n }\n /////////////sub.h/////////////////\n #ifndef __SUB_H__\n #define __SUB_H__ \n int sub(int a, int b); \n #endif // __SUB_H__\n /////////////add.c/////////////////\n #include \"add.h\"\n int sub(int a, int b)\n {\n return a - b;\n }\n ///////////main.c////////////////\n #include <stdio.h>\n #include \"add.h\"\n #include \"sub.h\"\n \n int main( void )\n {\n int a = 10;\n int b = 20;\n printf(\"add(10, 20)=%d\\n\", a, b, add(a, b));\n a = 100;\n b = 20;\n printf(\"sub(%d,%d)=%d\\n\", a, b, sub(a, b));\n }\n\n```\n然后我们编写`makefile`文件\n```makefile\nlib = libmymath.a\n\n$(lib):add.o sub.o \n\tar -rc $@ add.o sub.o \n\nadd.o:add.c \n\tgcc -c add.c -o add.o\n\nsub.o:sub.c\n\tgcc -c sub.c -o sub.o\n\n.PHONY:clean\nclean:\n\trm -f *.o *.a \n\n.PHONY:output \noutput:\n\tmkdir -p lib/include\n\tmkdir -p lib/mymathlib\n\tcp *.h lib/include\n\tcp *.a lib/mymathlib\n```\n`lib`作为`makefile`中的变量，储存了`库名`，默认的`make`指令用于打包库文件,其依赖的`add.o`和`sub.o`会自动调用后两句编译产生。\n\n`make output`指令自动准备好目录并拷贝头文件和静态库\n\n然后编译产生可执行程序\n\n```SHELL\ngcc main.c -o mycmd -I ./lib/include -L ./lib/mymathlib -lmymath\n```\n注意,使用第三方库时`-I`,`-L`和`-l`缺一不可\n\n但如果安装了第三方库时，即将`库文件/库文件的软链接`拷贝至`/lib64/`，将`头文件/头文件的软链接`拷贝至`/usr/inlude/`，使`gcc`能够自动搜索到路径，则编译时只需用`-l`指定`库名`即可\n\n\n# 动态库(.so)\n动态库的作用是使程序在**运行时**才去链接动态库的代码，多个程序共享使用库的代码，从而使编译出的可执行文件更小，节省磁盘空间。使用动态库时，动态库也要**加载到内存中**\n\n## 使用动态库底层的过程\n1. 使用动态库编译可执行程序：一个与动态库链接的可执行文件仅仅包含它用到的函数入口地址的一个表，而不是外部函数所在目标文件的整个机器码\n2. 动态链接: 在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的该动态库中复制(加载)到内存中，这个过程称为`动态链接`（dynamic linking）\n3. 运行时调用动态库：调用来自动态库的函数时，实现函数功能的机器码将由动态库提供\n\n## 生成和使用动态库\n这里使用`gcc`加`-fPIC`(产生位置无关码position independent code)和`-c`编译获得`.o`链接文件，再用`gcc`指令配合封装库文件,最后借助`makefile`简化文件目录的封装操作\n\n使用动态库：\n\n`gcc`编译时使用第三方静态库必须包含以下选项：\n+ `-I`指定头文件目录\n+ `-L`指定库路径\n+ `-l`指定库名（不加空格）,库名要把`文件名`前面去掉`lib`,后面去掉`.a`才是真正的库名\n\n否则编译器不知道头文件在哪，或者不知道链接哪个库\n\n特别的，当动静态库同时存在时，`gcc`默认优先使用动态库，除非加`-static`参数\n\n**但是**，仅仅编译出可执行文件还不够，因为可执行文件还**找不到**动态库,所以我们还得告诉系统中的`加载器`，我们的动态库在哪,所以我们要把动态库安装到`/lib64/`,拷贝文件或建立软连接都可以（需要`sudo`或`root`权限）\n\n亦或者修改环境变量`LD_LIBRARY_PATH`\n\n### 示例\n文件代码同上，这里展示`makefile`文件\n\n```makefile\nlib = mymathlib.a\n\n$(lib):add.o sub.o \n\tgcc -shared -o libmymath.so *.o \n\nadd.o:add.c \n\tgcc -fPIC -c add.c -o add.o \n\nsub.o:sub.c\n\tgcc -fPIC -c sub.c -o sub.o\n\n.PHONY:clean\nclean:\n\trm -f *.o *.a \n\n.PHONY:output \noutput:\n\tmkdir -p lib/include\n\tmkdir -p lib/mymathlib\n\tcp *.h lib/include\n\tcp *.so lib/mymathlib\n```\n\n### 库搜索路径\n库的搜索会按照一定的顺序\n\n1. 从左到右搜索-L指定的目录。\n2. 由环境变量指定的目录 （`LIBRARY_PATH`）\n3. 由系统指定的目录\n   + `/usr/lib`\n   + `/usr/local/lib`\n\n# 小结\n库文件命名规则`libxxx.a`/`libxxx.so`\n\n库文件名称->库名：去掉前缀`lib`,去掉后缀`.so`/`.a`\n\n使用动态库的可执行程序需要`安装动态库`或修改环境变量`LD_LIBRARY_PATH`\n","slug":"libs","published":1,"updated":"2024-08-10T04:41:15.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08f00134sp5b1dygapk","content":"<h1 id=\"静态库-a\"><a href=\"#静态库-a\" class=\"headerlink\" title=\"静态库(.a)\"></a>静态库(.a)</h1><p>程序在<strong>编译链接</strong>的时候把库的代码链接到可执行文件中。编译出的程序<strong>运行时不再需要</strong>静态库</p>\n<h2 id=\"生成和使用静态库\"><a href=\"#生成和使用静态库\" class=\"headerlink\" title=\"生成和使用静态库\"></a>生成和使用静态库</h2><p>这里使用<code>gcc</code>编译获得<code>.o</code>链接文件，再用<code>gnu</code>归档工具中的<code>ar</code>指令配合<code>-rc</code>选项(replace and create)封装库文件,最后借助<code>makefile</code>简化文件目录的封装操作</p>\n<p>使用第三方库时,还可以使用<code>ar -tv</code>查看库中的目录列表</p>\n<ul>\n<li>t:列出静态库中的文件</li>\n<li>v:verbose 详细信息</li>\n</ul>\n<p>使用静态库：</p>\n<p><code>gcc</code>编译时使用第三方静态库必须包含以下选项：</p>\n<ul>\n<li><code>-I</code>指定头文件目录</li>\n<li><code>-L</code>指定库路径</li>\n<li><code>-l</code>指定库名（不加空格）,库名要把<code>文件名</code>前面去掉<code>lib</code>,后面去掉<code>.a</code>才是真正的库名</li>\n</ul>\n<p>否则编译器不知道头文件在哪，或者不知道链接哪个库</p>\n<h3 id=\"库搜索路径\"><a href=\"#库搜索路径\" class=\"headerlink\" title=\"库搜索路径\"></a>库搜索路径</h3><p>库的搜索会按照一定的顺序</p>\n<ol>\n<li>从左到右搜索-L指定的目录。</li>\n<li>由环境变量指定的目录 （<code>LIBRARY_PATH</code>）</li>\n<li>由系统指定的目录<ul>\n<li><code>/usr/lib</code></li>\n<li><code>/usr/local/lib</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h3><p>测试程序（共<code>5</code>个文件）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/////////////add.h/////////////////</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">ifndef</span> __ADD_H__</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> __ADD_H__ </span></span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>; </span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// __ADD_H__</span></span></span><br><span class=\"line\"> <span class=\"comment\">/////////////add.c/////////////////</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;add.h&quot;</span></span></span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">/////////////sub.h/////////////////</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">ifndef</span> __SUB_H__</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> __SUB_H__ </span></span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">sub</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>; </span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// __SUB_H__</span></span></span><br><span class=\"line\"> <span class=\"comment\">/////////////add.c/////////////////</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;add.h&quot;</span></span></span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">sub</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">///////////main.c////////////////</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;add.h&quot;</span></span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;sub.h&quot;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"> <span class=\"type\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;add(10, 20)=%d\\n&quot;</span>, a, b, add(a, b));</span><br><span class=\"line\"> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"> b = <span class=\"number\">20</span>;</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sub(%d,%d)=%d\\n&quot;</span>, a, b, sub(a, b));</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>然后我们编写<code>makefile</code>文件</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lib = libmymath.a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(lib)</span>:add.o sub.o </span><br><span class=\"line\">\tar -rc <span class=\"variable\">$@</span> add.o sub.o </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">add.o:add.c </span></span><br><span class=\"line\">\tgcc -c add.c -o add.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">sub.o:sub.c</span></span><br><span class=\"line\">\tgcc -c sub.c -o sub.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:clean</span></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\trm -f *.o *.a </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:output </span></span><br><span class=\"line\"><span class=\"section\">output:</span></span><br><span class=\"line\">\tmkdir -p lib/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tmkdir -p lib/mymathlib</span><br><span class=\"line\">\tcp *.h lib/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tcp *.a lib/mymathlib</span><br></pre></td></tr></table></figure>\n<p><code>lib</code>作为<code>makefile</code>中的变量，储存了<code>库名</code>，默认的<code>make</code>指令用于打包库文件,其依赖的<code>add.o</code>和<code>sub.o</code>会自动调用后两句编译产生。</p>\n<p><code>make output</code>指令自动准备好目录并拷贝头文件和静态库</p>\n<p>然后编译产生可执行程序</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc main.c -o mycmd -I ./lib/include -L ./lib/mymathlib -lmymath</span><br></pre></td></tr></table></figure>\n<p>注意,使用第三方库时<code>-I</code>,<code>-L</code>和<code>-l</code>缺一不可</p>\n<p>但如果安装了第三方库时，即将<code>库文件/库文件的软链接</code>拷贝至<code>/lib64/</code>，将<code>头文件/头文件的软链接</code>拷贝至<code>/usr/inlude/</code>，使<code>gcc</code>能够自动搜索到路径，则编译时只需用<code>-l</code>指定<code>库名</code>即可</p>\n<h1 id=\"动态库-so\"><a href=\"#动态库-so\" class=\"headerlink\" title=\"动态库(.so)\"></a>动态库(.so)</h1><p>动态库的作用是使程序在<strong>运行时</strong>才去链接动态库的代码，多个程序共享使用库的代码，从而使编译出的可执行文件更小，节省磁盘空间。使用动态库时，动态库也要<strong>加载到内存中</strong></p>\n<h2 id=\"使用动态库底层的过程\"><a href=\"#使用动态库底层的过程\" class=\"headerlink\" title=\"使用动态库底层的过程\"></a>使用动态库底层的过程</h2><ol>\n<li>使用动态库编译可执行程序：一个与动态库链接的可执行文件仅仅包含它用到的函数入口地址的一个表，而不是外部函数所在目标文件的整个机器码</li>\n<li>动态链接: 在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的该动态库中复制(加载)到内存中，这个过程称为<code>动态链接</code>（dynamic linking）</li>\n<li>运行时调用动态库：调用来自动态库的函数时，实现函数功能的机器码将由动态库提供</li>\n</ol>\n<h2 id=\"生成和使用动态库\"><a href=\"#生成和使用动态库\" class=\"headerlink\" title=\"生成和使用动态库\"></a>生成和使用动态库</h2><p>这里使用<code>gcc</code>加<code>-fPIC</code>(产生位置无关码position independent code)和<code>-c</code>编译获得<code>.o</code>链接文件，再用<code>gcc</code>指令配合封装库文件,最后借助<code>makefile</code>简化文件目录的封装操作</p>\n<p>使用动态库：</p>\n<p><code>gcc</code>编译时使用第三方静态库必须包含以下选项：</p>\n<ul>\n<li><code>-I</code>指定头文件目录</li>\n<li><code>-L</code>指定库路径</li>\n<li><code>-l</code>指定库名（不加空格）,库名要把<code>文件名</code>前面去掉<code>lib</code>,后面去掉<code>.a</code>才是真正的库名</li>\n</ul>\n<p>否则编译器不知道头文件在哪，或者不知道链接哪个库</p>\n<p>特别的，当动静态库同时存在时，<code>gcc</code>默认优先使用动态库，除非加<code>-static</code>参数</p>\n<p><strong>但是</strong>，仅仅编译出可执行文件还不够，因为可执行文件还<strong>找不到</strong>动态库,所以我们还得告诉系统中的<code>加载器</code>，我们的动态库在哪,所以我们要把动态库安装到<code>/lib64/</code>,拷贝文件或建立软连接都可以（需要<code>sudo</code>或<code>root</code>权限）</p>\n<p>亦或者修改环境变量<code>LD_LIBRARY_PATH</code></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>文件代码同上，这里展示<code>makefile</code>文件</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lib = mymathlib.a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(lib)</span>:add.o sub.o </span><br><span class=\"line\">\tgcc -shared -o libmymath.so *.o </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">add.o:add.c </span></span><br><span class=\"line\">\tgcc -fPIC -c add.c -o add.o </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">sub.o:sub.c</span></span><br><span class=\"line\">\tgcc -fPIC -c sub.c -o sub.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:clean</span></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\trm -f *.o *.a </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:output </span></span><br><span class=\"line\"><span class=\"section\">output:</span></span><br><span class=\"line\">\tmkdir -p lib/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tmkdir -p lib/mymathlib</span><br><span class=\"line\">\tcp *.h lib/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tcp *.so lib/mymathlib</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"库搜索路径-1\"><a href=\"#库搜索路径-1\" class=\"headerlink\" title=\"库搜索路径\"></a>库搜索路径</h3><p>库的搜索会按照一定的顺序</p>\n<ol>\n<li>从左到右搜索-L指定的目录。</li>\n<li>由环境变量指定的目录 （<code>LIBRARY_PATH</code>）</li>\n<li>由系统指定的目录<ul>\n<li><code>/usr/lib</code></li>\n<li><code>/usr/local/lib</code></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>库文件命名规则<code>libxxx.a</code>&#x2F;<code>libxxx.so</code></p>\n<p>库文件名称-&gt;库名：去掉前缀<code>lib</code>,去掉后缀<code>.so</code>&#x2F;<code>.a</code></p>\n<p>使用动态库的可执行程序需要<code>安装动态库</code>或修改环境变量<code>LD_LIBRARY_PATH</code></p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/07c3084a53912063e65735a81fa2ceaf.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"静态库-a\"><a href=\"#静态库-a\" class=\"headerlink\" title=\"静态库(.a)\"></a>静态库(.a)</h1><p>程序在<strong>编译链接</strong>的时候把库的代码链接到可执行文件中。编译出的程序<strong>运行时不再需要</strong>静态库</p>\n<h2 id=\"生成和使用静态库\"><a href=\"#生成和使用静态库\" class=\"headerlink\" title=\"生成和使用静态库\"></a>生成和使用静态库</h2><p>这里使用<code>gcc</code>编译获得<code>.o</code>链接文件，再用<code>gnu</code>归档工具中的<code>ar</code>指令配合<code>-rc</code>选项(replace and create)封装库文件,最后借助<code>makefile</code>简化文件目录的封装操作</p>\n<p>使用第三方库时,还可以使用<code>ar -tv</code>查看库中的目录列表</p>\n<ul>\n<li>t:列出静态库中的文件</li>\n<li>v:verbose 详细信息</li>\n</ul>\n<p>使用静态库：</p>\n<p><code>gcc</code>编译时使用第三方静态库必须包含以下选项：</p>\n<ul>\n<li><code>-I</code>指定头文件目录</li>\n<li><code>-L</code>指定库路径</li>\n<li><code>-l</code>指定库名（不加空格）,库名要把<code>文件名</code>前面去掉<code>lib</code>,后面去掉<code>.a</code>才是真正的库名</li>\n</ul>\n<p>否则编译器不知道头文件在哪，或者不知道链接哪个库</p>\n<h3 id=\"库搜索路径\"><a href=\"#库搜索路径\" class=\"headerlink\" title=\"库搜索路径\"></a>库搜索路径</h3><p>库的搜索会按照一定的顺序</p>\n<ol>\n<li>从左到右搜索-L指定的目录。</li>\n<li>由环境变量指定的目录 （<code>LIBRARY_PATH</code>）</li>\n<li>由系统指定的目录<ul>\n<li><code>/usr/lib</code></li>\n<li><code>/usr/local/lib</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h3><p>测试程序（共<code>5</code>个文件）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/////////////add.h/////////////////</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">ifndef</span> __ADD_H__</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> __ADD_H__ </span></span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>; </span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// __ADD_H__</span></span></span><br><span class=\"line\"> <span class=\"comment\">/////////////add.c/////////////////</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;add.h&quot;</span></span></span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">/////////////sub.h/////////////////</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">ifndef</span> __SUB_H__</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> __SUB_H__ </span></span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">sub</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>; </span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// __SUB_H__</span></span></span><br><span class=\"line\"> <span class=\"comment\">/////////////add.c/////////////////</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;add.h&quot;</span></span></span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">sub</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">///////////main.c////////////////</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;add.h&quot;</span></span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;sub.h&quot;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">( <span class=\"type\">void</span> )</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"> <span class=\"type\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;add(10, 20)=%d\\n&quot;</span>, a, b, add(a, b));</span><br><span class=\"line\"> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"> b = <span class=\"number\">20</span>;</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sub(%d,%d)=%d\\n&quot;</span>, a, b, sub(a, b));</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>然后我们编写<code>makefile</code>文件</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lib = libmymath.a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(lib)</span>:add.o sub.o </span><br><span class=\"line\">\tar -rc <span class=\"variable\">$@</span> add.o sub.o </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">add.o:add.c </span></span><br><span class=\"line\">\tgcc -c add.c -o add.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">sub.o:sub.c</span></span><br><span class=\"line\">\tgcc -c sub.c -o sub.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:clean</span></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\trm -f *.o *.a </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:output </span></span><br><span class=\"line\"><span class=\"section\">output:</span></span><br><span class=\"line\">\tmkdir -p lib/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tmkdir -p lib/mymathlib</span><br><span class=\"line\">\tcp *.h lib/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tcp *.a lib/mymathlib</span><br></pre></td></tr></table></figure>\n<p><code>lib</code>作为<code>makefile</code>中的变量，储存了<code>库名</code>，默认的<code>make</code>指令用于打包库文件,其依赖的<code>add.o</code>和<code>sub.o</code>会自动调用后两句编译产生。</p>\n<p><code>make output</code>指令自动准备好目录并拷贝头文件和静态库</p>\n<p>然后编译产生可执行程序</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc main.c -o mycmd -I ./lib/include -L ./lib/mymathlib -lmymath</span><br></pre></td></tr></table></figure>\n<p>注意,使用第三方库时<code>-I</code>,<code>-L</code>和<code>-l</code>缺一不可</p>\n<p>但如果安装了第三方库时，即将<code>库文件/库文件的软链接</code>拷贝至<code>/lib64/</code>，将<code>头文件/头文件的软链接</code>拷贝至<code>/usr/inlude/</code>，使<code>gcc</code>能够自动搜索到路径，则编译时只需用<code>-l</code>指定<code>库名</code>即可</p>\n<h1 id=\"动态库-so\"><a href=\"#动态库-so\" class=\"headerlink\" title=\"动态库(.so)\"></a>动态库(.so)</h1><p>动态库的作用是使程序在<strong>运行时</strong>才去链接动态库的代码，多个程序共享使用库的代码，从而使编译出的可执行文件更小，节省磁盘空间。使用动态库时，动态库也要<strong>加载到内存中</strong></p>\n<h2 id=\"使用动态库底层的过程\"><a href=\"#使用动态库底层的过程\" class=\"headerlink\" title=\"使用动态库底层的过程\"></a>使用动态库底层的过程</h2><ol>\n<li>使用动态库编译可执行程序：一个与动态库链接的可执行文件仅仅包含它用到的函数入口地址的一个表，而不是外部函数所在目标文件的整个机器码</li>\n<li>动态链接: 在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的该动态库中复制(加载)到内存中，这个过程称为<code>动态链接</code>（dynamic linking）</li>\n<li>运行时调用动态库：调用来自动态库的函数时，实现函数功能的机器码将由动态库提供</li>\n</ol>\n<h2 id=\"生成和使用动态库\"><a href=\"#生成和使用动态库\" class=\"headerlink\" title=\"生成和使用动态库\"></a>生成和使用动态库</h2><p>这里使用<code>gcc</code>加<code>-fPIC</code>(产生位置无关码position independent code)和<code>-c</code>编译获得<code>.o</code>链接文件，再用<code>gcc</code>指令配合封装库文件,最后借助<code>makefile</code>简化文件目录的封装操作</p>\n<p>使用动态库：</p>\n<p><code>gcc</code>编译时使用第三方静态库必须包含以下选项：</p>\n<ul>\n<li><code>-I</code>指定头文件目录</li>\n<li><code>-L</code>指定库路径</li>\n<li><code>-l</code>指定库名（不加空格）,库名要把<code>文件名</code>前面去掉<code>lib</code>,后面去掉<code>.a</code>才是真正的库名</li>\n</ul>\n<p>否则编译器不知道头文件在哪，或者不知道链接哪个库</p>\n<p>特别的，当动静态库同时存在时，<code>gcc</code>默认优先使用动态库，除非加<code>-static</code>参数</p>\n<p><strong>但是</strong>，仅仅编译出可执行文件还不够，因为可执行文件还<strong>找不到</strong>动态库,所以我们还得告诉系统中的<code>加载器</code>，我们的动态库在哪,所以我们要把动态库安装到<code>/lib64/</code>,拷贝文件或建立软连接都可以（需要<code>sudo</code>或<code>root</code>权限）</p>\n<p>亦或者修改环境变量<code>LD_LIBRARY_PATH</code></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>文件代码同上，这里展示<code>makefile</code>文件</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lib = mymathlib.a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(lib)</span>:add.o sub.o </span><br><span class=\"line\">\tgcc -shared -o libmymath.so *.o </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">add.o:add.c </span></span><br><span class=\"line\">\tgcc -fPIC -c add.c -o add.o </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">sub.o:sub.c</span></span><br><span class=\"line\">\tgcc -fPIC -c sub.c -o sub.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:clean</span></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\trm -f *.o *.a </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:output </span></span><br><span class=\"line\"><span class=\"section\">output:</span></span><br><span class=\"line\">\tmkdir -p lib/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tmkdir -p lib/mymathlib</span><br><span class=\"line\">\tcp *.h lib/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tcp *.so lib/mymathlib</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"库搜索路径-1\"><a href=\"#库搜索路径-1\" class=\"headerlink\" title=\"库搜索路径\"></a>库搜索路径</h3><p>库的搜索会按照一定的顺序</p>\n<ol>\n<li>从左到右搜索-L指定的目录。</li>\n<li>由环境变量指定的目录 （<code>LIBRARY_PATH</code>）</li>\n<li>由系统指定的目录<ul>\n<li><code>/usr/lib</code></li>\n<li><code>/usr/local/lib</code></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>库文件命名规则<code>libxxx.a</code>&#x2F;<code>libxxx.so</code></p>\n<p>库文件名称-&gt;库名：去掉前缀<code>lib</code>,去掉后缀<code>.so</code>&#x2F;<code>.a</code></p>\n<p>使用动态库的可执行程序需要<code>安装动态库</code>或修改环境变量<code>LD_LIBRARY_PATH</code></p>\n"},{"title":"=C语言实践= 手把手教你做高端cmd简单扫雷","date":"2023-10-29T23:28:01.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-27-25.jpg","_content":"# 直接开始吧！\n\n## 多文件项目 #\n扫雷项目内容较多，需要调用的**函数**也较多，采用多文件的方式，可以使代码**条理清晰**，并且**易于管理和维护**。文件如下\n\n`game.h`用于宏定义，函数声明，引入头文件等\n\n`game.c`用于**函数的具体实现**\n\n`front.c`用于实现程序的**主干部分**\n\n`other.c`用于实现其他杂项函数，这里我用于实现`menu()`函数，~~主要内容太花了~~\n\n**注**  `.c`结尾的源文件均需加一句`#include \"game.h\"`\n\n## 头文件 #\n本次用到的头文件有`stdio.h` `stdlib.h` `time.h` `windows.h`\n和自己建的`game.h`\n\n**均在**文件`game.h`中`#include`\n\n\n## define宏定义 #\n为了便于**阅读和维护**代码,在`game.h`中的宏定义如下\n\n```C\n//显示行列\n#define ROW 9\n#define COL 9\n\n//实际数组大小\n#define ROWS ROW+2\n#define COLS COL + 2\n\n//地雷信息\n#define Bomb '*'\n#define Blank ' '\n\n//难度\n#define EZ_RANK 10\n#define HD_RANK 15\n\n//显示区\n#define UN '\u001f'\n#define Flag '!'\n\n```\n\n### 为什么实际数组要大一圈？ #\n\n如图，采用九宫格式访问时，大出来的一圈能有效**防止越界访问**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_11-23-51.jpg)\n\n\n## 构建main函数 #\n内容不多，主要是与菜单配合食用\n```C\nint main()\n{\n    //用time()获取时间戳，传给srand设置(随机值生成器的)种子\n\tsrand((unsigned int)time(NULL));\n\twhile (1)//循环游玩\n\t{\n\t\tint input = 0;\n\t\tMenu();//打印菜单\n\t\tprintf(\"请输入:>\");\n\t\tscanf(\"%d\", &input);//获取指令\n\t\tswitch (input)\n\t\t{\n\t\tcase 1:\n\t\t\tSleep(250);\n\t\t\tgame();//开始游戏,游戏具体在game()函数中实现\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"游戏结束\\n\");\n\t\t\treturn 0;//结束程序\n\t\tdefault:\n\t\t\tprintf(\"输入错误,请重试\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n\n## 打印菜单 #\n还在做静态菜单?~~弱爆了！~~来试试**动态出现**的菜单！\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/menu.gif)\n\n原理很**简单**，就是`打印空白数组`->`向内逐个替换两侧元素`->`清屏`->`再打印`->`再替换`->`...`\n\n*接下来的代码写在`other.c`中*\n\n```C\n//动态打印菜单\nvoid Menu()\n{\n\tchar cover[]  =  \"=======================\";\n\tchar option1[] = \"======  play (1) ======\";\n\tchar option2[] = \"======  exit (2) ======\"; \n\tchar empty_c[] = \"                       \";\n\tchar empty_1[] = \"                       \";\n\tchar empty_2[] = \"                       \";\n\n\tint left = 0;\n\tint right = 22;\n\twhile (left < right)\n\t{\n        //内容替换\n\t\tempty_c[left] = cover[left];\n\t\tempty_c[right] = cover[right];\n\t\tempty_1[left] = option1[left];\n\t\tempty_1[right] = option1[right];\n\t\tempty_2[left] = option2[left];\n\t\tempty_2[right] = option2[right];\n\n\t\tSleep(50);\n\t\tsystem(\"cls\");//清屏\n\t\tprintf(\"%s\\n%s\\n%s\\n%s\\n\",empty_c,empty_1,empty_2,empty_c);//打印菜单\n\n\t\tleft++;\n\t\tright--;\n\n\t}\n\tif (left == right)//打印最终菜单\n\t{\n\t\tSleep(50);\n\t\tsystem(\"cls\");\n\t\tempty_c[left] = cover[left];\n\t\tempty_1[left] = option1[left];\n\t\tempty_2[left] = option2[left];\n\t\tprintf(\"%s\\n%s\\n%s\\n%s\\n\", empty_c, empty_1, empty_2, empty_c);\n\t}\n}\n```\n\n## 实现game()函数 #\n*游戏的主要逻辑在game()中实现*\n\n```C\nvoid game()\n{\n\tchar mine[ROWS][COLS] = { 0 };\n\tchar show[ROWS][COLS] = { 0 };\n\tchar check[ROWS][COLS] = { 0 };\n\n    //初始化棋盘，其实就是用第二个形参填充二维数组\n\tInitBoard(mine, Blank);\n\tInitBoard(show, UN);\n\n\tInitCheck(check);//初始化check数组，逻辑与上面的初始化不同\n\n\tSetMine(mine,EZ_RANK);//设置地雷\n\tSetNum(mine);//设置雷周围的数字\n\n\t//DisplayBoard(mine); //用于开发时检查棋盘布局\n\t//DisplayBoard(show); //同上，不使用时注释掉\n\n    //以上是前期准备\n\tOPMine(mine,show, check);//开始排雷\n\n\tprintf(\"敲击enter以继续\\n\");\n\tgetchar();\n\tgetchar();\n\n}\n```\n\n### 为什么用三个二维数组？ #\n扫雷需要实现的功能较多，显然一个二维数组是不足以满足需求的，所以这里采用**三个**数组相叠加的方式，各自实现功能，并整合到一起。\n\n数组`mine`用于存放`雷`和雷周围的`计数数字`\n\n数组`show`用于储存给`用户`看到的内容，可以是`Unkown`,`空白`，`数字`，`旗帜`\n\n数组`check`用于记录棋盘的哪些地块被检查过了，防止后面用**递归**打开成片的空白区时，出现无限递归。\n\n**规定**：检查过的坐标储存`字符1`,没检查过的坐标储存`字符0`,大出来的**一圈**默认储存`字符1`\n\n## 实现游戏用的函数 #\n### 先看看有哪些要声明在`game.h`里的 #\n```C\nvoid Menu();//这个在上文实现过了\n\n//一下函数将在下文实现\n\n//初始化棋盘\nvoid InitBoard(char board[ROWS][COLS], char sign);\n//展示棋盘\nvoid DisplayBoard(char board[ROWS][COLS]);\n//初始化check棋盘\nvoid InitCheck(char check[ROWS][COLS]);\n//设置地雷/数字\nvoid SetMine(char board[ROWS][COLS],int rank);\nvoid SetNum(char board[ROWS][COLS]);\n//玩家排雷用的函数\nvoid OPMine(char mine[ROWS][COLS],char show[ROWS][COLS],char check[ROWS][COLS]);\n\n```\n*好，有了目标，接下来就去一个一个实现*\n\n**注**：以下代码均写在`game.c`文件里\n\n### InitBoard() #\n```C\nvoid InitBoard(char board[ROWS][COLS],char sign)\n{\n\tfor (int i = 0; i < ROWS; i++)\n\t{\n\t\tfor (int j = 0; j < COLS; j++)\n\t\t{\n\t\t\tboard[i][j] = sign;\n\t\t}\n\t}\n}\n```\n这里初始化的方式比较简单粗暴，就是用形参`sign`填充整个二维数组\n\n### DisplayBoard()函数 #\n这里采用的展示方式是带横纵坐标的\n```C\nvoid DisplayBoard(char board[ROWS][COLS])\n{\n\t//打印一排列坐标\n\tfor (int k = 0; k <= COL; k++)\n\t{\n\t\tprintf(\"%d \", k);\n\t}\n\tprintf(\"\\n\");\n\t//打印一排横分割线\n\tfor (int k = 0; k <= COL; k++)\n\t{\n\t\tprintf(\"--\");\n\t}\n\tprintf(\"\\n\");\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tprintf(\"%d|\", i);//这句话打印横排坐标和竖分割线\n\t\t//打印一排棋盘内容\n\t\tfor (int j = 1; j <= COL; j++)\n\t\t{\n\t\t\tprintf(\"%c \", board[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n```\n### InitCheck()函数 #\n这里复用了`InitBoard()`函数，是在其基础上增加了内容\n\n```C\nvoid InitCheck(char check[ROWS][COLS])\n{\n\tInitBoard(check, '0');\n\n\t//将边缘大出来的一圈改为'1'\n\tfor (int k = 0; k < COLS; k++)\n\t{\n\t\tcheck[0][k] = '1';\n\t\tcheck[ROWS - 1][k] = '1';\n\t}\n\tfor (int i = 1; i < ROWS -1; i++)\n\t{\n\t\tcheck[i][0] = '1';\n\t\tcheck[i][COLS - 1] = '1';\n\t}\n}\n\n```\n\n### SetMine()函数 #\n这里要使用`rand()`函数搭配`%`运算，来随机生成雷的坐标\n\n```C\nvoid SetMine(char board[ROWS][COLS],int rank)\n{\n\tint x = 0;\n\tint y = 0;\n\tfor (int count = 0;count < rank;)\n\t{\n\t\tx = rand() % ROW + 1;//x的范围是1~ROW\n\t\ty = rand() % COL + 1;\n\n\t\tif (board[x][y] == Blank)\n\t\t{\n\t\t\tcount++;\n\t\t\tboard[x][y] = Bomb;\n\t\t}\n\t}\n}\n\n```\n\n### SetNum()函数 #\n这里遍历一遍数组并采用`九宫格式`计数\n```C\n//该函数用于九宫格式计数，并在下个函数中被调用\nint CountMine(char board[ROWS][COLS], int x, int y)\n{\n\tint sum = 0;\n\tfor (int i = x - 1; i <= x + 1; i++)//上中下三行\n\t{\n\t\tfor (int j = y - 1; j <= y + 1; j++)//左中右三列\n\t\t{\n\t\t\tif (i != x || j != y)\n\t\t\t{\n\t\t\t\tif (board[i][j] == Bomb)\n\t\t\t\t{\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nvoid SetNum(char board[ROWS][COLS])\n{\n\t//遍历二维数组\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tfor (int j = 0; j <= COLS; j++)\n\t\t{\n\t\t\tif (board[i][j] == Blank)//仅操作非雷的格子\n\t\t\t{\n\t\t\t\tif (CountMine(board, i, j))\n\t\t\t\t{\n\t\t\t\t\tboard[i][j] = '0' + CountMine(board, i, j);//将返回的数字转化成字符\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### OPMine()函数--核心函数 #\n该函数为游戏的`核心函数`，有内置菜单，且多次调用其它函数，其中`函数`的具体实现见`四级标题`处\n\n```C\nvoid OPMine(char mine[ROWS][COLS],char show[ROWS][COLS],char check[ROWS][COLS])\n{\n\tint x = 0;//横纵坐标\n\tint y = 0;\n\tint flag = 1;//用于菜单选项\n\tint cont = 1;//cont为0时游戏结束\n\twhile (cont)\n\t{\n\t\tsystem(\"cls\");\n\t\tDisplayBoard(show);\n\t\tprintf(\"排雷(1)\\n插旗/拔旗(2)\\n请输入:>\");\n\t\tscanf(\"%d\", &flag);\n\t\t\n\t\tswitch (flag)\n\t\t{\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\t//排雷\n\t\t\t\tprintf(\"坐标格式,例>2(空格)2\\n\");\n\t\t\t\tprintf(\"请输入坐标:>\");\n\t\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\tif (show[x][y] == Flag)\n\t\t\t\t{\n\n\t\t\t\t\tprintf(\"此处为旗帜，不可排雷\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (show[x][y] != UN)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"不可重复排查\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//具体排雷操作\n\t\t\t\tcont = FindMine(mine,show,check, x, y);\n\t\t\t\tif (cont)\n\t\t\t\t{\n\t\t\t\t\t//检查是否赢得游戏\n\t\t\t\t\tcont = CheckWin(mine,show);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\t//插旗\n\t\t\t\tprintf(\"坐标格式,例>2(空格)2\\n\");\n\t\t\t\tprintf(\"请输入坐标:>\");\n\t\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\tSetFlag(show, x, y);//插旗函数\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n输入错误(恼\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n#### SetFlag()函数 #\n先捏软柿子，插旗函数比较简单\n\n```C\nvoid SetFlag(char show[ROWS][COLS], int x, int y)\n{\n\tif (show[x][y] == UN)//插旗\n\t{\n\t\tshow[x][y] = Flag;\n\t}\n\telse if (show[x][y] == Flag)//拔旗\n\t{\n\t\tshow[x][y] = UN;\n\t}\n\telse\n\t{\n\t\tprintf(\"报错\\n\");\n\t}\n}\n\n```\n#### ExpandBlank()函数 #\n这个函数用于打开成片的`空白区`,因为要从连着的空白连续开下去，所以要用到`函数递归`,此时`二维数组check`用于防止死递归\n\n**注**：这个函数一定要写在下一个函数(FindMine)前\n\n```C\nvoid ExpandBlank(char mine[ROWS][COLS], char show[ROWS][COLS], char check[ROWS][COLS],int x,int y)\n{\n\tshow[x][y] = mine[x][y];//将用户看到的格子改成mine中的格子,包括空白和数字格子\n\tcheck[x][y] = '1';//探测过的格子放`1`\n\tif (mine[x][y] == Blank)//仅空白格子会触发递归，数字格子不会\n\t{\n\t\t//九宫格式探测\n\t\tfor (int i = x - 1; i <= x + 1; i++)\n\t\t{\n\t\t\tfor (int j = y - 1; j <= y + 1; j++)\n\t\t\t{\n\t\t\t\tif (check[i][j] == '0' && mine[i][j] != Bomb && show[i][j] != Flag)\n\t\t\t\t{\n\t\t\t\t\t//含雷的格子不会执行ExpandBlank函数，就不会把雷放出来给用户看，但数字格子会\n\t\t\t\t\tExpandBlank(mine, show, check, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n#### FindMine()函数 #\n排雷用的函数\n\n```C\nint FindMine(char mine[ROWS][COLS], char show[ROW][COLS],char check[ROWS][COLS], int x, int y)\n{\n\tif (mine[x][y] == Bomb)\n\t{\n\t\tDisplayBoard(mine);\n\t\tprintf(\"炸死，游戏结束:)\\n\");\n\t\treturn 0;//返回0来结束游戏\n\t}\n\telse if (mine[x][y] != Blank)\n\t{\n\t\tshow[x][y] = mine[x][y];\n\t\treturn 1;//返回1来继续游戏\n\t}\n\telse\n\t{\n\t\t//这里有对上一个函数的调用\n\t\tExpandBlank(mine, show, check,x,y);\n\t\treturn 1;\n\t}\n}\n```\n#### CheckWin()函数 #\n用于检查玩家是否完全排雷，赢得游戏\n\n```C\nint CheckWin(char mine[ROWS][COLS], char show[ROWS][COLS])\n{\n\tint count = 0;//统计没排雷的格子数\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tfor (int j = 1; j <= COL; j++)\n\t\t{\n\t\t\tif (show[i][j] == UN || show[i][j] == Flag)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tif (count == EZ_RANK)//统计数==雷数\n\t{\n\t\tprintf(\"恭喜排雷成功!\\n\");\n\t\tDisplayBoard(mine);\n\t\treturn 0;//返回0，停止游戏\n\t}\n\telse\n\t{\n\t\treturn 1;\n\t}\n}\n```\n\n# 总结 #\n至此游戏所需的代码全部完成，已经可以编译出来玩耍啦。\n\n该实践项目主要练习了`二维数组`,`函数`,`函数递归`,`宏定义`等内容，代码量在入门学习中算较大的，本人在初次编写的时候也写出了不少bug，debug的过程是相当~~快乐~~\n\n建议多多画示意图，**耐下性子**写代码和debug,哪怕是实现这样的小游戏项目，也是颇有意义的","source":"_posts/mine-clearance.md","raw":"---\ntitle: =C语言实践= 手把手教你做高端cmd简单扫雷\ndate: 2023-10-30 07:28:01\ntags: C语言 实践项目\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-27-25.jpg\n---\n# 直接开始吧！\n\n## 多文件项目 #\n扫雷项目内容较多，需要调用的**函数**也较多，采用多文件的方式，可以使代码**条理清晰**，并且**易于管理和维护**。文件如下\n\n`game.h`用于宏定义，函数声明，引入头文件等\n\n`game.c`用于**函数的具体实现**\n\n`front.c`用于实现程序的**主干部分**\n\n`other.c`用于实现其他杂项函数，这里我用于实现`menu()`函数，~~主要内容太花了~~\n\n**注**  `.c`结尾的源文件均需加一句`#include \"game.h\"`\n\n## 头文件 #\n本次用到的头文件有`stdio.h` `stdlib.h` `time.h` `windows.h`\n和自己建的`game.h`\n\n**均在**文件`game.h`中`#include`\n\n\n## define宏定义 #\n为了便于**阅读和维护**代码,在`game.h`中的宏定义如下\n\n```C\n//显示行列\n#define ROW 9\n#define COL 9\n\n//实际数组大小\n#define ROWS ROW+2\n#define COLS COL + 2\n\n//地雷信息\n#define Bomb '*'\n#define Blank ' '\n\n//难度\n#define EZ_RANK 10\n#define HD_RANK 15\n\n//显示区\n#define UN '\u001f'\n#define Flag '!'\n\n```\n\n### 为什么实际数组要大一圈？ #\n\n如图，采用九宫格式访问时，大出来的一圈能有效**防止越界访问**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_11-23-51.jpg)\n\n\n## 构建main函数 #\n内容不多，主要是与菜单配合食用\n```C\nint main()\n{\n    //用time()获取时间戳，传给srand设置(随机值生成器的)种子\n\tsrand((unsigned int)time(NULL));\n\twhile (1)//循环游玩\n\t{\n\t\tint input = 0;\n\t\tMenu();//打印菜单\n\t\tprintf(\"请输入:>\");\n\t\tscanf(\"%d\", &input);//获取指令\n\t\tswitch (input)\n\t\t{\n\t\tcase 1:\n\t\t\tSleep(250);\n\t\t\tgame();//开始游戏,游戏具体在game()函数中实现\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"游戏结束\\n\");\n\t\t\treturn 0;//结束程序\n\t\tdefault:\n\t\t\tprintf(\"输入错误,请重试\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n\n## 打印菜单 #\n还在做静态菜单?~~弱爆了！~~来试试**动态出现**的菜单！\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/menu.gif)\n\n原理很**简单**，就是`打印空白数组`->`向内逐个替换两侧元素`->`清屏`->`再打印`->`再替换`->`...`\n\n*接下来的代码写在`other.c`中*\n\n```C\n//动态打印菜单\nvoid Menu()\n{\n\tchar cover[]  =  \"=======================\";\n\tchar option1[] = \"======  play (1) ======\";\n\tchar option2[] = \"======  exit (2) ======\"; \n\tchar empty_c[] = \"                       \";\n\tchar empty_1[] = \"                       \";\n\tchar empty_2[] = \"                       \";\n\n\tint left = 0;\n\tint right = 22;\n\twhile (left < right)\n\t{\n        //内容替换\n\t\tempty_c[left] = cover[left];\n\t\tempty_c[right] = cover[right];\n\t\tempty_1[left] = option1[left];\n\t\tempty_1[right] = option1[right];\n\t\tempty_2[left] = option2[left];\n\t\tempty_2[right] = option2[right];\n\n\t\tSleep(50);\n\t\tsystem(\"cls\");//清屏\n\t\tprintf(\"%s\\n%s\\n%s\\n%s\\n\",empty_c,empty_1,empty_2,empty_c);//打印菜单\n\n\t\tleft++;\n\t\tright--;\n\n\t}\n\tif (left == right)//打印最终菜单\n\t{\n\t\tSleep(50);\n\t\tsystem(\"cls\");\n\t\tempty_c[left] = cover[left];\n\t\tempty_1[left] = option1[left];\n\t\tempty_2[left] = option2[left];\n\t\tprintf(\"%s\\n%s\\n%s\\n%s\\n\", empty_c, empty_1, empty_2, empty_c);\n\t}\n}\n```\n\n## 实现game()函数 #\n*游戏的主要逻辑在game()中实现*\n\n```C\nvoid game()\n{\n\tchar mine[ROWS][COLS] = { 0 };\n\tchar show[ROWS][COLS] = { 0 };\n\tchar check[ROWS][COLS] = { 0 };\n\n    //初始化棋盘，其实就是用第二个形参填充二维数组\n\tInitBoard(mine, Blank);\n\tInitBoard(show, UN);\n\n\tInitCheck(check);//初始化check数组，逻辑与上面的初始化不同\n\n\tSetMine(mine,EZ_RANK);//设置地雷\n\tSetNum(mine);//设置雷周围的数字\n\n\t//DisplayBoard(mine); //用于开发时检查棋盘布局\n\t//DisplayBoard(show); //同上，不使用时注释掉\n\n    //以上是前期准备\n\tOPMine(mine,show, check);//开始排雷\n\n\tprintf(\"敲击enter以继续\\n\");\n\tgetchar();\n\tgetchar();\n\n}\n```\n\n### 为什么用三个二维数组？ #\n扫雷需要实现的功能较多，显然一个二维数组是不足以满足需求的，所以这里采用**三个**数组相叠加的方式，各自实现功能，并整合到一起。\n\n数组`mine`用于存放`雷`和雷周围的`计数数字`\n\n数组`show`用于储存给`用户`看到的内容，可以是`Unkown`,`空白`，`数字`，`旗帜`\n\n数组`check`用于记录棋盘的哪些地块被检查过了，防止后面用**递归**打开成片的空白区时，出现无限递归。\n\n**规定**：检查过的坐标储存`字符1`,没检查过的坐标储存`字符0`,大出来的**一圈**默认储存`字符1`\n\n## 实现游戏用的函数 #\n### 先看看有哪些要声明在`game.h`里的 #\n```C\nvoid Menu();//这个在上文实现过了\n\n//一下函数将在下文实现\n\n//初始化棋盘\nvoid InitBoard(char board[ROWS][COLS], char sign);\n//展示棋盘\nvoid DisplayBoard(char board[ROWS][COLS]);\n//初始化check棋盘\nvoid InitCheck(char check[ROWS][COLS]);\n//设置地雷/数字\nvoid SetMine(char board[ROWS][COLS],int rank);\nvoid SetNum(char board[ROWS][COLS]);\n//玩家排雷用的函数\nvoid OPMine(char mine[ROWS][COLS],char show[ROWS][COLS],char check[ROWS][COLS]);\n\n```\n*好，有了目标，接下来就去一个一个实现*\n\n**注**：以下代码均写在`game.c`文件里\n\n### InitBoard() #\n```C\nvoid InitBoard(char board[ROWS][COLS],char sign)\n{\n\tfor (int i = 0; i < ROWS; i++)\n\t{\n\t\tfor (int j = 0; j < COLS; j++)\n\t\t{\n\t\t\tboard[i][j] = sign;\n\t\t}\n\t}\n}\n```\n这里初始化的方式比较简单粗暴，就是用形参`sign`填充整个二维数组\n\n### DisplayBoard()函数 #\n这里采用的展示方式是带横纵坐标的\n```C\nvoid DisplayBoard(char board[ROWS][COLS])\n{\n\t//打印一排列坐标\n\tfor (int k = 0; k <= COL; k++)\n\t{\n\t\tprintf(\"%d \", k);\n\t}\n\tprintf(\"\\n\");\n\t//打印一排横分割线\n\tfor (int k = 0; k <= COL; k++)\n\t{\n\t\tprintf(\"--\");\n\t}\n\tprintf(\"\\n\");\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tprintf(\"%d|\", i);//这句话打印横排坐标和竖分割线\n\t\t//打印一排棋盘内容\n\t\tfor (int j = 1; j <= COL; j++)\n\t\t{\n\t\t\tprintf(\"%c \", board[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n```\n### InitCheck()函数 #\n这里复用了`InitBoard()`函数，是在其基础上增加了内容\n\n```C\nvoid InitCheck(char check[ROWS][COLS])\n{\n\tInitBoard(check, '0');\n\n\t//将边缘大出来的一圈改为'1'\n\tfor (int k = 0; k < COLS; k++)\n\t{\n\t\tcheck[0][k] = '1';\n\t\tcheck[ROWS - 1][k] = '1';\n\t}\n\tfor (int i = 1; i < ROWS -1; i++)\n\t{\n\t\tcheck[i][0] = '1';\n\t\tcheck[i][COLS - 1] = '1';\n\t}\n}\n\n```\n\n### SetMine()函数 #\n这里要使用`rand()`函数搭配`%`运算，来随机生成雷的坐标\n\n```C\nvoid SetMine(char board[ROWS][COLS],int rank)\n{\n\tint x = 0;\n\tint y = 0;\n\tfor (int count = 0;count < rank;)\n\t{\n\t\tx = rand() % ROW + 1;//x的范围是1~ROW\n\t\ty = rand() % COL + 1;\n\n\t\tif (board[x][y] == Blank)\n\t\t{\n\t\t\tcount++;\n\t\t\tboard[x][y] = Bomb;\n\t\t}\n\t}\n}\n\n```\n\n### SetNum()函数 #\n这里遍历一遍数组并采用`九宫格式`计数\n```C\n//该函数用于九宫格式计数，并在下个函数中被调用\nint CountMine(char board[ROWS][COLS], int x, int y)\n{\n\tint sum = 0;\n\tfor (int i = x - 1; i <= x + 1; i++)//上中下三行\n\t{\n\t\tfor (int j = y - 1; j <= y + 1; j++)//左中右三列\n\t\t{\n\t\t\tif (i != x || j != y)\n\t\t\t{\n\t\t\t\tif (board[i][j] == Bomb)\n\t\t\t\t{\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nvoid SetNum(char board[ROWS][COLS])\n{\n\t//遍历二维数组\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tfor (int j = 0; j <= COLS; j++)\n\t\t{\n\t\t\tif (board[i][j] == Blank)//仅操作非雷的格子\n\t\t\t{\n\t\t\t\tif (CountMine(board, i, j))\n\t\t\t\t{\n\t\t\t\t\tboard[i][j] = '0' + CountMine(board, i, j);//将返回的数字转化成字符\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### OPMine()函数--核心函数 #\n该函数为游戏的`核心函数`，有内置菜单，且多次调用其它函数，其中`函数`的具体实现见`四级标题`处\n\n```C\nvoid OPMine(char mine[ROWS][COLS],char show[ROWS][COLS],char check[ROWS][COLS])\n{\n\tint x = 0;//横纵坐标\n\tint y = 0;\n\tint flag = 1;//用于菜单选项\n\tint cont = 1;//cont为0时游戏结束\n\twhile (cont)\n\t{\n\t\tsystem(\"cls\");\n\t\tDisplayBoard(show);\n\t\tprintf(\"排雷(1)\\n插旗/拔旗(2)\\n请输入:>\");\n\t\tscanf(\"%d\", &flag);\n\t\t\n\t\tswitch (flag)\n\t\t{\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\t//排雷\n\t\t\t\tprintf(\"坐标格式,例>2(空格)2\\n\");\n\t\t\t\tprintf(\"请输入坐标:>\");\n\t\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\tif (show[x][y] == Flag)\n\t\t\t\t{\n\n\t\t\t\t\tprintf(\"此处为旗帜，不可排雷\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (show[x][y] != UN)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"不可重复排查\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//具体排雷操作\n\t\t\t\tcont = FindMine(mine,show,check, x, y);\n\t\t\t\tif (cont)\n\t\t\t\t{\n\t\t\t\t\t//检查是否赢得游戏\n\t\t\t\t\tcont = CheckWin(mine,show);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\t//插旗\n\t\t\t\tprintf(\"坐标格式,例>2(空格)2\\n\");\n\t\t\t\tprintf(\"请输入坐标:>\");\n\t\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\tSetFlag(show, x, y);//插旗函数\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n输入错误(恼\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n#### SetFlag()函数 #\n先捏软柿子，插旗函数比较简单\n\n```C\nvoid SetFlag(char show[ROWS][COLS], int x, int y)\n{\n\tif (show[x][y] == UN)//插旗\n\t{\n\t\tshow[x][y] = Flag;\n\t}\n\telse if (show[x][y] == Flag)//拔旗\n\t{\n\t\tshow[x][y] = UN;\n\t}\n\telse\n\t{\n\t\tprintf(\"报错\\n\");\n\t}\n}\n\n```\n#### ExpandBlank()函数 #\n这个函数用于打开成片的`空白区`,因为要从连着的空白连续开下去，所以要用到`函数递归`,此时`二维数组check`用于防止死递归\n\n**注**：这个函数一定要写在下一个函数(FindMine)前\n\n```C\nvoid ExpandBlank(char mine[ROWS][COLS], char show[ROWS][COLS], char check[ROWS][COLS],int x,int y)\n{\n\tshow[x][y] = mine[x][y];//将用户看到的格子改成mine中的格子,包括空白和数字格子\n\tcheck[x][y] = '1';//探测过的格子放`1`\n\tif (mine[x][y] == Blank)//仅空白格子会触发递归，数字格子不会\n\t{\n\t\t//九宫格式探测\n\t\tfor (int i = x - 1; i <= x + 1; i++)\n\t\t{\n\t\t\tfor (int j = y - 1; j <= y + 1; j++)\n\t\t\t{\n\t\t\t\tif (check[i][j] == '0' && mine[i][j] != Bomb && show[i][j] != Flag)\n\t\t\t\t{\n\t\t\t\t\t//含雷的格子不会执行ExpandBlank函数，就不会把雷放出来给用户看，但数字格子会\n\t\t\t\t\tExpandBlank(mine, show, check, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n#### FindMine()函数 #\n排雷用的函数\n\n```C\nint FindMine(char mine[ROWS][COLS], char show[ROW][COLS],char check[ROWS][COLS], int x, int y)\n{\n\tif (mine[x][y] == Bomb)\n\t{\n\t\tDisplayBoard(mine);\n\t\tprintf(\"炸死，游戏结束:)\\n\");\n\t\treturn 0;//返回0来结束游戏\n\t}\n\telse if (mine[x][y] != Blank)\n\t{\n\t\tshow[x][y] = mine[x][y];\n\t\treturn 1;//返回1来继续游戏\n\t}\n\telse\n\t{\n\t\t//这里有对上一个函数的调用\n\t\tExpandBlank(mine, show, check,x,y);\n\t\treturn 1;\n\t}\n}\n```\n#### CheckWin()函数 #\n用于检查玩家是否完全排雷，赢得游戏\n\n```C\nint CheckWin(char mine[ROWS][COLS], char show[ROWS][COLS])\n{\n\tint count = 0;//统计没排雷的格子数\n\tfor (int i = 1; i <= ROW; i++)\n\t{\n\t\tfor (int j = 1; j <= COL; j++)\n\t\t{\n\t\t\tif (show[i][j] == UN || show[i][j] == Flag)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tif (count == EZ_RANK)//统计数==雷数\n\t{\n\t\tprintf(\"恭喜排雷成功!\\n\");\n\t\tDisplayBoard(mine);\n\t\treturn 0;//返回0，停止游戏\n\t}\n\telse\n\t{\n\t\treturn 1;\n\t}\n}\n```\n\n# 总结 #\n至此游戏所需的代码全部完成，已经可以编译出来玩耍啦。\n\n该实践项目主要练习了`二维数组`,`函数`,`函数递归`,`宏定义`等内容，代码量在入门学习中算较大的，本人在初次编写的时候也写出了不少bug，debug的过程是相当~~快乐~~\n\n建议多多画示意图，**耐下性子**写代码和debug,哪怕是实现这样的小游戏项目，也是颇有意义的","slug":"mine-clearance","published":1,"updated":"2024-05-14T02:21:08.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08g00154sp5ckt95hzd","content":"<h1 id=\"直接开始吧！\"><a href=\"#直接开始吧！\" class=\"headerlink\" title=\"直接开始吧！\"></a>直接开始吧！</h1><h2 id=\"多文件项目\"><a href=\"#多文件项目\" class=\"headerlink\" title=\"多文件项目\"></a>多文件项目</h2><p>扫雷项目内容较多，需要调用的<strong>函数</strong>也较多，采用多文件的方式，可以使代码<strong>条理清晰</strong>，并且<strong>易于管理和维护</strong>。文件如下</p>\n<p><code>game.h</code>用于宏定义，函数声明，引入头文件等</p>\n<p><code>game.c</code>用于<strong>函数的具体实现</strong></p>\n<p><code>front.c</code>用于实现程序的<strong>主干部分</strong></p>\n<p><code>other.c</code>用于实现其他杂项函数，这里我用于实现<code>menu()</code>函数，<del>主要内容太花了</del></p>\n<p><strong>注</strong>  <code>.c</code>结尾的源文件均需加一句<code>#include &quot;game.h&quot;</code></p>\n<h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><p>本次用到的头文件有<code>stdio.h</code> <code>stdlib.h</code> <code>time.h</code> <code>windows.h</code><br>和自己建的<code>game.h</code></p>\n<p><strong>均在</strong>文件<code>game.h</code>中<code>#include</code></p>\n<h2 id=\"define宏定义\"><a href=\"#define宏定义\" class=\"headerlink\" title=\"define宏定义\"></a>define宏定义</h2><p>为了便于<strong>阅读和维护</strong>代码,在<code>game.h</code>中的宏定义如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//显示行列</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ROW 9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COL 9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实际数组大小</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ROWS ROW+2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COLS COL + 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//地雷信息</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Bomb <span class=\"string\">&#x27;*&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Blank <span class=\"string\">&#x27; &#x27;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//难度</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EZ_RANK 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HD_RANK 15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示区</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UN <span class=\"string\">&#x27;\u001f&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Flag <span class=\"string\">&#x27;!&#x27;</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么实际数组要大一圈？\"><a href=\"#为什么实际数组要大一圈？\" class=\"headerlink\" title=\"为什么实际数组要大一圈？\"></a>为什么实际数组要大一圈？</h3><p>如图，采用九宫格式访问时，大出来的一圈能有效<strong>防止越界访问</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_11-23-51.jpg\"></p>\n<h2 id=\"构建main函数\"><a href=\"#构建main函数\" class=\"headerlink\" title=\"构建main函数\"></a>构建main函数</h2><p>内容不多，主要是与菜单配合食用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//用time()获取时间戳，传给srand设置(随机值生成器的)种子</span></span><br><span class=\"line\">\tsrand((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)<span class=\"comment\">//循环游玩</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> input = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tMenu();<span class=\"comment\">//打印菜单</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;input);<span class=\"comment\">//获取指令</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (input)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\tSleep(<span class=\"number\">250</span>);</span><br><span class=\"line\">\t\t\tgame();<span class=\"comment\">//开始游戏,游戏具体在game()函数中实现</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;游戏结束\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//结束程序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;输入错误,请重试\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"打印菜单\"><a href=\"#打印菜单\" class=\"headerlink\" title=\"打印菜单\"></a>打印菜单</h2><p>还在做静态菜单?<del>弱爆了！</del>来试试<strong>动态出现</strong>的菜单！</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/menu.gif\"></p>\n<p>原理很<strong>简单</strong>，就是<code>打印空白数组</code>-&gt;<code>向内逐个替换两侧元素</code>-&gt;<code>清屏</code>-&gt;<code>再打印</code>-&gt;<code>再替换</code>-&gt;<code>...</code></p>\n<p><em>接下来的代码写在<code>other.c</code>中</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态打印菜单</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Menu</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> cover[]  =  <span class=\"string\">&quot;=======================&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> option1[] = <span class=\"string\">&quot;======  play (1) ======&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> option2[] = <span class=\"string\">&quot;======  exit (2) ======&quot;</span>; </span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_c[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_1[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_2[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> right = <span class=\"number\">22</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"comment\">//内容替换</span></span><br><span class=\"line\">\t\tempty_c[left] = cover[left];</span><br><span class=\"line\">\t\tempty_c[right] = cover[right];</span><br><span class=\"line\">\t\tempty_1[left] = option1[left];</span><br><span class=\"line\">\t\tempty_1[right] = option1[right];</span><br><span class=\"line\">\t\tempty_2[left] = option2[left];</span><br><span class=\"line\">\t\tempty_2[right] = option2[right];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);<span class=\"comment\">//清屏</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n%s\\n%s\\n%s\\n&quot;</span>,empty_c,empty_1,empty_2,empty_c);<span class=\"comment\">//打印菜单</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tleft++;</span><br><span class=\"line\">\t\tright--;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left == right)<span class=\"comment\">//打印最终菜单</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\tempty_c[left] = cover[left];</span><br><span class=\"line\">\t\tempty_1[left] = option1[left];</span><br><span class=\"line\">\t\tempty_2[left] = option2[left];</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n%s\\n%s\\n%s\\n&quot;</span>, empty_c, empty_1, empty_2, empty_c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现game-函数\"><a href=\"#实现game-函数\" class=\"headerlink\" title=\"实现game()函数\"></a>实现game()函数</h2><p><em>游戏的主要逻辑在game()中实现</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">game</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> mine[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">char</span> show[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">char</span> check[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化棋盘，其实就是用第二个形参填充二维数组</span></span><br><span class=\"line\">\tInitBoard(mine, Blank);</span><br><span class=\"line\">\tInitBoard(show, UN);</span><br><span class=\"line\"></span><br><span class=\"line\">\tInitCheck(check);<span class=\"comment\">//初始化check数组，逻辑与上面的初始化不同</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tSetMine(mine,EZ_RANK);<span class=\"comment\">//设置地雷</span></span><br><span class=\"line\">\tSetNum(mine);<span class=\"comment\">//设置雷周围的数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//DisplayBoard(mine); //用于开发时检查棋盘布局</span></span><br><span class=\"line\">\t<span class=\"comment\">//DisplayBoard(show); //同上，不使用时注释掉</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//以上是前期准备</span></span><br><span class=\"line\">\tOPMine(mine,show, check);<span class=\"comment\">//开始排雷</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;敲击enter以继续\\n&quot;</span>);</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么用三个二维数组？\"><a href=\"#为什么用三个二维数组？\" class=\"headerlink\" title=\"为什么用三个二维数组？\"></a>为什么用三个二维数组？</h3><p>扫雷需要实现的功能较多，显然一个二维数组是不足以满足需求的，所以这里采用<strong>三个</strong>数组相叠加的方式，各自实现功能，并整合到一起。</p>\n<p>数组<code>mine</code>用于存放<code>雷</code>和雷周围的<code>计数数字</code></p>\n<p>数组<code>show</code>用于储存给<code>用户</code>看到的内容，可以是<code>Unkown</code>,<code>空白</code>，<code>数字</code>，<code>旗帜</code></p>\n<p>数组<code>check</code>用于记录棋盘的哪些地块被检查过了，防止后面用<strong>递归</strong>打开成片的空白区时，出现无限递归。</p>\n<p><strong>规定</strong>：检查过的坐标储存<code>字符1</code>,没检查过的坐标储存<code>字符0</code>,大出来的<strong>一圈</strong>默认储存<code>字符1</code></p>\n<h2 id=\"实现游戏用的函数\"><a href=\"#实现游戏用的函数\" class=\"headerlink\" title=\"实现游戏用的函数\"></a>实现游戏用的函数</h2><h3 id=\"先看看有哪些要声明在game-h里的\"><a href=\"#先看看有哪些要声明在game-h里的\" class=\"headerlink\" title=\"先看看有哪些要声明在game.h里的\"></a>先看看有哪些要声明在<code>game.h</code>里的</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Menu</span><span class=\"params\">()</span>;<span class=\"comment\">//这个在上文实现过了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一下函数将在下文实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS], <span class=\"type\">char</span> sign)</span>;</span><br><span class=\"line\"><span class=\"comment\">//展示棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DisplayBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//初始化check棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitCheck</span><span class=\"params\">(<span class=\"type\">char</span> check[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//设置地雷/数字</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">int</span> rank)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetNum</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//玩家排雷用的函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">OPMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS],<span class=\"type\">char</span> show[ROWS][COLS],<span class=\"type\">char</span> check[ROWS][COLS])</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em>好，有了目标，接下来就去一个一个实现</em></p>\n<p><strong>注</strong>：以下代码均写在<code>game.c</code>文件里</p>\n<h3 id=\"InitBoard\"><a href=\"#InitBoard\" class=\"headerlink\" title=\"InitBoard()\"></a>InitBoard()</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">char</span> sign)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; ROWS; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; COLS; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tboard[i][j] = sign;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里初始化的方式比较简单粗暴，就是用形参<code>sign</code>填充整个二维数组</p>\n<h3 id=\"DisplayBoard-函数\"><a href=\"#DisplayBoard-函数\" class=\"headerlink\" title=\"DisplayBoard()函数\"></a>DisplayBoard()函数</h3><p>这里采用的展示方式是带横纵坐标的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DisplayBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//打印一排列坐标</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= COL; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, k);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//打印一排横分割线</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= COL; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;--&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d|&quot;</span>, i);<span class=\"comment\">//这句话打印横排坐标和竖分割线</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//打印一排棋盘内容</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= COL; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c &quot;</span>, board[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"InitCheck-函数\"><a href=\"#InitCheck-函数\" class=\"headerlink\" title=\"InitCheck()函数\"></a>InitCheck()函数</h3><p>这里复用了<code>InitBoard()</code>函数，是在其基础上增加了内容</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitCheck</span><span class=\"params\">(<span class=\"type\">char</span> check[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tInitBoard(check, <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将边缘大出来的一圈改为&#x27;1&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; COLS; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcheck[<span class=\"number\">0</span>][k] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t\tcheck[ROWS - <span class=\"number\">1</span>][k] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; ROWS <span class=\"number\">-1</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcheck[i][<span class=\"number\">0</span>] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t\tcheck[i][COLS - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SetMine-函数\"><a href=\"#SetMine-函数\" class=\"headerlink\" title=\"SetMine()函数\"></a>SetMine()函数</h3><p>这里要使用<code>rand()</code>函数搭配<code>%</code>运算，来随机生成雷的坐标</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">int</span> rank)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> count = <span class=\"number\">0</span>;count &lt; rank;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx = rand() % ROW + <span class=\"number\">1</span>;<span class=\"comment\">//x的范围是1~ROW</span></span><br><span class=\"line\">\t\ty = rand() % COL + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (board[x][y] == Blank)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcount++;</span><br><span class=\"line\">\t\t\tboard[x][y] = Bomb;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SetNum-函数\"><a href=\"#SetNum-函数\" class=\"headerlink\" title=\"SetNum()函数\"></a>SetNum()函数</h3><p>这里遍历一遍数组并采用<code>九宫格式</code>计数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//该函数用于九宫格式计数，并在下个函数中被调用</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">CountMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = x - <span class=\"number\">1</span>; i &lt;= x + <span class=\"number\">1</span>; i++)<span class=\"comment\">//上中下三行</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = y - <span class=\"number\">1</span>; j &lt;= y + <span class=\"number\">1</span>; j++)<span class=\"comment\">//左中右三列</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i != x || j != y)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (board[i][j] == Bomb)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tsum++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetNum</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//遍历二维数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= COLS; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (board[i][j] == Blank)<span class=\"comment\">//仅操作非雷的格子</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (CountMine(board, i, j))</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tboard[i][j] = <span class=\"string\">&#x27;0&#x27;</span> + CountMine(board, i, j);<span class=\"comment\">//将返回的数字转化成字符</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"OPMine-函数–核心函数\"><a href=\"#OPMine-函数–核心函数\" class=\"headerlink\" title=\"OPMine()函数–核心函数\"></a>OPMine()函数–核心函数</h3><p>该函数为游戏的<code>核心函数</code>，有内置菜单，且多次调用其它函数，其中<code>函数</code>的具体实现见<code>四级标题</code>处</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">OPMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS],<span class=\"type\">char</span> show[ROWS][COLS],<span class=\"type\">char</span> check[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>;<span class=\"comment\">//横纵坐标</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">1</span>;<span class=\"comment\">//用于菜单选项</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> cont = <span class=\"number\">1</span>;<span class=\"comment\">//cont为0时游戏结束</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cont)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\tDisplayBoard(show);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;排雷(1)\\n插旗/拔旗(2)\\n请输入:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;flag);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (flag)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//排雷</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;坐标格式,例&gt;2(空格)2\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (show[x][y] == Flag)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;此处为旗帜，不可排雷\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (show[x][y] != UN)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;不可重复排查\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//具体排雷操作</span></span><br><span class=\"line\">\t\t\t\tcont = FindMine(mine,show,check, x, y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cont)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//检查是否赢得游戏</span></span><br><span class=\"line\">\t\t\t\t\tcont = CheckWin(mine,show);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//插旗</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;坐标格式,例&gt;2(空格)2\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\t\t\tSetFlag(show, x, y);<span class=\"comment\">//插旗函数</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n输入错误(恼\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SetFlag-函数\"><a href=\"#SetFlag-函数\" class=\"headerlink\" title=\"SetFlag()函数\"></a>SetFlag()函数</h4><p>先捏软柿子，插旗函数比较简单</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetFlag</span><span class=\"params\">(<span class=\"type\">char</span> show[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (show[x][y] == UN)<span class=\"comment\">//插旗</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = Flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (show[x][y] == Flag)<span class=\"comment\">//拔旗</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = UN;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;报错\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"ExpandBlank-函数\"><a href=\"#ExpandBlank-函数\" class=\"headerlink\" title=\"ExpandBlank()函数\"></a>ExpandBlank()函数</h4><p>这个函数用于打开成片的<code>空白区</code>,因为要从连着的空白连续开下去，所以要用到<code>函数递归</code>,此时<code>二维数组check</code>用于防止死递归</p>\n<p><strong>注</strong>：这个函数一定要写在下一个函数(FindMine)前</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ExpandBlank</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROWS][COLS], <span class=\"type\">char</span> check[ROWS][COLS],<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tshow[x][y] = mine[x][y];<span class=\"comment\">//将用户看到的格子改成mine中的格子,包括空白和数字格子</span></span><br><span class=\"line\">\tcheck[x][y] = <span class=\"string\">&#x27;1&#x27;</span>;<span class=\"comment\">//探测过的格子放`1`</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mine[x][y] == Blank)<span class=\"comment\">//仅空白格子会触发递归，数字格子不会</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//九宫格式探测</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = x - <span class=\"number\">1</span>; i &lt;= x + <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = y - <span class=\"number\">1</span>; j &lt;= y + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (check[i][j] == <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; mine[i][j] != Bomb &amp;&amp; show[i][j] != Flag)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//含雷的格子不会执行ExpandBlank函数，就不会把雷放出来给用户看，但数字格子会</span></span><br><span class=\"line\">\t\t\t\t\tExpandBlank(mine, show, check, i, j);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"FindMine-函数\"><a href=\"#FindMine-函数\" class=\"headerlink\" title=\"FindMine()函数\"></a>FindMine()函数</h4><p>排雷用的函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">FindMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROW][COLS],<span class=\"type\">char</span> check[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mine[x][y] == Bomb)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tDisplayBoard(mine);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;炸死，游戏结束:)\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//返回0来结束游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mine[x][y] != Blank)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = mine[x][y];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;<span class=\"comment\">//返回1来继续游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里有对上一个函数的调用</span></span><br><span class=\"line\">\t\tExpandBlank(mine, show, check,x,y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CheckWin-函数\"><a href=\"#CheckWin-函数\" class=\"headerlink\" title=\"CheckWin()函数\"></a>CheckWin()函数</h4><p>用于检查玩家是否完全排雷，赢得游戏</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">CheckWin</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//统计没排雷的格子数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= COL; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (show[i][j] == UN || show[i][j] == Flag)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcount++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (count == EZ_RANK)<span class=\"comment\">//统计数==雷数</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;恭喜排雷成功!\\n&quot;</span>);</span><br><span class=\"line\">\t\tDisplayBoard(mine);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//返回0，停止游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>至此游戏所需的代码全部完成，已经可以编译出来玩耍啦。</p>\n<p>该实践项目主要练习了<code>二维数组</code>,<code>函数</code>,<code>函数递归</code>,<code>宏定义</code>等内容，代码量在入门学习中算较大的，本人在初次编写的时候也写出了不少bug，debug的过程是相当<del>快乐</del></p>\n<p>建议多多画示意图，<strong>耐下性子</strong>写代码和debug,哪怕是实现这样的小游戏项目，也是颇有意义的</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"直接开始吧！\"><a href=\"#直接开始吧！\" class=\"headerlink\" title=\"直接开始吧！\"></a>直接开始吧！</h1><h2 id=\"多文件项目\"><a href=\"#多文件项目\" class=\"headerlink\" title=\"多文件项目\"></a>多文件项目</h2><p>扫雷项目内容较多，需要调用的<strong>函数</strong>也较多，采用多文件的方式，可以使代码<strong>条理清晰</strong>，并且<strong>易于管理和维护</strong>。文件如下</p>\n<p><code>game.h</code>用于宏定义，函数声明，引入头文件等</p>\n<p><code>game.c</code>用于<strong>函数的具体实现</strong></p>\n<p><code>front.c</code>用于实现程序的<strong>主干部分</strong></p>\n<p><code>other.c</code>用于实现其他杂项函数，这里我用于实现<code>menu()</code>函数，<del>主要内容太花了</del></p>\n<p><strong>注</strong>  <code>.c</code>结尾的源文件均需加一句<code>#include &quot;game.h&quot;</code></p>\n<h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><p>本次用到的头文件有<code>stdio.h</code> <code>stdlib.h</code> <code>time.h</code> <code>windows.h</code><br>和自己建的<code>game.h</code></p>\n<p><strong>均在</strong>文件<code>game.h</code>中<code>#include</code></p>\n<h2 id=\"define宏定义\"><a href=\"#define宏定义\" class=\"headerlink\" title=\"define宏定义\"></a>define宏定义</h2><p>为了便于<strong>阅读和维护</strong>代码,在<code>game.h</code>中的宏定义如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//显示行列</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ROW 9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COL 9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实际数组大小</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ROWS ROW+2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COLS COL + 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//地雷信息</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Bomb <span class=\"string\">&#x27;*&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Blank <span class=\"string\">&#x27; &#x27;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//难度</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EZ_RANK 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HD_RANK 15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示区</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UN <span class=\"string\">&#x27;\u001f&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> Flag <span class=\"string\">&#x27;!&#x27;</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么实际数组要大一圈？\"><a href=\"#为什么实际数组要大一圈？\" class=\"headerlink\" title=\"为什么实际数组要大一圈？\"></a>为什么实际数组要大一圈？</h3><p>如图，采用九宫格式访问时，大出来的一圈能有效<strong>防止越界访问</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_11-23-51.jpg\"></p>\n<h2 id=\"构建main函数\"><a href=\"#构建main函数\" class=\"headerlink\" title=\"构建main函数\"></a>构建main函数</h2><p>内容不多，主要是与菜单配合食用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//用time()获取时间戳，传给srand设置(随机值生成器的)种子</span></span><br><span class=\"line\">\tsrand((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)<span class=\"comment\">//循环游玩</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> input = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tMenu();<span class=\"comment\">//打印菜单</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;input);<span class=\"comment\">//获取指令</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (input)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\tSleep(<span class=\"number\">250</span>);</span><br><span class=\"line\">\t\t\tgame();<span class=\"comment\">//开始游戏,游戏具体在game()函数中实现</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;游戏结束\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//结束程序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;输入错误,请重试\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"打印菜单\"><a href=\"#打印菜单\" class=\"headerlink\" title=\"打印菜单\"></a>打印菜单</h2><p>还在做静态菜单?<del>弱爆了！</del>来试试<strong>动态出现</strong>的菜单！</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/menu.gif\"></p>\n<p>原理很<strong>简单</strong>，就是<code>打印空白数组</code>-&gt;<code>向内逐个替换两侧元素</code>-&gt;<code>清屏</code>-&gt;<code>再打印</code>-&gt;<code>再替换</code>-&gt;<code>...</code></p>\n<p><em>接下来的代码写在<code>other.c</code>中</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态打印菜单</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Menu</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> cover[]  =  <span class=\"string\">&quot;=======================&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> option1[] = <span class=\"string\">&quot;======  play (1) ======&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> option2[] = <span class=\"string\">&quot;======  exit (2) ======&quot;</span>; </span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_c[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_1[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> empty_2[] = <span class=\"string\">&quot;                       &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> right = <span class=\"number\">22</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"comment\">//内容替换</span></span><br><span class=\"line\">\t\tempty_c[left] = cover[left];</span><br><span class=\"line\">\t\tempty_c[right] = cover[right];</span><br><span class=\"line\">\t\tempty_1[left] = option1[left];</span><br><span class=\"line\">\t\tempty_1[right] = option1[right];</span><br><span class=\"line\">\t\tempty_2[left] = option2[left];</span><br><span class=\"line\">\t\tempty_2[right] = option2[right];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);<span class=\"comment\">//清屏</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n%s\\n%s\\n%s\\n&quot;</span>,empty_c,empty_1,empty_2,empty_c);<span class=\"comment\">//打印菜单</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tleft++;</span><br><span class=\"line\">\t\tright--;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left == right)<span class=\"comment\">//打印最终菜单</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\tempty_c[left] = cover[left];</span><br><span class=\"line\">\t\tempty_1[left] = option1[left];</span><br><span class=\"line\">\t\tempty_2[left] = option2[left];</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n%s\\n%s\\n%s\\n&quot;</span>, empty_c, empty_1, empty_2, empty_c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现game-函数\"><a href=\"#实现game-函数\" class=\"headerlink\" title=\"实现game()函数\"></a>实现game()函数</h2><p><em>游戏的主要逻辑在game()中实现</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">game</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> mine[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">char</span> show[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">char</span> check[ROWS][COLS] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化棋盘，其实就是用第二个形参填充二维数组</span></span><br><span class=\"line\">\tInitBoard(mine, Blank);</span><br><span class=\"line\">\tInitBoard(show, UN);</span><br><span class=\"line\"></span><br><span class=\"line\">\tInitCheck(check);<span class=\"comment\">//初始化check数组，逻辑与上面的初始化不同</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tSetMine(mine,EZ_RANK);<span class=\"comment\">//设置地雷</span></span><br><span class=\"line\">\tSetNum(mine);<span class=\"comment\">//设置雷周围的数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//DisplayBoard(mine); //用于开发时检查棋盘布局</span></span><br><span class=\"line\">\t<span class=\"comment\">//DisplayBoard(show); //同上，不使用时注释掉</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//以上是前期准备</span></span><br><span class=\"line\">\tOPMine(mine,show, check);<span class=\"comment\">//开始排雷</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;敲击enter以继续\\n&quot;</span>);</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么用三个二维数组？\"><a href=\"#为什么用三个二维数组？\" class=\"headerlink\" title=\"为什么用三个二维数组？\"></a>为什么用三个二维数组？</h3><p>扫雷需要实现的功能较多，显然一个二维数组是不足以满足需求的，所以这里采用<strong>三个</strong>数组相叠加的方式，各自实现功能，并整合到一起。</p>\n<p>数组<code>mine</code>用于存放<code>雷</code>和雷周围的<code>计数数字</code></p>\n<p>数组<code>show</code>用于储存给<code>用户</code>看到的内容，可以是<code>Unkown</code>,<code>空白</code>，<code>数字</code>，<code>旗帜</code></p>\n<p>数组<code>check</code>用于记录棋盘的哪些地块被检查过了，防止后面用<strong>递归</strong>打开成片的空白区时，出现无限递归。</p>\n<p><strong>规定</strong>：检查过的坐标储存<code>字符1</code>,没检查过的坐标储存<code>字符0</code>,大出来的<strong>一圈</strong>默认储存<code>字符1</code></p>\n<h2 id=\"实现游戏用的函数\"><a href=\"#实现游戏用的函数\" class=\"headerlink\" title=\"实现游戏用的函数\"></a>实现游戏用的函数</h2><h3 id=\"先看看有哪些要声明在game-h里的\"><a href=\"#先看看有哪些要声明在game-h里的\" class=\"headerlink\" title=\"先看看有哪些要声明在game.h里的\"></a>先看看有哪些要声明在<code>game.h</code>里的</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Menu</span><span class=\"params\">()</span>;<span class=\"comment\">//这个在上文实现过了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一下函数将在下文实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS], <span class=\"type\">char</span> sign)</span>;</span><br><span class=\"line\"><span class=\"comment\">//展示棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DisplayBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//初始化check棋盘</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitCheck</span><span class=\"params\">(<span class=\"type\">char</span> check[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//设置地雷/数字</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">int</span> rank)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetNum</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span>;</span><br><span class=\"line\"><span class=\"comment\">//玩家排雷用的函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">OPMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS],<span class=\"type\">char</span> show[ROWS][COLS],<span class=\"type\">char</span> check[ROWS][COLS])</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em>好，有了目标，接下来就去一个一个实现</em></p>\n<p><strong>注</strong>：以下代码均写在<code>game.c</code>文件里</p>\n<h3 id=\"InitBoard\"><a href=\"#InitBoard\" class=\"headerlink\" title=\"InitBoard()\"></a>InitBoard()</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">char</span> sign)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; ROWS; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; COLS; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tboard[i][j] = sign;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里初始化的方式比较简单粗暴，就是用形参<code>sign</code>填充整个二维数组</p>\n<h3 id=\"DisplayBoard-函数\"><a href=\"#DisplayBoard-函数\" class=\"headerlink\" title=\"DisplayBoard()函数\"></a>DisplayBoard()函数</h3><p>这里采用的展示方式是带横纵坐标的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DisplayBoard</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//打印一排列坐标</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= COL; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, k);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//打印一排横分割线</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= COL; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;--&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d|&quot;</span>, i);<span class=\"comment\">//这句话打印横排坐标和竖分割线</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//打印一排棋盘内容</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= COL; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c &quot;</span>, board[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"InitCheck-函数\"><a href=\"#InitCheck-函数\" class=\"headerlink\" title=\"InitCheck()函数\"></a>InitCheck()函数</h3><p>这里复用了<code>InitBoard()</code>函数，是在其基础上增加了内容</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitCheck</span><span class=\"params\">(<span class=\"type\">char</span> check[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tInitBoard(check, <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将边缘大出来的一圈改为&#x27;1&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; COLS; k++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcheck[<span class=\"number\">0</span>][k] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t\tcheck[ROWS - <span class=\"number\">1</span>][k] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; ROWS <span class=\"number\">-1</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcheck[i][<span class=\"number\">0</span>] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t\tcheck[i][COLS - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SetMine-函数\"><a href=\"#SetMine-函数\" class=\"headerlink\" title=\"SetMine()函数\"></a>SetMine()函数</h3><p>这里要使用<code>rand()</code>函数搭配<code>%</code>运算，来随机生成雷的坐标</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS],<span class=\"type\">int</span> rank)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> count = <span class=\"number\">0</span>;count &lt; rank;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tx = rand() % ROW + <span class=\"number\">1</span>;<span class=\"comment\">//x的范围是1~ROW</span></span><br><span class=\"line\">\t\ty = rand() % COL + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (board[x][y] == Blank)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcount++;</span><br><span class=\"line\">\t\t\tboard[x][y] = Bomb;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SetNum-函数\"><a href=\"#SetNum-函数\" class=\"headerlink\" title=\"SetNum()函数\"></a>SetNum()函数</h3><p>这里遍历一遍数组并采用<code>九宫格式</code>计数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//该函数用于九宫格式计数，并在下个函数中被调用</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">CountMine</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = x - <span class=\"number\">1</span>; i &lt;= x + <span class=\"number\">1</span>; i++)<span class=\"comment\">//上中下三行</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = y - <span class=\"number\">1</span>; j &lt;= y + <span class=\"number\">1</span>; j++)<span class=\"comment\">//左中右三列</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i != x || j != y)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (board[i][j] == Bomb)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tsum++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetNum</span><span class=\"params\">(<span class=\"type\">char</span> board[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//遍历二维数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= COLS; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (board[i][j] == Blank)<span class=\"comment\">//仅操作非雷的格子</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (CountMine(board, i, j))</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tboard[i][j] = <span class=\"string\">&#x27;0&#x27;</span> + CountMine(board, i, j);<span class=\"comment\">//将返回的数字转化成字符</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"OPMine-函数–核心函数\"><a href=\"#OPMine-函数–核心函数\" class=\"headerlink\" title=\"OPMine()函数–核心函数\"></a>OPMine()函数–核心函数</h3><p>该函数为游戏的<code>核心函数</code>，有内置菜单，且多次调用其它函数，其中<code>函数</code>的具体实现见<code>四级标题</code>处</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">OPMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS],<span class=\"type\">char</span> show[ROWS][COLS],<span class=\"type\">char</span> check[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>;<span class=\"comment\">//横纵坐标</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">1</span>;<span class=\"comment\">//用于菜单选项</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> cont = <span class=\"number\">1</span>;<span class=\"comment\">//cont为0时游戏结束</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cont)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\tDisplayBoard(show);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;排雷(1)\\n插旗/拔旗(2)\\n请输入:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;flag);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (flag)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//排雷</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;坐标格式,例&gt;2(空格)2\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (show[x][y] == Flag)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;此处为旗帜，不可排雷\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (show[x][y] != UN)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;不可重复排查\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//具体排雷操作</span></span><br><span class=\"line\">\t\t\t\tcont = FindMine(mine,show,check, x, y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cont)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//检查是否赢得游戏</span></span><br><span class=\"line\">\t\t\t\t\tcont = CheckWin(mine,show);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//插旗</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;坐标格式,例&gt;2(空格)2\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入坐标:&gt;&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\t\t\tSetFlag(show, x, y);<span class=\"comment\">//插旗函数</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tsystem(<span class=\"string\">&quot;cls&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n输入错误(恼\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SetFlag-函数\"><a href=\"#SetFlag-函数\" class=\"headerlink\" title=\"SetFlag()函数\"></a>SetFlag()函数</h4><p>先捏软柿子，插旗函数比较简单</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SetFlag</span><span class=\"params\">(<span class=\"type\">char</span> show[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (show[x][y] == UN)<span class=\"comment\">//插旗</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = Flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (show[x][y] == Flag)<span class=\"comment\">//拔旗</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = UN;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;报错\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"ExpandBlank-函数\"><a href=\"#ExpandBlank-函数\" class=\"headerlink\" title=\"ExpandBlank()函数\"></a>ExpandBlank()函数</h4><p>这个函数用于打开成片的<code>空白区</code>,因为要从连着的空白连续开下去，所以要用到<code>函数递归</code>,此时<code>二维数组check</code>用于防止死递归</p>\n<p><strong>注</strong>：这个函数一定要写在下一个函数(FindMine)前</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ExpandBlank</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROWS][COLS], <span class=\"type\">char</span> check[ROWS][COLS],<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tshow[x][y] = mine[x][y];<span class=\"comment\">//将用户看到的格子改成mine中的格子,包括空白和数字格子</span></span><br><span class=\"line\">\tcheck[x][y] = <span class=\"string\">&#x27;1&#x27;</span>;<span class=\"comment\">//探测过的格子放`1`</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mine[x][y] == Blank)<span class=\"comment\">//仅空白格子会触发递归，数字格子不会</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//九宫格式探测</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = x - <span class=\"number\">1</span>; i &lt;= x + <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = y - <span class=\"number\">1</span>; j &lt;= y + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (check[i][j] == <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; mine[i][j] != Bomb &amp;&amp; show[i][j] != Flag)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//含雷的格子不会执行ExpandBlank函数，就不会把雷放出来给用户看，但数字格子会</span></span><br><span class=\"line\">\t\t\t\t\tExpandBlank(mine, show, check, i, j);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"FindMine-函数\"><a href=\"#FindMine-函数\" class=\"headerlink\" title=\"FindMine()函数\"></a>FindMine()函数</h4><p>排雷用的函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">FindMine</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROW][COLS],<span class=\"type\">char</span> check[ROWS][COLS], <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mine[x][y] == Bomb)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tDisplayBoard(mine);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;炸死，游戏结束:)\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//返回0来结束游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mine[x][y] != Blank)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshow[x][y] = mine[x][y];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;<span class=\"comment\">//返回1来继续游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里有对上一个函数的调用</span></span><br><span class=\"line\">\t\tExpandBlank(mine, show, check,x,y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CheckWin-函数\"><a href=\"#CheckWin-函数\" class=\"headerlink\" title=\"CheckWin()函数\"></a>CheckWin()函数</h4><p>用于检查玩家是否完全排雷，赢得游戏</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">CheckWin</span><span class=\"params\">(<span class=\"type\">char</span> mine[ROWS][COLS], <span class=\"type\">char</span> show[ROWS][COLS])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//统计没排雷的格子数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= ROW; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= COL; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (show[i][j] == UN || show[i][j] == Flag)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcount++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (count == EZ_RANK)<span class=\"comment\">//统计数==雷数</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;恭喜排雷成功!\\n&quot;</span>);</span><br><span class=\"line\">\t\tDisplayBoard(mine);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//返回0，停止游戏</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>至此游戏所需的代码全部完成，已经可以编译出来玩耍啦。</p>\n<p>该实践项目主要练习了<code>二维数组</code>,<code>函数</code>,<code>函数递归</code>,<code>宏定义</code>等内容，代码量在入门学习中算较大的，本人在初次编写的时候也写出了不少bug，debug的过程是相当<del>快乐</del></p>\n<p>建议多多画示意图，<strong>耐下性子</strong>写代码和debug,哪怕是实现这样的小游戏项目，也是颇有意义的</p>\n"},{"title":"Linux日志系统","date":"2024-08-13T10:17:50.000Z","_content":"# 引入\n首先看看AI对日志系统的重要性是怎么解释的\n\n>日志系统在软件开发和运维中扮演着至关重要的角色，主要体现在以下几个方面：\n>\n>`问题排查和调试`：日志记录了系统运行过程中的重要信息，包括错误信息、异常堆栈、接口调用信息等。开发人员可以通过分析日志快速定位问题，减少排查时间，提高开发效率。\n>\n>`性能监控`：通过记录应用程序的性能指标（如响应时间、请求吞吐量等），开发团队可以监控系统的健康状态，发现性能瓶颈并进行优化。\n>\n>`安全审计`：日志可以记录用户的操作和系统事件，为后期的安全审计提供依据。一旦发生安全事件，通过分析日志可以追踪到攻击来源和攻击方式。\n>\n>`用户行为分析`：通过对日志进行分析，开发团队可以了解用户的使用习惯和需求，这有助于改进产品功能和用户体验。\n>\n>`合规要求`：在许多行业中，日志记录是合规的要求之一。维护完整的日志记录可以帮助企业满足法律法规和行业标准。\n>\n>`系统健康监控`：通过实时监控日志，可以及时发现系统异常，进行预警和自动化处理，从而提高系统的可用性和稳定性。\n>\n>`故障恢复`：在系统出现故障时，日志记录可以帮助开发和运维人员还原问题发生前的状态，从而有助于快速恢复系统。\n>\n>总之，良好的日志系统能够帮助开发和运维团队提高效率、强化安全、提升用户体验，并确保系统的稳定性和可靠性。因此，在系统设计时，合理规划和实施日志记录机制是非常必要的。\n\n因此出于学习实践的目的，和方便日后自己打印日志，我们可以先自己用C++封装一个简单的日志系统\n\n# 基本功能要求\n+ 打印日志等级\n+ 打印日志日期和时间\n+ 格式化打印日志消息\n+ 可选择输出到显示器，还是单个文件，还是按等级分文件\n\n功能缺陷：没有完善清理日志文件的功能，因此不能投入到真正的项目中，否则时间长了可能造成日志文件过大的问题\n\n# 头文件 和 宏定义\n本次要用到的头文件依然较多,而用到的宏定义有文件名和缓冲区大小，因为有时日志要打印到文件中，所以要准备一个文件名\n```C++\n#include <iostream>\n#include <stdarg.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#define LOG_FILE \"log.txt\"//日志文件名\n\n#define SIZE 1024  //缓冲区大小\n```\n\n# 枚举\n日志系统中要用到较多选项，这里使用枚举最为直观和简洁\n\n```C++\nenum OUT_MODE//输出模式\n{\n    Screen,  //输出到显示器\n    OneFile, //输出到一个文件\n    MultiFile//按等级输出到多个文件\n};\n\nenum LEVEL //日志等级\n{\n    Info,    //一般信息\n    Debug,   //debug日志\n    Warning, //警告\n    Error,   //错误\n    Fatal    //失败\n};\n```\n# 类的基本构成\n这里我们封装一个`Log`类,\n+ 储存一个私有成员变量`_om`(output mode) \n+ 重载`operator()()`使其有仿函数的功能\n+ 声明`enable`函数用于切换输出模式\n+ 声明`levelToString`将`LEVEL`的枚举类型转换为`string`类\n+ 声明`printLog`用于调用不同接口打印日志\n+ 声明`printMultiFile`用于向指定`文件名`打印日志\n+ 声明`printMultiFile`用于向指定`日志等级`的文件打印日志\n\n# 功能突破\n有个别功能由于平时不常用/没见过，需要特别的突破一下\n\n## 打印日期和时间\n我们都知道在`<time.h>`中提供了`time()`函数获取时间戳，但如何方便地获取年月日和时分秒呢？\n\n这里要引出里面的另一个接口`localtime()`了\n\n`struct tm *localtime(const time_t *timep);`\n\n可以看到，给它一个时间戳的指针，它就会返回一个`struct tm`结构体的指针，我们再来看看结构体里有什么\n\n```C\nstruct tm {\n    int tm_sec;         /* seconds */           //秒\n    int tm_min;         /* minutes */           //分钟\n    int tm_hour;        /* hours */             //小时\n    int tm_mday;        /* day of the month */  //一个月的中的第几天\n    int tm_mon;         /* month */             //月份(从0月开始)\n    int tm_year;        /* year */              //年份,从1900年为0年开始\n    int tm_wday;        /* day of the week */   //一周的第几天\n    int tm_yday;        /* day in the year */   //一年中的第几天\n    int tm_isdst;       /* daylight saving time */\n};\n```\n可以看到，借助`localtime()`函数可以方便地获取详细时间,简化了代码\n\n```C++\nchar leftBuffer[SIZE] = {0};\ntime_t t = time(nullptr);\nstruct tm *ctime = localtime(&t);//获取时间\n\nsnprintf(leftBuffer,sizeof(leftBuffer),\"[%s][%d-%d-%d %d:%d:%d]\",levelToString(level).c_str(),1900+ctime->tm_year,1+ctime->tm_mon,ctime->tm_mday,\n    ctime->tm_hour,ctime->tm_min,ctime->tm_sec);\n```\n*levelToString()函数后文再介绍*\n\n## 可变参数列表 与 格式化字符串\n为了能让函数能够接受`格式化字符串`来方便打印日志，重载`operator()()`时要仿照`printf()`的函数声明\n\n`void operator()(LEVEL level,const char *format,...)`\n\n如上，最后一个参数用`...`\n\n那么如何取出来呢？这里就要用到头文件`stdarg.h`的接口了\n\n首先用`va_list`声明一个变量`s`，\n\n然后用`va_start()`初始化`s`,因为函数的形参是从右往左实例化的，，所以还要传`...`左边第一个参数给它定位,例如`va_start(s,format)`\n\n使用`va_start()`初始化后便可以调用其它函数了\n\n而在使用完的最后，还要调用`va_end()`来结束对变量`s`的使用,例如`va_end(s)`\n\n### va_arg()\n`type va_arg(va_list ap, type);`\n\n这个`宏函数`可以传类型作为参数，并从参数列表取出对应的参数\n\n以写一个n个数相加的函数为例\n```C++\n#include <stdarg.h>\n#include <iostream>\n\nusing namespace std;\n\nint nsum(int n,...)//参数n表示n个数相加\n{\n    va_list ap;\n    va_start(ap,n);\n\n    int sum = 0;\n    while(n--)\n    {\n        int num = va_arg(ap,int);//每次获取一个int 参数\n        sum+=num;\n    }\n    va_end(ap);\n    return sum;\n}\n\nint main()\n{\n    cout<<nsum(5,1,2,3,4,5)<<endl;//输出5个数相加\n    return 0;\n}\n```\n可以看到我们用`va_arg`实现了任意参数数量的整型相加\n\n### vsnprintf()\n`int vsnprintf(char *str, size_t size, const char *format, va_list ap);`\n\n+ `str`:存放字符串的缓冲区指针\n+ `size`:缓冲区大小\n+ `format`原格式字符串\n+ `ap`: va_list类型的变量\n\n有了这个函数就可以方便地把可变参数列表打印到字符串里了\n\n例如在本文的`Log`类中,\n\n```C++\n//将内容输出到缓冲区中\nva_list s;\nva_start(s,format);\nchar rightBuffer[SIZE];\nvsnprintf(rightBuffer,sizeof(rightBuffer),format,s);\nva_end(s);\n```\n\n# 完整代码\n剩下的部分就比较简单了，也就不分开讲解了，直接放出完整代码\n\n```C++\n#pragma once\n\n#include <iostream>\n#include <stdarg.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#define LOG_FILE \"log.txt\"//日志文件名\n\n#define SIZE 1024  //缓冲区大小\n\nenum OUT_MODE//输出模式\n{\n    Screen,  //输出到显示器\n    OneFile, //输出到一个文件\n    MultiFile//按等级输出到多个文件\n};\n\nenum LEVEL //日志等级\n{\n    Info,    //一般信息\n    Debug,   //debug日志\n    Warning, //警告\n    Error,   //错误\n    Fatal    //失败\n};\n\nclass Log\n{\npublic:\n    Log(OUT_MODE om = Screen):_om(om)//默认构造函数\n    {}\n    ~Log(){}//没有特殊用处\n    void enable(OUT_MODE om)//启用指定的输出模式\n    {\n        _om = om;\n    }\n    std::string levelToString(LEVEL level)\n    {\n        switch (level)\n        {\n            case Info:return \"Info\";\n            case Debug:return \"Debug\";\n            case Warning:return \"Warning\";\n            case Error:return \"Error\";\n            case Fatal:return \"Fatal\";\n        default: return \"None\";\n        }\n    }\n\n\n    void operator()(LEVEL level,const char *format,...)\n    {\n        char leftBuffer[SIZE] = {0};\n        time_t t = time(nullptr);\n        struct tm *ctime = localtime(&t);//获取时间\n\n        snprintf(leftBuffer,sizeof(leftBuffer),\"[%s][%d-%d-%d %d:%d:%d]\",levelToString(level).c_str(),1900+ctime->tm_year,1+ctime->tm_mon,ctime->tm_mday,\n            ctime->tm_hour,ctime->tm_min,ctime->tm_sec);\n\n        va_list s;\n        va_start(s,format);\n        char rightBuffer[SIZE];\n        vsnprintf(rightBuffer,sizeof(rightBuffer),format,s);\n        va_end(s);\n\n        char logtxt[SIZE*2];\n        snprintf(logtxt,sizeof(logtxt),\"%s %s\",leftBuffer,rightBuffer);\n        printLog(level,logtxt);;//打印日志\n    }\n\n    void printLog(LEVEL level, const std::string& logtxt)\n    {\n        switch(_om)\n        {\n            case Screen:std::cout<<logtxt<<std::endl;break;\n            case OneFile:printOneFile(LOG_FILE,logtxt);break;\n            case MultiFile:printMultiFile(level,logtxt);break;\n            default: break;\n        }\n    }\n\n    void printOneFile(const std::string& logname,const std::string& logtxt)//传两个参数用于代码复用\n    {\n        int fd = open(logname.c_str(), O_WRONLY|O_CREAT|O_APPEND,0666);\n        if(fd<0) return;\n        write(fd,logtxt.c_str(),logtxt.size());\n        close(fd);\n    }\n\n    void printMultiFile(LEVEL level,const std::string logtxt)\n    {\n        std::string filename = LOG_FILE;//构建文件名\n        filename+= \".\";\n        filename += levelToString(level);\n        printOneFile(filename,logtxt);//复用代码\n    }\nprivate:\n    OUT_MODE _om = Screen;\n};\n```\n","source":"_posts/logSystem.md","raw":"---\ntitle: Linux日志系统\ndate: 2024-08-13 18:17:50\ntags: Linux C++ 日志\n---\n# 引入\n首先看看AI对日志系统的重要性是怎么解释的\n\n>日志系统在软件开发和运维中扮演着至关重要的角色，主要体现在以下几个方面：\n>\n>`问题排查和调试`：日志记录了系统运行过程中的重要信息，包括错误信息、异常堆栈、接口调用信息等。开发人员可以通过分析日志快速定位问题，减少排查时间，提高开发效率。\n>\n>`性能监控`：通过记录应用程序的性能指标（如响应时间、请求吞吐量等），开发团队可以监控系统的健康状态，发现性能瓶颈并进行优化。\n>\n>`安全审计`：日志可以记录用户的操作和系统事件，为后期的安全审计提供依据。一旦发生安全事件，通过分析日志可以追踪到攻击来源和攻击方式。\n>\n>`用户行为分析`：通过对日志进行分析，开发团队可以了解用户的使用习惯和需求，这有助于改进产品功能和用户体验。\n>\n>`合规要求`：在许多行业中，日志记录是合规的要求之一。维护完整的日志记录可以帮助企业满足法律法规和行业标准。\n>\n>`系统健康监控`：通过实时监控日志，可以及时发现系统异常，进行预警和自动化处理，从而提高系统的可用性和稳定性。\n>\n>`故障恢复`：在系统出现故障时，日志记录可以帮助开发和运维人员还原问题发生前的状态，从而有助于快速恢复系统。\n>\n>总之，良好的日志系统能够帮助开发和运维团队提高效率、强化安全、提升用户体验，并确保系统的稳定性和可靠性。因此，在系统设计时，合理规划和实施日志记录机制是非常必要的。\n\n因此出于学习实践的目的，和方便日后自己打印日志，我们可以先自己用C++封装一个简单的日志系统\n\n# 基本功能要求\n+ 打印日志等级\n+ 打印日志日期和时间\n+ 格式化打印日志消息\n+ 可选择输出到显示器，还是单个文件，还是按等级分文件\n\n功能缺陷：没有完善清理日志文件的功能，因此不能投入到真正的项目中，否则时间长了可能造成日志文件过大的问题\n\n# 头文件 和 宏定义\n本次要用到的头文件依然较多,而用到的宏定义有文件名和缓冲区大小，因为有时日志要打印到文件中，所以要准备一个文件名\n```C++\n#include <iostream>\n#include <stdarg.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#define LOG_FILE \"log.txt\"//日志文件名\n\n#define SIZE 1024  //缓冲区大小\n```\n\n# 枚举\n日志系统中要用到较多选项，这里使用枚举最为直观和简洁\n\n```C++\nenum OUT_MODE//输出模式\n{\n    Screen,  //输出到显示器\n    OneFile, //输出到一个文件\n    MultiFile//按等级输出到多个文件\n};\n\nenum LEVEL //日志等级\n{\n    Info,    //一般信息\n    Debug,   //debug日志\n    Warning, //警告\n    Error,   //错误\n    Fatal    //失败\n};\n```\n# 类的基本构成\n这里我们封装一个`Log`类,\n+ 储存一个私有成员变量`_om`(output mode) \n+ 重载`operator()()`使其有仿函数的功能\n+ 声明`enable`函数用于切换输出模式\n+ 声明`levelToString`将`LEVEL`的枚举类型转换为`string`类\n+ 声明`printLog`用于调用不同接口打印日志\n+ 声明`printMultiFile`用于向指定`文件名`打印日志\n+ 声明`printMultiFile`用于向指定`日志等级`的文件打印日志\n\n# 功能突破\n有个别功能由于平时不常用/没见过，需要特别的突破一下\n\n## 打印日期和时间\n我们都知道在`<time.h>`中提供了`time()`函数获取时间戳，但如何方便地获取年月日和时分秒呢？\n\n这里要引出里面的另一个接口`localtime()`了\n\n`struct tm *localtime(const time_t *timep);`\n\n可以看到，给它一个时间戳的指针，它就会返回一个`struct tm`结构体的指针，我们再来看看结构体里有什么\n\n```C\nstruct tm {\n    int tm_sec;         /* seconds */           //秒\n    int tm_min;         /* minutes */           //分钟\n    int tm_hour;        /* hours */             //小时\n    int tm_mday;        /* day of the month */  //一个月的中的第几天\n    int tm_mon;         /* month */             //月份(从0月开始)\n    int tm_year;        /* year */              //年份,从1900年为0年开始\n    int tm_wday;        /* day of the week */   //一周的第几天\n    int tm_yday;        /* day in the year */   //一年中的第几天\n    int tm_isdst;       /* daylight saving time */\n};\n```\n可以看到，借助`localtime()`函数可以方便地获取详细时间,简化了代码\n\n```C++\nchar leftBuffer[SIZE] = {0};\ntime_t t = time(nullptr);\nstruct tm *ctime = localtime(&t);//获取时间\n\nsnprintf(leftBuffer,sizeof(leftBuffer),\"[%s][%d-%d-%d %d:%d:%d]\",levelToString(level).c_str(),1900+ctime->tm_year,1+ctime->tm_mon,ctime->tm_mday,\n    ctime->tm_hour,ctime->tm_min,ctime->tm_sec);\n```\n*levelToString()函数后文再介绍*\n\n## 可变参数列表 与 格式化字符串\n为了能让函数能够接受`格式化字符串`来方便打印日志，重载`operator()()`时要仿照`printf()`的函数声明\n\n`void operator()(LEVEL level,const char *format,...)`\n\n如上，最后一个参数用`...`\n\n那么如何取出来呢？这里就要用到头文件`stdarg.h`的接口了\n\n首先用`va_list`声明一个变量`s`，\n\n然后用`va_start()`初始化`s`,因为函数的形参是从右往左实例化的，，所以还要传`...`左边第一个参数给它定位,例如`va_start(s,format)`\n\n使用`va_start()`初始化后便可以调用其它函数了\n\n而在使用完的最后，还要调用`va_end()`来结束对变量`s`的使用,例如`va_end(s)`\n\n### va_arg()\n`type va_arg(va_list ap, type);`\n\n这个`宏函数`可以传类型作为参数，并从参数列表取出对应的参数\n\n以写一个n个数相加的函数为例\n```C++\n#include <stdarg.h>\n#include <iostream>\n\nusing namespace std;\n\nint nsum(int n,...)//参数n表示n个数相加\n{\n    va_list ap;\n    va_start(ap,n);\n\n    int sum = 0;\n    while(n--)\n    {\n        int num = va_arg(ap,int);//每次获取一个int 参数\n        sum+=num;\n    }\n    va_end(ap);\n    return sum;\n}\n\nint main()\n{\n    cout<<nsum(5,1,2,3,4,5)<<endl;//输出5个数相加\n    return 0;\n}\n```\n可以看到我们用`va_arg`实现了任意参数数量的整型相加\n\n### vsnprintf()\n`int vsnprintf(char *str, size_t size, const char *format, va_list ap);`\n\n+ `str`:存放字符串的缓冲区指针\n+ `size`:缓冲区大小\n+ `format`原格式字符串\n+ `ap`: va_list类型的变量\n\n有了这个函数就可以方便地把可变参数列表打印到字符串里了\n\n例如在本文的`Log`类中,\n\n```C++\n//将内容输出到缓冲区中\nva_list s;\nva_start(s,format);\nchar rightBuffer[SIZE];\nvsnprintf(rightBuffer,sizeof(rightBuffer),format,s);\nva_end(s);\n```\n\n# 完整代码\n剩下的部分就比较简单了，也就不分开讲解了，直接放出完整代码\n\n```C++\n#pragma once\n\n#include <iostream>\n#include <stdarg.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#define LOG_FILE \"log.txt\"//日志文件名\n\n#define SIZE 1024  //缓冲区大小\n\nenum OUT_MODE//输出模式\n{\n    Screen,  //输出到显示器\n    OneFile, //输出到一个文件\n    MultiFile//按等级输出到多个文件\n};\n\nenum LEVEL //日志等级\n{\n    Info,    //一般信息\n    Debug,   //debug日志\n    Warning, //警告\n    Error,   //错误\n    Fatal    //失败\n};\n\nclass Log\n{\npublic:\n    Log(OUT_MODE om = Screen):_om(om)//默认构造函数\n    {}\n    ~Log(){}//没有特殊用处\n    void enable(OUT_MODE om)//启用指定的输出模式\n    {\n        _om = om;\n    }\n    std::string levelToString(LEVEL level)\n    {\n        switch (level)\n        {\n            case Info:return \"Info\";\n            case Debug:return \"Debug\";\n            case Warning:return \"Warning\";\n            case Error:return \"Error\";\n            case Fatal:return \"Fatal\";\n        default: return \"None\";\n        }\n    }\n\n\n    void operator()(LEVEL level,const char *format,...)\n    {\n        char leftBuffer[SIZE] = {0};\n        time_t t = time(nullptr);\n        struct tm *ctime = localtime(&t);//获取时间\n\n        snprintf(leftBuffer,sizeof(leftBuffer),\"[%s][%d-%d-%d %d:%d:%d]\",levelToString(level).c_str(),1900+ctime->tm_year,1+ctime->tm_mon,ctime->tm_mday,\n            ctime->tm_hour,ctime->tm_min,ctime->tm_sec);\n\n        va_list s;\n        va_start(s,format);\n        char rightBuffer[SIZE];\n        vsnprintf(rightBuffer,sizeof(rightBuffer),format,s);\n        va_end(s);\n\n        char logtxt[SIZE*2];\n        snprintf(logtxt,sizeof(logtxt),\"%s %s\",leftBuffer,rightBuffer);\n        printLog(level,logtxt);;//打印日志\n    }\n\n    void printLog(LEVEL level, const std::string& logtxt)\n    {\n        switch(_om)\n        {\n            case Screen:std::cout<<logtxt<<std::endl;break;\n            case OneFile:printOneFile(LOG_FILE,logtxt);break;\n            case MultiFile:printMultiFile(level,logtxt);break;\n            default: break;\n        }\n    }\n\n    void printOneFile(const std::string& logname,const std::string& logtxt)//传两个参数用于代码复用\n    {\n        int fd = open(logname.c_str(), O_WRONLY|O_CREAT|O_APPEND,0666);\n        if(fd<0) return;\n        write(fd,logtxt.c_str(),logtxt.size());\n        close(fd);\n    }\n\n    void printMultiFile(LEVEL level,const std::string logtxt)\n    {\n        std::string filename = LOG_FILE;//构建文件名\n        filename+= \".\";\n        filename += levelToString(level);\n        printOneFile(filename,logtxt);//复用代码\n    }\nprivate:\n    OUT_MODE _om = Screen;\n};\n```\n","slug":"logSystem","published":1,"updated":"2024-08-14T08:31:23.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08h00174sp5dx794z57","content":"<h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><p>首先看看AI对日志系统的重要性是怎么解释的</p>\n<blockquote>\n<p>日志系统在软件开发和运维中扮演着至关重要的角色，主要体现在以下几个方面：</p>\n<p><code>问题排查和调试</code>：日志记录了系统运行过程中的重要信息，包括错误信息、异常堆栈、接口调用信息等。开发人员可以通过分析日志快速定位问题，减少排查时间，提高开发效率。</p>\n<p><code>性能监控</code>：通过记录应用程序的性能指标（如响应时间、请求吞吐量等），开发团队可以监控系统的健康状态，发现性能瓶颈并进行优化。</p>\n<p><code>安全审计</code>：日志可以记录用户的操作和系统事件，为后期的安全审计提供依据。一旦发生安全事件，通过分析日志可以追踪到攻击来源和攻击方式。</p>\n<p><code>用户行为分析</code>：通过对日志进行分析，开发团队可以了解用户的使用习惯和需求，这有助于改进产品功能和用户体验。</p>\n<p><code>合规要求</code>：在许多行业中，日志记录是合规的要求之一。维护完整的日志记录可以帮助企业满足法律法规和行业标准。</p>\n<p><code>系统健康监控</code>：通过实时监控日志，可以及时发现系统异常，进行预警和自动化处理，从而提高系统的可用性和稳定性。</p>\n<p><code>故障恢复</code>：在系统出现故障时，日志记录可以帮助开发和运维人员还原问题发生前的状态，从而有助于快速恢复系统。</p>\n<p>总之，良好的日志系统能够帮助开发和运维团队提高效率、强化安全、提升用户体验，并确保系统的稳定性和可靠性。因此，在系统设计时，合理规划和实施日志记录机制是非常必要的。</p>\n</blockquote>\n<p>因此出于学习实践的目的，和方便日后自己打印日志，我们可以先自己用C++封装一个简单的日志系统</p>\n<h1 id=\"基本功能要求\"><a href=\"#基本功能要求\" class=\"headerlink\" title=\"基本功能要求\"></a>基本功能要求</h1><ul>\n<li>打印日志等级</li>\n<li>打印日志日期和时间</li>\n<li>格式化打印日志消息</li>\n<li>可选择输出到显示器，还是单个文件，还是按等级分文件</li>\n</ul>\n<p>功能缺陷：没有完善清理日志文件的功能，因此不能投入到真正的项目中，否则时间长了可能造成日志文件过大的问题</p>\n<h1 id=\"头文件-和-宏定义\"><a href=\"#头文件-和-宏定义\" class=\"headerlink\" title=\"头文件 和 宏定义\"></a>头文件 和 宏定义</h1><p>本次要用到的头文件依然较多,而用到的宏定义有文件名和缓冲区大小，因为有时日志要打印到文件中，所以要准备一个文件名</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdarg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_FILE <span class=\"string\">&quot;log.txt&quot;</span><span class=\"comment\">//日志文件名</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE 1024  <span class=\"comment\">//缓冲区大小</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><p>日志系统中要用到较多选项，这里使用枚举最为直观和简洁</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">OUT_MODE</span><span class=\"comment\">//输出模式</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Screen,  <span class=\"comment\">//输出到显示器</span></span><br><span class=\"line\">    OneFile, <span class=\"comment\">//输出到一个文件</span></span><br><span class=\"line\">    MultiFile<span class=\"comment\">//按等级输出到多个文件</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">LEVEL</span> <span class=\"comment\">//日志等级</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Info,    <span class=\"comment\">//一般信息</span></span><br><span class=\"line\">    Debug,   <span class=\"comment\">//debug日志</span></span><br><span class=\"line\">    Warning, <span class=\"comment\">//警告</span></span><br><span class=\"line\">    Error,   <span class=\"comment\">//错误</span></span><br><span class=\"line\">    Fatal    <span class=\"comment\">//失败</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"类的基本构成\"><a href=\"#类的基本构成\" class=\"headerlink\" title=\"类的基本构成\"></a>类的基本构成</h1><p>这里我们封装一个<code>Log</code>类,</p>\n<ul>\n<li>储存一个私有成员变量<code>_om</code>(output mode) </li>\n<li>重载<code>operator()()</code>使其有仿函数的功能</li>\n<li>声明<code>enable</code>函数用于切换输出模式</li>\n<li>声明<code>levelToString</code>将<code>LEVEL</code>的枚举类型转换为<code>string</code>类</li>\n<li>声明<code>printLog</code>用于调用不同接口打印日志</li>\n<li>声明<code>printMultiFile</code>用于向指定<code>文件名</code>打印日志</li>\n<li>声明<code>printMultiFile</code>用于向指定<code>日志等级</code>的文件打印日志</li>\n</ul>\n<h1 id=\"功能突破\"><a href=\"#功能突破\" class=\"headerlink\" title=\"功能突破\"></a>功能突破</h1><p>有个别功能由于平时不常用&#x2F;没见过，需要特别的突破一下</p>\n<h2 id=\"打印日期和时间\"><a href=\"#打印日期和时间\" class=\"headerlink\" title=\"打印日期和时间\"></a>打印日期和时间</h2><p>我们都知道在<code>&lt;time.h&gt;</code>中提供了<code>time()</code>函数获取时间戳，但如何方便地获取年月日和时分秒呢？</p>\n<p>这里要引出里面的另一个接口<code>localtime()</code>了</p>\n<p><code>struct tm *localtime(const time_t *timep);</code></p>\n<p>可以看到，给它一个时间戳的指针，它就会返回一个<code>struct tm</code>结构体的指针，我们再来看看结构体里有什么</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tm</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_sec;         <span class=\"comment\">/* seconds */</span>           <span class=\"comment\">//秒</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_min;         <span class=\"comment\">/* minutes */</span>           <span class=\"comment\">//分钟</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_hour;        <span class=\"comment\">/* hours */</span>             <span class=\"comment\">//小时</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_mday;        <span class=\"comment\">/* day of the month */</span>  <span class=\"comment\">//一个月的中的第几天</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_mon;         <span class=\"comment\">/* month */</span>             <span class=\"comment\">//月份(从0月开始)</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_year;        <span class=\"comment\">/* year */</span>              <span class=\"comment\">//年份,从1900年为0年开始</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_wday;        <span class=\"comment\">/* day of the week */</span>   <span class=\"comment\">//一周的第几天</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_yday;        <span class=\"comment\">/* day in the year */</span>   <span class=\"comment\">//一年中的第几天</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_isdst;       <span class=\"comment\">/* daylight saving time */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到，借助<code>localtime()</code>函数可以方便地获取详细时间,简化了代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> leftBuffer[SIZE] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">time_t</span> t = <span class=\"built_in\">time</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tm</span> *ctime = <span class=\"built_in\">localtime</span>(&amp;t);<span class=\"comment\">//获取时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">snprintf</span>(leftBuffer,<span class=\"built_in\">sizeof</span>(leftBuffer),<span class=\"string\">&quot;[%s][%d-%d-%d %d:%d:%d]&quot;</span>,<span class=\"built_in\">levelToString</span>(level).<span class=\"built_in\">c_str</span>(),<span class=\"number\">1900</span>+ctime-&gt;tm_year,<span class=\"number\">1</span>+ctime-&gt;tm_mon,ctime-&gt;tm_mday,</span><br><span class=\"line\">    ctime-&gt;tm_hour,ctime-&gt;tm_min,ctime-&gt;tm_sec);</span><br></pre></td></tr></table></figure>\n<p><em>levelToString()函数后文再介绍</em></p>\n<h2 id=\"可变参数列表-与-格式化字符串\"><a href=\"#可变参数列表-与-格式化字符串\" class=\"headerlink\" title=\"可变参数列表 与 格式化字符串\"></a>可变参数列表 与 格式化字符串</h2><p>为了能让函数能够接受<code>格式化字符串</code>来方便打印日志，重载<code>operator()()</code>时要仿照<code>printf()</code>的函数声明</p>\n<p><code>void operator()(LEVEL level,const char *format,...)</code></p>\n<p>如上，最后一个参数用<code>...</code></p>\n<p>那么如何取出来呢？这里就要用到头文件<code>stdarg.h</code>的接口了</p>\n<p>首先用<code>va_list</code>声明一个变量<code>s</code>，</p>\n<p>然后用<code>va_start()</code>初始化<code>s</code>,因为函数的形参是从右往左实例化的，，所以还要传<code>...</code>左边第一个参数给它定位,例如<code>va_start(s,format)</code></p>\n<p>使用<code>va_start()</code>初始化后便可以调用其它函数了</p>\n<p>而在使用完的最后，还要调用<code>va_end()</code>来结束对变量<code>s</code>的使用,例如<code>va_end(s)</code></p>\n<h3 id=\"va-arg\"><a href=\"#va-arg\" class=\"headerlink\" title=\"va_arg()\"></a>va_arg()</h3><p><code>type va_arg(va_list ap, type);</code></p>\n<p>这个<code>宏函数</code>可以传类型作为参数，并从参数列表取出对应的参数</p>\n<p>以写一个n个数相加的函数为例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdarg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">nsum</span><span class=\"params\">(<span class=\"type\">int</span> n,...)</span><span class=\"comment\">//参数n表示n个数相加</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    va_list ap;</span><br><span class=\"line\">    <span class=\"built_in\">va_start</span>(ap,n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> num = <span class=\"built_in\">va_arg</span>(ap,<span class=\"type\">int</span>);<span class=\"comment\">//每次获取一个int 参数</span></span><br><span class=\"line\">        sum+=num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">va_end</span>(ap);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">nsum</span>(<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)&lt;&lt;endl;<span class=\"comment\">//输出5个数相加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到我们用<code>va_arg</code>实现了任意参数数量的整型相加</p>\n<h3 id=\"vsnprintf\"><a href=\"#vsnprintf\" class=\"headerlink\" title=\"vsnprintf()\"></a>vsnprintf()</h3><p><code>int vsnprintf(char *str, size_t size, const char *format, va_list ap);</code></p>\n<ul>\n<li><code>str</code>:存放字符串的缓冲区指针</li>\n<li><code>size</code>:缓冲区大小</li>\n<li><code>format</code>原格式字符串</li>\n<li><code>ap</code>: va_list类型的变量</li>\n</ul>\n<p>有了这个函数就可以方便地把可变参数列表打印到字符串里了</p>\n<p>例如在本文的<code>Log</code>类中,</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将内容输出到缓冲区中</span></span><br><span class=\"line\">va_list s;</span><br><span class=\"line\"><span class=\"built_in\">va_start</span>(s,format);</span><br><span class=\"line\"><span class=\"type\">char</span> rightBuffer[SIZE];</span><br><span class=\"line\"><span class=\"built_in\">vsnprintf</span>(rightBuffer,<span class=\"built_in\">sizeof</span>(rightBuffer),format,s);</span><br><span class=\"line\"><span class=\"built_in\">va_end</span>(s);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h1><p>剩下的部分就比较简单了，也就不分开讲解了，直接放出完整代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdarg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_FILE <span class=\"string\">&quot;log.txt&quot;</span><span class=\"comment\">//日志文件名</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE 1024  <span class=\"comment\">//缓冲区大小</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">OUT_MODE</span><span class=\"comment\">//输出模式</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Screen,  <span class=\"comment\">//输出到显示器</span></span><br><span class=\"line\">    OneFile, <span class=\"comment\">//输出到一个文件</span></span><br><span class=\"line\">    MultiFile<span class=\"comment\">//按等级输出到多个文件</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">LEVEL</span> <span class=\"comment\">//日志等级</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Info,    <span class=\"comment\">//一般信息</span></span><br><span class=\"line\">    Debug,   <span class=\"comment\">//debug日志</span></span><br><span class=\"line\">    Warning, <span class=\"comment\">//警告</span></span><br><span class=\"line\">    Error,   <span class=\"comment\">//错误</span></span><br><span class=\"line\">    Fatal    <span class=\"comment\">//失败</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Log</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Log</span>(OUT_MODE om = Screen):_om(om)<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    &#123;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Log</span>()&#123;&#125;<span class=\"comment\">//没有特殊用处</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enable</span><span class=\"params\">(OUT_MODE om)</span><span class=\"comment\">//启用指定的输出模式</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _om = om;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">levelToString</span><span class=\"params\">(LEVEL level)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (level)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Info:<span class=\"keyword\">return</span> <span class=\"string\">&quot;Info&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Debug:<span class=\"keyword\">return</span> <span class=\"string\">&quot;Debug&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Warning:<span class=\"keyword\">return</span> <span class=\"string\">&quot;Warning&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Error:<span class=\"keyword\">return</span> <span class=\"string\">&quot;Error&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Fatal:<span class=\"keyword\">return</span> <span class=\"string\">&quot;Fatal&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> <span class=\"string\">&quot;None&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(LEVEL level,<span class=\"type\">const</span> <span class=\"type\">char</span> *format,...)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> leftBuffer[SIZE] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">time_t</span> t = <span class=\"built_in\">time</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">tm</span> *ctime = <span class=\"built_in\">localtime</span>(&amp;t);<span class=\"comment\">//获取时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(leftBuffer,<span class=\"built_in\">sizeof</span>(leftBuffer),<span class=\"string\">&quot;[%s][%d-%d-%d %d:%d:%d]&quot;</span>,<span class=\"built_in\">levelToString</span>(level).<span class=\"built_in\">c_str</span>(),<span class=\"number\">1900</span>+ctime-&gt;tm_year,<span class=\"number\">1</span>+ctime-&gt;tm_mon,ctime-&gt;tm_mday,</span><br><span class=\"line\">            ctime-&gt;tm_hour,ctime-&gt;tm_min,ctime-&gt;tm_sec);</span><br><span class=\"line\"></span><br><span class=\"line\">        va_list s;</span><br><span class=\"line\">        <span class=\"built_in\">va_start</span>(s,format);</span><br><span class=\"line\">        <span class=\"type\">char</span> rightBuffer[SIZE];</span><br><span class=\"line\">        <span class=\"built_in\">vsnprintf</span>(rightBuffer,<span class=\"built_in\">sizeof</span>(rightBuffer),format,s);</span><br><span class=\"line\">        <span class=\"built_in\">va_end</span>(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">char</span> logtxt[SIZE*<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(logtxt,<span class=\"built_in\">sizeof</span>(logtxt),<span class=\"string\">&quot;%s %s&quot;</span>,leftBuffer,rightBuffer);</span><br><span class=\"line\">        <span class=\"built_in\">printLog</span>(level,logtxt);;<span class=\"comment\">//打印日志</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printLog</span><span class=\"params\">(LEVEL level, <span class=\"type\">const</span> std::string&amp; logtxt)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(_om)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Screen:std::cout&lt;&lt;logtxt&lt;&lt;std::endl;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OneFile:<span class=\"built_in\">printOneFile</span>(LOG_FILE,logtxt);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MultiFile:<span class=\"built_in\">printMultiFile</span>(level,logtxt);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printOneFile</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; logname,<span class=\"type\">const</span> std::string&amp; logtxt)</span><span class=\"comment\">//传两个参数用于代码复用</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = <span class=\"built_in\">open</span>(logname.<span class=\"built_in\">c_str</span>(), O_WRONLY|O_CREAT|O_APPEND,<span class=\"number\">0666</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fd&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">write</span>(fd,logtxt.<span class=\"built_in\">c_str</span>(),logtxt.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printMultiFile</span><span class=\"params\">(LEVEL level,<span class=\"type\">const</span> std::string logtxt)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        std::string filename = LOG_FILE;<span class=\"comment\">//构建文件名</span></span><br><span class=\"line\">        filename+= <span class=\"string\">&quot;.&quot;</span>;</span><br><span class=\"line\">        filename += <span class=\"built_in\">levelToString</span>(level);</span><br><span class=\"line\">        <span class=\"built_in\">printOneFile</span>(filename,logtxt);<span class=\"comment\">//复用代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    OUT_MODE _om = Screen;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/b728a89478687c0bf8c7f41d3062462b.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><p>首先看看AI对日志系统的重要性是怎么解释的</p>\n<blockquote>\n<p>日志系统在软件开发和运维中扮演着至关重要的角色，主要体现在以下几个方面：</p>\n<p><code>问题排查和调试</code>：日志记录了系统运行过程中的重要信息，包括错误信息、异常堆栈、接口调用信息等。开发人员可以通过分析日志快速定位问题，减少排查时间，提高开发效率。</p>\n<p><code>性能监控</code>：通过记录应用程序的性能指标（如响应时间、请求吞吐量等），开发团队可以监控系统的健康状态，发现性能瓶颈并进行优化。</p>\n<p><code>安全审计</code>：日志可以记录用户的操作和系统事件，为后期的安全审计提供依据。一旦发生安全事件，通过分析日志可以追踪到攻击来源和攻击方式。</p>\n<p><code>用户行为分析</code>：通过对日志进行分析，开发团队可以了解用户的使用习惯和需求，这有助于改进产品功能和用户体验。</p>\n<p><code>合规要求</code>：在许多行业中，日志记录是合规的要求之一。维护完整的日志记录可以帮助企业满足法律法规和行业标准。</p>\n<p><code>系统健康监控</code>：通过实时监控日志，可以及时发现系统异常，进行预警和自动化处理，从而提高系统的可用性和稳定性。</p>\n<p><code>故障恢复</code>：在系统出现故障时，日志记录可以帮助开发和运维人员还原问题发生前的状态，从而有助于快速恢复系统。</p>\n<p>总之，良好的日志系统能够帮助开发和运维团队提高效率、强化安全、提升用户体验，并确保系统的稳定性和可靠性。因此，在系统设计时，合理规划和实施日志记录机制是非常必要的。</p>\n</blockquote>\n<p>因此出于学习实践的目的，和方便日后自己打印日志，我们可以先自己用C++封装一个简单的日志系统</p>\n<h1 id=\"基本功能要求\"><a href=\"#基本功能要求\" class=\"headerlink\" title=\"基本功能要求\"></a>基本功能要求</h1><ul>\n<li>打印日志等级</li>\n<li>打印日志日期和时间</li>\n<li>格式化打印日志消息</li>\n<li>可选择输出到显示器，还是单个文件，还是按等级分文件</li>\n</ul>\n<p>功能缺陷：没有完善清理日志文件的功能，因此不能投入到真正的项目中，否则时间长了可能造成日志文件过大的问题</p>\n<h1 id=\"头文件-和-宏定义\"><a href=\"#头文件-和-宏定义\" class=\"headerlink\" title=\"头文件 和 宏定义\"></a>头文件 和 宏定义</h1><p>本次要用到的头文件依然较多,而用到的宏定义有文件名和缓冲区大小，因为有时日志要打印到文件中，所以要准备一个文件名</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdarg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_FILE <span class=\"string\">&quot;log.txt&quot;</span><span class=\"comment\">//日志文件名</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE 1024  <span class=\"comment\">//缓冲区大小</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><p>日志系统中要用到较多选项，这里使用枚举最为直观和简洁</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">OUT_MODE</span><span class=\"comment\">//输出模式</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Screen,  <span class=\"comment\">//输出到显示器</span></span><br><span class=\"line\">    OneFile, <span class=\"comment\">//输出到一个文件</span></span><br><span class=\"line\">    MultiFile<span class=\"comment\">//按等级输出到多个文件</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">LEVEL</span> <span class=\"comment\">//日志等级</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Info,    <span class=\"comment\">//一般信息</span></span><br><span class=\"line\">    Debug,   <span class=\"comment\">//debug日志</span></span><br><span class=\"line\">    Warning, <span class=\"comment\">//警告</span></span><br><span class=\"line\">    Error,   <span class=\"comment\">//错误</span></span><br><span class=\"line\">    Fatal    <span class=\"comment\">//失败</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"类的基本构成\"><a href=\"#类的基本构成\" class=\"headerlink\" title=\"类的基本构成\"></a>类的基本构成</h1><p>这里我们封装一个<code>Log</code>类,</p>\n<ul>\n<li>储存一个私有成员变量<code>_om</code>(output mode) </li>\n<li>重载<code>operator()()</code>使其有仿函数的功能</li>\n<li>声明<code>enable</code>函数用于切换输出模式</li>\n<li>声明<code>levelToString</code>将<code>LEVEL</code>的枚举类型转换为<code>string</code>类</li>\n<li>声明<code>printLog</code>用于调用不同接口打印日志</li>\n<li>声明<code>printMultiFile</code>用于向指定<code>文件名</code>打印日志</li>\n<li>声明<code>printMultiFile</code>用于向指定<code>日志等级</code>的文件打印日志</li>\n</ul>\n<h1 id=\"功能突破\"><a href=\"#功能突破\" class=\"headerlink\" title=\"功能突破\"></a>功能突破</h1><p>有个别功能由于平时不常用&#x2F;没见过，需要特别的突破一下</p>\n<h2 id=\"打印日期和时间\"><a href=\"#打印日期和时间\" class=\"headerlink\" title=\"打印日期和时间\"></a>打印日期和时间</h2><p>我们都知道在<code>&lt;time.h&gt;</code>中提供了<code>time()</code>函数获取时间戳，但如何方便地获取年月日和时分秒呢？</p>\n<p>这里要引出里面的另一个接口<code>localtime()</code>了</p>\n<p><code>struct tm *localtime(const time_t *timep);</code></p>\n<p>可以看到，给它一个时间戳的指针，它就会返回一个<code>struct tm</code>结构体的指针，我们再来看看结构体里有什么</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tm</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_sec;         <span class=\"comment\">/* seconds */</span>           <span class=\"comment\">//秒</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_min;         <span class=\"comment\">/* minutes */</span>           <span class=\"comment\">//分钟</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_hour;        <span class=\"comment\">/* hours */</span>             <span class=\"comment\">//小时</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_mday;        <span class=\"comment\">/* day of the month */</span>  <span class=\"comment\">//一个月的中的第几天</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_mon;         <span class=\"comment\">/* month */</span>             <span class=\"comment\">//月份(从0月开始)</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_year;        <span class=\"comment\">/* year */</span>              <span class=\"comment\">//年份,从1900年为0年开始</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_wday;        <span class=\"comment\">/* day of the week */</span>   <span class=\"comment\">//一周的第几天</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_yday;        <span class=\"comment\">/* day in the year */</span>   <span class=\"comment\">//一年中的第几天</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tm_isdst;       <span class=\"comment\">/* daylight saving time */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到，借助<code>localtime()</code>函数可以方便地获取详细时间,简化了代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> leftBuffer[SIZE] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">time_t</span> t = <span class=\"built_in\">time</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tm</span> *ctime = <span class=\"built_in\">localtime</span>(&amp;t);<span class=\"comment\">//获取时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">snprintf</span>(leftBuffer,<span class=\"built_in\">sizeof</span>(leftBuffer),<span class=\"string\">&quot;[%s][%d-%d-%d %d:%d:%d]&quot;</span>,<span class=\"built_in\">levelToString</span>(level).<span class=\"built_in\">c_str</span>(),<span class=\"number\">1900</span>+ctime-&gt;tm_year,<span class=\"number\">1</span>+ctime-&gt;tm_mon,ctime-&gt;tm_mday,</span><br><span class=\"line\">    ctime-&gt;tm_hour,ctime-&gt;tm_min,ctime-&gt;tm_sec);</span><br></pre></td></tr></table></figure>\n<p><em>levelToString()函数后文再介绍</em></p>\n<h2 id=\"可变参数列表-与-格式化字符串\"><a href=\"#可变参数列表-与-格式化字符串\" class=\"headerlink\" title=\"可变参数列表 与 格式化字符串\"></a>可变参数列表 与 格式化字符串</h2><p>为了能让函数能够接受<code>格式化字符串</code>来方便打印日志，重载<code>operator()()</code>时要仿照<code>printf()</code>的函数声明</p>\n<p><code>void operator()(LEVEL level,const char *format,...)</code></p>\n<p>如上，最后一个参数用<code>...</code></p>\n<p>那么如何取出来呢？这里就要用到头文件<code>stdarg.h</code>的接口了</p>\n<p>首先用<code>va_list</code>声明一个变量<code>s</code>，</p>\n<p>然后用<code>va_start()</code>初始化<code>s</code>,因为函数的形参是从右往左实例化的，，所以还要传<code>...</code>左边第一个参数给它定位,例如<code>va_start(s,format)</code></p>\n<p>使用<code>va_start()</code>初始化后便可以调用其它函数了</p>\n<p>而在使用完的最后，还要调用<code>va_end()</code>来结束对变量<code>s</code>的使用,例如<code>va_end(s)</code></p>\n<h3 id=\"va-arg\"><a href=\"#va-arg\" class=\"headerlink\" title=\"va_arg()\"></a>va_arg()</h3><p><code>type va_arg(va_list ap, type);</code></p>\n<p>这个<code>宏函数</code>可以传类型作为参数，并从参数列表取出对应的参数</p>\n<p>以写一个n个数相加的函数为例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdarg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">nsum</span><span class=\"params\">(<span class=\"type\">int</span> n,...)</span><span class=\"comment\">//参数n表示n个数相加</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    va_list ap;</span><br><span class=\"line\">    <span class=\"built_in\">va_start</span>(ap,n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> num = <span class=\"built_in\">va_arg</span>(ap,<span class=\"type\">int</span>);<span class=\"comment\">//每次获取一个int 参数</span></span><br><span class=\"line\">        sum+=num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">va_end</span>(ap);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">nsum</span>(<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)&lt;&lt;endl;<span class=\"comment\">//输出5个数相加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到我们用<code>va_arg</code>实现了任意参数数量的整型相加</p>\n<h3 id=\"vsnprintf\"><a href=\"#vsnprintf\" class=\"headerlink\" title=\"vsnprintf()\"></a>vsnprintf()</h3><p><code>int vsnprintf(char *str, size_t size, const char *format, va_list ap);</code></p>\n<ul>\n<li><code>str</code>:存放字符串的缓冲区指针</li>\n<li><code>size</code>:缓冲区大小</li>\n<li><code>format</code>原格式字符串</li>\n<li><code>ap</code>: va_list类型的变量</li>\n</ul>\n<p>有了这个函数就可以方便地把可变参数列表打印到字符串里了</p>\n<p>例如在本文的<code>Log</code>类中,</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将内容输出到缓冲区中</span></span><br><span class=\"line\">va_list s;</span><br><span class=\"line\"><span class=\"built_in\">va_start</span>(s,format);</span><br><span class=\"line\"><span class=\"type\">char</span> rightBuffer[SIZE];</span><br><span class=\"line\"><span class=\"built_in\">vsnprintf</span>(rightBuffer,<span class=\"built_in\">sizeof</span>(rightBuffer),format,s);</span><br><span class=\"line\"><span class=\"built_in\">va_end</span>(s);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h1><p>剩下的部分就比较简单了，也就不分开讲解了，直接放出完整代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdarg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_FILE <span class=\"string\">&quot;log.txt&quot;</span><span class=\"comment\">//日志文件名</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE 1024  <span class=\"comment\">//缓冲区大小</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">OUT_MODE</span><span class=\"comment\">//输出模式</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Screen,  <span class=\"comment\">//输出到显示器</span></span><br><span class=\"line\">    OneFile, <span class=\"comment\">//输出到一个文件</span></span><br><span class=\"line\">    MultiFile<span class=\"comment\">//按等级输出到多个文件</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">LEVEL</span> <span class=\"comment\">//日志等级</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Info,    <span class=\"comment\">//一般信息</span></span><br><span class=\"line\">    Debug,   <span class=\"comment\">//debug日志</span></span><br><span class=\"line\">    Warning, <span class=\"comment\">//警告</span></span><br><span class=\"line\">    Error,   <span class=\"comment\">//错误</span></span><br><span class=\"line\">    Fatal    <span class=\"comment\">//失败</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Log</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Log</span>(OUT_MODE om = Screen):_om(om)<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    &#123;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Log</span>()&#123;&#125;<span class=\"comment\">//没有特殊用处</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">enable</span><span class=\"params\">(OUT_MODE om)</span><span class=\"comment\">//启用指定的输出模式</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _om = om;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">levelToString</span><span class=\"params\">(LEVEL level)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (level)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Info:<span class=\"keyword\">return</span> <span class=\"string\">&quot;Info&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Debug:<span class=\"keyword\">return</span> <span class=\"string\">&quot;Debug&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Warning:<span class=\"keyword\">return</span> <span class=\"string\">&quot;Warning&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Error:<span class=\"keyword\">return</span> <span class=\"string\">&quot;Error&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Fatal:<span class=\"keyword\">return</span> <span class=\"string\">&quot;Fatal&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> <span class=\"string\">&quot;None&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(LEVEL level,<span class=\"type\">const</span> <span class=\"type\">char</span> *format,...)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> leftBuffer[SIZE] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">time_t</span> t = <span class=\"built_in\">time</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">tm</span> *ctime = <span class=\"built_in\">localtime</span>(&amp;t);<span class=\"comment\">//获取时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(leftBuffer,<span class=\"built_in\">sizeof</span>(leftBuffer),<span class=\"string\">&quot;[%s][%d-%d-%d %d:%d:%d]&quot;</span>,<span class=\"built_in\">levelToString</span>(level).<span class=\"built_in\">c_str</span>(),<span class=\"number\">1900</span>+ctime-&gt;tm_year,<span class=\"number\">1</span>+ctime-&gt;tm_mon,ctime-&gt;tm_mday,</span><br><span class=\"line\">            ctime-&gt;tm_hour,ctime-&gt;tm_min,ctime-&gt;tm_sec);</span><br><span class=\"line\"></span><br><span class=\"line\">        va_list s;</span><br><span class=\"line\">        <span class=\"built_in\">va_start</span>(s,format);</span><br><span class=\"line\">        <span class=\"type\">char</span> rightBuffer[SIZE];</span><br><span class=\"line\">        <span class=\"built_in\">vsnprintf</span>(rightBuffer,<span class=\"built_in\">sizeof</span>(rightBuffer),format,s);</span><br><span class=\"line\">        <span class=\"built_in\">va_end</span>(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">char</span> logtxt[SIZE*<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(logtxt,<span class=\"built_in\">sizeof</span>(logtxt),<span class=\"string\">&quot;%s %s&quot;</span>,leftBuffer,rightBuffer);</span><br><span class=\"line\">        <span class=\"built_in\">printLog</span>(level,logtxt);;<span class=\"comment\">//打印日志</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printLog</span><span class=\"params\">(LEVEL level, <span class=\"type\">const</span> std::string&amp; logtxt)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(_om)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> Screen:std::cout&lt;&lt;logtxt&lt;&lt;std::endl;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OneFile:<span class=\"built_in\">printOneFile</span>(LOG_FILE,logtxt);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MultiFile:<span class=\"built_in\">printMultiFile</span>(level,logtxt);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printOneFile</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; logname,<span class=\"type\">const</span> std::string&amp; logtxt)</span><span class=\"comment\">//传两个参数用于代码复用</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = <span class=\"built_in\">open</span>(logname.<span class=\"built_in\">c_str</span>(), O_WRONLY|O_CREAT|O_APPEND,<span class=\"number\">0666</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fd&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">write</span>(fd,logtxt.<span class=\"built_in\">c_str</span>(),logtxt.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printMultiFile</span><span class=\"params\">(LEVEL level,<span class=\"type\">const</span> std::string logtxt)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        std::string filename = LOG_FILE;<span class=\"comment\">//构建文件名</span></span><br><span class=\"line\">        filename+= <span class=\"string\">&quot;.&quot;</span>;</span><br><span class=\"line\">        filename += <span class=\"built_in\">levelToString</span>(level);</span><br><span class=\"line\">        <span class=\"built_in\">printOneFile</span>(filename,logtxt);<span class=\"comment\">//复用代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    OUT_MODE _om = Screen;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"玩转N组输入和多组输入","date":"2023-10-18T14:39:57.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg","_content":"\n# 引入 #\n当我们在写IO型OJ时，`多组输入`便是我们绕过不开的话题了，但**不用担心**，可能初见多组输入会觉得难以理解，但用多了之后就会发现，`多组输入` 花样并不多，混熟了就**很简单了**\n\n## 先看看一组输入输出如何完成的 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_17-06-13.jpg)\n\n*如图*：一组输入时，用`scanf`获取一组输入，并在主体部分完成数据的处理，产生结果，最后用`printf`输出产生的一组结果。\n\n*以下用实现加法的程序做演示*\n\n```C\n#include <stdio.h>\n\nint main()\n{\n    int a,b;\n    scanf(\"%d %d\",&a,&b);//获取一组输入\n    int sum = a + b;//产生结果\n    printf(\"%d\\n\",sum);//输出结果\n    return 0;\n}\n```\n\n# 然后升级到N组输入\n有的OJ题在一个测试文件中会先输入一个`n`,告诉你接下来有`n`组输入，你就要产生`n`组输出,也就是说要将`一组输入输出`**重复性地**完成`n次`。难道我们要把代码重复`n次`吗？显然不现实。\n\n所以是时候使用**循环**了，具体用法如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg)\n\n如图，先用一个`scanf`获取循环次数`n`,然后创建一个循环，将`一组输入输出`放入循环体，一次一次循环处理即可\n\n## 变量的重置 #\n\n为防止前后两次循环产生干扰，有两种处理`变量`的方式\n\n1.(推荐)除了输入的变量，**其它所有变量**在循环体内声明，这些变量会在一次循环后*销毁*，下一次循环开始时**自动***重新声明*，从而完成**变量的自动重置**\n\n*以下面这个一次求和3个数的程序为例*\n```C\n#include <stdio.h>\n\nint main()\n{\n    int n = 0;\n    scanf(\"%d\",&n);//获取循环次数n\n    for(int i =0;i<n;i++)//创建循环\n    {\n        //以下完成一组输入输出\n        int sum = 0;//声明一个局部变量，下次循环时会自动重声明\n        int num = 0;//储存输入的数字\n        for(int j =0;j<3;j++)\n        {\n            scanf(\"%d\",&num);\n            sum+=num;\n        }\n        printf(\"%d\\n\",sum);//完成输出\n        //本次循环走完后变量sum被销毁，然后进入下一次循环,完成重置\n    }\n    return 0;\n}\n\n```\n\n2.在循环外部声明变量，然后在**循环末尾**手动重置变量\n\n*以下面这个一次求和3个数的程序为例*\n\n```C\n#include <stdio.h>\n\nint main()\n{\n    int sum = 0;//声明在循环外部\n    int n = 0;\n    scanf(\"%d\",&n);//获取循环次数n\n    for(int i =0;i<n;i++)//创建循环\n    {\n        //以下完成一组输入输出\n        int num = 0;//储存输入的数字\n        for(int j =0;j<3;j++)\n        {\n            scanf(\"%d\",&num);\n            sum+=num;\n        }\n        printf(\"%d\\n\",sum);//完成输出\n        sum = 0;//重置sum\n    }\n    return 0;\n}\n\n```\n\n\n## 要不要用数组储存输入，或储存结果再一次性输出？ #\n答案是：**可以，但没必要**。\n\n只需要像上图那么写即可，因为输入是一次性喂进去的 。存数组再输出，和每产生一个结果就输出一次，最终呈现出来是一样的（如下图）\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%A4%9A%E7%BB%84%E8%BE%93%E5%87%BA.gif)\n\n# 现在，勇士，来挑战多组输入吧 #\n\n## scanf的返回值 #\n多组输入时，究竟会输入多少组数据，也不告诉你了，**但是**，此时`scanf`的返回值就派上用场了。和我们在终端手打输入不同,OJ的输入是喂一个文件进去，所以当**输入结束时**，`scanf`的返回值是`EOF`*(意为文件结尾end of file)*,而当成功输入数据时，则会返回输入数据的个数(文档截图如下)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_20-46-54.jpg)\n\n## 结合循环 #\n那么就把`scanf`放入`while`循环吧,每次试图获取下一组输入时，检测是否返回值为`EOF`,若是，则跳出循环，结束程序；若否，则继续循环\n\n*以下面这个一次求和3个数的程序为例*\n\n```C\n#include <stdio.h>\nint main()\n{\n    int num = 0;//先声明至少一个待输入的变量\n    while(scanf(\"%d\",&n) != EOF)//创建循环，每次循环开始时scanf一次，并检测是否返回EOF\n    {\n        //开始构建循坏体\n        int sum = 0;\n        sum+=n;\n        //完成剩下的两次输入\n        for(int i =0; i < 3 - 1;i++)\n        {\n            scanf(\"%d\",&n);\n            sum+=n\n        }\n        printf(\"%d\\n\",sum);//完成一次输出\n    }\n    //scanf返回EOF后跳出循环\n    return 0;\n}\n```\n## 基本架构 #\n以后再要写`多组输入`，基本就像上面那个程序一样\n\n1.先声明至少一个待输入的变量\n\n2.创建循环，每次循环开始时scanf一次，并检测是否返回EOF\n\n3.开始构建循坏体(包括完成剩下的输入,完成一组输出)**别忘了回车！！！**\n\n4.直至scanf返回EOF后跳出循环\n\n# 想模拟一下多组输入看看？ #\n像下图一样每组数据间加个`空格`就行，什么？题目的样例输入有`回车`？不用管它，放心大胆地`换成空格`就行。自己`测试`程序，只需要**输出**一样就行，至于怎么输入，**没必要**和题目一模一样\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/mutiInpuut.gif)\n\n# 注意！！！不要试图在终端停止程序 #\n因为和OJ不同，在本地运行程序时，不是文件输入，而是终端输入,没法让`scanf`返回`EOF`,~~炫迈，根本停不来~~\n\n你要是想立即`中断`程序，那就按`ctrl+c`","source":"_posts/mutiInput.md","raw":"---\ntitle: 玩转N组输入和多组输入\ndate: 2023-10-18 22:39:57\ntags: C语言 多组输入\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg\n---\n\n# 引入 #\n当我们在写IO型OJ时，`多组输入`便是我们绕过不开的话题了，但**不用担心**，可能初见多组输入会觉得难以理解，但用多了之后就会发现，`多组输入` 花样并不多，混熟了就**很简单了**\n\n## 先看看一组输入输出如何完成的 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_17-06-13.jpg)\n\n*如图*：一组输入时，用`scanf`获取一组输入，并在主体部分完成数据的处理，产生结果，最后用`printf`输出产生的一组结果。\n\n*以下用实现加法的程序做演示*\n\n```C\n#include <stdio.h>\n\nint main()\n{\n    int a,b;\n    scanf(\"%d %d\",&a,&b);//获取一组输入\n    int sum = a + b;//产生结果\n    printf(\"%d\\n\",sum);//输出结果\n    return 0;\n}\n```\n\n# 然后升级到N组输入\n有的OJ题在一个测试文件中会先输入一个`n`,告诉你接下来有`n`组输入，你就要产生`n`组输出,也就是说要将`一组输入输出`**重复性地**完成`n次`。难道我们要把代码重复`n次`吗？显然不现实。\n\n所以是时候使用**循环**了，具体用法如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg)\n\n如图，先用一个`scanf`获取循环次数`n`,然后创建一个循环，将`一组输入输出`放入循环体，一次一次循环处理即可\n\n## 变量的重置 #\n\n为防止前后两次循环产生干扰，有两种处理`变量`的方式\n\n1.(推荐)除了输入的变量，**其它所有变量**在循环体内声明，这些变量会在一次循环后*销毁*，下一次循环开始时**自动***重新声明*，从而完成**变量的自动重置**\n\n*以下面这个一次求和3个数的程序为例*\n```C\n#include <stdio.h>\n\nint main()\n{\n    int n = 0;\n    scanf(\"%d\",&n);//获取循环次数n\n    for(int i =0;i<n;i++)//创建循环\n    {\n        //以下完成一组输入输出\n        int sum = 0;//声明一个局部变量，下次循环时会自动重声明\n        int num = 0;//储存输入的数字\n        for(int j =0;j<3;j++)\n        {\n            scanf(\"%d\",&num);\n            sum+=num;\n        }\n        printf(\"%d\\n\",sum);//完成输出\n        //本次循环走完后变量sum被销毁，然后进入下一次循环,完成重置\n    }\n    return 0;\n}\n\n```\n\n2.在循环外部声明变量，然后在**循环末尾**手动重置变量\n\n*以下面这个一次求和3个数的程序为例*\n\n```C\n#include <stdio.h>\n\nint main()\n{\n    int sum = 0;//声明在循环外部\n    int n = 0;\n    scanf(\"%d\",&n);//获取循环次数n\n    for(int i =0;i<n;i++)//创建循环\n    {\n        //以下完成一组输入输出\n        int num = 0;//储存输入的数字\n        for(int j =0;j<3;j++)\n        {\n            scanf(\"%d\",&num);\n            sum+=num;\n        }\n        printf(\"%d\\n\",sum);//完成输出\n        sum = 0;//重置sum\n    }\n    return 0;\n}\n\n```\n\n\n## 要不要用数组储存输入，或储存结果再一次性输出？ #\n答案是：**可以，但没必要**。\n\n只需要像上图那么写即可，因为输入是一次性喂进去的 。存数组再输出，和每产生一个结果就输出一次，最终呈现出来是一样的（如下图）\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%A4%9A%E7%BB%84%E8%BE%93%E5%87%BA.gif)\n\n# 现在，勇士，来挑战多组输入吧 #\n\n## scanf的返回值 #\n多组输入时，究竟会输入多少组数据，也不告诉你了，**但是**，此时`scanf`的返回值就派上用场了。和我们在终端手打输入不同,OJ的输入是喂一个文件进去，所以当**输入结束时**，`scanf`的返回值是`EOF`*(意为文件结尾end of file)*,而当成功输入数据时，则会返回输入数据的个数(文档截图如下)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_20-46-54.jpg)\n\n## 结合循环 #\n那么就把`scanf`放入`while`循环吧,每次试图获取下一组输入时，检测是否返回值为`EOF`,若是，则跳出循环，结束程序；若否，则继续循环\n\n*以下面这个一次求和3个数的程序为例*\n\n```C\n#include <stdio.h>\nint main()\n{\n    int num = 0;//先声明至少一个待输入的变量\n    while(scanf(\"%d\",&n) != EOF)//创建循环，每次循环开始时scanf一次，并检测是否返回EOF\n    {\n        //开始构建循坏体\n        int sum = 0;\n        sum+=n;\n        //完成剩下的两次输入\n        for(int i =0; i < 3 - 1;i++)\n        {\n            scanf(\"%d\",&n);\n            sum+=n\n        }\n        printf(\"%d\\n\",sum);//完成一次输出\n    }\n    //scanf返回EOF后跳出循环\n    return 0;\n}\n```\n## 基本架构 #\n以后再要写`多组输入`，基本就像上面那个程序一样\n\n1.先声明至少一个待输入的变量\n\n2.创建循环，每次循环开始时scanf一次，并检测是否返回EOF\n\n3.开始构建循坏体(包括完成剩下的输入,完成一组输出)**别忘了回车！！！**\n\n4.直至scanf返回EOF后跳出循环\n\n# 想模拟一下多组输入看看？ #\n像下图一样每组数据间加个`空格`就行，什么？题目的样例输入有`回车`？不用管它，放心大胆地`换成空格`就行。自己`测试`程序，只需要**输出**一样就行，至于怎么输入，**没必要**和题目一模一样\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/mutiInpuut.gif)\n\n# 注意！！！不要试图在终端停止程序 #\n因为和OJ不同，在本地运行程序时，不是文件输入，而是终端输入,没法让`scanf`返回`EOF`,~~炫迈，根本停不来~~\n\n你要是想立即`中断`程序，那就按`ctrl+c`","slug":"mutiInput","published":1,"updated":"2024-05-14T02:21:35.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08i00194sp5bibd6yv5","content":"<h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><p>当我们在写IO型OJ时，<code>多组输入</code>便是我们绕过不开的话题了，但<strong>不用担心</strong>，可能初见多组输入会觉得难以理解，但用多了之后就会发现，<code>多组输入</code> 花样并不多，混熟了就<strong>很简单了</strong></p>\n<h2 id=\"先看看一组输入输出如何完成的\"><a href=\"#先看看一组输入输出如何完成的\" class=\"headerlink\" title=\"先看看一组输入输出如何完成的\"></a>先看看一组输入输出如何完成的</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_17-06-13.jpg\"></p>\n<p><em>如图</em>：一组输入时，用<code>scanf</code>获取一组输入，并在主体部分完成数据的处理，产生结果，最后用<code>printf</code>输出产生的一组结果。</p>\n<p><em>以下用实现加法的程序做演示</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<span class=\"comment\">//获取一组输入</span></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = a + b;<span class=\"comment\">//产生结果</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//输出结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"然后升级到N组输入\"><a href=\"#然后升级到N组输入\" class=\"headerlink\" title=\"然后升级到N组输入\"></a>然后升级到N组输入</h1><p>有的OJ题在一个测试文件中会先输入一个<code>n</code>,告诉你接下来有<code>n</code>组输入，你就要产生<code>n</code>组输出,也就是说要将<code>一组输入输出</code><strong>重复性地</strong>完成<code>n次</code>。难道我们要把代码重复<code>n次</code>吗？显然不现实。</p>\n<p>所以是时候使用<strong>循环</strong>了，具体用法如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg\"></p>\n<p>如图，先用一个<code>scanf</code>获取循环次数<code>n</code>,然后创建一个循环，将<code>一组输入输出</code>放入循环体，一次一次循环处理即可</p>\n<h2 id=\"变量的重置\"><a href=\"#变量的重置\" class=\"headerlink\" title=\"变量的重置\"></a>变量的重置</h2><p>为防止前后两次循环产生干扰，有两种处理<code>变量</code>的方式</p>\n<p>1.(推荐)除了输入的变量，<strong>其它所有变量</strong>在循环体内声明，这些变量会在一次循环后<em>销毁</em>，下一次循环开始时<strong>自动</strong><em>重新声明</em>，从而完成<strong>变量的自动重置</strong></p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);<span class=\"comment\">//获取循环次数n</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"comment\">//创建循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以下完成一组输入输出</span></span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;<span class=\"comment\">//声明一个局部变量，下次循环时会自动重声明</span></span><br><span class=\"line\">        <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//储存输入的数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">0</span>;j&lt;<span class=\"number\">3</span>;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num);</span><br><span class=\"line\">            sum+=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成输出</span></span><br><span class=\"line\">        <span class=\"comment\">//本次循环走完后变量sum被销毁，然后进入下一次循环,完成重置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>2.在循环外部声明变量，然后在<strong>循环末尾</strong>手动重置变量</p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;<span class=\"comment\">//声明在循环外部</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);<span class=\"comment\">//获取循环次数n</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"comment\">//创建循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以下完成一组输入输出</span></span><br><span class=\"line\">        <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//储存输入的数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">0</span>;j&lt;<span class=\"number\">3</span>;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num);</span><br><span class=\"line\">            sum+=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成输出</span></span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;<span class=\"comment\">//重置sum</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"要不要用数组储存输入，或储存结果再一次性输出？\"><a href=\"#要不要用数组储存输入，或储存结果再一次性输出？\" class=\"headerlink\" title=\"要不要用数组储存输入，或储存结果再一次性输出？\"></a>要不要用数组储存输入，或储存结果再一次性输出？</h2><p>答案是：<strong>可以，但没必要</strong>。</p>\n<p>只需要像上图那么写即可，因为输入是一次性喂进去的 。存数组再输出，和每产生一个结果就输出一次，最终呈现出来是一样的（如下图）</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%A4%9A%E7%BB%84%E8%BE%93%E5%87%BA.gif\"></p>\n<h1 id=\"现在，勇士，来挑战多组输入吧\"><a href=\"#现在，勇士，来挑战多组输入吧\" class=\"headerlink\" title=\"现在，勇士，来挑战多组输入吧\"></a>现在，勇士，来挑战多组输入吧</h1><h2 id=\"scanf的返回值\"><a href=\"#scanf的返回值\" class=\"headerlink\" title=\"scanf的返回值\"></a>scanf的返回值</h2><p>多组输入时，究竟会输入多少组数据，也不告诉你了，<strong>但是</strong>，此时<code>scanf</code>的返回值就派上用场了。和我们在终端手打输入不同,OJ的输入是喂一个文件进去，所以当<strong>输入结束时</strong>，<code>scanf</code>的返回值是<code>EOF</code><em>(意为文件结尾end of file)</em>,而当成功输入数据时，则会返回输入数据的个数(文档截图如下)</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_20-46-54.jpg\"></p>\n<h2 id=\"结合循环\"><a href=\"#结合循环\" class=\"headerlink\" title=\"结合循环\"></a>结合循环</h2><p>那么就把<code>scanf</code>放入<code>while</code>循环吧,每次试图获取下一组输入时，检测是否返回值为<code>EOF</code>,若是，则跳出循环，结束程序；若否，则继续循环</p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//先声明至少一个待输入的变量</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n) != EOF)<span class=\"comment\">//创建循环，每次循环开始时scanf一次，并检测是否返回EOF</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//开始构建循坏体</span></span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        sum+=n;</span><br><span class=\"line\">        <span class=\"comment\">//完成剩下的两次输入</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span> - <span class=\"number\">1</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">            sum+=n</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成一次输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//scanf返回EOF后跳出循环</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h2><p>以后再要写<code>多组输入</code>，基本就像上面那个程序一样</p>\n<p>1.先声明至少一个待输入的变量</p>\n<p>2.创建循环，每次循环开始时scanf一次，并检测是否返回EOF</p>\n<p>3.开始构建循坏体(包括完成剩下的输入,完成一组输出)<strong>别忘了回车！！！</strong></p>\n<p>4.直至scanf返回EOF后跳出循环</p>\n<h1 id=\"想模拟一下多组输入看看？\"><a href=\"#想模拟一下多组输入看看？\" class=\"headerlink\" title=\"想模拟一下多组输入看看？\"></a>想模拟一下多组输入看看？</h1><p>像下图一样每组数据间加个<code>空格</code>就行，什么？题目的样例输入有<code>回车</code>？不用管它，放心大胆地<code>换成空格</code>就行。自己<code>测试</code>程序，只需要<strong>输出</strong>一样就行，至于怎么输入，<strong>没必要</strong>和题目一模一样</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/mutiInpuut.gif\"></p>\n<h1 id=\"注意！！！不要试图在终端停止程序\"><a href=\"#注意！！！不要试图在终端停止程序\" class=\"headerlink\" title=\"注意！！！不要试图在终端停止程序\"></a>注意！！！不要试图在终端停止程序</h1><p>因为和OJ不同，在本地运行程序时，不是文件输入，而是终端输入,没法让<code>scanf</code>返回<code>EOF</code>,<del>炫迈，根本停不来</del></p>\n<p>你要是想立即<code>中断</code>程序，那就按<code>ctrl+c</code></p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><p>当我们在写IO型OJ时，<code>多组输入</code>便是我们绕过不开的话题了，但<strong>不用担心</strong>，可能初见多组输入会觉得难以理解，但用多了之后就会发现，<code>多组输入</code> 花样并不多，混熟了就<strong>很简单了</strong></p>\n<h2 id=\"先看看一组输入输出如何完成的\"><a href=\"#先看看一组输入输出如何完成的\" class=\"headerlink\" title=\"先看看一组输入输出如何完成的\"></a>先看看一组输入输出如何完成的</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-19_17-06-13.jpg\"></p>\n<p><em>如图</em>：一组输入时，用<code>scanf</code>获取一组输入，并在主体部分完成数据的处理，产生结果，最后用<code>printf</code>输出产生的一组结果。</p>\n<p><em>以下用实现加法的程序做演示</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<span class=\"comment\">//获取一组输入</span></span><br><span class=\"line\">    <span class=\"type\">int</span> sum = a + b;<span class=\"comment\">//产生结果</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//输出结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"然后升级到N组输入\"><a href=\"#然后升级到N组输入\" class=\"headerlink\" title=\"然后升级到N组输入\"></a>然后升级到N组输入</h1><p>有的OJ题在一个测试文件中会先输入一个<code>n</code>,告诉你接下来有<code>n</code>组输入，你就要产生<code>n</code>组输出,也就是说要将<code>一组输入输出</code><strong>重复性地</strong>完成<code>n次</code>。难道我们要把代码重复<code>n次</code>吗？显然不现实。</p>\n<p>所以是时候使用<strong>循环</strong>了，具体用法如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_07-34-35.jpg\"></p>\n<p>如图，先用一个<code>scanf</code>获取循环次数<code>n</code>,然后创建一个循环，将<code>一组输入输出</code>放入循环体，一次一次循环处理即可</p>\n<h2 id=\"变量的重置\"><a href=\"#变量的重置\" class=\"headerlink\" title=\"变量的重置\"></a>变量的重置</h2><p>为防止前后两次循环产生干扰，有两种处理<code>变量</code>的方式</p>\n<p>1.(推荐)除了输入的变量，<strong>其它所有变量</strong>在循环体内声明，这些变量会在一次循环后<em>销毁</em>，下一次循环开始时<strong>自动</strong><em>重新声明</em>，从而完成<strong>变量的自动重置</strong></p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);<span class=\"comment\">//获取循环次数n</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"comment\">//创建循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以下完成一组输入输出</span></span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;<span class=\"comment\">//声明一个局部变量，下次循环时会自动重声明</span></span><br><span class=\"line\">        <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//储存输入的数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">0</span>;j&lt;<span class=\"number\">3</span>;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num);</span><br><span class=\"line\">            sum+=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成输出</span></span><br><span class=\"line\">        <span class=\"comment\">//本次循环走完后变量sum被销毁，然后进入下一次循环,完成重置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>2.在循环外部声明变量，然后在<strong>循环末尾</strong>手动重置变量</p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;<span class=\"comment\">//声明在循环外部</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);<span class=\"comment\">//获取循环次数n</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;n;i++)<span class=\"comment\">//创建循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//以下完成一组输入输出</span></span><br><span class=\"line\">        <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//储存输入的数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j =<span class=\"number\">0</span>;j&lt;<span class=\"number\">3</span>;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num);</span><br><span class=\"line\">            sum+=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成输出</span></span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;<span class=\"comment\">//重置sum</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"要不要用数组储存输入，或储存结果再一次性输出？\"><a href=\"#要不要用数组储存输入，或储存结果再一次性输出？\" class=\"headerlink\" title=\"要不要用数组储存输入，或储存结果再一次性输出？\"></a>要不要用数组储存输入，或储存结果再一次性输出？</h2><p>答案是：<strong>可以，但没必要</strong>。</p>\n<p>只需要像上图那么写即可，因为输入是一次性喂进去的 。存数组再输出，和每产生一个结果就输出一次，最终呈现出来是一样的（如下图）</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/%E5%A4%9A%E7%BB%84%E8%BE%93%E5%87%BA.gif\"></p>\n<h1 id=\"现在，勇士，来挑战多组输入吧\"><a href=\"#现在，勇士，来挑战多组输入吧\" class=\"headerlink\" title=\"现在，勇士，来挑战多组输入吧\"></a>现在，勇士，来挑战多组输入吧</h1><h2 id=\"scanf的返回值\"><a href=\"#scanf的返回值\" class=\"headerlink\" title=\"scanf的返回值\"></a>scanf的返回值</h2><p>多组输入时，究竟会输入多少组数据，也不告诉你了，<strong>但是</strong>，此时<code>scanf</code>的返回值就派上用场了。和我们在终端手打输入不同,OJ的输入是喂一个文件进去，所以当<strong>输入结束时</strong>，<code>scanf</code>的返回值是<code>EOF</code><em>(意为文件结尾end of file)</em>,而当成功输入数据时，则会返回输入数据的个数(文档截图如下)</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-20_20-46-54.jpg\"></p>\n<h2 id=\"结合循环\"><a href=\"#结合循环\" class=\"headerlink\" title=\"结合循环\"></a>结合循环</h2><p>那么就把<code>scanf</code>放入<code>while</code>循环吧,每次试图获取下一组输入时，检测是否返回值为<code>EOF</code>,若是，则跳出循环，结束程序；若否，则继续循环</p>\n<p><em>以下面这个一次求和3个数的程序为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num = <span class=\"number\">0</span>;<span class=\"comment\">//先声明至少一个待输入的变量</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n) != EOF)<span class=\"comment\">//创建循环，每次循环开始时scanf一次，并检测是否返回EOF</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//开始构建循坏体</span></span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        sum+=n;</span><br><span class=\"line\">        <span class=\"comment\">//完成剩下的两次输入</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span> - <span class=\"number\">1</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">            sum+=n</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sum);<span class=\"comment\">//完成一次输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//scanf返回EOF后跳出循环</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h2><p>以后再要写<code>多组输入</code>，基本就像上面那个程序一样</p>\n<p>1.先声明至少一个待输入的变量</p>\n<p>2.创建循环，每次循环开始时scanf一次，并检测是否返回EOF</p>\n<p>3.开始构建循坏体(包括完成剩下的输入,完成一组输出)<strong>别忘了回车！！！</strong></p>\n<p>4.直至scanf返回EOF后跳出循环</p>\n<h1 id=\"想模拟一下多组输入看看？\"><a href=\"#想模拟一下多组输入看看？\" class=\"headerlink\" title=\"想模拟一下多组输入看看？\"></a>想模拟一下多组输入看看？</h1><p>像下图一样每组数据间加个<code>空格</code>就行，什么？题目的样例输入有<code>回车</code>？不用管它，放心大胆地<code>换成空格</code>就行。自己<code>测试</code>程序，只需要<strong>输出</strong>一样就行，至于怎么输入，<strong>没必要</strong>和题目一模一样</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/mutiInpuut.gif\"></p>\n<h1 id=\"注意！！！不要试图在终端停止程序\"><a href=\"#注意！！！不要试图在终端停止程序\" class=\"headerlink\" title=\"注意！！！不要试图在终端停止程序\"></a>注意！！！不要试图在终端停止程序</h1><p>因为和OJ不同，在本地运行程序时，不是文件输入，而是终端输入,没法让<code>scanf</code>返回<code>EOF</code>,<del>炫迈，根本停不来</del></p>\n<p>你要是想立即<code>中断</code>程序，那就按<code>ctrl+c</code></p>\n"},{"title":"=Linux=一步步自己写一个shell程序","date":"2024-06-03T16:13:55.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/craftTerminal.png","_content":"\n***\n系统：阿里云服务器Linux CentOs 7\n\n编辑器: vim \n\n编译器: gcc (支持C99)\n***\n\n# 文件\n本次写的程序较为简单，所以只使用一个源文件\n\n所以在shell中`touch`一个`makefile`和一个`myshell.c`\n> shell\n```Linux\ntouch makefile\ntouch myshell.c\n```\n\n然后编辑`makefile`文件\n> makefile\n\n```makefile\n1 myshell:myshell.c                         \n  gcc -o $@ $^ -std=c99\n\n.PHONY:clean\nclean:\n   rm -f myshell\n```\n# 头文件\n本程序因函数较杂，会`include`较多头文件\n\n> myshell.c\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n```\n\n# 宏定义\n为了统一修改部分参数，以及使参数更易读，这里使用部分宏定义\n> myshell.c\n```C\n#define LEFT \"[\"\n#define RIGHT \"]\"\n#define LABEL \"# \"//注意有个空格\n\n#define LINE_SIZE 1024\n#define ARGC_SIZE 32\n#define DLIM \" \\t\" //可能有多个分隔符\n#define EXIT_CODE 446 //特殊的退出码，表示程序未正常退出，具体数字目前没有约定\n```\n\n# 全局变量\n我们需要用全局的变量来存储`命令行`(command line)和`参数包`\n\n> myshell.c\n```C\nchar cline[LINE_SIZE];\nchar* arg[ARGC_SIZE];\nint last_code = 0;\n```\n\n# 用`Interact`函数实现交互功能\n\n## 打印命令行头部\n为了打印命令行头部，我们需要知道三样东西：用户，主机，工作路径，这里包装了三个函数来分别调用`getenv`函数\n\n> myshell.c\n```C\nconst char* getusername()//获取用户名\n{\n    return getenv(\"USER\");\n}\n\nconst char* gethostname()//获取主机名\n{\n    return getenv(\"HOSTNAME\");\n}\n\nconst char* getpwd()//获取工作路径\n{\n    return getenv(\"PWD\");\n}\n\n```\n\n因此打印的代码为\n```C\nprintf(LEFT \"%s@%s %s\" RIGHT LABLE,getusername(),gethostname(),getpwd());\n```\n\n## 获取命令行\n使用Linux的终端时，我们会打`命令+空格+参数...`,因此我们的`myshell`程序也要支持连空格一起读入,读入一整行命令\n\n所以`scanf`并不适合用来读入命令，这次我们使用`fgets`函数，这个函数可以从`文件流`中整行读入，而正好在终端输入的字符都储存在`标准输入流`,即`stdin`中,因此可以用一行代码获取`命令行`\n\n为安全考虑，这里使用一个临时变量`s`来接受`fgets`的返回值并用`assert`判空,但在`release`版本中`assert`不被编译，导致变量`s`未被调用，而报警告（甚至报错），所以还要再加一句`(void) s`,只为了调用一下`s`,没有更多用处\n\n之后便完成了文件流的读取\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-25-34.png)\n\n但此时获得的命令行在`\\0`前以`\\n`结尾，所以要把`\\n`替换为`\\0`\n\n```C\nchar *s = fgets(cline,size,stdin);\nassert(s);//s为空时报错\n(void) s;//防止因未调用s而报警告\n\ncline[strlen(cline) - 1] = '\\0';\n```\n\n## 整个函数体\n> myshell.c\n```C\nvoid Interact(char* cline,int size)\n{\n    printf(LEFT \"%s@%s %s\" RIGHT LABLE,getusername(),gethostname(),getpwd());//打印头部\n    fgets(cline,size,stdin);//获取命令行\n    assert(s);//s为空时报错\n    (void) s;//防止因未调用s而报警告\n    cline[strlen(cline) - 1] = '\\0';\n\n    printf(\"echo: %s\\n\");//写一段测一段的测试代码，输出获取的命令行,测完可删\n}\n```\n\n## 测试\n先在`main`函数里调用一次`Interact`函数测试一下\n\n我的测试结果如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-42-55.png)\n\n可以看到达到了预期效果，但是`工作路径`太长了，还是学一学Linux的展示方式吧，我们来把`getpwd`函数重写一下\n\n## 重写`getpwd()`\n```C\nconst char* getpwd()\n{\n    const char* pwd = getenv(\"PWD\");\n    int n = strlen(pwd);\n    while(n)\n    {\n        if(pwd[n] == '/') break;\n        n--;\n    }\n    return (pwd+n+1);\n}\n```\n这样打印出的工作路径仅为当前文件夹，可以缩短很多长度\n\n# 分割命令行\n现在的`cline`中的命令行还是完整的一串，需要分割出命令和参数包，因此我们也封装一个函数`Splitcline`\n\n这里使用的是`string.h`中的`strtok`函数，可以用特定的单个或多个字符将字符串分割\n\n> myshell.c\n\n```C\nint Splitcline(char*cline,char** argv)\n{\n    memset(argv,0,sizeof(char*) * ARGV_SIZE);\n    int i = 1;\n    argv[0] = strtok(cline,DLIM);\n    if(argv[0])\n        while(argv[i++] == strtok(NULL,DLIM));\n\n    *argv_n = i-1;//输出型参数\n}\n\n```\n\n再写一段测试代码\n\n> myshell.c\n\n```C\nint main()\n{\n    Interact(cline,sizeof(cline));\n\n    Splitcline(cline,argv);\n    for(int i = 0;argv[i];i++)//逐行打印输出argv的内容\n    {\n        printf(\"%s\\n\",argv[i]);\n    }\n    return 0;\n}\n```\n\n# 执行外部命令\n通过`fork`函数创建子进程，然后用`execvp`替换子进程，通过环境变量`PATH`找到外部命令并替换到子进程执行，同时父进程`myshell`调用`waitpid`函数等待子进程结束，保证`myshell`程序正常运行\n\n> myshell.c\n\n```C\nvoid ExternalCommand()\n{\n    pid_t id = fork();\n    if(id <0)\n    {\n        perror(\"fork\");\n        return;\n    }\n    else if(id == 0)//child\n    {\n        execvp(argv[0],argv+1);//+1之后才是参数列表\n        exit(EXIT_CODE);\n    }\n    else\n    {\n        int status = 0;\n        pid_t rid = waitpid(id,&status,0);\n        if(rid == id)\n        {\n            last_code = WEXITSTATUS(status);\n        }\n        return;\n    }\n}\n```\n\n# 执行内建命令\n`shell`中并不是所有的命令都由子进程完成的，比如用`cd`命令改变工作路径，就不能让子进程去执行(~~否则只是改了子进程的路径~~),因此我们还需要加一个内建命令接口\n\n> myshell.c\n\n```C\nint BuildCommand(char* _argv[],int _argv_n)//处理内建命令\n{\n  if(_argv_n == 2 && strcmp(_argv[0],\"cd\")== 0)//特殊处理的命令1\n  {\n    chdir(argv[1]);\n    getpwd();\n    sprintf(getenv(\"PWD\"),\"%s\",pwd);\n    return 1;//完成执行返回1\n  }\n  //还可以继续else uf 加特殊处理的命令2,3,4,,,n\n  return 0;//未执行内建命令。返回0\n}\n\n```\n\n# 完成框架\n\n至此，把`main`函数组织好后，一个简单的`shell`代码框架就搭好了，可以根据需要继续扩展`内建命令`的内容，比如导出环境变量，实现`echo`指令等（略写）。\n\n> myshell.c\n\n```C\nint main()\n{\n   int quit = 0;\n   while(!quit)\n   {\n     Interact(cline,sizeof(cline));\n     int argv_n;\n     Splitcline(cline,argv,&argv_n);\n \n     if(argv_n == 0 )continue;\n     \n     int flag = BuildCommand(argv,argv_n);\n     if(!flag) ExeternalCommand();\n   }\n \n    return 0;                            \n}          \n```\n\n# 拓展\n这里的命令行处理并没有考虑`输入/输出重定向`,所以仍有较大的需要完善的地方\n\n## 源代码\n\n[点我去往github仓库](https://github.com/sis-shen/Linux_Code)。\n\n","source":"_posts/myshell.md","raw":"---\ntitle: =Linux=一步步自己写一个shell程序\ndate: 2024-06-04 00:13:55\ntags: Linux C\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/craftTerminal.png\n---\n\n***\n系统：阿里云服务器Linux CentOs 7\n\n编辑器: vim \n\n编译器: gcc (支持C99)\n***\n\n# 文件\n本次写的程序较为简单，所以只使用一个源文件\n\n所以在shell中`touch`一个`makefile`和一个`myshell.c`\n> shell\n```Linux\ntouch makefile\ntouch myshell.c\n```\n\n然后编辑`makefile`文件\n> makefile\n\n```makefile\n1 myshell:myshell.c                         \n  gcc -o $@ $^ -std=c99\n\n.PHONY:clean\nclean:\n   rm -f myshell\n```\n# 头文件\n本程序因函数较杂，会`include`较多头文件\n\n> myshell.c\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n```\n\n# 宏定义\n为了统一修改部分参数，以及使参数更易读，这里使用部分宏定义\n> myshell.c\n```C\n#define LEFT \"[\"\n#define RIGHT \"]\"\n#define LABEL \"# \"//注意有个空格\n\n#define LINE_SIZE 1024\n#define ARGC_SIZE 32\n#define DLIM \" \\t\" //可能有多个分隔符\n#define EXIT_CODE 446 //特殊的退出码，表示程序未正常退出，具体数字目前没有约定\n```\n\n# 全局变量\n我们需要用全局的变量来存储`命令行`(command line)和`参数包`\n\n> myshell.c\n```C\nchar cline[LINE_SIZE];\nchar* arg[ARGC_SIZE];\nint last_code = 0;\n```\n\n# 用`Interact`函数实现交互功能\n\n## 打印命令行头部\n为了打印命令行头部，我们需要知道三样东西：用户，主机，工作路径，这里包装了三个函数来分别调用`getenv`函数\n\n> myshell.c\n```C\nconst char* getusername()//获取用户名\n{\n    return getenv(\"USER\");\n}\n\nconst char* gethostname()//获取主机名\n{\n    return getenv(\"HOSTNAME\");\n}\n\nconst char* getpwd()//获取工作路径\n{\n    return getenv(\"PWD\");\n}\n\n```\n\n因此打印的代码为\n```C\nprintf(LEFT \"%s@%s %s\" RIGHT LABLE,getusername(),gethostname(),getpwd());\n```\n\n## 获取命令行\n使用Linux的终端时，我们会打`命令+空格+参数...`,因此我们的`myshell`程序也要支持连空格一起读入,读入一整行命令\n\n所以`scanf`并不适合用来读入命令，这次我们使用`fgets`函数，这个函数可以从`文件流`中整行读入，而正好在终端输入的字符都储存在`标准输入流`,即`stdin`中,因此可以用一行代码获取`命令行`\n\n为安全考虑，这里使用一个临时变量`s`来接受`fgets`的返回值并用`assert`判空,但在`release`版本中`assert`不被编译，导致变量`s`未被调用，而报警告（甚至报错），所以还要再加一句`(void) s`,只为了调用一下`s`,没有更多用处\n\n之后便完成了文件流的读取\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-25-34.png)\n\n但此时获得的命令行在`\\0`前以`\\n`结尾，所以要把`\\n`替换为`\\0`\n\n```C\nchar *s = fgets(cline,size,stdin);\nassert(s);//s为空时报错\n(void) s;//防止因未调用s而报警告\n\ncline[strlen(cline) - 1] = '\\0';\n```\n\n## 整个函数体\n> myshell.c\n```C\nvoid Interact(char* cline,int size)\n{\n    printf(LEFT \"%s@%s %s\" RIGHT LABLE,getusername(),gethostname(),getpwd());//打印头部\n    fgets(cline,size,stdin);//获取命令行\n    assert(s);//s为空时报错\n    (void) s;//防止因未调用s而报警告\n    cline[strlen(cline) - 1] = '\\0';\n\n    printf(\"echo: %s\\n\");//写一段测一段的测试代码，输出获取的命令行,测完可删\n}\n```\n\n## 测试\n先在`main`函数里调用一次`Interact`函数测试一下\n\n我的测试结果如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-42-55.png)\n\n可以看到达到了预期效果，但是`工作路径`太长了，还是学一学Linux的展示方式吧，我们来把`getpwd`函数重写一下\n\n## 重写`getpwd()`\n```C\nconst char* getpwd()\n{\n    const char* pwd = getenv(\"PWD\");\n    int n = strlen(pwd);\n    while(n)\n    {\n        if(pwd[n] == '/') break;\n        n--;\n    }\n    return (pwd+n+1);\n}\n```\n这样打印出的工作路径仅为当前文件夹，可以缩短很多长度\n\n# 分割命令行\n现在的`cline`中的命令行还是完整的一串，需要分割出命令和参数包，因此我们也封装一个函数`Splitcline`\n\n这里使用的是`string.h`中的`strtok`函数，可以用特定的单个或多个字符将字符串分割\n\n> myshell.c\n\n```C\nint Splitcline(char*cline,char** argv)\n{\n    memset(argv,0,sizeof(char*) * ARGV_SIZE);\n    int i = 1;\n    argv[0] = strtok(cline,DLIM);\n    if(argv[0])\n        while(argv[i++] == strtok(NULL,DLIM));\n\n    *argv_n = i-1;//输出型参数\n}\n\n```\n\n再写一段测试代码\n\n> myshell.c\n\n```C\nint main()\n{\n    Interact(cline,sizeof(cline));\n\n    Splitcline(cline,argv);\n    for(int i = 0;argv[i];i++)//逐行打印输出argv的内容\n    {\n        printf(\"%s\\n\",argv[i]);\n    }\n    return 0;\n}\n```\n\n# 执行外部命令\n通过`fork`函数创建子进程，然后用`execvp`替换子进程，通过环境变量`PATH`找到外部命令并替换到子进程执行，同时父进程`myshell`调用`waitpid`函数等待子进程结束，保证`myshell`程序正常运行\n\n> myshell.c\n\n```C\nvoid ExternalCommand()\n{\n    pid_t id = fork();\n    if(id <0)\n    {\n        perror(\"fork\");\n        return;\n    }\n    else if(id == 0)//child\n    {\n        execvp(argv[0],argv+1);//+1之后才是参数列表\n        exit(EXIT_CODE);\n    }\n    else\n    {\n        int status = 0;\n        pid_t rid = waitpid(id,&status,0);\n        if(rid == id)\n        {\n            last_code = WEXITSTATUS(status);\n        }\n        return;\n    }\n}\n```\n\n# 执行内建命令\n`shell`中并不是所有的命令都由子进程完成的，比如用`cd`命令改变工作路径，就不能让子进程去执行(~~否则只是改了子进程的路径~~),因此我们还需要加一个内建命令接口\n\n> myshell.c\n\n```C\nint BuildCommand(char* _argv[],int _argv_n)//处理内建命令\n{\n  if(_argv_n == 2 && strcmp(_argv[0],\"cd\")== 0)//特殊处理的命令1\n  {\n    chdir(argv[1]);\n    getpwd();\n    sprintf(getenv(\"PWD\"),\"%s\",pwd);\n    return 1;//完成执行返回1\n  }\n  //还可以继续else uf 加特殊处理的命令2,3,4,,,n\n  return 0;//未执行内建命令。返回0\n}\n\n```\n\n# 完成框架\n\n至此，把`main`函数组织好后，一个简单的`shell`代码框架就搭好了，可以根据需要继续扩展`内建命令`的内容，比如导出环境变量，实现`echo`指令等（略写）。\n\n> myshell.c\n\n```C\nint main()\n{\n   int quit = 0;\n   while(!quit)\n   {\n     Interact(cline,sizeof(cline));\n     int argv_n;\n     Splitcline(cline,argv,&argv_n);\n \n     if(argv_n == 0 )continue;\n     \n     int flag = BuildCommand(argv,argv_n);\n     if(!flag) ExeternalCommand();\n   }\n \n    return 0;                            \n}          \n```\n\n# 拓展\n这里的命令行处理并没有考虑`输入/输出重定向`,所以仍有较大的需要完善的地方\n\n## 源代码\n\n[点我去往github仓库](https://github.com/sis-shen/Linux_Code)。\n\n","slug":"myshell","published":1,"updated":"2024-06-18T14:38:21.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08i001b4sp55qv827ki","content":"<hr>\n<p>系统：阿里云服务器Linux CentOs 7</p>\n<p>编辑器: vim </p>\n<p>编译器: gcc (支持C99)</p>\n<hr>\n<h1 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h1><p>本次写的程序较为简单，所以只使用一个源文件</p>\n<p>所以在shell中<code>touch</code>一个<code>makefile</code>和一个<code>myshell.c</code></p>\n<blockquote>\n<p>shell</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch makefile</span><br><span class=\"line\">touch myshell.c</span><br></pre></td></tr></table></figure>\n\n<p>然后编辑<code>makefile</code>文件</p>\n<blockquote>\n<p>makefile</p>\n</blockquote>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 myshell:myshell.c                         </span><br><span class=\"line\">  gcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> -std=c99</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:clean</span></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">   rm -f myshell</span><br></pre></td></tr></table></figure>\n<h1 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h1><p>本程序因函数较杂，会<code>include</code>较多头文件</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"宏定义\"><a href=\"#宏定义\" class=\"headerlink\" title=\"宏定义\"></a>宏定义</h1><p>为了统一修改部分参数，以及使参数更易读，这里使用部分宏定义</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LEFT <span class=\"string\">&quot;[&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RIGHT <span class=\"string\">&quot;]&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LABEL <span class=\"string\">&quot;# &quot;</span><span class=\"comment\">//注意有个空格</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LINE_SIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ARGC_SIZE 32</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DLIM <span class=\"string\">&quot; \\t&quot;</span> <span class=\"comment\">//可能有多个分隔符</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXIT_CODE 446 <span class=\"comment\">//特殊的退出码，表示程序未正常退出，具体数字目前没有约定</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h1><p>我们需要用全局的变量来存储<code>命令行</code>(command line)和<code>参数包</code></p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> cline[LINE_SIZE];</span><br><span class=\"line\"><span class=\"type\">char</span>* arg[ARGC_SIZE];</span><br><span class=\"line\"><span class=\"type\">int</span> last_code = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用Interact函数实现交互功能\"><a href=\"#用Interact函数实现交互功能\" class=\"headerlink\" title=\"用Interact函数实现交互功能\"></a>用<code>Interact</code>函数实现交互功能</h1><h2 id=\"打印命令行头部\"><a href=\"#打印命令行头部\" class=\"headerlink\" title=\"打印命令行头部\"></a>打印命令行头部</h2><p>为了打印命令行头部，我们需要知道三样东西：用户，主机，工作路径，这里包装了三个函数来分别调用<code>getenv</code>函数</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title function_\">getusername</span><span class=\"params\">()</span><span class=\"comment\">//获取用户名</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getenv(<span class=\"string\">&quot;USER&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title function_\">gethostname</span><span class=\"params\">()</span><span class=\"comment\">//获取主机名</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getenv(<span class=\"string\">&quot;HOSTNAME&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title function_\">getpwd</span><span class=\"params\">()</span><span class=\"comment\">//获取工作路径</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getenv(<span class=\"string\">&quot;PWD&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>因此打印的代码为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(LEFT <span class=\"string\">&quot;%s@%s %s&quot;</span> RIGHT LABLE,getusername(),gethostname(),getpwd());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"获取命令行\"><a href=\"#获取命令行\" class=\"headerlink\" title=\"获取命令行\"></a>获取命令行</h2><p>使用Linux的终端时，我们会打<code>命令+空格+参数...</code>,因此我们的<code>myshell</code>程序也要支持连空格一起读入,读入一整行命令</p>\n<p>所以<code>scanf</code>并不适合用来读入命令，这次我们使用<code>fgets</code>函数，这个函数可以从<code>文件流</code>中整行读入，而正好在终端输入的字符都储存在<code>标准输入流</code>,即<code>stdin</code>中,因此可以用一行代码获取<code>命令行</code></p>\n<p>为安全考虑，这里使用一个临时变量<code>s</code>来接受<code>fgets</code>的返回值并用<code>assert</code>判空,但在<code>release</code>版本中<code>assert</code>不被编译，导致变量<code>s</code>未被调用，而报警告（甚至报错），所以还要再加一句<code>(void) s</code>,只为了调用一下<code>s</code>,没有更多用处</p>\n<p>之后便完成了文件流的读取</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-25-34.png\"></p>\n<p>但此时获得的命令行在<code>\\0</code>前以<code>\\n</code>结尾，所以要把<code>\\n</code>替换为<code>\\0</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> *s = fgets(cline,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">assert(s);<span class=\"comment\">//s为空时报错</span></span><br><span class=\"line\">(<span class=\"type\">void</span>) s;<span class=\"comment\">//防止因未调用s而报警告</span></span><br><span class=\"line\"></span><br><span class=\"line\">cline[<span class=\"built_in\">strlen</span>(cline) - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"整个函数体\"><a href=\"#整个函数体\" class=\"headerlink\" title=\"整个函数体\"></a>整个函数体</h2><blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Interact</span><span class=\"params\">(<span class=\"type\">char</span>* cline,<span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(LEFT <span class=\"string\">&quot;%s@%s %s&quot;</span> RIGHT LABLE,getusername(),gethostname(),getpwd());<span class=\"comment\">//打印头部</span></span><br><span class=\"line\">    fgets(cline,size,<span class=\"built_in\">stdin</span>);<span class=\"comment\">//获取命令行</span></span><br><span class=\"line\">    assert(s);<span class=\"comment\">//s为空时报错</span></span><br><span class=\"line\">    (<span class=\"type\">void</span>) s;<span class=\"comment\">//防止因未调用s而报警告</span></span><br><span class=\"line\">    cline[<span class=\"built_in\">strlen</span>(cline) - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;echo: %s\\n&quot;</span>);<span class=\"comment\">//写一段测一段的测试代码，输出获取的命令行,测完可删</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>先在<code>main</code>函数里调用一次<code>Interact</code>函数测试一下</p>\n<p>我的测试结果如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-42-55.png\"></p>\n<p>可以看到达到了预期效果，但是<code>工作路径</code>太长了，还是学一学Linux的展示方式吧，我们来把<code>getpwd</code>函数重写一下</p>\n<h2 id=\"重写getpwd\"><a href=\"#重写getpwd\" class=\"headerlink\" title=\"重写getpwd()\"></a>重写<code>getpwd()</code></h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title function_\">getpwd</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* pwd = getenv(<span class=\"string\">&quot;PWD&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"built_in\">strlen</span>(pwd);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pwd[n] == <span class=\"string\">&#x27;/&#x27;</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        n--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (pwd+n+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样打印出的工作路径仅为当前文件夹，可以缩短很多长度</p>\n<h1 id=\"分割命令行\"><a href=\"#分割命令行\" class=\"headerlink\" title=\"分割命令行\"></a>分割命令行</h1><p>现在的<code>cline</code>中的命令行还是完整的一串，需要分割出命令和参数包，因此我们也封装一个函数<code>Splitcline</code></p>\n<p>这里使用的是<code>string.h</code>中的<code>strtok</code>函数，可以用特定的单个或多个字符将字符串分割</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Splitcline</span><span class=\"params\">(<span class=\"type\">char</span>*cline,<span class=\"type\">char</span>** argv)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(argv,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>*) * ARGV_SIZE);</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    argv[<span class=\"number\">0</span>] = strtok(cline,DLIM);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(argv[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(argv[i++] == strtok(<span class=\"literal\">NULL</span>,DLIM));</span><br><span class=\"line\"></span><br><span class=\"line\">    *argv_n = i<span class=\"number\">-1</span>;<span class=\"comment\">//输出型参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>再写一段测试代码</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Interact(cline,<span class=\"keyword\">sizeof</span>(cline));</span><br><span class=\"line\"></span><br><span class=\"line\">    Splitcline(cline,argv);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;argv[i];i++)<span class=\"comment\">//逐行打印输出argv的内容</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,argv[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"执行外部命令\"><a href=\"#执行外部命令\" class=\"headerlink\" title=\"执行外部命令\"></a>执行外部命令</h1><p>通过<code>fork</code>函数创建子进程，然后用<code>execvp</code>替换子进程，通过环境变量<code>PATH</code>找到外部命令并替换到子进程执行，同时父进程<code>myshell</code>调用<code>waitpid</code>函数等待子进程结束，保证<code>myshell</code>程序正常运行</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ExternalCommand</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id &lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;fork&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)<span class=\"comment\">//child</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        execvp(argv[<span class=\"number\">0</span>],argv+<span class=\"number\">1</span>);<span class=\"comment\">//+1之后才是参数列表</span></span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_CODE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> status = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">pid_t</span> rid = waitpid(id,&amp;status,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rid == id)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            last_code = WEXITSTATUS(status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"执行内建命令\"><a href=\"#执行内建命令\" class=\"headerlink\" title=\"执行内建命令\"></a>执行内建命令</h1><p><code>shell</code>中并不是所有的命令都由子进程完成的，比如用<code>cd</code>命令改变工作路径，就不能让子进程去执行(<del>否则只是改了子进程的路径</del>),因此我们还需要加一个内建命令接口</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">BuildCommand</span><span class=\"params\">(<span class=\"type\">char</span>* _argv[],<span class=\"type\">int</span> _argv_n)</span><span class=\"comment\">//处理内建命令</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(_argv_n == <span class=\"number\">2</span> &amp;&amp; <span class=\"built_in\">strcmp</span>(_argv[<span class=\"number\">0</span>],<span class=\"string\">&quot;cd&quot;</span>)== <span class=\"number\">0</span>)<span class=\"comment\">//特殊处理的命令1</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    chdir(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    getpwd();</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(getenv(<span class=\"string\">&quot;PWD&quot;</span>),<span class=\"string\">&quot;%s&quot;</span>,pwd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;<span class=\"comment\">//完成执行返回1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//还可以继续else uf 加特殊处理的命令2,3,4,,,n</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//未执行内建命令。返回0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"完成框架\"><a href=\"#完成框架\" class=\"headerlink\" title=\"完成框架\"></a>完成框架</h1><p>至此，把<code>main</code>函数组织好后，一个简单的<code>shell</code>代码框架就搭好了，可以根据需要继续扩展<code>内建命令</code>的内容，比如导出环境变量，实现<code>echo</code>指令等（略写）。</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> quit = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span>(!quit)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     Interact(cline,<span class=\"keyword\">sizeof</span>(cline));</span><br><span class=\"line\">     <span class=\"type\">int</span> argv_n;</span><br><span class=\"line\">     Splitcline(cline,argv,&amp;argv_n);</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"keyword\">if</span>(argv_n == <span class=\"number\">0</span> )<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"type\">int</span> flag = BuildCommand(argv,argv_n);</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(!flag) ExeternalCommand();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;                            </span><br><span class=\"line\">&#125;          </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h1><p>这里的命令行处理并没有考虑<code>输入/输出重定向</code>,所以仍有较大的需要完善的地方</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><p><a href=\"https://github.com/sis-shen/Linux_Code\">点我去往github仓库</a>。</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<hr>\n<p>系统：阿里云服务器Linux CentOs 7</p>\n<p>编辑器: vim </p>\n<p>编译器: gcc (支持C99)</p>\n<hr>\n<h1 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h1><p>本次写的程序较为简单，所以只使用一个源文件</p>\n<p>所以在shell中<code>touch</code>一个<code>makefile</code>和一个<code>myshell.c</code></p>\n<blockquote>\n<p>shell</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch makefile</span><br><span class=\"line\">touch myshell.c</span><br></pre></td></tr></table></figure>\n\n<p>然后编辑<code>makefile</code>文件</p>\n<blockquote>\n<p>makefile</p>\n</blockquote>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 myshell:myshell.c                         </span><br><span class=\"line\">  gcc -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> -std=c99</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:clean</span></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">   rm -f myshell</span><br></pre></td></tr></table></figure>\n<h1 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h1><p>本程序因函数较杂，会<code>include</code>较多头文件</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"宏定义\"><a href=\"#宏定义\" class=\"headerlink\" title=\"宏定义\"></a>宏定义</h1><p>为了统一修改部分参数，以及使参数更易读，这里使用部分宏定义</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LEFT <span class=\"string\">&quot;[&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RIGHT <span class=\"string\">&quot;]&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LABEL <span class=\"string\">&quot;# &quot;</span><span class=\"comment\">//注意有个空格</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LINE_SIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ARGC_SIZE 32</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DLIM <span class=\"string\">&quot; \\t&quot;</span> <span class=\"comment\">//可能有多个分隔符</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXIT_CODE 446 <span class=\"comment\">//特殊的退出码，表示程序未正常退出，具体数字目前没有约定</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h1><p>我们需要用全局的变量来存储<code>命令行</code>(command line)和<code>参数包</code></p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> cline[LINE_SIZE];</span><br><span class=\"line\"><span class=\"type\">char</span>* arg[ARGC_SIZE];</span><br><span class=\"line\"><span class=\"type\">int</span> last_code = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用Interact函数实现交互功能\"><a href=\"#用Interact函数实现交互功能\" class=\"headerlink\" title=\"用Interact函数实现交互功能\"></a>用<code>Interact</code>函数实现交互功能</h1><h2 id=\"打印命令行头部\"><a href=\"#打印命令行头部\" class=\"headerlink\" title=\"打印命令行头部\"></a>打印命令行头部</h2><p>为了打印命令行头部，我们需要知道三样东西：用户，主机，工作路径，这里包装了三个函数来分别调用<code>getenv</code>函数</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title function_\">getusername</span><span class=\"params\">()</span><span class=\"comment\">//获取用户名</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getenv(<span class=\"string\">&quot;USER&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title function_\">gethostname</span><span class=\"params\">()</span><span class=\"comment\">//获取主机名</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getenv(<span class=\"string\">&quot;HOSTNAME&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title function_\">getpwd</span><span class=\"params\">()</span><span class=\"comment\">//获取工作路径</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getenv(<span class=\"string\">&quot;PWD&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>因此打印的代码为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(LEFT <span class=\"string\">&quot;%s@%s %s&quot;</span> RIGHT LABLE,getusername(),gethostname(),getpwd());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"获取命令行\"><a href=\"#获取命令行\" class=\"headerlink\" title=\"获取命令行\"></a>获取命令行</h2><p>使用Linux的终端时，我们会打<code>命令+空格+参数...</code>,因此我们的<code>myshell</code>程序也要支持连空格一起读入,读入一整行命令</p>\n<p>所以<code>scanf</code>并不适合用来读入命令，这次我们使用<code>fgets</code>函数，这个函数可以从<code>文件流</code>中整行读入，而正好在终端输入的字符都储存在<code>标准输入流</code>,即<code>stdin</code>中,因此可以用一行代码获取<code>命令行</code></p>\n<p>为安全考虑，这里使用一个临时变量<code>s</code>来接受<code>fgets</code>的返回值并用<code>assert</code>判空,但在<code>release</code>版本中<code>assert</code>不被编译，导致变量<code>s</code>未被调用，而报警告（甚至报错），所以还要再加一句<code>(void) s</code>,只为了调用一下<code>s</code>,没有更多用处</p>\n<p>之后便完成了文件流的读取</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-25-34.png\"></p>\n<p>但此时获得的命令行在<code>\\0</code>前以<code>\\n</code>结尾，所以要把<code>\\n</code>替换为<code>\\0</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> *s = fgets(cline,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">assert(s);<span class=\"comment\">//s为空时报错</span></span><br><span class=\"line\">(<span class=\"type\">void</span>) s;<span class=\"comment\">//防止因未调用s而报警告</span></span><br><span class=\"line\"></span><br><span class=\"line\">cline[<span class=\"built_in\">strlen</span>(cline) - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"整个函数体\"><a href=\"#整个函数体\" class=\"headerlink\" title=\"整个函数体\"></a>整个函数体</h2><blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Interact</span><span class=\"params\">(<span class=\"type\">char</span>* cline,<span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(LEFT <span class=\"string\">&quot;%s@%s %s&quot;</span> RIGHT LABLE,getusername(),gethostname(),getpwd());<span class=\"comment\">//打印头部</span></span><br><span class=\"line\">    fgets(cline,size,<span class=\"built_in\">stdin</span>);<span class=\"comment\">//获取命令行</span></span><br><span class=\"line\">    assert(s);<span class=\"comment\">//s为空时报错</span></span><br><span class=\"line\">    (<span class=\"type\">void</span>) s;<span class=\"comment\">//防止因未调用s而报警告</span></span><br><span class=\"line\">    cline[<span class=\"built_in\">strlen</span>(cline) - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;echo: %s\\n&quot;</span>);<span class=\"comment\">//写一段测一段的测试代码，输出获取的命令行,测完可删</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>先在<code>main</code>函数里调用一次<code>Interact</code>函数测试一下</p>\n<p>我的测试结果如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-06-04_16-42-55.png\"></p>\n<p>可以看到达到了预期效果，但是<code>工作路径</code>太长了，还是学一学Linux的展示方式吧，我们来把<code>getpwd</code>函数重写一下</p>\n<h2 id=\"重写getpwd\"><a href=\"#重写getpwd\" class=\"headerlink\" title=\"重写getpwd()\"></a>重写<code>getpwd()</code></h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title function_\">getpwd</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* pwd = getenv(<span class=\"string\">&quot;PWD&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"built_in\">strlen</span>(pwd);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pwd[n] == <span class=\"string\">&#x27;/&#x27;</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        n--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (pwd+n+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样打印出的工作路径仅为当前文件夹，可以缩短很多长度</p>\n<h1 id=\"分割命令行\"><a href=\"#分割命令行\" class=\"headerlink\" title=\"分割命令行\"></a>分割命令行</h1><p>现在的<code>cline</code>中的命令行还是完整的一串，需要分割出命令和参数包，因此我们也封装一个函数<code>Splitcline</code></p>\n<p>这里使用的是<code>string.h</code>中的<code>strtok</code>函数，可以用特定的单个或多个字符将字符串分割</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Splitcline</span><span class=\"params\">(<span class=\"type\">char</span>*cline,<span class=\"type\">char</span>** argv)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(argv,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>*) * ARGV_SIZE);</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    argv[<span class=\"number\">0</span>] = strtok(cline,DLIM);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(argv[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(argv[i++] == strtok(<span class=\"literal\">NULL</span>,DLIM));</span><br><span class=\"line\"></span><br><span class=\"line\">    *argv_n = i<span class=\"number\">-1</span>;<span class=\"comment\">//输出型参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>再写一段测试代码</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Interact(cline,<span class=\"keyword\">sizeof</span>(cline));</span><br><span class=\"line\"></span><br><span class=\"line\">    Splitcline(cline,argv);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;argv[i];i++)<span class=\"comment\">//逐行打印输出argv的内容</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,argv[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"执行外部命令\"><a href=\"#执行外部命令\" class=\"headerlink\" title=\"执行外部命令\"></a>执行外部命令</h1><p>通过<code>fork</code>函数创建子进程，然后用<code>execvp</code>替换子进程，通过环境变量<code>PATH</code>找到外部命令并替换到子进程执行，同时父进程<code>myshell</code>调用<code>waitpid</code>函数等待子进程结束，保证<code>myshell</code>程序正常运行</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ExternalCommand</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id &lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;fork&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)<span class=\"comment\">//child</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        execvp(argv[<span class=\"number\">0</span>],argv+<span class=\"number\">1</span>);<span class=\"comment\">//+1之后才是参数列表</span></span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_CODE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> status = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">pid_t</span> rid = waitpid(id,&amp;status,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rid == id)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            last_code = WEXITSTATUS(status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"执行内建命令\"><a href=\"#执行内建命令\" class=\"headerlink\" title=\"执行内建命令\"></a>执行内建命令</h1><p><code>shell</code>中并不是所有的命令都由子进程完成的，比如用<code>cd</code>命令改变工作路径，就不能让子进程去执行(<del>否则只是改了子进程的路径</del>),因此我们还需要加一个内建命令接口</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">BuildCommand</span><span class=\"params\">(<span class=\"type\">char</span>* _argv[],<span class=\"type\">int</span> _argv_n)</span><span class=\"comment\">//处理内建命令</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(_argv_n == <span class=\"number\">2</span> &amp;&amp; <span class=\"built_in\">strcmp</span>(_argv[<span class=\"number\">0</span>],<span class=\"string\">&quot;cd&quot;</span>)== <span class=\"number\">0</span>)<span class=\"comment\">//特殊处理的命令1</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    chdir(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    getpwd();</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(getenv(<span class=\"string\">&quot;PWD&quot;</span>),<span class=\"string\">&quot;%s&quot;</span>,pwd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;<span class=\"comment\">//完成执行返回1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//还可以继续else uf 加特殊处理的命令2,3,4,,,n</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//未执行内建命令。返回0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"完成框架\"><a href=\"#完成框架\" class=\"headerlink\" title=\"完成框架\"></a>完成框架</h1><p>至此，把<code>main</code>函数组织好后，一个简单的<code>shell</code>代码框架就搭好了，可以根据需要继续扩展<code>内建命令</code>的内容，比如导出环境变量，实现<code>echo</code>指令等（略写）。</p>\n<blockquote>\n<p>myshell.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> quit = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span>(!quit)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     Interact(cline,<span class=\"keyword\">sizeof</span>(cline));</span><br><span class=\"line\">     <span class=\"type\">int</span> argv_n;</span><br><span class=\"line\">     Splitcline(cline,argv,&amp;argv_n);</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"keyword\">if</span>(argv_n == <span class=\"number\">0</span> )<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"type\">int</span> flag = BuildCommand(argv,argv_n);</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(!flag) ExeternalCommand();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;                            </span><br><span class=\"line\">&#125;          </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h1><p>这里的命令行处理并没有考虑<code>输入/输出重定向</code>,所以仍有较大的需要完善的地方</p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><p><a href=\"https://github.com/sis-shen/Linux_Code\">点我去往github仓库</a>。</p>\n"},{"title":"=C语言=动态内存分配遇上函数-经典错误纠错","date":"2023-08-28T08:11:37.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-46-45.jpg","_content":"### 直接完整代码 #\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid GetMemory(char* p)   //申请内存\n{\n\tp = (char*)malloc(100);  \n}\n\nvoid Test()\n{\n\tchar* str = NULL;\n\tGetMemory(str);\n\tstrcpy(str, \"hello world\"); //复制字符串\n\tprintf(str);  //输出字符串\n}\n\nint main()\n{\n\tTest();\n\treturn 0;\n}\n```\n### 分析 #\n推测这段代码的的目的是通过``GetMemory``函数申请内存，然后把返回的地址存入指针变量``str``,再把字符串``\"hello world\"``复制到``str``所指向的内存中，最后``printf``输出\n\n#### 逐步纠错 #\n\n##### ``GetMemory`` #\n\n1. 首先是传参错误。若在函数内修改外部的一级指针，不能直接将外部一级指针作为**实参**传入：因为函数会将**实参**赋给**形参**，程序运行到大括号外面后，**形参**被销毁，**实参**没有变化。所以应该使用``char** p``二级指针作为**形参**,储存地址时使用``*p``\\\n2. 其次是内存泄漏。开辟的内存的地址并没有传递给实参，形参又最后销毁了，同时没有释放内存，函数运行完后申请的内存无法找到，导致最终无法释放，造成内存泄漏\n\n```C\n//更合适的代码\nvoid GetMenmory(char** p)\n{\n    *p = (char*)malloc(100);\n}\n\n```\n##### ``Test`` #\n1. NULL的大问题。假设``malloc``返回的地址已经存入``str``,但任然缺少对空指针的判断,导致``strcmp``中传入了空指针->报错;``printf``中传入空指针->报错\n2. 没有释放内存->内存泄漏。\n```C\n//更适合的代码\nvoid Test()\n{\n    char* str = NULL;\n    GetMemory(str);\n    if(str == MULL)\n    {\n        return;\n    }\n    strcpy(str,\"hello world\");\n    printf(\"%s\\n\",str);\n    free(str); //防止内存泄漏\n    str = NULL; //清除野指针\n}\n\n```\n","source":"_posts/mistake1.md","raw":"---\ntitle: =C语言=动态内存分配遇上函数-经典错误纠错\ndate: 2023-08-28 16:11:37\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-46-45.jpg\n---\n### 直接完整代码 #\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid GetMemory(char* p)   //申请内存\n{\n\tp = (char*)malloc(100);  \n}\n\nvoid Test()\n{\n\tchar* str = NULL;\n\tGetMemory(str);\n\tstrcpy(str, \"hello world\"); //复制字符串\n\tprintf(str);  //输出字符串\n}\n\nint main()\n{\n\tTest();\n\treturn 0;\n}\n```\n### 分析 #\n推测这段代码的的目的是通过``GetMemory``函数申请内存，然后把返回的地址存入指针变量``str``,再把字符串``\"hello world\"``复制到``str``所指向的内存中，最后``printf``输出\n\n#### 逐步纠错 #\n\n##### ``GetMemory`` #\n\n1. 首先是传参错误。若在函数内修改外部的一级指针，不能直接将外部一级指针作为**实参**传入：因为函数会将**实参**赋给**形参**，程序运行到大括号外面后，**形参**被销毁，**实参**没有变化。所以应该使用``char** p``二级指针作为**形参**,储存地址时使用``*p``\\\n2. 其次是内存泄漏。开辟的内存的地址并没有传递给实参，形参又最后销毁了，同时没有释放内存，函数运行完后申请的内存无法找到，导致最终无法释放，造成内存泄漏\n\n```C\n//更合适的代码\nvoid GetMenmory(char** p)\n{\n    *p = (char*)malloc(100);\n}\n\n```\n##### ``Test`` #\n1. NULL的大问题。假设``malloc``返回的地址已经存入``str``,但任然缺少对空指针的判断,导致``strcmp``中传入了空指针->报错;``printf``中传入空指针->报错\n2. 没有释放内存->内存泄漏。\n```C\n//更适合的代码\nvoid Test()\n{\n    char* str = NULL;\n    GetMemory(str);\n    if(str == MULL)\n    {\n        return;\n    }\n    strcpy(str,\"hello world\");\n    printf(\"%s\\n\",str);\n    free(str); //防止内存泄漏\n    str = NULL; //清除野指针\n}\n\n```\n","slug":"mistake1","published":1,"updated":"2023-11-14T00:32:03.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08k001d4sp55dj5d4il","content":"<h3 id=\"直接完整代码\"><a href=\"#直接完整代码\" class=\"headerlink\" title=\"直接完整代码\"></a>直接完整代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GetMemory</span><span class=\"params\">(<span class=\"type\">char</span>* p)</span>   <span class=\"comment\">//申请内存</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tp = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Test</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span>* str = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tGetMemory(str);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(str, <span class=\"string\">&quot;hello world&quot;</span>); <span class=\"comment\">//复制字符串</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(str);  <span class=\"comment\">//输出字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tTest();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>推测这段代码的的目的是通过<code>GetMemory</code>函数申请内存，然后把返回的地址存入指针变量<code>str</code>,再把字符串<code>&quot;hello world&quot;</code>复制到<code>str</code>所指向的内存中，最后<code>printf</code>输出</p>\n<h4 id=\"逐步纠错\"><a href=\"#逐步纠错\" class=\"headerlink\" title=\"逐步纠错\"></a>逐步纠错</h4><h5 id=\"GetMemory\"><a href=\"#GetMemory\" class=\"headerlink\" title=\"GetMemory\"></a><code>GetMemory</code></h5><ol>\n<li>首先是传参错误。若在函数内修改外部的一级指针，不能直接将外部一级指针作为<strong>实参</strong>传入：因为函数会将<strong>实参</strong>赋给<strong>形参</strong>，程序运行到大括号外面后，<strong>形参</strong>被销毁，<strong>实参</strong>没有变化。所以应该使用<code>char** p</code>二级指针作为<strong>形参</strong>,储存地址时使用<code>*p</code>\\</li>\n<li>其次是内存泄漏。开辟的内存的地址并没有传递给实参，形参又最后销毁了，同时没有释放内存，函数运行完后申请的内存无法找到，导致最终无法释放，造成内存泄漏</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//更合适的代码</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GetMenmory</span><span class=\"params\">(<span class=\"type\">char</span>** p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    *p = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a><code>Test</code></h5><ol>\n<li>NULL的大问题。假设<code>malloc</code>返回的地址已经存入<code>str</code>,但任然缺少对空指针的判断,导致<code>strcmp</code>中传入了空指针-&gt;报错;<code>printf</code>中传入空指针-&gt;报错</li>\n<li>没有释放内存-&gt;内存泄漏。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//更适合的代码</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Test</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* str = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    GetMemory(str);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str == MULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(str,<span class=\"string\">&quot;hello world&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,str);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(str); <span class=\"comment\">//防止内存泄漏</span></span><br><span class=\"line\">    str = <span class=\"literal\">NULL</span>; <span class=\"comment\">//清除野指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<h3 id=\"直接完整代码\"><a href=\"#直接完整代码\" class=\"headerlink\" title=\"直接完整代码\"></a>直接完整代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GetMemory</span><span class=\"params\">(<span class=\"type\">char</span>* p)</span>   <span class=\"comment\">//申请内存</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tp = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Test</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span>* str = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tGetMemory(str);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(str, <span class=\"string\">&quot;hello world&quot;</span>); <span class=\"comment\">//复制字符串</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(str);  <span class=\"comment\">//输出字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tTest();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>推测这段代码的的目的是通过<code>GetMemory</code>函数申请内存，然后把返回的地址存入指针变量<code>str</code>,再把字符串<code>&quot;hello world&quot;</code>复制到<code>str</code>所指向的内存中，最后<code>printf</code>输出</p>\n<h4 id=\"逐步纠错\"><a href=\"#逐步纠错\" class=\"headerlink\" title=\"逐步纠错\"></a>逐步纠错</h4><h5 id=\"GetMemory\"><a href=\"#GetMemory\" class=\"headerlink\" title=\"GetMemory\"></a><code>GetMemory</code></h5><ol>\n<li>首先是传参错误。若在函数内修改外部的一级指针，不能直接将外部一级指针作为<strong>实参</strong>传入：因为函数会将<strong>实参</strong>赋给<strong>形参</strong>，程序运行到大括号外面后，<strong>形参</strong>被销毁，<strong>实参</strong>没有变化。所以应该使用<code>char** p</code>二级指针作为<strong>形参</strong>,储存地址时使用<code>*p</code>\\</li>\n<li>其次是内存泄漏。开辟的内存的地址并没有传递给实参，形参又最后销毁了，同时没有释放内存，函数运行完后申请的内存无法找到，导致最终无法释放，造成内存泄漏</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//更合适的代码</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GetMenmory</span><span class=\"params\">(<span class=\"type\">char</span>** p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    *p = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a><code>Test</code></h5><ol>\n<li>NULL的大问题。假设<code>malloc</code>返回的地址已经存入<code>str</code>,但任然缺少对空指针的判断,导致<code>strcmp</code>中传入了空指针-&gt;报错;<code>printf</code>中传入空指针-&gt;报错</li>\n<li>没有释放内存-&gt;内存泄漏。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//更适合的代码</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Test</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* str = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    GetMemory(str);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str == MULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(str,<span class=\"string\">&quot;hello world&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,str);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(str); <span class=\"comment\">//防止内存泄漏</span></span><br><span class=\"line\">    str = <span class=\"literal\">NULL</span>; <span class=\"comment\">//清除野指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"进程间通信--匿名管道与命名管道","date":"2024-08-02T13:16:14.000Z","_content":"\n# 什么是管道文件\n首先，管道是Unix中最古老的进程间通信的形式。它用于进程间的**单向**通信\n\n那么具体是怎样实现的呢？从标题里就可以发现，是基于`文件`\n\n既然一个文件可以被多个进程打开，那么不妨将文件作为两个进程通信的**媒介**。但是一般位于磁盘上的文件，IO效率相比于`CPU`，`内存`之类的读写速度慢了几个数量级，但文件是可以被加载到内存中的，而专门建立在**内存中**,而没有磁盘文件，专门用于进程间通信的**内存级**文件，我们就叫它`管道文件`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-09_21-19-22.png)\n\n*管道文件由内核维护*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-10_17-52-20.png)\n*管道文件是单向的，可以是父进程->子进程，也可以子进程->父进程*\n\n## 管道读写规则\n+ 写端未关闭，但读端**无数据**可读时\n  + (默认)`O_NONBLOCK disable`：`read`调用阻塞，即进程暂停执行，一直等到有数据来到为止。\n  + `O_NONBLOCK enable`：`read`调用返回`-1`，`errno`值为`EAGAIN`。\n+ 读端未关闭，但写端写入管道已经**写满**时\n  + (默认)` O_NONBLOCK disable`： `write`调用阻塞，直到有进程读走数据\n  + `O_NONBLOCK enable`：`wrtie`调用返回`-1`，`errno`值为`EAGAIN`\n+ 若写端关闭,则`read`返回`0`\n+ 若读端关闭,则`write`操作会产生信号`SIGPIPE`,进而可能导致`write`进程**退出**\n\n### 原子性\n头文件提供了宏`PIPE_BUF`,规定了保证原子性读写操作的最大字节数\n\n+ 当要写入的数据量不大于`PIPE_BUF`时，linux将保证写入的原子性。\n+ 当要写入的数据量大于`PIPE_BUF`时，linux将不再保证写入的原子性。\n\n## 管道特点\n\n+ 管道提供流式服务\n+ 一般而言，进程退出，管道释放，所以管道的生命周期随进程\n+ 一般而言，内核会对管道操作进行**同步与互斥**\n+ 一个管道只有一个通信方向，数据只能向一个方向流动；需要**双方**通信时，需要建立起**两个**管道\n\n# 匿名管道\n匿名管道主要用于`父子进程`间的通信\n\n用到的接口是来自`<unistd.h>`的接口`pipe`\n\n`int pipe(int pipefd[2]);`\n\n可以看到有一个输出型参数`pipefd`数组，其中规定`pipefd[0]`储存了管道文件的`读端fd`,`pipefd[1]`储存了管道文件的`写端fd`\n\n要利用管道通信时，必须用`close`一方关闭写端而另一端关闭读端\n\n## 示例 子进程发送报文，父进程接受模型\n```C\n#include <iostream>\n#include <cstdlib>\n#include <unistd.h>\n#include <string>\n#include <cstring>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#define N 2\n#define NUM 1024\n\nusing namespace std;\n\n//child\nvoid Writer(int wfd)\n{\n    string s = \"hello,I am child\";//准备子进程的报文\n    pid_t self = getpid();\n    int number = 5;\n\n    char buffer[NUM] = {0};\n    while(number--)\n    {\n        buffer[0] = 0;//清空字符串\n        snprintf(buffer,sizeof(buffer),\"%s-%d-%d\\n\",s.c_str(),self,number);\n\n        //发送/写入报文\n        write(wfd,buffer,strlen(buffer));\n\n        sleep(1);\n    }\n}\n\n//father\nvoid Reader(int rfd)\n{\n    char buffer[NUM];\n\n    while(true)\n    {\n        buffer[0] = 0;\n        ssize_t n = read(rfd,buffer,sizeof(buffer));\n        if(n > 0)\n        {\n            buffer[n] = 0;//恢复成字符串\n            cout<<\"father get a message >> \"<<buffer<<endl;\n        }\n    }\n}\n\nint main()\n{\n    int pipefd[N] = {0};\n    \n    int n = pipe(pipefd);\n    if(n<0) return 1;\n\n    pid_t id = fork();\n    if(id  < 0) return 2;\n    else if(id == 0)\n    {\n        //子进程\n        close(pipefd[0]);//关闭读\n        \n        Writer(pipefd[1]);\n\n        close(pipefd[1]);\n        exit(0);\n    }\n    else\n    {\n        close(pipefd[1]);//关闭写\n\n        Reader(pipefd[0]);\n\n        pid_t rid = waitpid(id,nullptr,0);\n\n        if(id <0) return 3;\n\n        close(pipefd[0]);\n    }\n\n    return 0;\n}\n```\n\n## 小小项目--进程池\n详见[此博客🔗](https://www.supdriver.top/2024/08/02/processPool/)\n\n# 命名管道\n匿名管道无非实现不相关进程（无亲缘关系）的进程间通信，因此要用到命名管道来实现这个功能\n\n命名管道文件,即`FIFO`文件，是一种用于不相关进程间通信的特殊类型的文件\n\n## 命令行上创建\n使用`mkfifo`可以在命令行上创建命名管道\n\n例`mkfile fifo_file`\n\n## 程序内创建和删除\n使用接口`mkfifo`创建,注：要同时引用头文件`sys/types.h`和`sys/stat.h`\n\n函数声明如下\n\n`int mkfifo(const char *pathname, mode_t mode);`\n\n+ 返回值：成功时返回`0`,失败时返回`-1`,并设置`errno`\n+ `pathname`：文件名（当前目录），或者路径+文件名\n+ `mode` 新创建的管道文件的权限,一般用`0644`或`0664`\n\n使用`unlink`删除文件,引用自头文件`<unistd.h>`\n\n`int unlink(const char *pathname);`\n\n+ 返回值：成功时返回`0`,失败时返回`-1`,并设置`errno`\n+ `pathname`：文件名（当前目录），或者路径+文件名\n\n## 使用\n由一个进程`写模式`打开，同时由另一个进程`读模式`打开，便可建立进程间通信，其余操作与匿名管道相同\n\n## 命名管道的打开规则\n+ `读模式`打开`FIFO`文件时\n  + `O_NONBLOCK disable`：阻塞等待直到有相应进程为写而打开该`FIFO`\n  + `O_NONBLOCK enable`：立刻返回成功\n+ `写模式`打开`FIFO`文件时\n  + `O_NONBLOCK disable`：阻塞直到有相应进程为读而打开该`FIFO`\n  + ` O_NONBLOCK enable`：立刻返回失败，错误码为`ENXIO`\n\n## 示例 命名管道实现 客户端 向 服务端通信\n\n### makefile\n小技巧：这里在最前面使用伪目标`all`，这样在使用`make`命令时能编译多个目标文件\n\n```makefile\n.PHONY:all\nall:sever client\n\nsever:sever.cpp\n\tg++ -o $@ $^ -std=c++11\nclient:client.cpp\n\tg++ -o $@ $^ -std=c++11\n\n.PHONY:cl \ncl:\n\trm -f sever client\n```\n\n### comm.hpp\n使用同一个头文件能方便地统一`fifo`文件的路径，以及统一退出码的约定等\n\n```C++\n#pragma once\n\n#include <iostream>\n#include <errno.h>\n#include <cstring>\n#include <cstdlib>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#define FIFO_NAME \"./myfifo\" //设置管道文件名\n#define MODE 0664 //设置管道文件的权限\n\nenum//枚举错误码\n{\n    FIFO_CREAT_ERR = 1,\n    FIFO_DELETE_ERR,\n    FIFO_OPEN_ERR\n};\n```\n\n### sever.cpp\n\n```C++\n#include \"comm.hpp\"\n\nusing namespace std;\n\nint main()\n{\n    //创建信道\n    int n = mkfifo(FIFO_NAME,MODE);\n    if(n == -1)//创建失败\n    {\n        perror(\"mkfifo\");\n        exit(FIFO_CREAT_ERR);\n    }\n\n    //打开信道\n    int fd = open(FIFO_NAME,O_RDONLY);//只读模式打开FIFO\n    if(fd == -1)//打开失败\n    {\n        perror(\"open\");\n        exit(FIFO_OPEN_ERR);\n    }\n\n    //开始通信\n    cout<<\"[@]sever start running\"<<endl;\n    while(true)\n    {\n        char buffer[1024] = {0};\n        int sz = read(fd,buffer,sizeof(buffer)-1);//给结尾\\0预留位置\n        if(sz > 0)\n        {\n            buffer[sz] = 0;\n            cout<<\"client say# \"<<buffer<<endl;\n        }\n        else if(sz == 0)\n        {\n            //写端关闭\n            cout<<\"client quit, sever will quie later...\" <<endl;\n            break;\n        }\n        else break;\n    }\n\n    //关闭信道\n    close(fd);\n    int m = unlink(FIFO_NAME);\n    if(m == -1)\n    {\n        perror(\"unlink\");\n        exit(FIFO_DELETE_ERR);\n    }\n\n    return 0;\n}\n```\n\n### client.cpp\n\n```C++\n#include \"comm.hpp\"\n\nusing namespace std;\n\nint main()\n{\n    int fd = open(FIFO_NAME,O_WRONLY);//只读模式打开\n    if(fd <0)\n    {\n        perror(\"open\");\n        exit(FIFO_OPEN_ERR);\n    }\n\n    string line;\n    while(true)\n    {\n        cout<<\"Please enter@ \";\n        getline(cin,line);//获取输入\n\n        write(fd,line.c_str(),line.size());\n    }\n\n    close(fd);\n    return 0;\n}\n\n```\n### 实现效果\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-13_16-49-49.png)\n\n","source":"_posts/pipe.md","raw":"---\ntitle: 进程间通信--匿名管道与命名管道\ndate: 2024-08-02 21:16:14\ntags: Linux\n---\n\n# 什么是管道文件\n首先，管道是Unix中最古老的进程间通信的形式。它用于进程间的**单向**通信\n\n那么具体是怎样实现的呢？从标题里就可以发现，是基于`文件`\n\n既然一个文件可以被多个进程打开，那么不妨将文件作为两个进程通信的**媒介**。但是一般位于磁盘上的文件，IO效率相比于`CPU`，`内存`之类的读写速度慢了几个数量级，但文件是可以被加载到内存中的，而专门建立在**内存中**,而没有磁盘文件，专门用于进程间通信的**内存级**文件，我们就叫它`管道文件`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-09_21-19-22.png)\n\n*管道文件由内核维护*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-10_17-52-20.png)\n*管道文件是单向的，可以是父进程->子进程，也可以子进程->父进程*\n\n## 管道读写规则\n+ 写端未关闭，但读端**无数据**可读时\n  + (默认)`O_NONBLOCK disable`：`read`调用阻塞，即进程暂停执行，一直等到有数据来到为止。\n  + `O_NONBLOCK enable`：`read`调用返回`-1`，`errno`值为`EAGAIN`。\n+ 读端未关闭，但写端写入管道已经**写满**时\n  + (默认)` O_NONBLOCK disable`： `write`调用阻塞，直到有进程读走数据\n  + `O_NONBLOCK enable`：`wrtie`调用返回`-1`，`errno`值为`EAGAIN`\n+ 若写端关闭,则`read`返回`0`\n+ 若读端关闭,则`write`操作会产生信号`SIGPIPE`,进而可能导致`write`进程**退出**\n\n### 原子性\n头文件提供了宏`PIPE_BUF`,规定了保证原子性读写操作的最大字节数\n\n+ 当要写入的数据量不大于`PIPE_BUF`时，linux将保证写入的原子性。\n+ 当要写入的数据量大于`PIPE_BUF`时，linux将不再保证写入的原子性。\n\n## 管道特点\n\n+ 管道提供流式服务\n+ 一般而言，进程退出，管道释放，所以管道的生命周期随进程\n+ 一般而言，内核会对管道操作进行**同步与互斥**\n+ 一个管道只有一个通信方向，数据只能向一个方向流动；需要**双方**通信时，需要建立起**两个**管道\n\n# 匿名管道\n匿名管道主要用于`父子进程`间的通信\n\n用到的接口是来自`<unistd.h>`的接口`pipe`\n\n`int pipe(int pipefd[2]);`\n\n可以看到有一个输出型参数`pipefd`数组，其中规定`pipefd[0]`储存了管道文件的`读端fd`,`pipefd[1]`储存了管道文件的`写端fd`\n\n要利用管道通信时，必须用`close`一方关闭写端而另一端关闭读端\n\n## 示例 子进程发送报文，父进程接受模型\n```C\n#include <iostream>\n#include <cstdlib>\n#include <unistd.h>\n#include <string>\n#include <cstring>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#define N 2\n#define NUM 1024\n\nusing namespace std;\n\n//child\nvoid Writer(int wfd)\n{\n    string s = \"hello,I am child\";//准备子进程的报文\n    pid_t self = getpid();\n    int number = 5;\n\n    char buffer[NUM] = {0};\n    while(number--)\n    {\n        buffer[0] = 0;//清空字符串\n        snprintf(buffer,sizeof(buffer),\"%s-%d-%d\\n\",s.c_str(),self,number);\n\n        //发送/写入报文\n        write(wfd,buffer,strlen(buffer));\n\n        sleep(1);\n    }\n}\n\n//father\nvoid Reader(int rfd)\n{\n    char buffer[NUM];\n\n    while(true)\n    {\n        buffer[0] = 0;\n        ssize_t n = read(rfd,buffer,sizeof(buffer));\n        if(n > 0)\n        {\n            buffer[n] = 0;//恢复成字符串\n            cout<<\"father get a message >> \"<<buffer<<endl;\n        }\n    }\n}\n\nint main()\n{\n    int pipefd[N] = {0};\n    \n    int n = pipe(pipefd);\n    if(n<0) return 1;\n\n    pid_t id = fork();\n    if(id  < 0) return 2;\n    else if(id == 0)\n    {\n        //子进程\n        close(pipefd[0]);//关闭读\n        \n        Writer(pipefd[1]);\n\n        close(pipefd[1]);\n        exit(0);\n    }\n    else\n    {\n        close(pipefd[1]);//关闭写\n\n        Reader(pipefd[0]);\n\n        pid_t rid = waitpid(id,nullptr,0);\n\n        if(id <0) return 3;\n\n        close(pipefd[0]);\n    }\n\n    return 0;\n}\n```\n\n## 小小项目--进程池\n详见[此博客🔗](https://www.supdriver.top/2024/08/02/processPool/)\n\n# 命名管道\n匿名管道无非实现不相关进程（无亲缘关系）的进程间通信，因此要用到命名管道来实现这个功能\n\n命名管道文件,即`FIFO`文件，是一种用于不相关进程间通信的特殊类型的文件\n\n## 命令行上创建\n使用`mkfifo`可以在命令行上创建命名管道\n\n例`mkfile fifo_file`\n\n## 程序内创建和删除\n使用接口`mkfifo`创建,注：要同时引用头文件`sys/types.h`和`sys/stat.h`\n\n函数声明如下\n\n`int mkfifo(const char *pathname, mode_t mode);`\n\n+ 返回值：成功时返回`0`,失败时返回`-1`,并设置`errno`\n+ `pathname`：文件名（当前目录），或者路径+文件名\n+ `mode` 新创建的管道文件的权限,一般用`0644`或`0664`\n\n使用`unlink`删除文件,引用自头文件`<unistd.h>`\n\n`int unlink(const char *pathname);`\n\n+ 返回值：成功时返回`0`,失败时返回`-1`,并设置`errno`\n+ `pathname`：文件名（当前目录），或者路径+文件名\n\n## 使用\n由一个进程`写模式`打开，同时由另一个进程`读模式`打开，便可建立进程间通信，其余操作与匿名管道相同\n\n## 命名管道的打开规则\n+ `读模式`打开`FIFO`文件时\n  + `O_NONBLOCK disable`：阻塞等待直到有相应进程为写而打开该`FIFO`\n  + `O_NONBLOCK enable`：立刻返回成功\n+ `写模式`打开`FIFO`文件时\n  + `O_NONBLOCK disable`：阻塞直到有相应进程为读而打开该`FIFO`\n  + ` O_NONBLOCK enable`：立刻返回失败，错误码为`ENXIO`\n\n## 示例 命名管道实现 客户端 向 服务端通信\n\n### makefile\n小技巧：这里在最前面使用伪目标`all`，这样在使用`make`命令时能编译多个目标文件\n\n```makefile\n.PHONY:all\nall:sever client\n\nsever:sever.cpp\n\tg++ -o $@ $^ -std=c++11\nclient:client.cpp\n\tg++ -o $@ $^ -std=c++11\n\n.PHONY:cl \ncl:\n\trm -f sever client\n```\n\n### comm.hpp\n使用同一个头文件能方便地统一`fifo`文件的路径，以及统一退出码的约定等\n\n```C++\n#pragma once\n\n#include <iostream>\n#include <errno.h>\n#include <cstring>\n#include <cstdlib>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#define FIFO_NAME \"./myfifo\" //设置管道文件名\n#define MODE 0664 //设置管道文件的权限\n\nenum//枚举错误码\n{\n    FIFO_CREAT_ERR = 1,\n    FIFO_DELETE_ERR,\n    FIFO_OPEN_ERR\n};\n```\n\n### sever.cpp\n\n```C++\n#include \"comm.hpp\"\n\nusing namespace std;\n\nint main()\n{\n    //创建信道\n    int n = mkfifo(FIFO_NAME,MODE);\n    if(n == -1)//创建失败\n    {\n        perror(\"mkfifo\");\n        exit(FIFO_CREAT_ERR);\n    }\n\n    //打开信道\n    int fd = open(FIFO_NAME,O_RDONLY);//只读模式打开FIFO\n    if(fd == -1)//打开失败\n    {\n        perror(\"open\");\n        exit(FIFO_OPEN_ERR);\n    }\n\n    //开始通信\n    cout<<\"[@]sever start running\"<<endl;\n    while(true)\n    {\n        char buffer[1024] = {0};\n        int sz = read(fd,buffer,sizeof(buffer)-1);//给结尾\\0预留位置\n        if(sz > 0)\n        {\n            buffer[sz] = 0;\n            cout<<\"client say# \"<<buffer<<endl;\n        }\n        else if(sz == 0)\n        {\n            //写端关闭\n            cout<<\"client quit, sever will quie later...\" <<endl;\n            break;\n        }\n        else break;\n    }\n\n    //关闭信道\n    close(fd);\n    int m = unlink(FIFO_NAME);\n    if(m == -1)\n    {\n        perror(\"unlink\");\n        exit(FIFO_DELETE_ERR);\n    }\n\n    return 0;\n}\n```\n\n### client.cpp\n\n```C++\n#include \"comm.hpp\"\n\nusing namespace std;\n\nint main()\n{\n    int fd = open(FIFO_NAME,O_WRONLY);//只读模式打开\n    if(fd <0)\n    {\n        perror(\"open\");\n        exit(FIFO_OPEN_ERR);\n    }\n\n    string line;\n    while(true)\n    {\n        cout<<\"Please enter@ \";\n        getline(cin,line);//获取输入\n\n        write(fd,line.c_str(),line.size());\n    }\n\n    close(fd);\n    return 0;\n}\n\n```\n### 实现效果\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-13_16-49-49.png)\n\n","slug":"pipe","published":1,"updated":"2024-08-13T09:12:47.501Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08k001f4sp54hdhhoc9","content":"<h1 id=\"什么是管道文件\"><a href=\"#什么是管道文件\" class=\"headerlink\" title=\"什么是管道文件\"></a>什么是管道文件</h1><p>首先，管道是Unix中最古老的进程间通信的形式。它用于进程间的<strong>单向</strong>通信</p>\n<p>那么具体是怎样实现的呢？从标题里就可以发现，是基于<code>文件</code></p>\n<p>既然一个文件可以被多个进程打开，那么不妨将文件作为两个进程通信的<strong>媒介</strong>。但是一般位于磁盘上的文件，IO效率相比于<code>CPU</code>，<code>内存</code>之类的读写速度慢了几个数量级，但文件是可以被加载到内存中的，而专门建立在<strong>内存中</strong>,而没有磁盘文件，专门用于进程间通信的<strong>内存级</strong>文件，我们就叫它<code>管道文件</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-09_21-19-22.png\"></p>\n<p><em>管道文件由内核维护</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-10_17-52-20.png\"><br><em>管道文件是单向的，可以是父进程-&gt;子进程，也可以子进程-&gt;父进程</em></p>\n<h2 id=\"管道读写规则\"><a href=\"#管道读写规则\" class=\"headerlink\" title=\"管道读写规则\"></a>管道读写规则</h2><ul>\n<li>写端未关闭，但读端<strong>无数据</strong>可读时<ul>\n<li>(默认)<code>O_NONBLOCK disable</code>：<code>read</code>调用阻塞，即进程暂停执行，一直等到有数据来到为止。</li>\n<li><code>O_NONBLOCK enable</code>：<code>read</code>调用返回<code>-1</code>，<code>errno</code>值为<code>EAGAIN</code>。</li>\n</ul>\n</li>\n<li>读端未关闭，但写端写入管道已经<strong>写满</strong>时<ul>\n<li>(默认)<code> O_NONBLOCK disable</code>： <code>write</code>调用阻塞，直到有进程读走数据</li>\n<li><code>O_NONBLOCK enable</code>：<code>wrtie</code>调用返回<code>-1</code>，<code>errno</code>值为<code>EAGAIN</code></li>\n</ul>\n</li>\n<li>若写端关闭,则<code>read</code>返回<code>0</code></li>\n<li>若读端关闭,则<code>write</code>操作会产生信号<code>SIGPIPE</code>,进而可能导致<code>write</code>进程<strong>退出</strong></li>\n</ul>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>头文件提供了宏<code>PIPE_BUF</code>,规定了保证原子性读写操作的最大字节数</p>\n<ul>\n<li>当要写入的数据量不大于<code>PIPE_BUF</code>时，linux将保证写入的原子性。</li>\n<li>当要写入的数据量大于<code>PIPE_BUF</code>时，linux将不再保证写入的原子性。</li>\n</ul>\n<h2 id=\"管道特点\"><a href=\"#管道特点\" class=\"headerlink\" title=\"管道特点\"></a>管道特点</h2><ul>\n<li>管道提供流式服务</li>\n<li>一般而言，进程退出，管道释放，所以管道的生命周期随进程</li>\n<li>一般而言，内核会对管道操作进行<strong>同步与互斥</strong></li>\n<li>一个管道只有一个通信方向，数据只能向一个方向流动；需要<strong>双方</strong>通信时，需要建立起<strong>两个</strong>管道</li>\n</ul>\n<h1 id=\"匿名管道\"><a href=\"#匿名管道\" class=\"headerlink\" title=\"匿名管道\"></a>匿名管道</h1><p>匿名管道主要用于<code>父子进程</code>间的通信</p>\n<p>用到的接口是来自<code>&lt;unistd.h&gt;</code>的接口<code>pipe</code></p>\n<p><code>int pipe(int pipefd[2]);</code></p>\n<p>可以看到有一个输出型参数<code>pipefd</code>数组，其中规定<code>pipefd[0]</code>储存了管道文件的<code>读端fd</code>,<code>pipefd[1]</code>储存了管道文件的<code>写端fd</code></p>\n<p>要利用管道通信时，必须用<code>close</code>一方关闭写端而另一端关闭读端</p>\n<h2 id=\"示例-子进程发送报文，父进程接受模型\"><a href=\"#示例-子进程发送报文，父进程接受模型\" class=\"headerlink\" title=\"示例 子进程发送报文，父进程接受模型\"></a>示例 子进程发送报文，父进程接受模型</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N 2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NUM 1024</span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//child</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Writer</span><span class=\"params\">(<span class=\"type\">int</span> wfd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s = <span class=\"string\">&quot;hello,I am child&quot;</span>;<span class=\"comment\">//准备子进程的报文</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> self = getpid();</span><br><span class=\"line\">    <span class=\"type\">int</span> number = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span> buffer[NUM] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(number--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buffer[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;<span class=\"comment\">//清空字符串</span></span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buffer,<span class=\"keyword\">sizeof</span>(buffer),<span class=\"string\">&quot;%s-%d-%d\\n&quot;</span>,s.c_str(),self,number);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//发送/写入报文</span></span><br><span class=\"line\">        write(wfd,buffer,<span class=\"built_in\">strlen</span>(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//father</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Reader</span><span class=\"params\">(<span class=\"type\">int</span> rfd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buffer[NUM];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buffer[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">ssize_t</span> n = read(rfd,buffer,<span class=\"keyword\">sizeof</span>(buffer));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            buffer[n] = <span class=\"number\">0</span>;<span class=\"comment\">//恢复成字符串</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;father get a message &gt;&gt; &quot;</span>&lt;&lt;buffer&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pipefd[N] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> n = pipe(pipefd);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id  &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//子进程</span></span><br><span class=\"line\">        close(pipefd[<span class=\"number\">0</span>]);<span class=\"comment\">//关闭读</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        Writer(pipefd[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        close(pipefd[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        close(pipefd[<span class=\"number\">1</span>]);<span class=\"comment\">//关闭写</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Reader(pipefd[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">pid_t</span> rid = waitpid(id,nullptr,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(id &lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        close(pipefd[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小小项目–进程池\"><a href=\"#小小项目–进程池\" class=\"headerlink\" title=\"小小项目–进程池\"></a>小小项目–进程池</h2><p>详见<a href=\"https://www.supdriver.top/2024/08/02/processPool/\">此博客🔗</a></p>\n<h1 id=\"命名管道\"><a href=\"#命名管道\" class=\"headerlink\" title=\"命名管道\"></a>命名管道</h1><p>匿名管道无非实现不相关进程（无亲缘关系）的进程间通信，因此要用到命名管道来实现这个功能</p>\n<p>命名管道文件,即<code>FIFO</code>文件，是一种用于不相关进程间通信的特殊类型的文件</p>\n<h2 id=\"命令行上创建\"><a href=\"#命令行上创建\" class=\"headerlink\" title=\"命令行上创建\"></a>命令行上创建</h2><p>使用<code>mkfifo</code>可以在命令行上创建命名管道</p>\n<p>例<code>mkfile fifo_file</code></p>\n<h2 id=\"程序内创建和删除\"><a href=\"#程序内创建和删除\" class=\"headerlink\" title=\"程序内创建和删除\"></a>程序内创建和删除</h2><p>使用接口<code>mkfifo</code>创建,注：要同时引用头文件<code>sys/types.h</code>和<code>sys/stat.h</code></p>\n<p>函数声明如下</p>\n<p><code>int mkfifo(const char *pathname, mode_t mode);</code></p>\n<ul>\n<li>返回值：成功时返回<code>0</code>,失败时返回<code>-1</code>,并设置<code>errno</code></li>\n<li><code>pathname</code>：文件名（当前目录），或者路径+文件名</li>\n<li><code>mode</code> 新创建的管道文件的权限,一般用<code>0644</code>或<code>0664</code></li>\n</ul>\n<p>使用<code>unlink</code>删除文件,引用自头文件<code>&lt;unistd.h&gt;</code></p>\n<p><code>int unlink(const char *pathname);</code></p>\n<ul>\n<li>返回值：成功时返回<code>0</code>,失败时返回<code>-1</code>,并设置<code>errno</code></li>\n<li><code>pathname</code>：文件名（当前目录），或者路径+文件名</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>由一个进程<code>写模式</code>打开，同时由另一个进程<code>读模式</code>打开，便可建立进程间通信，其余操作与匿名管道相同</p>\n<h2 id=\"命名管道的打开规则\"><a href=\"#命名管道的打开规则\" class=\"headerlink\" title=\"命名管道的打开规则\"></a>命名管道的打开规则</h2><ul>\n<li><code>读模式</code>打开<code>FIFO</code>文件时<ul>\n<li><code>O_NONBLOCK disable</code>：阻塞等待直到有相应进程为写而打开该<code>FIFO</code></li>\n<li><code>O_NONBLOCK enable</code>：立刻返回成功</li>\n</ul>\n</li>\n<li><code>写模式</code>打开<code>FIFO</code>文件时<ul>\n<li><code>O_NONBLOCK disable</code>：阻塞直到有相应进程为读而打开该<code>FIFO</code></li>\n<li><code> O_NONBLOCK enable</code>：立刻返回失败，错误码为<code>ENXIO</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"示例-命名管道实现-客户端-向-服务端通信\"><a href=\"#示例-命名管道实现-客户端-向-服务端通信\" class=\"headerlink\" title=\"示例 命名管道实现 客户端 向 服务端通信\"></a>示例 命名管道实现 客户端 向 服务端通信</h2><h3 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h3><p>小技巧：这里在最前面使用伪目标<code>all</code>，这样在使用<code>make</code>命令时能编译多个目标文件</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:all</span></span><br><span class=\"line\"><span class=\"section\">all:sever client</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">sever:sever.cpp</span></span><br><span class=\"line\">\tg++ -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> -std=c++11</span><br><span class=\"line\"><span class=\"section\">client:client.cpp</span></span><br><span class=\"line\">\tg++ -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> -std=c++11</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:cl </span></span><br><span class=\"line\"><span class=\"section\">cl:</span></span><br><span class=\"line\">\trm -f sever client</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"comm-hpp\"><a href=\"#comm-hpp\" class=\"headerlink\" title=\"comm.hpp\"></a>comm.hpp</h3><p>使用同一个头文件能方便地统一<code>fifo</code>文件的路径，以及统一退出码的约定等</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIFO_NAME <span class=\"string\">&quot;./myfifo&quot;</span> <span class=\"comment\">//设置管道文件名</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MODE 0664 <span class=\"comment\">//设置管道文件的权限</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span><span class=\"comment\">//枚举错误码</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FIFO_CREAT_ERR = <span class=\"number\">1</span>,</span><br><span class=\"line\">    FIFO_DELETE_ERR,</span><br><span class=\"line\">    FIFO_OPEN_ERR</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sever-cpp\"><a href=\"#sever-cpp\" class=\"headerlink\" title=\"sever.cpp\"></a>sever.cpp</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;comm.hpp&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建信道</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"built_in\">mkfifo</span>(FIFO_NAME,MODE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == <span class=\"number\">-1</span>)<span class=\"comment\">//创建失败</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;mkfifo&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(FIFO_CREAT_ERR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//打开信道</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd = <span class=\"built_in\">open</span>(FIFO_NAME,O_RDONLY);<span class=\"comment\">//只读模式打开FIFO</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd == <span class=\"number\">-1</span>)<span class=\"comment\">//打开失败</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;open&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(FIFO_OPEN_ERR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//开始通信</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;[@]sever start running&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> buffer[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> sz = <span class=\"built_in\">read</span>(fd,buffer,<span class=\"built_in\">sizeof</span>(buffer)<span class=\"number\">-1</span>);<span class=\"comment\">//给结尾\\0预留位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sz &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            buffer[sz] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;client say# &quot;</span>&lt;&lt;buffer&lt;&lt;endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sz == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//写端关闭</span></span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;client quit, sever will quie later...&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//关闭信道</span></span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">    <span class=\"type\">int</span> m = <span class=\"built_in\">unlink</span>(FIFO_NAME);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;unlink&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(FIFO_DELETE_ERR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"client-cpp\"><a href=\"#client-cpp\" class=\"headerlink\" title=\"client.cpp\"></a>client.cpp</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;comm.hpp&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = <span class=\"built_in\">open</span>(FIFO_NAME,O_WRONLY);<span class=\"comment\">//只读模式打开</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd &lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;open&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(FIFO_OPEN_ERR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    string line;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Please enter@ &quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">getline</span>(cin,line);<span class=\"comment\">//获取输入</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">write</span>(fd,line.<span class=\"built_in\">c_str</span>(),line.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-13_16-49-49.png\"></p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/07c3084a53912063e65735a81fa2ceaf.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"什么是管道文件\"><a href=\"#什么是管道文件\" class=\"headerlink\" title=\"什么是管道文件\"></a>什么是管道文件</h1><p>首先，管道是Unix中最古老的进程间通信的形式。它用于进程间的<strong>单向</strong>通信</p>\n<p>那么具体是怎样实现的呢？从标题里就可以发现，是基于<code>文件</code></p>\n<p>既然一个文件可以被多个进程打开，那么不妨将文件作为两个进程通信的<strong>媒介</strong>。但是一般位于磁盘上的文件，IO效率相比于<code>CPU</code>，<code>内存</code>之类的读写速度慢了几个数量级，但文件是可以被加载到内存中的，而专门建立在<strong>内存中</strong>,而没有磁盘文件，专门用于进程间通信的<strong>内存级</strong>文件，我们就叫它<code>管道文件</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-09_21-19-22.png\"></p>\n<p><em>管道文件由内核维护</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-10_17-52-20.png\"><br><em>管道文件是单向的，可以是父进程-&gt;子进程，也可以子进程-&gt;父进程</em></p>\n<h2 id=\"管道读写规则\"><a href=\"#管道读写规则\" class=\"headerlink\" title=\"管道读写规则\"></a>管道读写规则</h2><ul>\n<li>写端未关闭，但读端<strong>无数据</strong>可读时<ul>\n<li>(默认)<code>O_NONBLOCK disable</code>：<code>read</code>调用阻塞，即进程暂停执行，一直等到有数据来到为止。</li>\n<li><code>O_NONBLOCK enable</code>：<code>read</code>调用返回<code>-1</code>，<code>errno</code>值为<code>EAGAIN</code>。</li>\n</ul>\n</li>\n<li>读端未关闭，但写端写入管道已经<strong>写满</strong>时<ul>\n<li>(默认)<code> O_NONBLOCK disable</code>： <code>write</code>调用阻塞，直到有进程读走数据</li>\n<li><code>O_NONBLOCK enable</code>：<code>wrtie</code>调用返回<code>-1</code>，<code>errno</code>值为<code>EAGAIN</code></li>\n</ul>\n</li>\n<li>若写端关闭,则<code>read</code>返回<code>0</code></li>\n<li>若读端关闭,则<code>write</code>操作会产生信号<code>SIGPIPE</code>,进而可能导致<code>write</code>进程<strong>退出</strong></li>\n</ul>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>头文件提供了宏<code>PIPE_BUF</code>,规定了保证原子性读写操作的最大字节数</p>\n<ul>\n<li>当要写入的数据量不大于<code>PIPE_BUF</code>时，linux将保证写入的原子性。</li>\n<li>当要写入的数据量大于<code>PIPE_BUF</code>时，linux将不再保证写入的原子性。</li>\n</ul>\n<h2 id=\"管道特点\"><a href=\"#管道特点\" class=\"headerlink\" title=\"管道特点\"></a>管道特点</h2><ul>\n<li>管道提供流式服务</li>\n<li>一般而言，进程退出，管道释放，所以管道的生命周期随进程</li>\n<li>一般而言，内核会对管道操作进行<strong>同步与互斥</strong></li>\n<li>一个管道只有一个通信方向，数据只能向一个方向流动；需要<strong>双方</strong>通信时，需要建立起<strong>两个</strong>管道</li>\n</ul>\n<h1 id=\"匿名管道\"><a href=\"#匿名管道\" class=\"headerlink\" title=\"匿名管道\"></a>匿名管道</h1><p>匿名管道主要用于<code>父子进程</code>间的通信</p>\n<p>用到的接口是来自<code>&lt;unistd.h&gt;</code>的接口<code>pipe</code></p>\n<p><code>int pipe(int pipefd[2]);</code></p>\n<p>可以看到有一个输出型参数<code>pipefd</code>数组，其中规定<code>pipefd[0]</code>储存了管道文件的<code>读端fd</code>,<code>pipefd[1]</code>储存了管道文件的<code>写端fd</code></p>\n<p>要利用管道通信时，必须用<code>close</code>一方关闭写端而另一端关闭读端</p>\n<h2 id=\"示例-子进程发送报文，父进程接受模型\"><a href=\"#示例-子进程发送报文，父进程接受模型\" class=\"headerlink\" title=\"示例 子进程发送报文，父进程接受模型\"></a>示例 子进程发送报文，父进程接受模型</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N 2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NUM 1024</span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//child</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Writer</span><span class=\"params\">(<span class=\"type\">int</span> wfd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s = <span class=\"string\">&quot;hello,I am child&quot;</span>;<span class=\"comment\">//准备子进程的报文</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> self = getpid();</span><br><span class=\"line\">    <span class=\"type\">int</span> number = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span> buffer[NUM] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(number--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buffer[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;<span class=\"comment\">//清空字符串</span></span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(buffer,<span class=\"keyword\">sizeof</span>(buffer),<span class=\"string\">&quot;%s-%d-%d\\n&quot;</span>,s.c_str(),self,number);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//发送/写入报文</span></span><br><span class=\"line\">        write(wfd,buffer,<span class=\"built_in\">strlen</span>(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//father</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Reader</span><span class=\"params\">(<span class=\"type\">int</span> rfd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buffer[NUM];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        buffer[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">ssize_t</span> n = read(rfd,buffer,<span class=\"keyword\">sizeof</span>(buffer));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            buffer[n] = <span class=\"number\">0</span>;<span class=\"comment\">//恢复成字符串</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;father get a message &gt;&gt; &quot;</span>&lt;&lt;buffer&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pipefd[N] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> n = pipe(pipefd);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(id  &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//子进程</span></span><br><span class=\"line\">        close(pipefd[<span class=\"number\">0</span>]);<span class=\"comment\">//关闭读</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        Writer(pipefd[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        close(pipefd[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        close(pipefd[<span class=\"number\">1</span>]);<span class=\"comment\">//关闭写</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Reader(pipefd[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">pid_t</span> rid = waitpid(id,nullptr,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(id &lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        close(pipefd[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小小项目–进程池\"><a href=\"#小小项目–进程池\" class=\"headerlink\" title=\"小小项目–进程池\"></a>小小项目–进程池</h2><p>详见<a href=\"https://www.supdriver.top/2024/08/02/processPool/\">此博客🔗</a></p>\n<h1 id=\"命名管道\"><a href=\"#命名管道\" class=\"headerlink\" title=\"命名管道\"></a>命名管道</h1><p>匿名管道无非实现不相关进程（无亲缘关系）的进程间通信，因此要用到命名管道来实现这个功能</p>\n<p>命名管道文件,即<code>FIFO</code>文件，是一种用于不相关进程间通信的特殊类型的文件</p>\n<h2 id=\"命令行上创建\"><a href=\"#命令行上创建\" class=\"headerlink\" title=\"命令行上创建\"></a>命令行上创建</h2><p>使用<code>mkfifo</code>可以在命令行上创建命名管道</p>\n<p>例<code>mkfile fifo_file</code></p>\n<h2 id=\"程序内创建和删除\"><a href=\"#程序内创建和删除\" class=\"headerlink\" title=\"程序内创建和删除\"></a>程序内创建和删除</h2><p>使用接口<code>mkfifo</code>创建,注：要同时引用头文件<code>sys/types.h</code>和<code>sys/stat.h</code></p>\n<p>函数声明如下</p>\n<p><code>int mkfifo(const char *pathname, mode_t mode);</code></p>\n<ul>\n<li>返回值：成功时返回<code>0</code>,失败时返回<code>-1</code>,并设置<code>errno</code></li>\n<li><code>pathname</code>：文件名（当前目录），或者路径+文件名</li>\n<li><code>mode</code> 新创建的管道文件的权限,一般用<code>0644</code>或<code>0664</code></li>\n</ul>\n<p>使用<code>unlink</code>删除文件,引用自头文件<code>&lt;unistd.h&gt;</code></p>\n<p><code>int unlink(const char *pathname);</code></p>\n<ul>\n<li>返回值：成功时返回<code>0</code>,失败时返回<code>-1</code>,并设置<code>errno</code></li>\n<li><code>pathname</code>：文件名（当前目录），或者路径+文件名</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>由一个进程<code>写模式</code>打开，同时由另一个进程<code>读模式</code>打开，便可建立进程间通信，其余操作与匿名管道相同</p>\n<h2 id=\"命名管道的打开规则\"><a href=\"#命名管道的打开规则\" class=\"headerlink\" title=\"命名管道的打开规则\"></a>命名管道的打开规则</h2><ul>\n<li><code>读模式</code>打开<code>FIFO</code>文件时<ul>\n<li><code>O_NONBLOCK disable</code>：阻塞等待直到有相应进程为写而打开该<code>FIFO</code></li>\n<li><code>O_NONBLOCK enable</code>：立刻返回成功</li>\n</ul>\n</li>\n<li><code>写模式</code>打开<code>FIFO</code>文件时<ul>\n<li><code>O_NONBLOCK disable</code>：阻塞直到有相应进程为读而打开该<code>FIFO</code></li>\n<li><code> O_NONBLOCK enable</code>：立刻返回失败，错误码为<code>ENXIO</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"示例-命名管道实现-客户端-向-服务端通信\"><a href=\"#示例-命名管道实现-客户端-向-服务端通信\" class=\"headerlink\" title=\"示例 命名管道实现 客户端 向 服务端通信\"></a>示例 命名管道实现 客户端 向 服务端通信</h2><h3 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h3><p>小技巧：这里在最前面使用伪目标<code>all</code>，这样在使用<code>make</code>命令时能编译多个目标文件</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:all</span></span><br><span class=\"line\"><span class=\"section\">all:sever client</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">sever:sever.cpp</span></span><br><span class=\"line\">\tg++ -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> -std=c++11</span><br><span class=\"line\"><span class=\"section\">client:client.cpp</span></span><br><span class=\"line\">\tg++ -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> -std=c++11</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:cl </span></span><br><span class=\"line\"><span class=\"section\">cl:</span></span><br><span class=\"line\">\trm -f sever client</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"comm-hpp\"><a href=\"#comm-hpp\" class=\"headerlink\" title=\"comm.hpp\"></a>comm.hpp</h3><p>使用同一个头文件能方便地统一<code>fifo</code>文件的路径，以及统一退出码的约定等</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FIFO_NAME <span class=\"string\">&quot;./myfifo&quot;</span> <span class=\"comment\">//设置管道文件名</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MODE 0664 <span class=\"comment\">//设置管道文件的权限</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span><span class=\"comment\">//枚举错误码</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FIFO_CREAT_ERR = <span class=\"number\">1</span>,</span><br><span class=\"line\">    FIFO_DELETE_ERR,</span><br><span class=\"line\">    FIFO_OPEN_ERR</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sever-cpp\"><a href=\"#sever-cpp\" class=\"headerlink\" title=\"sever.cpp\"></a>sever.cpp</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;comm.hpp&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建信道</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"built_in\">mkfifo</span>(FIFO_NAME,MODE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == <span class=\"number\">-1</span>)<span class=\"comment\">//创建失败</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;mkfifo&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(FIFO_CREAT_ERR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//打开信道</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd = <span class=\"built_in\">open</span>(FIFO_NAME,O_RDONLY);<span class=\"comment\">//只读模式打开FIFO</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd == <span class=\"number\">-1</span>)<span class=\"comment\">//打开失败</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;open&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(FIFO_OPEN_ERR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//开始通信</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;[@]sever start running&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> buffer[<span class=\"number\">1024</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> sz = <span class=\"built_in\">read</span>(fd,buffer,<span class=\"built_in\">sizeof</span>(buffer)<span class=\"number\">-1</span>);<span class=\"comment\">//给结尾\\0预留位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sz &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            buffer[sz] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;client say# &quot;</span>&lt;&lt;buffer&lt;&lt;endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sz == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//写端关闭</span></span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;client quit, sever will quie later...&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//关闭信道</span></span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">    <span class=\"type\">int</span> m = <span class=\"built_in\">unlink</span>(FIFO_NAME);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;unlink&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(FIFO_DELETE_ERR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"client-cpp\"><a href=\"#client-cpp\" class=\"headerlink\" title=\"client.cpp\"></a>client.cpp</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;comm.hpp&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd = <span class=\"built_in\">open</span>(FIFO_NAME,O_WRONLY);<span class=\"comment\">//只读模式打开</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd &lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;open&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(FIFO_OPEN_ERR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    string line;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Please enter@ &quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">getline</span>(cin,line);<span class=\"comment\">//获取输入</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">write</span>(fd,line.<span class=\"built_in\">c_str</span>(),line.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-13_16-49-49.png\"></p>\n"},{"title":"【Linux】简易进程池","date":"2024-08-02T12:02:48.000Z","_content":"\n# 原理\n`匿名管道`可用于父子进程间的通讯，于是可以有父进程创建多个子进程形成`进程池`，并通过`匿名管道`文件向各个子进程`派发任务`\n\n[戳我去管道原理🔗](https://www.supdriver.top/2024/08/02/pipe/)\n\n这里使用C++编写进程池代码，在程序中创建多个进程，并在父进程中使用自定义类`channel`用于描述和管理子进程,然后在`task.hpp`中模拟一些任务给主程序随机派发\n# 代码\n\n## 代码规范\n这次对形参有了新的规范,这里用`variable`代指形参名\n\n+ 输入: `const &variable`\n+ 输出: `*variable`\n+ 输入输出: `&variable`\n\n## 准备makefile文件\n这里使用`g++`编译，规定语法标准为`C++11`\n```makefile\nprocessPool:processPool.cc\n\tg++ -o $@ $^ -std=c++11\n\n.PHONY:clean\nclean:\n\trm -rf processPool\n```\n\n## 准备任务文件\n\n首先要准备前后需要用到的头文件,然后构建模拟任务，并提供加载任务列表的函数\n> `task.hpp`\n```C++\n#pragma once\n\n#include <vector>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <cassert>\n#include <iostream>\n#include <string>\n\n\ntypedef void (*task_t)();//定义函数指针\n\nvoid task1()\n{\n    std::cout << \"PVZ 刷新日志\" << std::endl;\n}\nvoid task2()\n{\n    std::cout<< \"PVZ 生成阳光\"<<std::endl;\n}\nvoid task3()\n{\n    std::cout<<\"PVZ 检测更新\" <<std::endl;\n}\nvoid task4()\n{\n    std::cout<<\"PVZ 使用能量豆\"<<std::endl;\n}\n\nvoid LoadTask(std::vector<task_t>*tasks)//载入任务列表的接口\n{\n    tasks->push_back(task1);\n    tasks->push_back(task2);\n    tasks->push_back(task3);\n    tasks->push_back(task4);\n}\n```\n\n## 编写主程序\n主程序文件名为`processPool.cc`,我们按类和接口从上往下编程\n\n### 描述和组织\n\n我们把头文件准备好,然后定义最大进程数和创建任务列表,接着创建`channel`类来描述每个进程池中的子进程\n```C++\n#include \"task.hpp\"\n#include <ctime>//获取时间戳\n#include <sys/stat.h>\n#include <sys/wait.h>\n\n\nconst int processNum = 5;//最大进程数\nstd::vector<task_t> tasks;//承载任务的映射列表\n\n//先描述\nclass channel\n{\npublic:\n    channel(int cmdfd,pid_t slaverid,std::string& name)\n    :_cmdfd(cmdfd),_slaverid(slaverid),_processname(name)\n    {}\n\npublic:\n    int _cmdfd;                    //发送任务的文件描述符\n    pid_t _slaverid;               //子进程的id \n    std::string _processname;             //子进程的名字  --方便打印日志\n};\n```\n\n### slaver函数\n创建子进程后，子进程都进入`slaver`函数等待获取任务\n\n这里统一采用`输入重定向`，在创建子进程后，进入`slaver()`前先把标准输入重定向到管道文件,然后从标准输入读取`任务码`\n\n```C++\nvoid slaver()\n{\n    while(true)\n    {\n        int cmdcode = 0;\n        int n = read(0,&cmdcode,sizeof(int));//读取任务码\n        if(n == sizeof(int))//成功获取任务码\n        {\n            //std::cout<<\"child say@ \"<<\"get cmdcode: \"<<cmdcode<<std::endl;//DEBUG\n            if(cmdcode >=0 && cmdcode < tasks.size())//输入合法的输入码\n            {\n                tasks[cmdcode]();\n            }\n            else //输出错误信息\n            {\n                std::cout<<\"wrong cmdcode: \"<<cmdcode \n                    <<\" max size: \"<<tasks.size()<<std::endl;\n            }\n        }\n    }\n}\n```\n\n### InnitChannels\n该函数用鱼创建子进程,创建子进程，并封装进频道类\n\n```C++\nvoid InitChannels(std::vector<channel>* channels)\n{\n    for(int i = 0;i<processNum;i++)\n    {\n        int pipefd[2];\n        int n = pipe(pipefd);\n        assert(!n);\n        (void)n;//调用一下n\n\n        pid_t id = fork();\n        if(id == 0)//child\n        {\n            close(pipefd[1]);\n            dup2(pipefd[0],0);//子进程输入重定向\n            slaver();\n            std::cout<<\"proccess \"<< getpid() << \" quit\"<<std::endl;\n            exit(0);\n        } \n        //father\n        close(pipefd[0]);\n        std::string name = \"process-\"+std::to_string(i);\n        channels->push_back(channel(pipefd[1],id,name));\n    }\n}\n```\n\n### channelDEBUG\n这里封装一个用于测试创建频道的`DEBUG`函数\n\n```C++\nvoid Debug(const std::vector<channel> channels)\n{\n    for(auto &c:channels)\n    {\n        std::cout<<c._cmdfd << \" \" << c._slaverid<< \" \" << c._processname << std::endl;\n    }\n}\n```\n\n### ctrlSlaver\n这里封装一个`ctrlSlaver`用于控制子进程，也就是用于派发任务的函数\n\n```C++\nvoid ctrlSlaver(const std::vector<channel> &channels)\n{\n    for(int i = 0;i<10;i++)//随机派发10个任务\n    {\n        int cmdcode = rand() % tasks.size();//获取随机任务码\n        int select_num = rand()%channels.size();//获取选择码\n        std::cout<<\"father say# \"<<\"taskcode: \"<<cmdcode<<\" send to \"<<channels[select_num]._processname\n            << std::endl;//输出日志\n        write(channels[select_num]._cmdfd,&cmdcode,sizeof(cmdcode));//写入任务码，派发任务\n        sleep(1);\n    }\n}\n```\n\n### QuitProcess\n最后当然要有父进程控制关闭子进程，并回收僵尸进程\n\n因为`InitChannels`中管道文件的处理比较粗糙，会发生如下图的关系，所以关闭时两步操作一定要放在两个循环中\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-13_11-25-01.png)\n\n```C++\nvoid QuitProcess(const std::vector<channel>& channels)\n{\n    //因为创建子进程时管道文件的连接没有进一步处理，关系复杂，所以下面两个循环一定要分开来\n    for(const auto &c:channels)close(c._cmdfd);//关闭主进程管道文件的写端，使子进程的read函数读取失败，返回0\n    for(const auto &c:channels)waitpid(c._slaverid,nullptr,0);//阻塞等待子进程，回收僵尸进程\n}\n```\n\n### main函数\n经过上文一系列封装,`main`函数就可以简洁明了地描述子进程的运行过程了\n\n```C++\nint main()\n{\n    srand(time(nullptr) ^ getpid()^1023);//种随机数种子\n    std::vector<channel> channels;\n    //1.初始化\n    LoadTask(&tasks);//必须先载入任务再产生子进程，否则子进程看不到任务列表\n    InitChannels(&channels);\n\n    //测试函数\n    //Debug(channels);\n\n    //2.控制子进程\n    ctrlSlaver(channels);\n\n    //3.关闭进程池\n    QuitProcess(channels);\n\n    return 0;\n}\n```\n\n# 源文件\n[戳我去github仓库🔗](https://github.com/sis-shen/Linux_Code/tree/main/pipe_use)","source":"_posts/processPool.md","raw":"---\ntitle: 【Linux】简易进程池\ndate: 2024-08-02 20:02:48\ntags:\n---\n\n# 原理\n`匿名管道`可用于父子进程间的通讯，于是可以有父进程创建多个子进程形成`进程池`，并通过`匿名管道`文件向各个子进程`派发任务`\n\n[戳我去管道原理🔗](https://www.supdriver.top/2024/08/02/pipe/)\n\n这里使用C++编写进程池代码，在程序中创建多个进程，并在父进程中使用自定义类`channel`用于描述和管理子进程,然后在`task.hpp`中模拟一些任务给主程序随机派发\n# 代码\n\n## 代码规范\n这次对形参有了新的规范,这里用`variable`代指形参名\n\n+ 输入: `const &variable`\n+ 输出: `*variable`\n+ 输入输出: `&variable`\n\n## 准备makefile文件\n这里使用`g++`编译，规定语法标准为`C++11`\n```makefile\nprocessPool:processPool.cc\n\tg++ -o $@ $^ -std=c++11\n\n.PHONY:clean\nclean:\n\trm -rf processPool\n```\n\n## 准备任务文件\n\n首先要准备前后需要用到的头文件,然后构建模拟任务，并提供加载任务列表的函数\n> `task.hpp`\n```C++\n#pragma once\n\n#include <vector>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <cassert>\n#include <iostream>\n#include <string>\n\n\ntypedef void (*task_t)();//定义函数指针\n\nvoid task1()\n{\n    std::cout << \"PVZ 刷新日志\" << std::endl;\n}\nvoid task2()\n{\n    std::cout<< \"PVZ 生成阳光\"<<std::endl;\n}\nvoid task3()\n{\n    std::cout<<\"PVZ 检测更新\" <<std::endl;\n}\nvoid task4()\n{\n    std::cout<<\"PVZ 使用能量豆\"<<std::endl;\n}\n\nvoid LoadTask(std::vector<task_t>*tasks)//载入任务列表的接口\n{\n    tasks->push_back(task1);\n    tasks->push_back(task2);\n    tasks->push_back(task3);\n    tasks->push_back(task4);\n}\n```\n\n## 编写主程序\n主程序文件名为`processPool.cc`,我们按类和接口从上往下编程\n\n### 描述和组织\n\n我们把头文件准备好,然后定义最大进程数和创建任务列表,接着创建`channel`类来描述每个进程池中的子进程\n```C++\n#include \"task.hpp\"\n#include <ctime>//获取时间戳\n#include <sys/stat.h>\n#include <sys/wait.h>\n\n\nconst int processNum = 5;//最大进程数\nstd::vector<task_t> tasks;//承载任务的映射列表\n\n//先描述\nclass channel\n{\npublic:\n    channel(int cmdfd,pid_t slaverid,std::string& name)\n    :_cmdfd(cmdfd),_slaverid(slaverid),_processname(name)\n    {}\n\npublic:\n    int _cmdfd;                    //发送任务的文件描述符\n    pid_t _slaverid;               //子进程的id \n    std::string _processname;             //子进程的名字  --方便打印日志\n};\n```\n\n### slaver函数\n创建子进程后，子进程都进入`slaver`函数等待获取任务\n\n这里统一采用`输入重定向`，在创建子进程后，进入`slaver()`前先把标准输入重定向到管道文件,然后从标准输入读取`任务码`\n\n```C++\nvoid slaver()\n{\n    while(true)\n    {\n        int cmdcode = 0;\n        int n = read(0,&cmdcode,sizeof(int));//读取任务码\n        if(n == sizeof(int))//成功获取任务码\n        {\n            //std::cout<<\"child say@ \"<<\"get cmdcode: \"<<cmdcode<<std::endl;//DEBUG\n            if(cmdcode >=0 && cmdcode < tasks.size())//输入合法的输入码\n            {\n                tasks[cmdcode]();\n            }\n            else //输出错误信息\n            {\n                std::cout<<\"wrong cmdcode: \"<<cmdcode \n                    <<\" max size: \"<<tasks.size()<<std::endl;\n            }\n        }\n    }\n}\n```\n\n### InnitChannels\n该函数用鱼创建子进程,创建子进程，并封装进频道类\n\n```C++\nvoid InitChannels(std::vector<channel>* channels)\n{\n    for(int i = 0;i<processNum;i++)\n    {\n        int pipefd[2];\n        int n = pipe(pipefd);\n        assert(!n);\n        (void)n;//调用一下n\n\n        pid_t id = fork();\n        if(id == 0)//child\n        {\n            close(pipefd[1]);\n            dup2(pipefd[0],0);//子进程输入重定向\n            slaver();\n            std::cout<<\"proccess \"<< getpid() << \" quit\"<<std::endl;\n            exit(0);\n        } \n        //father\n        close(pipefd[0]);\n        std::string name = \"process-\"+std::to_string(i);\n        channels->push_back(channel(pipefd[1],id,name));\n    }\n}\n```\n\n### channelDEBUG\n这里封装一个用于测试创建频道的`DEBUG`函数\n\n```C++\nvoid Debug(const std::vector<channel> channels)\n{\n    for(auto &c:channels)\n    {\n        std::cout<<c._cmdfd << \" \" << c._slaverid<< \" \" << c._processname << std::endl;\n    }\n}\n```\n\n### ctrlSlaver\n这里封装一个`ctrlSlaver`用于控制子进程，也就是用于派发任务的函数\n\n```C++\nvoid ctrlSlaver(const std::vector<channel> &channels)\n{\n    for(int i = 0;i<10;i++)//随机派发10个任务\n    {\n        int cmdcode = rand() % tasks.size();//获取随机任务码\n        int select_num = rand()%channels.size();//获取选择码\n        std::cout<<\"father say# \"<<\"taskcode: \"<<cmdcode<<\" send to \"<<channels[select_num]._processname\n            << std::endl;//输出日志\n        write(channels[select_num]._cmdfd,&cmdcode,sizeof(cmdcode));//写入任务码，派发任务\n        sleep(1);\n    }\n}\n```\n\n### QuitProcess\n最后当然要有父进程控制关闭子进程，并回收僵尸进程\n\n因为`InitChannels`中管道文件的处理比较粗糙，会发生如下图的关系，所以关闭时两步操作一定要放在两个循环中\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-13_11-25-01.png)\n\n```C++\nvoid QuitProcess(const std::vector<channel>& channels)\n{\n    //因为创建子进程时管道文件的连接没有进一步处理，关系复杂，所以下面两个循环一定要分开来\n    for(const auto &c:channels)close(c._cmdfd);//关闭主进程管道文件的写端，使子进程的read函数读取失败，返回0\n    for(const auto &c:channels)waitpid(c._slaverid,nullptr,0);//阻塞等待子进程，回收僵尸进程\n}\n```\n\n### main函数\n经过上文一系列封装,`main`函数就可以简洁明了地描述子进程的运行过程了\n\n```C++\nint main()\n{\n    srand(time(nullptr) ^ getpid()^1023);//种随机数种子\n    std::vector<channel> channels;\n    //1.初始化\n    LoadTask(&tasks);//必须先载入任务再产生子进程，否则子进程看不到任务列表\n    InitChannels(&channels);\n\n    //测试函数\n    //Debug(channels);\n\n    //2.控制子进程\n    ctrlSlaver(channels);\n\n    //3.关闭进程池\n    QuitProcess(channels);\n\n    return 0;\n}\n```\n\n# 源文件\n[戳我去github仓库🔗](https://github.com/sis-shen/Linux_Code/tree/main/pipe_use)","slug":"processPool","published":1,"updated":"2024-08-13T03:34:30.248Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08k001g4sp54zok57c3","content":"<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p><code>匿名管道</code>可用于父子进程间的通讯，于是可以有父进程创建多个子进程形成<code>进程池</code>，并通过<code>匿名管道</code>文件向各个子进程<code>派发任务</code></p>\n<p><a href=\"https://www.supdriver.top/2024/08/02/pipe/\">戳我去管道原理🔗</a></p>\n<p>这里使用C++编写进程池代码，在程序中创建多个进程，并在父进程中使用自定义类<code>channel</code>用于描述和管理子进程,然后在<code>task.hpp</code>中模拟一些任务给主程序随机派发</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><h2 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h2><p>这次对形参有了新的规范,这里用<code>variable</code>代指形参名</p>\n<ul>\n<li>输入: <code>const &amp;variable</code></li>\n<li>输出: <code>*variable</code></li>\n<li>输入输出: <code>&amp;variable</code></li>\n</ul>\n<h2 id=\"准备makefile文件\"><a href=\"#准备makefile文件\" class=\"headerlink\" title=\"准备makefile文件\"></a>准备makefile文件</h2><p>这里使用<code>g++</code>编译，规定语法标准为<code>C++11</code></p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">processPool:processPool.cc</span></span><br><span class=\"line\">\tg++ -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> -std=c++11</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:clean</span></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\trm -rf processPool</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"准备任务文件\"><a href=\"#准备任务文件\" class=\"headerlink\" title=\"准备任务文件\"></a>准备任务文件</h2><p>首先要准备前后需要用到的头文件,然后构建模拟任务，并提供加载任务列表的函数</p>\n<blockquote>\n<p><code>task.hpp</code></p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*<span class=\"type\">task_t</span>)</span><span class=\"params\">()</span></span>;<span class=\"comment\">//定义函数指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">task1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;PVZ 刷新日志&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">task2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout&lt;&lt; <span class=\"string\">&quot;PVZ 生成阳光&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">task3</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout&lt;&lt;<span class=\"string\">&quot;PVZ 检测更新&quot;</span> &lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">task4</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout&lt;&lt;<span class=\"string\">&quot;PVZ 使用能量豆&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">LoadTask</span><span class=\"params\">(std::vector&lt;<span class=\"type\">task_t</span>&gt;*tasks)</span><span class=\"comment\">//载入任务列表的接口</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    tasks-&gt;<span class=\"built_in\">push_back</span>(task1);</span><br><span class=\"line\">    tasks-&gt;<span class=\"built_in\">push_back</span>(task2);</span><br><span class=\"line\">    tasks-&gt;<span class=\"built_in\">push_back</span>(task3);</span><br><span class=\"line\">    tasks-&gt;<span class=\"built_in\">push_back</span>(task4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"编写主程序\"><a href=\"#编写主程序\" class=\"headerlink\" title=\"编写主程序\"></a>编写主程序</h2><p>主程序文件名为<code>processPool.cc</code>,我们按类和接口从上往下编程</p>\n<h3 id=\"描述和组织\"><a href=\"#描述和组织\" class=\"headerlink\" title=\"描述和组织\"></a>描述和组织</h3><p>我们把头文件准备好,然后定义最大进程数和创建任务列表,接着创建<code>channel</code>类来描述每个进程池中的子进程</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;task.hpp&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span><span class=\"comment\">//获取时间戳</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> processNum = <span class=\"number\">5</span>;<span class=\"comment\">//最大进程数</span></span><br><span class=\"line\">std::vector&lt;<span class=\"type\">task_t</span>&gt; tasks;<span class=\"comment\">//承载任务的映射列表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//先描述</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">channel</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">channel</span>(<span class=\"type\">int</span> cmdfd,<span class=\"type\">pid_t</span> slaverid,std::string&amp; name)</span><br><span class=\"line\">    :_cmdfd(cmdfd),_slaverid(slaverid),_processname(name)</span><br><span class=\"line\">    &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _cmdfd;                    <span class=\"comment\">//发送任务的文件描述符</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> _slaverid;               <span class=\"comment\">//子进程的id </span></span><br><span class=\"line\">    std::string _processname;             <span class=\"comment\">//子进程的名字  --方便打印日志</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"slaver函数\"><a href=\"#slaver函数\" class=\"headerlink\" title=\"slaver函数\"></a>slaver函数</h3><p>创建子进程后，子进程都进入<code>slaver</code>函数等待获取任务</p>\n<p>这里统一采用<code>输入重定向</code>，在创建子进程后，进入<code>slaver()</code>前先把标准输入重定向到管道文件,然后从标准输入读取<code>任务码</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slaver</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cmdcode = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = <span class=\"built_in\">read</span>(<span class=\"number\">0</span>,&amp;cmdcode,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>));<span class=\"comment\">//读取任务码</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>))<span class=\"comment\">//成功获取任务码</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//std::cout&lt;&lt;&quot;child say@ &quot;&lt;&lt;&quot;get cmdcode: &quot;&lt;&lt;cmdcode&lt;&lt;std::endl;//DEBUG</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cmdcode &gt;=<span class=\"number\">0</span> &amp;&amp; cmdcode &lt; tasks.<span class=\"built_in\">size</span>())<span class=\"comment\">//输入合法的输入码</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                tasks[cmdcode]();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"comment\">//输出错误信息</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                std::cout&lt;&lt;<span class=\"string\">&quot;wrong cmdcode: &quot;</span>&lt;&lt;cmdcode </span><br><span class=\"line\">                    &lt;&lt;<span class=\"string\">&quot; max size: &quot;</span>&lt;&lt;tasks.<span class=\"built_in\">size</span>()&lt;&lt;std::endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"InnitChannels\"><a href=\"#InnitChannels\" class=\"headerlink\" title=\"InnitChannels\"></a>InnitChannels</h3><p>该函数用鱼创建子进程,创建子进程，并封装进频道类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitChannels</span><span class=\"params\">(std::vector&lt;channel&gt;* channels)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;processNum;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> pipefd[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> n = <span class=\"built_in\">pipe</span>(pipefd);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!n);</span><br><span class=\"line\">        (<span class=\"type\">void</span>)n;<span class=\"comment\">//调用一下n</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)<span class=\"comment\">//child</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>(pipefd[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"built_in\">dup2</span>(pipefd[<span class=\"number\">0</span>],<span class=\"number\">0</span>);<span class=\"comment\">//子进程输入重定向</span></span><br><span class=\"line\">            <span class=\"built_in\">slaver</span>();</span><br><span class=\"line\">            std::cout&lt;&lt;<span class=\"string\">&quot;proccess &quot;</span>&lt;&lt; <span class=\"built_in\">getpid</span>() &lt;&lt; <span class=\"string\">&quot; quit&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"comment\">//father</span></span><br><span class=\"line\">        <span class=\"built_in\">close</span>(pipefd[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        std::string name = <span class=\"string\">&quot;process-&quot;</span>+std::<span class=\"built_in\">to_string</span>(i);</span><br><span class=\"line\">        channels-&gt;<span class=\"built_in\">push_back</span>(<span class=\"built_in\">channel</span>(pipefd[<span class=\"number\">1</span>],id,name));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"channelDEBUG\"><a href=\"#channelDEBUG\" class=\"headerlink\" title=\"channelDEBUG\"></a>channelDEBUG</h3><p>这里封装一个用于测试创建频道的<code>DEBUG</code>函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Debug</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;channel&gt; channels)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;c:channels)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout&lt;&lt;c._cmdfd &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; c._slaverid&lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; c._processname &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ctrlSlaver\"><a href=\"#ctrlSlaver\" class=\"headerlink\" title=\"ctrlSlaver\"></a>ctrlSlaver</h3><p>这里封装一个<code>ctrlSlaver</code>用于控制子进程，也就是用于派发任务的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ctrlSlaver</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;channel&gt; &amp;channels)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)<span class=\"comment\">//随机派发10个任务</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cmdcode = <span class=\"built_in\">rand</span>() % tasks.<span class=\"built_in\">size</span>();<span class=\"comment\">//获取随机任务码</span></span><br><span class=\"line\">        <span class=\"type\">int</span> select_num = <span class=\"built_in\">rand</span>()%channels.<span class=\"built_in\">size</span>();<span class=\"comment\">//获取选择码</span></span><br><span class=\"line\">        std::cout&lt;&lt;<span class=\"string\">&quot;father say# &quot;</span>&lt;&lt;<span class=\"string\">&quot;taskcode: &quot;</span>&lt;&lt;cmdcode&lt;&lt;<span class=\"string\">&quot; send to &quot;</span>&lt;&lt;channels[select_num]._processname</span><br><span class=\"line\">            &lt;&lt; std::endl;<span class=\"comment\">//输出日志</span></span><br><span class=\"line\">        <span class=\"built_in\">write</span>(channels[select_num]._cmdfd,&amp;cmdcode,<span class=\"built_in\">sizeof</span>(cmdcode));<span class=\"comment\">//写入任务码，派发任务</span></span><br><span class=\"line\">        <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"QuitProcess\"><a href=\"#QuitProcess\" class=\"headerlink\" title=\"QuitProcess\"></a>QuitProcess</h3><p>最后当然要有父进程控制关闭子进程，并回收僵尸进程</p>\n<p>因为<code>InitChannels</code>中管道文件的处理比较粗糙，会发生如下图的关系，所以关闭时两步操作一定要放在两个循环中</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-13_11-25-01.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">QuitProcess</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;channel&gt;&amp; channels)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//因为创建子进程时管道文件的连接没有进一步处理，关系复杂，所以下面两个循环一定要分开来</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;c:channels)<span class=\"built_in\">close</span>(c._cmdfd);<span class=\"comment\">//关闭主进程管道文件的写端，使子进程的read函数读取失败，返回0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;c:channels)<span class=\"built_in\">waitpid</span>(c._slaverid,<span class=\"literal\">nullptr</span>,<span class=\"number\">0</span>);<span class=\"comment\">//阻塞等待子进程，回收僵尸进程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h3><p>经过上文一系列封装,<code>main</code>函数就可以简洁明了地描述子进程的运行过程了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"literal\">nullptr</span>) ^ <span class=\"built_in\">getpid</span>()^<span class=\"number\">1023</span>);<span class=\"comment\">//种随机数种子</span></span><br><span class=\"line\">    std::vector&lt;channel&gt; channels;</span><br><span class=\"line\">    <span class=\"comment\">//1.初始化</span></span><br><span class=\"line\">    <span class=\"built_in\">LoadTask</span>(&amp;tasks);<span class=\"comment\">//必须先载入任务再产生子进程，否则子进程看不到任务列表</span></span><br><span class=\"line\">    <span class=\"built_in\">InitChannels</span>(&amp;channels);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//测试函数</span></span><br><span class=\"line\">    <span class=\"comment\">//Debug(channels);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2.控制子进程</span></span><br><span class=\"line\">    <span class=\"built_in\">ctrlSlaver</span>(channels);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3.关闭进程池</span></span><br><span class=\"line\">    <span class=\"built_in\">QuitProcess</span>(channels);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"源文件\"><a href=\"#源文件\" class=\"headerlink\" title=\"源文件\"></a>源文件</h1><p><a href=\"https://github.com/sis-shen/Linux_Code/tree/main/pipe_use\">戳我去github仓库🔗</a></p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409052350711.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p><code>匿名管道</code>可用于父子进程间的通讯，于是可以有父进程创建多个子进程形成<code>进程池</code>，并通过<code>匿名管道</code>文件向各个子进程<code>派发任务</code></p>\n<p><a href=\"https://www.supdriver.top/2024/08/02/pipe/\">戳我去管道原理🔗</a></p>\n<p>这里使用C++编写进程池代码，在程序中创建多个进程，并在父进程中使用自定义类<code>channel</code>用于描述和管理子进程,然后在<code>task.hpp</code>中模拟一些任务给主程序随机派发</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><h2 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h2><p>这次对形参有了新的规范,这里用<code>variable</code>代指形参名</p>\n<ul>\n<li>输入: <code>const &amp;variable</code></li>\n<li>输出: <code>*variable</code></li>\n<li>输入输出: <code>&amp;variable</code></li>\n</ul>\n<h2 id=\"准备makefile文件\"><a href=\"#准备makefile文件\" class=\"headerlink\" title=\"准备makefile文件\"></a>准备makefile文件</h2><p>这里使用<code>g++</code>编译，规定语法标准为<code>C++11</code></p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">processPool:processPool.cc</span></span><br><span class=\"line\">\tg++ -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> -std=c++11</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"keyword\">.PHONY</span>:clean</span></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\trm -rf processPool</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"准备任务文件\"><a href=\"#准备任务文件\" class=\"headerlink\" title=\"准备任务文件\"></a>准备任务文件</h2><p>首先要准备前后需要用到的头文件,然后构建模拟任务，并提供加载任务列表的函数</p>\n<blockquote>\n<p><code>task.hpp</code></p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*<span class=\"type\">task_t</span>)</span><span class=\"params\">()</span></span>;<span class=\"comment\">//定义函数指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">task1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;PVZ 刷新日志&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">task2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout&lt;&lt; <span class=\"string\">&quot;PVZ 生成阳光&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">task3</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout&lt;&lt;<span class=\"string\">&quot;PVZ 检测更新&quot;</span> &lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">task4</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout&lt;&lt;<span class=\"string\">&quot;PVZ 使用能量豆&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">LoadTask</span><span class=\"params\">(std::vector&lt;<span class=\"type\">task_t</span>&gt;*tasks)</span><span class=\"comment\">//载入任务列表的接口</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    tasks-&gt;<span class=\"built_in\">push_back</span>(task1);</span><br><span class=\"line\">    tasks-&gt;<span class=\"built_in\">push_back</span>(task2);</span><br><span class=\"line\">    tasks-&gt;<span class=\"built_in\">push_back</span>(task3);</span><br><span class=\"line\">    tasks-&gt;<span class=\"built_in\">push_back</span>(task4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"编写主程序\"><a href=\"#编写主程序\" class=\"headerlink\" title=\"编写主程序\"></a>编写主程序</h2><p>主程序文件名为<code>processPool.cc</code>,我们按类和接口从上往下编程</p>\n<h3 id=\"描述和组织\"><a href=\"#描述和组织\" class=\"headerlink\" title=\"描述和组织\"></a>描述和组织</h3><p>我们把头文件准备好,然后定义最大进程数和创建任务列表,接着创建<code>channel</code>类来描述每个进程池中的子进程</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;task.hpp&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span><span class=\"comment\">//获取时间戳</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> processNum = <span class=\"number\">5</span>;<span class=\"comment\">//最大进程数</span></span><br><span class=\"line\">std::vector&lt;<span class=\"type\">task_t</span>&gt; tasks;<span class=\"comment\">//承载任务的映射列表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//先描述</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">channel</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">channel</span>(<span class=\"type\">int</span> cmdfd,<span class=\"type\">pid_t</span> slaverid,std::string&amp; name)</span><br><span class=\"line\">    :_cmdfd(cmdfd),_slaverid(slaverid),_processname(name)</span><br><span class=\"line\">    &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _cmdfd;                    <span class=\"comment\">//发送任务的文件描述符</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span> _slaverid;               <span class=\"comment\">//子进程的id </span></span><br><span class=\"line\">    std::string _processname;             <span class=\"comment\">//子进程的名字  --方便打印日志</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"slaver函数\"><a href=\"#slaver函数\" class=\"headerlink\" title=\"slaver函数\"></a>slaver函数</h3><p>创建子进程后，子进程都进入<code>slaver</code>函数等待获取任务</p>\n<p>这里统一采用<code>输入重定向</code>，在创建子进程后，进入<code>slaver()</code>前先把标准输入重定向到管道文件,然后从标准输入读取<code>任务码</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slaver</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cmdcode = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = <span class=\"built_in\">read</span>(<span class=\"number\">0</span>,&amp;cmdcode,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>));<span class=\"comment\">//读取任务码</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>))<span class=\"comment\">//成功获取任务码</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//std::cout&lt;&lt;&quot;child say@ &quot;&lt;&lt;&quot;get cmdcode: &quot;&lt;&lt;cmdcode&lt;&lt;std::endl;//DEBUG</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cmdcode &gt;=<span class=\"number\">0</span> &amp;&amp; cmdcode &lt; tasks.<span class=\"built_in\">size</span>())<span class=\"comment\">//输入合法的输入码</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                tasks[cmdcode]();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"comment\">//输出错误信息</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                std::cout&lt;&lt;<span class=\"string\">&quot;wrong cmdcode: &quot;</span>&lt;&lt;cmdcode </span><br><span class=\"line\">                    &lt;&lt;<span class=\"string\">&quot; max size: &quot;</span>&lt;&lt;tasks.<span class=\"built_in\">size</span>()&lt;&lt;std::endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"InnitChannels\"><a href=\"#InnitChannels\" class=\"headerlink\" title=\"InnitChannels\"></a>InnitChannels</h3><p>该函数用鱼创建子进程,创建子进程，并封装进频道类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitChannels</span><span class=\"params\">(std::vector&lt;channel&gt;* channels)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;processNum;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> pipefd[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> n = <span class=\"built_in\">pipe</span>(pipefd);</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(!n);</span><br><span class=\"line\">        (<span class=\"type\">void</span>)n;<span class=\"comment\">//调用一下n</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)<span class=\"comment\">//child</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>(pipefd[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"built_in\">dup2</span>(pipefd[<span class=\"number\">0</span>],<span class=\"number\">0</span>);<span class=\"comment\">//子进程输入重定向</span></span><br><span class=\"line\">            <span class=\"built_in\">slaver</span>();</span><br><span class=\"line\">            std::cout&lt;&lt;<span class=\"string\">&quot;proccess &quot;</span>&lt;&lt; <span class=\"built_in\">getpid</span>() &lt;&lt; <span class=\"string\">&quot; quit&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"comment\">//father</span></span><br><span class=\"line\">        <span class=\"built_in\">close</span>(pipefd[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        std::string name = <span class=\"string\">&quot;process-&quot;</span>+std::<span class=\"built_in\">to_string</span>(i);</span><br><span class=\"line\">        channels-&gt;<span class=\"built_in\">push_back</span>(<span class=\"built_in\">channel</span>(pipefd[<span class=\"number\">1</span>],id,name));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"channelDEBUG\"><a href=\"#channelDEBUG\" class=\"headerlink\" title=\"channelDEBUG\"></a>channelDEBUG</h3><p>这里封装一个用于测试创建频道的<code>DEBUG</code>函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Debug</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;channel&gt; channels)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;c:channels)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout&lt;&lt;c._cmdfd &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; c._slaverid&lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; c._processname &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ctrlSlaver\"><a href=\"#ctrlSlaver\" class=\"headerlink\" title=\"ctrlSlaver\"></a>ctrlSlaver</h3><p>这里封装一个<code>ctrlSlaver</code>用于控制子进程，也就是用于派发任务的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ctrlSlaver</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;channel&gt; &amp;channels)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)<span class=\"comment\">//随机派发10个任务</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cmdcode = <span class=\"built_in\">rand</span>() % tasks.<span class=\"built_in\">size</span>();<span class=\"comment\">//获取随机任务码</span></span><br><span class=\"line\">        <span class=\"type\">int</span> select_num = <span class=\"built_in\">rand</span>()%channels.<span class=\"built_in\">size</span>();<span class=\"comment\">//获取选择码</span></span><br><span class=\"line\">        std::cout&lt;&lt;<span class=\"string\">&quot;father say# &quot;</span>&lt;&lt;<span class=\"string\">&quot;taskcode: &quot;</span>&lt;&lt;cmdcode&lt;&lt;<span class=\"string\">&quot; send to &quot;</span>&lt;&lt;channels[select_num]._processname</span><br><span class=\"line\">            &lt;&lt; std::endl;<span class=\"comment\">//输出日志</span></span><br><span class=\"line\">        <span class=\"built_in\">write</span>(channels[select_num]._cmdfd,&amp;cmdcode,<span class=\"built_in\">sizeof</span>(cmdcode));<span class=\"comment\">//写入任务码，派发任务</span></span><br><span class=\"line\">        <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"QuitProcess\"><a href=\"#QuitProcess\" class=\"headerlink\" title=\"QuitProcess\"></a>QuitProcess</h3><p>最后当然要有父进程控制关闭子进程，并回收僵尸进程</p>\n<p>因为<code>InitChannels</code>中管道文件的处理比较粗糙，会发生如下图的关系，所以关闭时两步操作一定要放在两个循环中</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-13_11-25-01.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">QuitProcess</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;channel&gt;&amp; channels)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//因为创建子进程时管道文件的连接没有进一步处理，关系复杂，所以下面两个循环一定要分开来</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;c:channels)<span class=\"built_in\">close</span>(c._cmdfd);<span class=\"comment\">//关闭主进程管道文件的写端，使子进程的read函数读取失败，返回0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;c:channels)<span class=\"built_in\">waitpid</span>(c._slaverid,<span class=\"literal\">nullptr</span>,<span class=\"number\">0</span>);<span class=\"comment\">//阻塞等待子进程，回收僵尸进程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h3><p>经过上文一系列封装,<code>main</code>函数就可以简洁明了地描述子进程的运行过程了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"literal\">nullptr</span>) ^ <span class=\"built_in\">getpid</span>()^<span class=\"number\">1023</span>);<span class=\"comment\">//种随机数种子</span></span><br><span class=\"line\">    std::vector&lt;channel&gt; channels;</span><br><span class=\"line\">    <span class=\"comment\">//1.初始化</span></span><br><span class=\"line\">    <span class=\"built_in\">LoadTask</span>(&amp;tasks);<span class=\"comment\">//必须先载入任务再产生子进程，否则子进程看不到任务列表</span></span><br><span class=\"line\">    <span class=\"built_in\">InitChannels</span>(&amp;channels);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//测试函数</span></span><br><span class=\"line\">    <span class=\"comment\">//Debug(channels);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2.控制子进程</span></span><br><span class=\"line\">    <span class=\"built_in\">ctrlSlaver</span>(channels);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3.关闭进程池</span></span><br><span class=\"line\">    <span class=\"built_in\">QuitProcess</span>(channels);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"源文件\"><a href=\"#源文件\" class=\"headerlink\" title=\"源文件\"></a>源文件</h1><p><a href=\"https://github.com/sis-shen/Linux_Code/tree/main/pipe_use\">戳我去github仓库🔗</a></p>\n"},{"title":"指针详解","date":"2023-11-22T23:35:39.000Z","_content":"*这篇质量不太行:（*\n# 内存和地址 #\n在了解指针之前，先讲讲内存是如何管理的\n\n首先因为内存很大（一般有几个G）,所以为了高效管理，有了`内存单元`的概念。而这个单元的大小，正好是一个字节。\n\n因为一个`比特位`就是一个二进制位，太小了，超过一个字节，在处理`char`这样一个字节长的变量很麻烦。\n\n定下长度后，就可以给内存单元编号，而每个内存单元获得的独一无二的编号，便是它的**地址**,以声明了一个变量a为例,示意图如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_09-59-30.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_10-21-48.png)\n\n## 变量的地址\n\n上图中`a`占4个字节，每个字节都有自己的地址，但要找到`a`其实只需要找到第一个地址就行了，实际上在`C语言`中也是如此,`a`的地址就是`首字节地址`,即图中的`0x000000AF88DFF6A4`\n\n## 关于几个名词 #\n在`C语言`中称`地址`为`指针`,**储存**地址的变量叫`指针变量`,平时也**简称**`指针`,此时强调的是`指针变量`里储存的地址，而不是这个变量。\n\n## 指针变量的组成 #\n指针变量也要**拆成两部分**来看\n\n一个是变量的`值`,在同一个程序中，所有指针变量的值的`长度`都是一样的，都指向了某**一**个内存中的`字节`, 至于具体多长，取决于环境:`32位程序是4个字节`,`64位程序是8个字节`\n\n另一个是变量的`类型`,类型决定编译器从`值`所指向的字节，向后总共读**几个**字节，以及用**什么方式**读取内存里的内容。以下图的代码为例\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-36-47.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-29-53.png)\n\n可以看到三种指针指向了**同一个**字节，即它们的值是相等的，但`指针类型`不同，解引用之后得到的`值`也不同,\n\n`char`比`int`短，所以`*p_char`只能取到`00`,\n\n而虽然`float`和`int`一样长，但对内存的**读法不同**，所以`*p_float`和`*p_int`依然不同\n\n# 指针(变量)的使用 #\n\n## 声明指针变量 #\n\n指针变量也是变量，在没有结合性问题时，和一般变量的声明方式差不多。\n\n变量的声明:`变量类型` + `变量名`\n\n指针的声明:`指向的变量类型` + `*` + `变量名`\n\n以下以声明一个字符指针为例\n\n```C\nchar* pointer = NULL;\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-24_10-02-19.png)\n\n*变量的声明逻辑如上图*\n\n### 进阶：二级指针->N级指针 #\n我们可以用同样的逻辑声明更高级的指针\n\n```C\nchar* *ppstr = NULL;//ppstr是一个二级指针\nchar** *ppstr = NULL;//pppstr是一个三级指针\n```\n\n在声明中,前面的`char*`声明了`ppstr`**指向**的变量类型,后面的`*`与`变量名`结合，声明`ppstr`是一个指针.\n\n此处，称指向`一级指针`的指针为`二级指针`,同理有`三级指针`,至`N级指针`.\n\n## 指针的解引用 #\n指针最常见的用处就是通过变量里**储存的地址**，通过直接修改目标变量的**内存**来修改变量的值 ， 当然还有强制转换指针类型来读取目标变量的**一部分**内存 之类的骚操作\n\n### 函数的传址调用 #\n在遇到指针前，使用函数时，由于实参传到函数里都变成了**形参**,无法通过形参（*包括修改形参的值*）来改变实参的值，因为形参终究只是实参的一份**临时拷贝**.\n\n而有了指针之后，函数的实参，形参关系不变，但我们有了**更高端**的形参,也就是`指针`, 尽管`函数内的指针`依旧是`函数外的指针`的**临时拷贝**,但我们已经能通过其储存的**值**访问`函数外变量`的内存了,同时包括`读取`和`修改`, 这种通过传入指针来修改外部变量的函数调用，便称为`函数的传址调用`\n\n*以如下代码为例*\n\n```C\nvoid Swap_int(int*a,int*b)\n{\n    //给我两个整型的地址，我就能 真·交换它们的值\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n```\n\n#### 提问?如何修改函数外的指针的值? #\n依然还是把这一**指针的地址**传进去，而函数的形参写成**更高一级**的指针\n\n*如下代码，例如我想在函数里把外部的指针置空*\n\n```C\nvoid Reset(char* *pstr) \n{\n    *pstr = NULL;\n}\n\nint main()\n{\n    char* str;\n    Reset(&str)//对一级指针取地址，传入二级指针\n    return 0;\n}\n```\n\n# 有关指针的危险操作 #\n## 野指针的解引用 #\n\n有些指针因为错误操作，指向了不能访问的内存，一旦解引用，就有可能使程序崩溃\n\n*情形如下*\n\n### 使用了 未初始化/赋值 的指针 #\n```C\nint* pa;//未初始化，pa的值为随机值\n*pa = 0 ;//野指针的解引用\n\n//正确的用法\nint arr[10] = {0};\n\nint* pa;\npa = arr;//立即初始化\nint* pb = NULL;//初始化\n\n```\n所以声明指针时最好初始化,如果不知道初始化成什么，就用`NULL`空指针初始化\n\n### 指向了 已回收的 内存空间 #\n有的函数**错误***地返回了内部临时变量的地址， 在**外面**使用返回的指针，因为此时函数的栈帧已经**销毁**，会发生野指针的解引用\n\n```C\nchar* fun(void)\n{\n    char a = 0;\n    char* pa = &a;\n    return pa;\n}\n\nint main()\n{\n    //情形一\n    char* pa = fun();\n    *pa = 1;//此时变量a已经销毁，发生野指针的解引用，即非法访问\n\n    //情形二\n    char* str = (char*) malloc(sizeof(char) *10) //在堆区开辟10个字节的空间\n    free(str);//然后释放掉\n    str[0] = 'A';//试图访问已free的内存，并写入，发生非法访问\n    return 0;\n}\n\n```\n\n## 空指针的解引用 #\n空指针`NULL`,`值`为`0`,一旦解引用就会报错，所以在解引用陌生指针时一定要注意判空\n\n```C\n//情形一\nchar* func(char* str)\n{\n    if(str == NULL)//防止使用者错误传入空指针\n    {\n        return NULL;\n    }\n\n    printf(\"%s\\n\");\n}\n//情形二\nchar* InitArray(char** pstr)\n{\n    if(pstr == NULL)\n    {\n        return NULL;\n    }\n    *pstr = (char*)malloc(sizeof(char) * 10);\n    if(*ptr == NULL)//malloc一旦失败就会返回NULL,所以调用后一定要判空\n    {\n        return NULL;\n    }\n}\n\n```\n\n\n\n\n\n\n\n","source":"_posts/pointer.md","raw":"---\ntitle: 指针详解\ndate: 2023-11-23 07:35:39\ntags:\n---\n*这篇质量不太行:（*\n# 内存和地址 #\n在了解指针之前，先讲讲内存是如何管理的\n\n首先因为内存很大（一般有几个G）,所以为了高效管理，有了`内存单元`的概念。而这个单元的大小，正好是一个字节。\n\n因为一个`比特位`就是一个二进制位，太小了，超过一个字节，在处理`char`这样一个字节长的变量很麻烦。\n\n定下长度后，就可以给内存单元编号，而每个内存单元获得的独一无二的编号，便是它的**地址**,以声明了一个变量a为例,示意图如下\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_09-59-30.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_10-21-48.png)\n\n## 变量的地址\n\n上图中`a`占4个字节，每个字节都有自己的地址，但要找到`a`其实只需要找到第一个地址就行了，实际上在`C语言`中也是如此,`a`的地址就是`首字节地址`,即图中的`0x000000AF88DFF6A4`\n\n## 关于几个名词 #\n在`C语言`中称`地址`为`指针`,**储存**地址的变量叫`指针变量`,平时也**简称**`指针`,此时强调的是`指针变量`里储存的地址，而不是这个变量。\n\n## 指针变量的组成 #\n指针变量也要**拆成两部分**来看\n\n一个是变量的`值`,在同一个程序中，所有指针变量的值的`长度`都是一样的，都指向了某**一**个内存中的`字节`, 至于具体多长，取决于环境:`32位程序是4个字节`,`64位程序是8个字节`\n\n另一个是变量的`类型`,类型决定编译器从`值`所指向的字节，向后总共读**几个**字节，以及用**什么方式**读取内存里的内容。以下图的代码为例\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-36-47.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-29-53.png)\n\n可以看到三种指针指向了**同一个**字节，即它们的值是相等的，但`指针类型`不同，解引用之后得到的`值`也不同,\n\n`char`比`int`短，所以`*p_char`只能取到`00`,\n\n而虽然`float`和`int`一样长，但对内存的**读法不同**，所以`*p_float`和`*p_int`依然不同\n\n# 指针(变量)的使用 #\n\n## 声明指针变量 #\n\n指针变量也是变量，在没有结合性问题时，和一般变量的声明方式差不多。\n\n变量的声明:`变量类型` + `变量名`\n\n指针的声明:`指向的变量类型` + `*` + `变量名`\n\n以下以声明一个字符指针为例\n\n```C\nchar* pointer = NULL;\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-24_10-02-19.png)\n\n*变量的声明逻辑如上图*\n\n### 进阶：二级指针->N级指针 #\n我们可以用同样的逻辑声明更高级的指针\n\n```C\nchar* *ppstr = NULL;//ppstr是一个二级指针\nchar** *ppstr = NULL;//pppstr是一个三级指针\n```\n\n在声明中,前面的`char*`声明了`ppstr`**指向**的变量类型,后面的`*`与`变量名`结合，声明`ppstr`是一个指针.\n\n此处，称指向`一级指针`的指针为`二级指针`,同理有`三级指针`,至`N级指针`.\n\n## 指针的解引用 #\n指针最常见的用处就是通过变量里**储存的地址**，通过直接修改目标变量的**内存**来修改变量的值 ， 当然还有强制转换指针类型来读取目标变量的**一部分**内存 之类的骚操作\n\n### 函数的传址调用 #\n在遇到指针前，使用函数时，由于实参传到函数里都变成了**形参**,无法通过形参（*包括修改形参的值*）来改变实参的值，因为形参终究只是实参的一份**临时拷贝**.\n\n而有了指针之后，函数的实参，形参关系不变，但我们有了**更高端**的形参,也就是`指针`, 尽管`函数内的指针`依旧是`函数外的指针`的**临时拷贝**,但我们已经能通过其储存的**值**访问`函数外变量`的内存了,同时包括`读取`和`修改`, 这种通过传入指针来修改外部变量的函数调用，便称为`函数的传址调用`\n\n*以如下代码为例*\n\n```C\nvoid Swap_int(int*a,int*b)\n{\n    //给我两个整型的地址，我就能 真·交换它们的值\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n```\n\n#### 提问?如何修改函数外的指针的值? #\n依然还是把这一**指针的地址**传进去，而函数的形参写成**更高一级**的指针\n\n*如下代码，例如我想在函数里把外部的指针置空*\n\n```C\nvoid Reset(char* *pstr) \n{\n    *pstr = NULL;\n}\n\nint main()\n{\n    char* str;\n    Reset(&str)//对一级指针取地址，传入二级指针\n    return 0;\n}\n```\n\n# 有关指针的危险操作 #\n## 野指针的解引用 #\n\n有些指针因为错误操作，指向了不能访问的内存，一旦解引用，就有可能使程序崩溃\n\n*情形如下*\n\n### 使用了 未初始化/赋值 的指针 #\n```C\nint* pa;//未初始化，pa的值为随机值\n*pa = 0 ;//野指针的解引用\n\n//正确的用法\nint arr[10] = {0};\n\nint* pa;\npa = arr;//立即初始化\nint* pb = NULL;//初始化\n\n```\n所以声明指针时最好初始化,如果不知道初始化成什么，就用`NULL`空指针初始化\n\n### 指向了 已回收的 内存空间 #\n有的函数**错误***地返回了内部临时变量的地址， 在**外面**使用返回的指针，因为此时函数的栈帧已经**销毁**，会发生野指针的解引用\n\n```C\nchar* fun(void)\n{\n    char a = 0;\n    char* pa = &a;\n    return pa;\n}\n\nint main()\n{\n    //情形一\n    char* pa = fun();\n    *pa = 1;//此时变量a已经销毁，发生野指针的解引用，即非法访问\n\n    //情形二\n    char* str = (char*) malloc(sizeof(char) *10) //在堆区开辟10个字节的空间\n    free(str);//然后释放掉\n    str[0] = 'A';//试图访问已free的内存，并写入，发生非法访问\n    return 0;\n}\n\n```\n\n## 空指针的解引用 #\n空指针`NULL`,`值`为`0`,一旦解引用就会报错，所以在解引用陌生指针时一定要注意判空\n\n```C\n//情形一\nchar* func(char* str)\n{\n    if(str == NULL)//防止使用者错误传入空指针\n    {\n        return NULL;\n    }\n\n    printf(\"%s\\n\");\n}\n//情形二\nchar* InitArray(char** pstr)\n{\n    if(pstr == NULL)\n    {\n        return NULL;\n    }\n    *pstr = (char*)malloc(sizeof(char) * 10);\n    if(*ptr == NULL)//malloc一旦失败就会返回NULL,所以调用后一定要判空\n    {\n        return NULL;\n    }\n}\n\n```\n\n\n\n\n\n\n\n","slug":"pointer","published":1,"updated":"2024-05-22T15:13:43.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08l001j4sp5bx0yhoqn","content":"<p><em>这篇质量不太行:（</em></p>\n<h1 id=\"内存和地址\"><a href=\"#内存和地址\" class=\"headerlink\" title=\"内存和地址\"></a>内存和地址</h1><p>在了解指针之前，先讲讲内存是如何管理的</p>\n<p>首先因为内存很大（一般有几个G）,所以为了高效管理，有了<code>内存单元</code>的概念。而这个单元的大小，正好是一个字节。</p>\n<p>因为一个<code>比特位</code>就是一个二进制位，太小了，超过一个字节，在处理<code>char</code>这样一个字节长的变量很麻烦。</p>\n<p>定下长度后，就可以给内存单元编号，而每个内存单元获得的独一无二的编号，便是它的<strong>地址</strong>,以声明了一个变量a为例,示意图如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_09-59-30.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_10-21-48.png\"></p>\n<h2 id=\"变量的地址\"><a href=\"#变量的地址\" class=\"headerlink\" title=\"变量的地址\"></a>变量的地址</h2><p>上图中<code>a</code>占4个字节，每个字节都有自己的地址，但要找到<code>a</code>其实只需要找到第一个地址就行了，实际上在<code>C语言</code>中也是如此,<code>a</code>的地址就是<code>首字节地址</code>,即图中的<code>0x000000AF88DFF6A4</code></p>\n<h2 id=\"关于几个名词\"><a href=\"#关于几个名词\" class=\"headerlink\" title=\"关于几个名词\"></a>关于几个名词</h2><p>在<code>C语言</code>中称<code>地址</code>为<code>指针</code>,<strong>储存</strong>地址的变量叫<code>指针变量</code>,平时也<strong>简称</strong><code>指针</code>,此时强调的是<code>指针变量</code>里储存的地址，而不是这个变量。</p>\n<h2 id=\"指针变量的组成\"><a href=\"#指针变量的组成\" class=\"headerlink\" title=\"指针变量的组成\"></a>指针变量的组成</h2><p>指针变量也要<strong>拆成两部分</strong>来看</p>\n<p>一个是变量的<code>值</code>,在同一个程序中，所有指针变量的值的<code>长度</code>都是一样的，都指向了某<strong>一</strong>个内存中的<code>字节</code>, 至于具体多长，取决于环境:<code>32位程序是4个字节</code>,<code>64位程序是8个字节</code></p>\n<p>另一个是变量的<code>类型</code>,类型决定编译器从<code>值</code>所指向的字节，向后总共读<strong>几个</strong>字节，以及用<strong>什么方式</strong>读取内存里的内容。以下图的代码为例</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-36-47.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-29-53.png\"></p>\n<p>可以看到三种指针指向了<strong>同一个</strong>字节，即它们的值是相等的，但<code>指针类型</code>不同，解引用之后得到的<code>值</code>也不同,</p>\n<p><code>char</code>比<code>int</code>短，所以<code>*p_char</code>只能取到<code>00</code>,</p>\n<p>而虽然<code>float</code>和<code>int</code>一样长，但对内存的<strong>读法不同</strong>，所以<code>*p_float</code>和<code>*p_int</code>依然不同</p>\n<h1 id=\"指针-变量-的使用\"><a href=\"#指针-变量-的使用\" class=\"headerlink\" title=\"指针(变量)的使用\"></a>指针(变量)的使用</h1><h2 id=\"声明指针变量\"><a href=\"#声明指针变量\" class=\"headerlink\" title=\"声明指针变量\"></a>声明指针变量</h2><p>指针变量也是变量，在没有结合性问题时，和一般变量的声明方式差不多。</p>\n<p>变量的声明:<code>变量类型</code> + <code>变量名</code></p>\n<p>指针的声明:<code>指向的变量类型</code> + <code>*</code> + <code>变量名</code></p>\n<p>以下以声明一个字符指针为例</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* pointer = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-24_10-02-19.png\"></p>\n<p><em>变量的声明逻辑如上图</em></p>\n<h3 id=\"进阶：二级指针-N级指针\"><a href=\"#进阶：二级指针-N级指针\" class=\"headerlink\" title=\"进阶：二级指针-&gt;N级指针\"></a>进阶：二级指针-&gt;N级指针</h3><p>我们可以用同样的逻辑声明更高级的指针</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* *ppstr = <span class=\"literal\">NULL</span>;<span class=\"comment\">//ppstr是一个二级指针</span></span><br><span class=\"line\"><span class=\"type\">char</span>** *ppstr = <span class=\"literal\">NULL</span>;<span class=\"comment\">//pppstr是一个三级指针</span></span><br></pre></td></tr></table></figure>\n\n<p>在声明中,前面的<code>char*</code>声明了<code>ppstr</code><strong>指向</strong>的变量类型,后面的<code>*</code>与<code>变量名</code>结合，声明<code>ppstr</code>是一个指针.</p>\n<p>此处，称指向<code>一级指针</code>的指针为<code>二级指针</code>,同理有<code>三级指针</code>,至<code>N级指针</code>.</p>\n<h2 id=\"指针的解引用\"><a href=\"#指针的解引用\" class=\"headerlink\" title=\"指针的解引用\"></a>指针的解引用</h2><p>指针最常见的用处就是通过变量里<strong>储存的地址</strong>，通过直接修改目标变量的<strong>内存</strong>来修改变量的值 ， 当然还有强制转换指针类型来读取目标变量的<strong>一部分</strong>内存 之类的骚操作</p>\n<h3 id=\"函数的传址调用\"><a href=\"#函数的传址调用\" class=\"headerlink\" title=\"函数的传址调用\"></a>函数的传址调用</h3><p>在遇到指针前，使用函数时，由于实参传到函数里都变成了<strong>形参</strong>,无法通过形参（<em>包括修改形参的值</em>）来改变实参的值，因为形参终究只是实参的一份<strong>临时拷贝</strong>.</p>\n<p>而有了指针之后，函数的实参，形参关系不变，但我们有了<strong>更高端</strong>的形参,也就是<code>指针</code>, 尽管<code>函数内的指针</code>依旧是<code>函数外的指针</code>的<strong>临时拷贝</strong>,但我们已经能通过其储存的<strong>值</strong>访问<code>函数外变量</code>的内存了,同时包括<code>读取</code>和<code>修改</code>, 这种通过传入指针来修改外部变量的函数调用，便称为<code>函数的传址调用</code></p>\n<p><em>以如下代码为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Swap_int</span><span class=\"params\">(<span class=\"type\">int</span>*a,<span class=\"type\">int</span>*b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//给我两个整型的地址，我就能 真·交换它们的值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tmp = *a;</span><br><span class=\"line\">    *a = *b;</span><br><span class=\"line\">    *b = tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"提问-如何修改函数外的指针的值\"><a href=\"#提问-如何修改函数外的指针的值\" class=\"headerlink\" title=\"提问?如何修改函数外的指针的值?\"></a>提问?如何修改函数外的指针的值?</h4><p>依然还是把这一<strong>指针的地址</strong>传进去，而函数的形参写成<strong>更高一级</strong>的指针</p>\n<p><em>如下代码，例如我想在函数里把外部的指针置空</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Reset</span><span class=\"params\">(<span class=\"type\">char</span>* *pstr)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    *pstr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* str;</span><br><span class=\"line\">    Reset(&amp;str)<span class=\"comment\">//对一级指针取地址，传入二级指针</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"有关指针的危险操作\"><a href=\"#有关指针的危险操作\" class=\"headerlink\" title=\"有关指针的危险操作\"></a>有关指针的危险操作</h1><h2 id=\"野指针的解引用\"><a href=\"#野指针的解引用\" class=\"headerlink\" title=\"野指针的解引用\"></a>野指针的解引用</h2><p>有些指针因为错误操作，指向了不能访问的内存，一旦解引用，就有可能使程序崩溃</p>\n<p><em>情形如下</em></p>\n<h3 id=\"使用了-未初始化-赋值-的指针\"><a href=\"#使用了-未初始化-赋值-的指针\" class=\"headerlink\" title=\"使用了 未初始化&#x2F;赋值 的指针\"></a>使用了 未初始化&#x2F;赋值 的指针</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* pa;<span class=\"comment\">//未初始化，pa的值为随机值</span></span><br><span class=\"line\">*pa = <span class=\"number\">0</span> ;<span class=\"comment\">//野指针的解引用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//正确的用法</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span>* pa;</span><br><span class=\"line\">pa = arr;<span class=\"comment\">//立即初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span>* pb = <span class=\"literal\">NULL</span>;<span class=\"comment\">//初始化</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>所以声明指针时最好初始化,如果不知道初始化成什么，就用<code>NULL</code>空指针初始化</p>\n<h3 id=\"指向了-已回收的-内存空间\"><a href=\"#指向了-已回收的-内存空间\" class=\"headerlink\" title=\"指向了 已回收的 内存空间\"></a>指向了 已回收的 内存空间</h3><p>有的函数<strong>错误</strong>*地返回了内部临时变量的地址， 在<strong>外面</strong>使用返回的指针，因为此时函数的栈帧已经<strong>销毁</strong>，会发生野指针的解引用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* <span class=\"title function_\">fun</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span>* pa = &amp;a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pa;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//情形一</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* pa = fun();</span><br><span class=\"line\">    *pa = <span class=\"number\">1</span>;<span class=\"comment\">//此时变量a已经销毁，发生野指针的解引用，即非法访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//情形二</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* str = (<span class=\"type\">char</span>*) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>) *<span class=\"number\">10</span>) <span class=\"comment\">//在堆区开辟10个字节的空间</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(str);<span class=\"comment\">//然后释放掉</span></span><br><span class=\"line\">    str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;A&#x27;</span>;<span class=\"comment\">//试图访问已free的内存，并写入，发生非法访问</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"空指针的解引用\"><a href=\"#空指针的解引用\" class=\"headerlink\" title=\"空指针的解引用\"></a>空指针的解引用</h2><p>空指针<code>NULL</code>,<code>值</code>为<code>0</code>,一旦解引用就会报错，所以在解引用陌生指针时一定要注意判空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//情形一</span></span><br><span class=\"line\"><span class=\"type\">char</span>* <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">char</span>* str)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str == <span class=\"literal\">NULL</span>)<span class=\"comment\">//防止使用者错误传入空指针</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//情形二</span></span><br><span class=\"line\"><span class=\"type\">char</span>* <span class=\"title function_\">InitArray</span><span class=\"params\">(<span class=\"type\">char</span>** pstr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pstr == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *pstr = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>) * <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*ptr == <span class=\"literal\">NULL</span>)<span class=\"comment\">//malloc一旦失败就会返回NULL,所以调用后一定要判空</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/d13a1291622bbd20e6b92dd4c9aab2b0.jpg","cover_type":"img","excerpt":"","more":"<p><em>这篇质量不太行:（</em></p>\n<h1 id=\"内存和地址\"><a href=\"#内存和地址\" class=\"headerlink\" title=\"内存和地址\"></a>内存和地址</h1><p>在了解指针之前，先讲讲内存是如何管理的</p>\n<p>首先因为内存很大（一般有几个G）,所以为了高效管理，有了<code>内存单元</code>的概念。而这个单元的大小，正好是一个字节。</p>\n<p>因为一个<code>比特位</code>就是一个二进制位，太小了，超过一个字节，在处理<code>char</code>这样一个字节长的变量很麻烦。</p>\n<p>定下长度后，就可以给内存单元编号，而每个内存单元获得的独一无二的编号，便是它的<strong>地址</strong>,以声明了一个变量a为例,示意图如下</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_09-59-30.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_10-21-48.png\"></p>\n<h2 id=\"变量的地址\"><a href=\"#变量的地址\" class=\"headerlink\" title=\"变量的地址\"></a>变量的地址</h2><p>上图中<code>a</code>占4个字节，每个字节都有自己的地址，但要找到<code>a</code>其实只需要找到第一个地址就行了，实际上在<code>C语言</code>中也是如此,<code>a</code>的地址就是<code>首字节地址</code>,即图中的<code>0x000000AF88DFF6A4</code></p>\n<h2 id=\"关于几个名词\"><a href=\"#关于几个名词\" class=\"headerlink\" title=\"关于几个名词\"></a>关于几个名词</h2><p>在<code>C语言</code>中称<code>地址</code>为<code>指针</code>,<strong>储存</strong>地址的变量叫<code>指针变量</code>,平时也<strong>简称</strong><code>指针</code>,此时强调的是<code>指针变量</code>里储存的地址，而不是这个变量。</p>\n<h2 id=\"指针变量的组成\"><a href=\"#指针变量的组成\" class=\"headerlink\" title=\"指针变量的组成\"></a>指针变量的组成</h2><p>指针变量也要<strong>拆成两部分</strong>来看</p>\n<p>一个是变量的<code>值</code>,在同一个程序中，所有指针变量的值的<code>长度</code>都是一样的，都指向了某<strong>一</strong>个内存中的<code>字节</code>, 至于具体多长，取决于环境:<code>32位程序是4个字节</code>,<code>64位程序是8个字节</code></p>\n<p>另一个是变量的<code>类型</code>,类型决定编译器从<code>值</code>所指向的字节，向后总共读<strong>几个</strong>字节，以及用<strong>什么方式</strong>读取内存里的内容。以下图的代码为例</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-36-47.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-23_11-29-53.png\"></p>\n<p>可以看到三种指针指向了<strong>同一个</strong>字节，即它们的值是相等的，但<code>指针类型</code>不同，解引用之后得到的<code>值</code>也不同,</p>\n<p><code>char</code>比<code>int</code>短，所以<code>*p_char</code>只能取到<code>00</code>,</p>\n<p>而虽然<code>float</code>和<code>int</code>一样长，但对内存的<strong>读法不同</strong>，所以<code>*p_float</code>和<code>*p_int</code>依然不同</p>\n<h1 id=\"指针-变量-的使用\"><a href=\"#指针-变量-的使用\" class=\"headerlink\" title=\"指针(变量)的使用\"></a>指针(变量)的使用</h1><h2 id=\"声明指针变量\"><a href=\"#声明指针变量\" class=\"headerlink\" title=\"声明指针变量\"></a>声明指针变量</h2><p>指针变量也是变量，在没有结合性问题时，和一般变量的声明方式差不多。</p>\n<p>变量的声明:<code>变量类型</code> + <code>变量名</code></p>\n<p>指针的声明:<code>指向的变量类型</code> + <code>*</code> + <code>变量名</code></p>\n<p>以下以声明一个字符指针为例</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* pointer = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-24_10-02-19.png\"></p>\n<p><em>变量的声明逻辑如上图</em></p>\n<h3 id=\"进阶：二级指针-N级指针\"><a href=\"#进阶：二级指针-N级指针\" class=\"headerlink\" title=\"进阶：二级指针-&gt;N级指针\"></a>进阶：二级指针-&gt;N级指针</h3><p>我们可以用同样的逻辑声明更高级的指针</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* *ppstr = <span class=\"literal\">NULL</span>;<span class=\"comment\">//ppstr是一个二级指针</span></span><br><span class=\"line\"><span class=\"type\">char</span>** *ppstr = <span class=\"literal\">NULL</span>;<span class=\"comment\">//pppstr是一个三级指针</span></span><br></pre></td></tr></table></figure>\n\n<p>在声明中,前面的<code>char*</code>声明了<code>ppstr</code><strong>指向</strong>的变量类型,后面的<code>*</code>与<code>变量名</code>结合，声明<code>ppstr</code>是一个指针.</p>\n<p>此处，称指向<code>一级指针</code>的指针为<code>二级指针</code>,同理有<code>三级指针</code>,至<code>N级指针</code>.</p>\n<h2 id=\"指针的解引用\"><a href=\"#指针的解引用\" class=\"headerlink\" title=\"指针的解引用\"></a>指针的解引用</h2><p>指针最常见的用处就是通过变量里<strong>储存的地址</strong>，通过直接修改目标变量的<strong>内存</strong>来修改变量的值 ， 当然还有强制转换指针类型来读取目标变量的<strong>一部分</strong>内存 之类的骚操作</p>\n<h3 id=\"函数的传址调用\"><a href=\"#函数的传址调用\" class=\"headerlink\" title=\"函数的传址调用\"></a>函数的传址调用</h3><p>在遇到指针前，使用函数时，由于实参传到函数里都变成了<strong>形参</strong>,无法通过形参（<em>包括修改形参的值</em>）来改变实参的值，因为形参终究只是实参的一份<strong>临时拷贝</strong>.</p>\n<p>而有了指针之后，函数的实参，形参关系不变，但我们有了<strong>更高端</strong>的形参,也就是<code>指针</code>, 尽管<code>函数内的指针</code>依旧是<code>函数外的指针</code>的<strong>临时拷贝</strong>,但我们已经能通过其储存的<strong>值</strong>访问<code>函数外变量</code>的内存了,同时包括<code>读取</code>和<code>修改</code>, 这种通过传入指针来修改外部变量的函数调用，便称为<code>函数的传址调用</code></p>\n<p><em>以如下代码为例</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Swap_int</span><span class=\"params\">(<span class=\"type\">int</span>*a,<span class=\"type\">int</span>*b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//给我两个整型的地址，我就能 真·交换它们的值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tmp = *a;</span><br><span class=\"line\">    *a = *b;</span><br><span class=\"line\">    *b = tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"提问-如何修改函数外的指针的值\"><a href=\"#提问-如何修改函数外的指针的值\" class=\"headerlink\" title=\"提问?如何修改函数外的指针的值?\"></a>提问?如何修改函数外的指针的值?</h4><p>依然还是把这一<strong>指针的地址</strong>传进去，而函数的形参写成<strong>更高一级</strong>的指针</p>\n<p><em>如下代码，例如我想在函数里把外部的指针置空</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Reset</span><span class=\"params\">(<span class=\"type\">char</span>* *pstr)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    *pstr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* str;</span><br><span class=\"line\">    Reset(&amp;str)<span class=\"comment\">//对一级指针取地址，传入二级指针</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"有关指针的危险操作\"><a href=\"#有关指针的危险操作\" class=\"headerlink\" title=\"有关指针的危险操作\"></a>有关指针的危险操作</h1><h2 id=\"野指针的解引用\"><a href=\"#野指针的解引用\" class=\"headerlink\" title=\"野指针的解引用\"></a>野指针的解引用</h2><p>有些指针因为错误操作，指向了不能访问的内存，一旦解引用，就有可能使程序崩溃</p>\n<p><em>情形如下</em></p>\n<h3 id=\"使用了-未初始化-赋值-的指针\"><a href=\"#使用了-未初始化-赋值-的指针\" class=\"headerlink\" title=\"使用了 未初始化&#x2F;赋值 的指针\"></a>使用了 未初始化&#x2F;赋值 的指针</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* pa;<span class=\"comment\">//未初始化，pa的值为随机值</span></span><br><span class=\"line\">*pa = <span class=\"number\">0</span> ;<span class=\"comment\">//野指针的解引用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//正确的用法</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span>* pa;</span><br><span class=\"line\">pa = arr;<span class=\"comment\">//立即初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span>* pb = <span class=\"literal\">NULL</span>;<span class=\"comment\">//初始化</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>所以声明指针时最好初始化,如果不知道初始化成什么，就用<code>NULL</code>空指针初始化</p>\n<h3 id=\"指向了-已回收的-内存空间\"><a href=\"#指向了-已回收的-内存空间\" class=\"headerlink\" title=\"指向了 已回收的 内存空间\"></a>指向了 已回收的 内存空间</h3><p>有的函数<strong>错误</strong>*地返回了内部临时变量的地址， 在<strong>外面</strong>使用返回的指针，因为此时函数的栈帧已经<strong>销毁</strong>，会发生野指针的解引用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* <span class=\"title function_\">fun</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span>* pa = &amp;a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pa;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//情形一</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* pa = fun();</span><br><span class=\"line\">    *pa = <span class=\"number\">1</span>;<span class=\"comment\">//此时变量a已经销毁，发生野指针的解引用，即非法访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//情形二</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* str = (<span class=\"type\">char</span>*) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>) *<span class=\"number\">10</span>) <span class=\"comment\">//在堆区开辟10个字节的空间</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(str);<span class=\"comment\">//然后释放掉</span></span><br><span class=\"line\">    str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;A&#x27;</span>;<span class=\"comment\">//试图访问已free的内存，并写入，发生非法访问</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"空指针的解引用\"><a href=\"#空指针的解引用\" class=\"headerlink\" title=\"空指针的解引用\"></a>空指针的解引用</h2><p>空指针<code>NULL</code>,<code>值</code>为<code>0</code>,一旦解引用就会报错，所以在解引用陌生指针时一定要注意判空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//情形一</span></span><br><span class=\"line\"><span class=\"type\">char</span>* <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">char</span>* str)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str == <span class=\"literal\">NULL</span>)<span class=\"comment\">//防止使用者错误传入空指针</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//情形二</span></span><br><span class=\"line\"><span class=\"type\">char</span>* <span class=\"title function_\">InitArray</span><span class=\"params\">(<span class=\"type\">char</span>** pstr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pstr == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *pstr = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>) * <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*ptr == <span class=\"literal\">NULL</span>)<span class=\"comment\">//malloc一旦失败就会返回NULL,所以调用后一定要判空</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n"},{"title":"进程间通信","date":"2024-08-02T13:46:55.000Z","_content":"\n本篇博客更偏向于总括和导航,部分概念更细致的介绍将内嵌链接在文章中\n\n**重点内容**\n+ 初识进程间通信\n+ 管道\n+ 消息队列\n+ 共享内存\n+ 信号量\n\n# 进程间通信的目的\n+ 数据传输： 一个进程需要将它的数据**发送**给另一个进程\n+ 资源共享： 多个进程之间**共享**同样的资源\n+ 通知事件：一个进程需要向另一个或一组进程**发送消息**，**通知**它（它们）发生了某种事件（如子进程终止时要通知父进程）\n+ 进程控制： 有些进程希望**完全控制**另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变\n\n# 进程间通信的主要方式\n+ 管道\n+ System V进程间通信\n+ POSIX进程间通信\n\n# 进程间通信的分类\n\n## 管道\n+ 匿名管道\n+ 命名管道\n\n## System V IPC\n+ System V 消息队列\n+ SysTem V 共享内存\n+ System V 信号量\n\n## POSIX IPC\n+ 消息队列\n+ 共享内存\n+ 信号量\n+ 互斥量\n+ 条件变量\n+ 读写锁\n\n# 管道\n怎么使用？[戳我去管道博客🔗](https://www.supdriver.top/2024/08/02/pipe/)\n\n首先，管道是Unix中最古老的进程间通信的形式。它用于进程间的**单向**通信\n\n那么具体是怎样实现的呢？从标题里就可以发现，是基于`文件`\n\n既然一个文件可以被多个进程打开，那么不妨将文件作为两个进程通信的**媒介**。但是一般位于磁盘上的文件，IO效率相比于`CPU`，`内存`之类的读写速度慢了几个数量级，但文件是可以被加载到内存中的，而专门建立在**内存中**,而没有磁盘文件，专门用于进程间通信的**内存级**文件，我们就叫它`管道文件`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-09_21-19-22.png)\n\n*管道文件由内核维护*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-10_17-52-20.png)\n*管道文件是单向的，可以是父进程->子进程，也可以子进程->父进程*\n\n### 原子性\n头文件提供了宏`PIPE_BUF`,规定了保证原子性读写操作的最大字节数\n\n+ 当要写入的数据量不大于`PIPE_BUF`时，linux将保证写入的原子性。\n+ 当要写入的数据量大于`PIPE_BUF`时，linux将不再保证写入的原子性。\n\n## 管道特点\n\n+ 管道提供流式服务\n+ 一般而言，进程退出，管道释放，所以管道的生命周期随进程\n+ 一般而言，内核会对管道操作进行**同步与互斥**\n+ 一个管道只有一个通信方向，数据只能向一个方向流动；需要**双方**通信时，需要建立起**两个**管道\n\n\n# system V共享内存\n共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递**不再涉及**到\n`内核`，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据,而是直接使用内存中的共享区。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/shared_mm.png)\n\n## 读写共享区内存\n挂接上的进程是真正意义上的看到同一块内存，而且完全可以像`malloc`申请出的一段内存一样操作,比如把共享区的内存当成字符串的缓冲区,直接把标准输入用`fgets`拷贝到共享内存中\n\n不过默认的共享内存并没有同步互斥行为,需要额外控制,比如使用`FIFO命名管道`来完成同步操作\n\n[戳我去具体介绍🔗](https://www.supdriver.top/2024/08/14/shmd/)\n","source":"_posts/progressMSG.md","raw":"---\ntitle: 进程间通信\ndate: 2024-08-02 21:46:55\ntags:\n---\n\n本篇博客更偏向于总括和导航,部分概念更细致的介绍将内嵌链接在文章中\n\n**重点内容**\n+ 初识进程间通信\n+ 管道\n+ 消息队列\n+ 共享内存\n+ 信号量\n\n# 进程间通信的目的\n+ 数据传输： 一个进程需要将它的数据**发送**给另一个进程\n+ 资源共享： 多个进程之间**共享**同样的资源\n+ 通知事件：一个进程需要向另一个或一组进程**发送消息**，**通知**它（它们）发生了某种事件（如子进程终止时要通知父进程）\n+ 进程控制： 有些进程希望**完全控制**另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变\n\n# 进程间通信的主要方式\n+ 管道\n+ System V进程间通信\n+ POSIX进程间通信\n\n# 进程间通信的分类\n\n## 管道\n+ 匿名管道\n+ 命名管道\n\n## System V IPC\n+ System V 消息队列\n+ SysTem V 共享内存\n+ System V 信号量\n\n## POSIX IPC\n+ 消息队列\n+ 共享内存\n+ 信号量\n+ 互斥量\n+ 条件变量\n+ 读写锁\n\n# 管道\n怎么使用？[戳我去管道博客🔗](https://www.supdriver.top/2024/08/02/pipe/)\n\n首先，管道是Unix中最古老的进程间通信的形式。它用于进程间的**单向**通信\n\n那么具体是怎样实现的呢？从标题里就可以发现，是基于`文件`\n\n既然一个文件可以被多个进程打开，那么不妨将文件作为两个进程通信的**媒介**。但是一般位于磁盘上的文件，IO效率相比于`CPU`，`内存`之类的读写速度慢了几个数量级，但文件是可以被加载到内存中的，而专门建立在**内存中**,而没有磁盘文件，专门用于进程间通信的**内存级**文件，我们就叫它`管道文件`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-09_21-19-22.png)\n\n*管道文件由内核维护*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-10_17-52-20.png)\n*管道文件是单向的，可以是父进程->子进程，也可以子进程->父进程*\n\n### 原子性\n头文件提供了宏`PIPE_BUF`,规定了保证原子性读写操作的最大字节数\n\n+ 当要写入的数据量不大于`PIPE_BUF`时，linux将保证写入的原子性。\n+ 当要写入的数据量大于`PIPE_BUF`时，linux将不再保证写入的原子性。\n\n## 管道特点\n\n+ 管道提供流式服务\n+ 一般而言，进程退出，管道释放，所以管道的生命周期随进程\n+ 一般而言，内核会对管道操作进行**同步与互斥**\n+ 一个管道只有一个通信方向，数据只能向一个方向流动；需要**双方**通信时，需要建立起**两个**管道\n\n\n# system V共享内存\n共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递**不再涉及**到\n`内核`，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据,而是直接使用内存中的共享区。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/shared_mm.png)\n\n## 读写共享区内存\n挂接上的进程是真正意义上的看到同一块内存，而且完全可以像`malloc`申请出的一段内存一样操作,比如把共享区的内存当成字符串的缓冲区,直接把标准输入用`fgets`拷贝到共享内存中\n\n不过默认的共享内存并没有同步互斥行为,需要额外控制,比如使用`FIFO命名管道`来完成同步操作\n\n[戳我去具体介绍🔗](https://www.supdriver.top/2024/08/14/shmd/)\n","slug":"progressMSG","published":1,"updated":"2024-08-26T01:41:18.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08n001l4sp5b8hz5ost","content":"<p>本篇博客更偏向于总括和导航,部分概念更细致的介绍将内嵌链接在文章中</p>\n<p><strong>重点内容</strong></p>\n<ul>\n<li>初识进程间通信</li>\n<li>管道</li>\n<li>消息队列</li>\n<li>共享内存</li>\n<li>信号量</li>\n</ul>\n<h1 id=\"进程间通信的目的\"><a href=\"#进程间通信的目的\" class=\"headerlink\" title=\"进程间通信的目的\"></a>进程间通信的目的</h1><ul>\n<li>数据传输： 一个进程需要将它的数据<strong>发送</strong>给另一个进程</li>\n<li>资源共享： 多个进程之间<strong>共享</strong>同样的资源</li>\n<li>通知事件：一个进程需要向另一个或一组进程<strong>发送消息</strong>，<strong>通知</strong>它（它们）发生了某种事件（如子进程终止时要通知父进程）</li>\n<li>进程控制： 有些进程希望<strong>完全控制</strong>另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变</li>\n</ul>\n<h1 id=\"进程间通信的主要方式\"><a href=\"#进程间通信的主要方式\" class=\"headerlink\" title=\"进程间通信的主要方式\"></a>进程间通信的主要方式</h1><ul>\n<li>管道</li>\n<li>System V进程间通信</li>\n<li>POSIX进程间通信</li>\n</ul>\n<h1 id=\"进程间通信的分类\"><a href=\"#进程间通信的分类\" class=\"headerlink\" title=\"进程间通信的分类\"></a>进程间通信的分类</h1><h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h2><ul>\n<li>匿名管道</li>\n<li>命名管道</li>\n</ul>\n<h2 id=\"System-V-IPC\"><a href=\"#System-V-IPC\" class=\"headerlink\" title=\"System V IPC\"></a>System V IPC</h2><ul>\n<li>System V 消息队列</li>\n<li>SysTem V 共享内存</li>\n<li>System V 信号量</li>\n</ul>\n<h2 id=\"POSIX-IPC\"><a href=\"#POSIX-IPC\" class=\"headerlink\" title=\"POSIX IPC\"></a>POSIX IPC</h2><ul>\n<li>消息队列</li>\n<li>共享内存</li>\n<li>信号量</li>\n<li>互斥量</li>\n<li>条件变量</li>\n<li>读写锁</li>\n</ul>\n<h1 id=\"管道-1\"><a href=\"#管道-1\" class=\"headerlink\" title=\"管道\"></a>管道</h1><p>怎么使用？<a href=\"https://www.supdriver.top/2024/08/02/pipe/\">戳我去管道博客🔗</a></p>\n<p>首先，管道是Unix中最古老的进程间通信的形式。它用于进程间的<strong>单向</strong>通信</p>\n<p>那么具体是怎样实现的呢？从标题里就可以发现，是基于<code>文件</code></p>\n<p>既然一个文件可以被多个进程打开，那么不妨将文件作为两个进程通信的<strong>媒介</strong>。但是一般位于磁盘上的文件，IO效率相比于<code>CPU</code>，<code>内存</code>之类的读写速度慢了几个数量级，但文件是可以被加载到内存中的，而专门建立在<strong>内存中</strong>,而没有磁盘文件，专门用于进程间通信的<strong>内存级</strong>文件，我们就叫它<code>管道文件</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-09_21-19-22.png\"></p>\n<p><em>管道文件由内核维护</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-10_17-52-20.png\"><br><em>管道文件是单向的，可以是父进程-&gt;子进程，也可以子进程-&gt;父进程</em></p>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>头文件提供了宏<code>PIPE_BUF</code>,规定了保证原子性读写操作的最大字节数</p>\n<ul>\n<li>当要写入的数据量不大于<code>PIPE_BUF</code>时，linux将保证写入的原子性。</li>\n<li>当要写入的数据量大于<code>PIPE_BUF</code>时，linux将不再保证写入的原子性。</li>\n</ul>\n<h2 id=\"管道特点\"><a href=\"#管道特点\" class=\"headerlink\" title=\"管道特点\"></a>管道特点</h2><ul>\n<li>管道提供流式服务</li>\n<li>一般而言，进程退出，管道释放，所以管道的生命周期随进程</li>\n<li>一般而言，内核会对管道操作进行<strong>同步与互斥</strong></li>\n<li>一个管道只有一个通信方向，数据只能向一个方向流动；需要<strong>双方</strong>通信时，需要建立起<strong>两个</strong>管道</li>\n</ul>\n<h1 id=\"system-V共享内存\"><a href=\"#system-V共享内存\" class=\"headerlink\" title=\"system V共享内存\"></a>system V共享内存</h1><p>共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递<strong>不再涉及</strong>到<br><code>内核</code>，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据,而是直接使用内存中的共享区。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/shared_mm.png\"></p>\n<h2 id=\"读写共享区内存\"><a href=\"#读写共享区内存\" class=\"headerlink\" title=\"读写共享区内存\"></a>读写共享区内存</h2><p>挂接上的进程是真正意义上的看到同一块内存，而且完全可以像<code>malloc</code>申请出的一段内存一样操作,比如把共享区的内存当成字符串的缓冲区,直接把标准输入用<code>fgets</code>拷贝到共享内存中</p>\n<p>不过默认的共享内存并没有同步互斥行为,需要额外控制,比如使用<code>FIFO命名管道</code>来完成同步操作</p>\n<p><a href=\"https://www.supdriver.top/2024/08/14/shmd/\">戳我去具体介绍🔗</a></p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/6d98b25ed940e1702fd7023bd166babf.jpg","cover_type":"img","excerpt":"","more":"<p>本篇博客更偏向于总括和导航,部分概念更细致的介绍将内嵌链接在文章中</p>\n<p><strong>重点内容</strong></p>\n<ul>\n<li>初识进程间通信</li>\n<li>管道</li>\n<li>消息队列</li>\n<li>共享内存</li>\n<li>信号量</li>\n</ul>\n<h1 id=\"进程间通信的目的\"><a href=\"#进程间通信的目的\" class=\"headerlink\" title=\"进程间通信的目的\"></a>进程间通信的目的</h1><ul>\n<li>数据传输： 一个进程需要将它的数据<strong>发送</strong>给另一个进程</li>\n<li>资源共享： 多个进程之间<strong>共享</strong>同样的资源</li>\n<li>通知事件：一个进程需要向另一个或一组进程<strong>发送消息</strong>，<strong>通知</strong>它（它们）发生了某种事件（如子进程终止时要通知父进程）</li>\n<li>进程控制： 有些进程希望<strong>完全控制</strong>另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变</li>\n</ul>\n<h1 id=\"进程间通信的主要方式\"><a href=\"#进程间通信的主要方式\" class=\"headerlink\" title=\"进程间通信的主要方式\"></a>进程间通信的主要方式</h1><ul>\n<li>管道</li>\n<li>System V进程间通信</li>\n<li>POSIX进程间通信</li>\n</ul>\n<h1 id=\"进程间通信的分类\"><a href=\"#进程间通信的分类\" class=\"headerlink\" title=\"进程间通信的分类\"></a>进程间通信的分类</h1><h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h2><ul>\n<li>匿名管道</li>\n<li>命名管道</li>\n</ul>\n<h2 id=\"System-V-IPC\"><a href=\"#System-V-IPC\" class=\"headerlink\" title=\"System V IPC\"></a>System V IPC</h2><ul>\n<li>System V 消息队列</li>\n<li>SysTem V 共享内存</li>\n<li>System V 信号量</li>\n</ul>\n<h2 id=\"POSIX-IPC\"><a href=\"#POSIX-IPC\" class=\"headerlink\" title=\"POSIX IPC\"></a>POSIX IPC</h2><ul>\n<li>消息队列</li>\n<li>共享内存</li>\n<li>信号量</li>\n<li>互斥量</li>\n<li>条件变量</li>\n<li>读写锁</li>\n</ul>\n<h1 id=\"管道-1\"><a href=\"#管道-1\" class=\"headerlink\" title=\"管道\"></a>管道</h1><p>怎么使用？<a href=\"https://www.supdriver.top/2024/08/02/pipe/\">戳我去管道博客🔗</a></p>\n<p>首先，管道是Unix中最古老的进程间通信的形式。它用于进程间的<strong>单向</strong>通信</p>\n<p>那么具体是怎样实现的呢？从标题里就可以发现，是基于<code>文件</code></p>\n<p>既然一个文件可以被多个进程打开，那么不妨将文件作为两个进程通信的<strong>媒介</strong>。但是一般位于磁盘上的文件，IO效率相比于<code>CPU</code>，<code>内存</code>之类的读写速度慢了几个数量级，但文件是可以被加载到内存中的，而专门建立在<strong>内存中</strong>,而没有磁盘文件，专门用于进程间通信的<strong>内存级</strong>文件，我们就叫它<code>管道文件</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-09_21-19-22.png\"></p>\n<p><em>管道文件由内核维护</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-08-10_17-52-20.png\"><br><em>管道文件是单向的，可以是父进程-&gt;子进程，也可以子进程-&gt;父进程</em></p>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><p>头文件提供了宏<code>PIPE_BUF</code>,规定了保证原子性读写操作的最大字节数</p>\n<ul>\n<li>当要写入的数据量不大于<code>PIPE_BUF</code>时，linux将保证写入的原子性。</li>\n<li>当要写入的数据量大于<code>PIPE_BUF</code>时，linux将不再保证写入的原子性。</li>\n</ul>\n<h2 id=\"管道特点\"><a href=\"#管道特点\" class=\"headerlink\" title=\"管道特点\"></a>管道特点</h2><ul>\n<li>管道提供流式服务</li>\n<li>一般而言，进程退出，管道释放，所以管道的生命周期随进程</li>\n<li>一般而言，内核会对管道操作进行<strong>同步与互斥</strong></li>\n<li>一个管道只有一个通信方向，数据只能向一个方向流动；需要<strong>双方</strong>通信时，需要建立起<strong>两个</strong>管道</li>\n</ul>\n<h1 id=\"system-V共享内存\"><a href=\"#system-V共享内存\" class=\"headerlink\" title=\"system V共享内存\"></a>system V共享内存</h1><p>共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递<strong>不再涉及</strong>到<br><code>内核</code>，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据,而是直接使用内存中的共享区。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/shared_mm.png\"></p>\n<h2 id=\"读写共享区内存\"><a href=\"#读写共享区内存\" class=\"headerlink\" title=\"读写共享区内存\"></a>读写共享区内存</h2><p>挂接上的进程是真正意义上的看到同一块内存，而且完全可以像<code>malloc</code>申请出的一段内存一样操作,比如把共享区的内存当成字符串的缓冲区,直接把标准输入用<code>fgets</code>拷贝到共享内存中</p>\n<p>不过默认的共享内存并没有同步互斥行为,需要额外控制,比如使用<code>FIFO命名管道</code>来完成同步操作</p>\n<p><a href=\"https://www.supdriver.top/2024/08/14/shmd/\">戳我去具体介绍🔗</a></p>\n"},{"title":"初识进程","date":"2024-07-04T15:02:14.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_23-41-09.png","_content":"\n***\n操作系统平台:Linux\n服务器系统: CentOS 7\n***\n\n# 概念抽象\n\n## 程序\n\n`程序` = `代码` + `数据`\n\n程序是储存在硬盘上的可执行文件\n\n## 进程\n将`程序`加载到`内存`后，就在`内存`中程序的就是进程。也就是说一个正在运行的程序就能叫做进程\n\n*结构关系如下*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_13-55-08.png)\n\n如图，操作系统为了**管理**内存中的进程,使用了`PCB`结构体来描述进程,通过管理`PCB`来管理进程,依然是*先描述再组织*\n\n`PCB`:进程控制块的数据结构(process control block)\n\n所以实际上:`进程`=`PCB`+`代码和数据`\n\n对于`代码和数据`没什么好说的，接下来主要讨论`PCB`\n\n## task_struct\n`Linux`平台下的`PCB`叫做`task_struct`\n\n> `task_struct`内容分类:\n\n+ **标示符**: 描述本进程的唯一标示符，用来区别其他进程。\n+ **状态**: 任务状态，退出代码，退出信号等。\n+ **优先级**: 相对于其他进程的优先级。\n+ 程序计数器: 程序中即将被执行的下一条指令的地址。\n+ 内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针\n+ 上下文数据: 进程执行时处理器的寄存器中的数据。\n+ I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。\n+ 记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。\n+ 其他信息\n  \n*加粗部分会详细介绍*\n\n# 查看进程\n进程的信息可以通过/proc 系统文件夹查看,其中文件夹的名字就是进程的`PID`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_21-53-59.png)\n\n大多数进程信息同样可以使用top和ps这些用户级工具来获取\n\n> 以我自己编写的一个程序为例\n\n*Makefile*\n```\nmycmd:mycmd.c\n\tgcc -o $@ $^\n\n.PHONY:clean\nclean:\n\trm -rf mycmd\n```\n\n**注**： 后面的程序都是这三个头文件，仅修改`main()`函数体即可\n*mycmd.c*\n```C\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\n\nint main()\n{\n  while(1) sleep(1);//死循环使该进程常驻内存\n  return 0;\n}\n```\n然后编译并运行程序\n*命令行*\n```\nmake\n./mycmd\nps aux | grep mycmd | grep -v grep\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_22-56-05.png)\n\n## 进程标示符(PID PPID)\n可以通过系统接口获取进程标示符\n\n+ 进程id (pid)    使用`getpid()`\n+ 父进程id (ppid) 使用`getppid()`\n  \n*来修改一下代码*\n*mycmd.c*\n```C\n\nint main()\n{\n  printf(\"pid: %d\\n\",getpid());//打印pid (该进程id)\n  printf(\"ppid: %d\\n\",getppid());//打印ppid (父进程id)\n  return 0;\n}\n```\n\n*命令行*\n```\nmake clean\nmake\n./mycmd\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_23-28-35.png)\n\n## 利用`fork()`创建子进程\n\n*mycmd.c*\n```C\n\nint main()\n{\n  pid_t id = fork();\n  if(id == 0)//子进程\n  {\n    printf(\"child pid: %d\\n\",getpid());//打印pid (该进程id)\n    printf(\"child ppid: %d\\n\",getppid());//打印ppid (父进程id)\n    sleep(1);\n  }\n  else//父进程\n  {\n    printf(\"father pid: %d\\n\",getpid());//打印pid (该进程id)\n    printf(\"father ppid: %d\\n\",getppid());//打印ppid (父进程id)\n    sleep(1);\n  }\n  return 0;\n}\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_10-56-48.png)\n\n如图，`fork()`创建了子进程，且子进程的`PPID`和父进程`PID`相同\n\n### fork()的返回值\n父子进程中`fork()`函数的返回值(此处用变量`id`储存)是不同的:\n\n**父进程**里`id`的值为子进程的`PID`,其值`>0`;**子进程**里`id`值固定为`0`\n\n+ `id > 0` 父进程\n+ `id == 0` 子进程\n+ `id < 0` fork()失败\n\n### 父子进程分流\n利用`fork()`返回值不同的特性可以做到分流操作，利用`if...else...`让父子进程执行不同的代码\n\n[戳我去fork的详细介绍](https://www.supdriver.top/2024/07/07/fork/)\n\n# 进程状态 \n*状态在kernel源代码里定义*\n```C\n static const char * const task_state_array[] = {\n \"R (running)\", /* 0 */\n \"S (sleeping)\", /* 1 */\n \"D (disk sleep)\", /* 2 */\n \"T (stopped)\", /* 4 */\n \"t (tracing stop)\", /* 8 */\n \"X (dead)\", /* 16 */\n \"Z (zombie)\", /* 32 */\n };\n```\n\n## R 运行状态(running)\nR状态并不一定正在运行，而是`正在运行`和`处于运行队列`中的一种\n\n```C\nint main()\n{\n  while(1);\n  return 0;\n}\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-14-49.png)\n\n## S 睡眠状态(sleeping)\nS 意味着进程在**等待**运行完成\n\n(*这里的睡眠有时也可叫做可中断睡眠 interruptible sleep*)\n\n*下面展示两种S状态的进程*\n```C\nint main()\n{\n  sleep(50);\n  return 0;\n}\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-45-14.png)\n\n直接使用`sleep()`系列的函数直接使进程休眠\n\n```C\nint main()\n{\n  int n;\n  printf(\"Enter the num: \");\n  scanf(\"%d\",&n);\n  return 0;\n}\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-47-33.png)\n\n像`scanf()`这种需要等待外设(键盘)的接口，在**阻塞等待**资源的过程中会使进程进入`S`状态\n\n## D 磁盘休眠状态（Disk sleep）\n有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的进程通常会等待`IO`的结束。\n\n## T 停止状态（stopped）\n可以通过(*kill等命令*)发送 `SIGSTOP` 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 `SIGCONT `信号让进程继续运行。\n\n```C\nint main()\n{\n  while(1) sleep(1);\n  return 0;\n}\n```\n运行前先**复制**ssh渠道，其中一个窗口用于执行进程\n```\nmake clean\nmake\n./mycmd\n```\n另一个进程用于输入命令\n\n先查看该进程的`PID`\n```\nps ajx | head -1 && ps ajx | grep mycmd | grep -v grep\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-04-51.png)\n\n如图，这次的`PID`是`20275`\n\n然后用`kill`发送`SIGSTOP`,对应参数为`-19`\n\n```\nkill -19 20275\nps ajx | head -1 && ps ajx | grep mycmd | grep -v grep\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-06-38.png)\n\n可以看到它已经由`S`状态改为`T`状态了\n\n接下来发送`SIGCONT`,对应参数`-18`,使进程恢复\n\n```\nkill -18 20275\nps ajx | head -1 && ps ajx | grep mycmd | grep -v grep\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-08-45.png)\n\n可以看到已经由`T`变为原本的`S`状态了\n\n## X 死亡状态（dead）\n这个状态只是一个返回状态，你不会在任务列表里看到这个状态。\n\n## Z 僵尸进程(zombie)\n这个详细讨论下\n\n### 产生\n当该进程退出后，父进程尚未使用`wait()`之类的接口获取该进程的`退出码`,且父进程**没有结束**时，该进程会变成僵尸进程\n\n*父进程比子进程先退出时，子进程的父进程会改变为PID为1的进程，由新进程托管*\n\n*下面创建一个例子*\n\n```C\nint main()\n{\n  pid_t id = fork();\n  if(id == 0)//子进程\n  {\n    printf(\"child exit\\n\");\n  }\n  else//父进程\n  {\n    sleep(30);\n    printf(\"father exit\\n\");\n  }\n  return 0;\n}\n```\n\n运行程序后的`30秒`内查看进程状态，可以看到子进程进入了`Z`状态\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_16-27-27.png)\n\n### 行为\n僵尸进程会以终止状态保持在进程表中，等待父进程读取退出状态代码\n\n### 危害\n+ 父进程一直**未获取**子进程的退出码,僵尸状态就会一直保持\n+ 保持`Z`状态的进程的`PCB`仍然要一直维护，占用资源\n+ 未退出`Z`状态的子进程可能造成内存泄漏\n\n## 孤儿进程\n当父进程比子进程**先**退出后,这个子进程便成了`孤儿进程`\n\n既然原本的父进程没了，谁来托管子进程呢？答案是`PID`为`1`的那个进程\n\n*例子如下*\n\n```C\nint main()\n{\n  pid_t id = fork();\n  if(id == 0)//子进程\n  {\n    sleep(30);\n    printf(\"child exit\\n\");\n  }\n  else//父进程\n  {\n    sleep(1);\n    printf(\"father exit\\n\");\n  }\n  return 0;\n}\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-05-32.png)\n\n# 进程优先级\n\n## 基础概念\n+ cpu资源分配的先后顺序，就是指进程的优先权（priority）。\n+ 优先权高的进程有优先执行权利。配置进程优先权对多任务环境的linux很有用，可以改善系统性能。\n+ 还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，可以大大改善系统整体性能\n\n## 查看优先级\n*首先写一个常驻进程*\n```C\nint main()\n{\n  while(1)sleep(1);\n  return 0;\n}\n```\n\n然后使用`ps -la`查看进程信息\n```\n./mycmd\nps -la\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-59-12.png)\n\n其中的`PRI`和`NI`与进程优先级有关,`PRI`就是进程的优先级，跟排队摇号一样，此值`越小`，被执行的优先级越高,而`NI`就是nice值，用于修正原`PRI`值\n\n### PRI值的计算\n首先在看到的`PRI`值之外，还有个隐藏的基准值，本文用`PRI0`指代，这个`PRI0`是固定的，当`NI`值为`0`时，`PRI == PRI0`,而\n无论怎么修改多少次`NI`,`PRI`的值减去`NI`值都相等，所以大可以推断在本系统(Linux)中,`PRI`值有如下计算公式\n\n`PRI = PRI0 + NI`\n\n### 修改NI值\n因为修改`NI`值要管理员权限，所以要么`root`用户用`top`，要么信任用户用`sudo top`打开界面，然后按`r`,输入待修改进程的`PID`,按下回车后再输入新的`NI`值(有效范围`-20~19`)\n\n*此处可以用`ps -la`查看进程的PID,或调用`getpid()`*\n\n*再写一个例子*\n```C\nint main()\n{\n  while(1)\n  {\n    printf(\"mypid: %d\\n\",getpid());\n    sleep(1);\n  }\n  return 0;\n}\n```\n`sudo top`然后按`r`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-14-38.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-15-50.png)\n\n`ps -la`可以看到被修改后的进程优先级\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-17-02.png)\n\n# 其它概念\n\n+ 竞争性: 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级\n+ 独立性: 多进程运行，需要独享各种资源，多进程运行期间**互不干扰**\n+ 并行: 多个进程在**多个CPU**下分别，同时进行运行，这称之为并行\n+ 并发: 多个进程在**一个CPU**下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发\n\n*下一章*[环境变量](https://www.supdriver.top/2024/07/06/evn/)\n","source":"_posts/progress.md","raw":"---\ntitle: 初识进程\ndate: 2024-07-04 23:02:14\ntags: 进程 Linux\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_23-41-09.png\n---\n\n***\n操作系统平台:Linux\n服务器系统: CentOS 7\n***\n\n# 概念抽象\n\n## 程序\n\n`程序` = `代码` + `数据`\n\n程序是储存在硬盘上的可执行文件\n\n## 进程\n将`程序`加载到`内存`后，就在`内存`中程序的就是进程。也就是说一个正在运行的程序就能叫做进程\n\n*结构关系如下*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_13-55-08.png)\n\n如图，操作系统为了**管理**内存中的进程,使用了`PCB`结构体来描述进程,通过管理`PCB`来管理进程,依然是*先描述再组织*\n\n`PCB`:进程控制块的数据结构(process control block)\n\n所以实际上:`进程`=`PCB`+`代码和数据`\n\n对于`代码和数据`没什么好说的，接下来主要讨论`PCB`\n\n## task_struct\n`Linux`平台下的`PCB`叫做`task_struct`\n\n> `task_struct`内容分类:\n\n+ **标示符**: 描述本进程的唯一标示符，用来区别其他进程。\n+ **状态**: 任务状态，退出代码，退出信号等。\n+ **优先级**: 相对于其他进程的优先级。\n+ 程序计数器: 程序中即将被执行的下一条指令的地址。\n+ 内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针\n+ 上下文数据: 进程执行时处理器的寄存器中的数据。\n+ I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。\n+ 记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。\n+ 其他信息\n  \n*加粗部分会详细介绍*\n\n# 查看进程\n进程的信息可以通过/proc 系统文件夹查看,其中文件夹的名字就是进程的`PID`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_21-53-59.png)\n\n大多数进程信息同样可以使用top和ps这些用户级工具来获取\n\n> 以我自己编写的一个程序为例\n\n*Makefile*\n```\nmycmd:mycmd.c\n\tgcc -o $@ $^\n\n.PHONY:clean\nclean:\n\trm -rf mycmd\n```\n\n**注**： 后面的程序都是这三个头文件，仅修改`main()`函数体即可\n*mycmd.c*\n```C\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\n\nint main()\n{\n  while(1) sleep(1);//死循环使该进程常驻内存\n  return 0;\n}\n```\n然后编译并运行程序\n*命令行*\n```\nmake\n./mycmd\nps aux | grep mycmd | grep -v grep\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_22-56-05.png)\n\n## 进程标示符(PID PPID)\n可以通过系统接口获取进程标示符\n\n+ 进程id (pid)    使用`getpid()`\n+ 父进程id (ppid) 使用`getppid()`\n  \n*来修改一下代码*\n*mycmd.c*\n```C\n\nint main()\n{\n  printf(\"pid: %d\\n\",getpid());//打印pid (该进程id)\n  printf(\"ppid: %d\\n\",getppid());//打印ppid (父进程id)\n  return 0;\n}\n```\n\n*命令行*\n```\nmake clean\nmake\n./mycmd\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_23-28-35.png)\n\n## 利用`fork()`创建子进程\n\n*mycmd.c*\n```C\n\nint main()\n{\n  pid_t id = fork();\n  if(id == 0)//子进程\n  {\n    printf(\"child pid: %d\\n\",getpid());//打印pid (该进程id)\n    printf(\"child ppid: %d\\n\",getppid());//打印ppid (父进程id)\n    sleep(1);\n  }\n  else//父进程\n  {\n    printf(\"father pid: %d\\n\",getpid());//打印pid (该进程id)\n    printf(\"father ppid: %d\\n\",getppid());//打印ppid (父进程id)\n    sleep(1);\n  }\n  return 0;\n}\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_10-56-48.png)\n\n如图，`fork()`创建了子进程，且子进程的`PPID`和父进程`PID`相同\n\n### fork()的返回值\n父子进程中`fork()`函数的返回值(此处用变量`id`储存)是不同的:\n\n**父进程**里`id`的值为子进程的`PID`,其值`>0`;**子进程**里`id`值固定为`0`\n\n+ `id > 0` 父进程\n+ `id == 0` 子进程\n+ `id < 0` fork()失败\n\n### 父子进程分流\n利用`fork()`返回值不同的特性可以做到分流操作，利用`if...else...`让父子进程执行不同的代码\n\n[戳我去fork的详细介绍](https://www.supdriver.top/2024/07/07/fork/)\n\n# 进程状态 \n*状态在kernel源代码里定义*\n```C\n static const char * const task_state_array[] = {\n \"R (running)\", /* 0 */\n \"S (sleeping)\", /* 1 */\n \"D (disk sleep)\", /* 2 */\n \"T (stopped)\", /* 4 */\n \"t (tracing stop)\", /* 8 */\n \"X (dead)\", /* 16 */\n \"Z (zombie)\", /* 32 */\n };\n```\n\n## R 运行状态(running)\nR状态并不一定正在运行，而是`正在运行`和`处于运行队列`中的一种\n\n```C\nint main()\n{\n  while(1);\n  return 0;\n}\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-14-49.png)\n\n## S 睡眠状态(sleeping)\nS 意味着进程在**等待**运行完成\n\n(*这里的睡眠有时也可叫做可中断睡眠 interruptible sleep*)\n\n*下面展示两种S状态的进程*\n```C\nint main()\n{\n  sleep(50);\n  return 0;\n}\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-45-14.png)\n\n直接使用`sleep()`系列的函数直接使进程休眠\n\n```C\nint main()\n{\n  int n;\n  printf(\"Enter the num: \");\n  scanf(\"%d\",&n);\n  return 0;\n}\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-47-33.png)\n\n像`scanf()`这种需要等待外设(键盘)的接口，在**阻塞等待**资源的过程中会使进程进入`S`状态\n\n## D 磁盘休眠状态（Disk sleep）\n有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的进程通常会等待`IO`的结束。\n\n## T 停止状态（stopped）\n可以通过(*kill等命令*)发送 `SIGSTOP` 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 `SIGCONT `信号让进程继续运行。\n\n```C\nint main()\n{\n  while(1) sleep(1);\n  return 0;\n}\n```\n运行前先**复制**ssh渠道，其中一个窗口用于执行进程\n```\nmake clean\nmake\n./mycmd\n```\n另一个进程用于输入命令\n\n先查看该进程的`PID`\n```\nps ajx | head -1 && ps ajx | grep mycmd | grep -v grep\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-04-51.png)\n\n如图，这次的`PID`是`20275`\n\n然后用`kill`发送`SIGSTOP`,对应参数为`-19`\n\n```\nkill -19 20275\nps ajx | head -1 && ps ajx | grep mycmd | grep -v grep\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-06-38.png)\n\n可以看到它已经由`S`状态改为`T`状态了\n\n接下来发送`SIGCONT`,对应参数`-18`,使进程恢复\n\n```\nkill -18 20275\nps ajx | head -1 && ps ajx | grep mycmd | grep -v grep\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-08-45.png)\n\n可以看到已经由`T`变为原本的`S`状态了\n\n## X 死亡状态（dead）\n这个状态只是一个返回状态，你不会在任务列表里看到这个状态。\n\n## Z 僵尸进程(zombie)\n这个详细讨论下\n\n### 产生\n当该进程退出后，父进程尚未使用`wait()`之类的接口获取该进程的`退出码`,且父进程**没有结束**时，该进程会变成僵尸进程\n\n*父进程比子进程先退出时，子进程的父进程会改变为PID为1的进程，由新进程托管*\n\n*下面创建一个例子*\n\n```C\nint main()\n{\n  pid_t id = fork();\n  if(id == 0)//子进程\n  {\n    printf(\"child exit\\n\");\n  }\n  else//父进程\n  {\n    sleep(30);\n    printf(\"father exit\\n\");\n  }\n  return 0;\n}\n```\n\n运行程序后的`30秒`内查看进程状态，可以看到子进程进入了`Z`状态\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_16-27-27.png)\n\n### 行为\n僵尸进程会以终止状态保持在进程表中，等待父进程读取退出状态代码\n\n### 危害\n+ 父进程一直**未获取**子进程的退出码,僵尸状态就会一直保持\n+ 保持`Z`状态的进程的`PCB`仍然要一直维护，占用资源\n+ 未退出`Z`状态的子进程可能造成内存泄漏\n\n## 孤儿进程\n当父进程比子进程**先**退出后,这个子进程便成了`孤儿进程`\n\n既然原本的父进程没了，谁来托管子进程呢？答案是`PID`为`1`的那个进程\n\n*例子如下*\n\n```C\nint main()\n{\n  pid_t id = fork();\n  if(id == 0)//子进程\n  {\n    sleep(30);\n    printf(\"child exit\\n\");\n  }\n  else//父进程\n  {\n    sleep(1);\n    printf(\"father exit\\n\");\n  }\n  return 0;\n}\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-05-32.png)\n\n# 进程优先级\n\n## 基础概念\n+ cpu资源分配的先后顺序，就是指进程的优先权（priority）。\n+ 优先权高的进程有优先执行权利。配置进程优先权对多任务环境的linux很有用，可以改善系统性能。\n+ 还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，可以大大改善系统整体性能\n\n## 查看优先级\n*首先写一个常驻进程*\n```C\nint main()\n{\n  while(1)sleep(1);\n  return 0;\n}\n```\n\n然后使用`ps -la`查看进程信息\n```\n./mycmd\nps -la\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-59-12.png)\n\n其中的`PRI`和`NI`与进程优先级有关,`PRI`就是进程的优先级，跟排队摇号一样，此值`越小`，被执行的优先级越高,而`NI`就是nice值，用于修正原`PRI`值\n\n### PRI值的计算\n首先在看到的`PRI`值之外，还有个隐藏的基准值，本文用`PRI0`指代，这个`PRI0`是固定的，当`NI`值为`0`时，`PRI == PRI0`,而\n无论怎么修改多少次`NI`,`PRI`的值减去`NI`值都相等，所以大可以推断在本系统(Linux)中,`PRI`值有如下计算公式\n\n`PRI = PRI0 + NI`\n\n### 修改NI值\n因为修改`NI`值要管理员权限，所以要么`root`用户用`top`，要么信任用户用`sudo top`打开界面，然后按`r`,输入待修改进程的`PID`,按下回车后再输入新的`NI`值(有效范围`-20~19`)\n\n*此处可以用`ps -la`查看进程的PID,或调用`getpid()`*\n\n*再写一个例子*\n```C\nint main()\n{\n  while(1)\n  {\n    printf(\"mypid: %d\\n\",getpid());\n    sleep(1);\n  }\n  return 0;\n}\n```\n`sudo top`然后按`r`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-14-38.png)\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-15-50.png)\n\n`ps -la`可以看到被修改后的进程优先级\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-17-02.png)\n\n# 其它概念\n\n+ 竞争性: 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级\n+ 独立性: 多进程运行，需要独享各种资源，多进程运行期间**互不干扰**\n+ 并行: 多个进程在**多个CPU**下分别，同时进行运行，这称之为并行\n+ 并发: 多个进程在**一个CPU**下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发\n\n*下一章*[环境变量](https://www.supdriver.top/2024/07/06/evn/)\n","slug":"progress","published":1,"updated":"2024-07-07T15:42:57.386Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08n001n4sp52kuqep25","content":"<hr>\n<p>操作系统平台:Linux<br>服务器系统: CentOS 7</p>\n<hr>\n<h1 id=\"概念抽象\"><a href=\"#概念抽象\" class=\"headerlink\" title=\"概念抽象\"></a>概念抽象</h1><h2 id=\"程序\"><a href=\"#程序\" class=\"headerlink\" title=\"程序\"></a>程序</h2><p><code>程序</code> &#x3D; <code>代码</code> + <code>数据</code></p>\n<p>程序是储存在硬盘上的可执行文件</p>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>将<code>程序</code>加载到<code>内存</code>后，就在<code>内存</code>中程序的就是进程。也就是说一个正在运行的程序就能叫做进程</p>\n<p><em>结构关系如下</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_13-55-08.png\"></p>\n<p>如图，操作系统为了<strong>管理</strong>内存中的进程,使用了<code>PCB</code>结构体来描述进程,通过管理<code>PCB</code>来管理进程,依然是<em>先描述再组织</em></p>\n<p><code>PCB</code>:进程控制块的数据结构(process control block)</p>\n<p>所以实际上:<code>进程</code>&#x3D;<code>PCB</code>+<code>代码和数据</code></p>\n<p>对于<code>代码和数据</code>没什么好说的，接下来主要讨论<code>PCB</code></p>\n<h2 id=\"task-struct\"><a href=\"#task-struct\" class=\"headerlink\" title=\"task_struct\"></a>task_struct</h2><p><code>Linux</code>平台下的<code>PCB</code>叫做<code>task_struct</code></p>\n<blockquote>\n<p><code>task_struct</code>内容分类:</p>\n</blockquote>\n<ul>\n<li><strong>标示符</strong>: 描述本进程的唯一标示符，用来区别其他进程。</li>\n<li><strong>状态</strong>: 任务状态，退出代码，退出信号等。</li>\n<li><strong>优先级</strong>: 相对于其他进程的优先级。</li>\n<li>程序计数器: 程序中即将被执行的下一条指令的地址。</li>\n<li>内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针</li>\n<li>上下文数据: 进程执行时处理器的寄存器中的数据。</li>\n<li>I／O状态信息: 包括显示的I&#x2F;O请求,分配给进程的I／O设备和被进程使用的文件列表。</li>\n<li>记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。</li>\n<li>其他信息</li>\n</ul>\n<p><em>加粗部分会详细介绍</em></p>\n<h1 id=\"查看进程\"><a href=\"#查看进程\" class=\"headerlink\" title=\"查看进程\"></a>查看进程</h1><p>进程的信息可以通过&#x2F;proc 系统文件夹查看,其中文件夹的名字就是进程的<code>PID</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_21-53-59.png\"></p>\n<p>大多数进程信息同样可以使用top和ps这些用户级工具来获取</p>\n<blockquote>\n<p>以我自己编写的一个程序为例</p>\n</blockquote>\n<p><em>Makefile</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mycmd:mycmd.c</span><br><span class=\"line\">\tgcc -o $@ $^</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY:clean</span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -rf mycmd</span><br></pre></td></tr></table></figure>\n\n<p><strong>注</strong>： 后面的程序都是这三个头文件，仅修改<code>main()</code>函数体即可<br><em>mycmd.c</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) sleep(<span class=\"number\">1</span>);<span class=\"comment\">//死循环使该进程常驻内存</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后编译并运行程序<br><em>命令行</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make</span><br><span class=\"line\">./mycmd</span><br><span class=\"line\">ps aux | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_22-56-05.png\"></p>\n<h2 id=\"进程标示符-PID-PPID\"><a href=\"#进程标示符-PID-PPID\" class=\"headerlink\" title=\"进程标示符(PID PPID)\"></a>进程标示符(PID PPID)</h2><p>可以通过系统接口获取进程标示符</p>\n<ul>\n<li>进程id (pid)    使用<code>getpid()</code></li>\n<li>父进程id (ppid) 使用<code>getppid()</code></li>\n</ul>\n<p><em>来修改一下代码</em><br><em>mycmd.c</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;pid: %d\\n&quot;</span>,getpid());<span class=\"comment\">//打印pid (该进程id)</span></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ppid: %d\\n&quot;</span>,getppid());<span class=\"comment\">//打印ppid (父进程id)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>命令行</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make clean</span><br><span class=\"line\">make</span><br><span class=\"line\">./mycmd</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_23-28-35.png\"></p>\n<h2 id=\"利用fork-创建子进程\"><a href=\"#利用fork-创建子进程\" class=\"headerlink\" title=\"利用fork()创建子进程\"></a>利用<code>fork()</code>创建子进程</h2><p><em>mycmd.c</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)<span class=\"comment\">//子进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child pid: %d\\n&quot;</span>,getpid());<span class=\"comment\">//打印pid (该进程id)</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child ppid: %d\\n&quot;</span>,getppid());<span class=\"comment\">//打印ppid (父进程id)</span></span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span><span class=\"comment\">//父进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father pid: %d\\n&quot;</span>,getpid());<span class=\"comment\">//打印pid (该进程id)</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father ppid: %d\\n&quot;</span>,getppid());<span class=\"comment\">//打印ppid (父进程id)</span></span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_10-56-48.png\"></p>\n<p>如图，<code>fork()</code>创建了子进程，且子进程的<code>PPID</code>和父进程<code>PID</code>相同</p>\n<h3 id=\"fork-的返回值\"><a href=\"#fork-的返回值\" class=\"headerlink\" title=\"fork()的返回值\"></a>fork()的返回值</h3><p>父子进程中<code>fork()</code>函数的返回值(此处用变量<code>id</code>储存)是不同的:</p>\n<p><strong>父进程</strong>里<code>id</code>的值为子进程的<code>PID</code>,其值<code>&gt;0</code>;<strong>子进程</strong>里<code>id</code>值固定为<code>0</code></p>\n<ul>\n<li><code>id &gt; 0</code> 父进程</li>\n<li><code>id == 0</code> 子进程</li>\n<li><code>id &lt; 0</code> fork()失败</li>\n</ul>\n<h3 id=\"父子进程分流\"><a href=\"#父子进程分流\" class=\"headerlink\" title=\"父子进程分流\"></a>父子进程分流</h3><p>利用<code>fork()</code>返回值不同的特性可以做到分流操作，利用<code>if...else...</code>让父子进程执行不同的代码</p>\n<p><a href=\"https://www.supdriver.top/2024/07/07/fork/\">戳我去fork的详细介绍</a></p>\n<h1 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h1><p><em>状态在kernel源代码里定义</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> task_state_array[] = &#123;</span><br><span class=\"line\"><span class=\"string\">&quot;R (running)&quot;</span>, <span class=\"comment\">/* 0 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;S (sleeping)&quot;</span>, <span class=\"comment\">/* 1 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;D (disk sleep)&quot;</span>, <span class=\"comment\">/* 2 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;T (stopped)&quot;</span>, <span class=\"comment\">/* 4 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;t (tracing stop)&quot;</span>, <span class=\"comment\">/* 8 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;X (dead)&quot;</span>, <span class=\"comment\">/* 16 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;Z (zombie)&quot;</span>, <span class=\"comment\">/* 32 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"R-运行状态-running\"><a href=\"#R-运行状态-running\" class=\"headerlink\" title=\"R 运行状态(running)\"></a>R 运行状态(running)</h2><p>R状态并不一定正在运行，而是<code>正在运行</code>和<code>处于运行队列</code>中的一种</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-14-49.png\"></p>\n<h2 id=\"S-睡眠状态-sleeping\"><a href=\"#S-睡眠状态-sleeping\" class=\"headerlink\" title=\"S 睡眠状态(sleeping)\"></a>S 睡眠状态(sleeping)</h2><p>S 意味着进程在<strong>等待</strong>运行完成</p>\n<p>(<em>这里的睡眠有时也可叫做可中断睡眠 interruptible sleep</em>)</p>\n<p><em>下面展示两种S状态的进程</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  sleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-45-14.png\"></p>\n<p>直接使用<code>sleep()</code>系列的函数直接使进程休眠</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> n;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter the num: &quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-47-33.png\"></p>\n<p>像<code>scanf()</code>这种需要等待外设(键盘)的接口，在<strong>阻塞等待</strong>资源的过程中会使进程进入<code>S</code>状态</p>\n<h2 id=\"D-磁盘休眠状态（Disk-sleep）\"><a href=\"#D-磁盘休眠状态（Disk-sleep）\" class=\"headerlink\" title=\"D 磁盘休眠状态（Disk sleep）\"></a>D 磁盘休眠状态（Disk sleep）</h2><p>有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的进程通常会等待<code>IO</code>的结束。</p>\n<h2 id=\"T-停止状态（stopped）\"><a href=\"#T-停止状态（stopped）\" class=\"headerlink\" title=\"T 停止状态（stopped）\"></a>T 停止状态（stopped）</h2><p>可以通过(<em>kill等命令</em>)发送 <code>SIGSTOP</code> 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 <code>SIGCONT </code>信号让进程继续运行。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行前先<strong>复制</strong>ssh渠道，其中一个窗口用于执行进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make clean</span><br><span class=\"line\">make</span><br><span class=\"line\">./mycmd</span><br></pre></td></tr></table></figure>\n<p>另一个进程用于输入命令</p>\n<p>先查看该进程的<code>PID</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-04-51.png\"></p>\n<p>如图，这次的<code>PID</code>是<code>20275</code></p>\n<p>然后用<code>kill</code>发送<code>SIGSTOP</code>,对应参数为<code>-19</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -19 20275</span><br><span class=\"line\">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-06-38.png\"></p>\n<p>可以看到它已经由<code>S</code>状态改为<code>T</code>状态了</p>\n<p>接下来发送<code>SIGCONT</code>,对应参数<code>-18</code>,使进程恢复</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -18 20275</span><br><span class=\"line\">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-08-45.png\"></p>\n<p>可以看到已经由<code>T</code>变为原本的<code>S</code>状态了</p>\n<h2 id=\"X-死亡状态（dead）\"><a href=\"#X-死亡状态（dead）\" class=\"headerlink\" title=\"X 死亡状态（dead）\"></a>X 死亡状态（dead）</h2><p>这个状态只是一个返回状态，你不会在任务列表里看到这个状态。</p>\n<h2 id=\"Z-僵尸进程-zombie\"><a href=\"#Z-僵尸进程-zombie\" class=\"headerlink\" title=\"Z 僵尸进程(zombie)\"></a>Z 僵尸进程(zombie)</h2><p>这个详细讨论下</p>\n<h3 id=\"产生\"><a href=\"#产生\" class=\"headerlink\" title=\"产生\"></a>产生</h3><p>当该进程退出后，父进程尚未使用<code>wait()</code>之类的接口获取该进程的<code>退出码</code>,且父进程<strong>没有结束</strong>时，该进程会变成僵尸进程</p>\n<p><em>父进程比子进程先退出时，子进程的父进程会改变为PID为1的进程，由新进程托管</em></p>\n<p><em>下面创建一个例子</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)<span class=\"comment\">//子进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child exit\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span><span class=\"comment\">//父进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sleep(<span class=\"number\">30</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father exit\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行程序后的<code>30秒</code>内查看进程状态，可以看到子进程进入了<code>Z</code>状态</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_16-27-27.png\"></p>\n<h3 id=\"行为\"><a href=\"#行为\" class=\"headerlink\" title=\"行为\"></a>行为</h3><p>僵尸进程会以终止状态保持在进程表中，等待父进程读取退出状态代码</p>\n<h3 id=\"危害\"><a href=\"#危害\" class=\"headerlink\" title=\"危害\"></a>危害</h3><ul>\n<li>父进程一直<strong>未获取</strong>子进程的退出码,僵尸状态就会一直保持</li>\n<li>保持<code>Z</code>状态的进程的<code>PCB</code>仍然要一直维护，占用资源</li>\n<li>未退出<code>Z</code>状态的子进程可能造成内存泄漏</li>\n</ul>\n<h2 id=\"孤儿进程\"><a href=\"#孤儿进程\" class=\"headerlink\" title=\"孤儿进程\"></a>孤儿进程</h2><p>当父进程比子进程<strong>先</strong>退出后,这个子进程便成了<code>孤儿进程</code></p>\n<p>既然原本的父进程没了，谁来托管子进程呢？答案是<code>PID</code>为<code>1</code>的那个进程</p>\n<p><em>例子如下</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)<span class=\"comment\">//子进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sleep(<span class=\"number\">30</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child exit\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span><span class=\"comment\">//父进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father exit\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-05-32.png\"></p>\n<h1 id=\"进程优先级\"><a href=\"#进程优先级\" class=\"headerlink\" title=\"进程优先级\"></a>进程优先级</h1><h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><ul>\n<li>cpu资源分配的先后顺序，就是指进程的优先权（priority）。</li>\n<li>优先权高的进程有优先执行权利。配置进程优先权对多任务环境的linux很有用，可以改善系统性能。</li>\n<li>还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，可以大大改善系统整体性能</li>\n</ul>\n<h2 id=\"查看优先级\"><a href=\"#查看优先级\" class=\"headerlink\" title=\"查看优先级\"></a>查看优先级</h2><p><em>首先写一个常驻进程</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后使用<code>ps -la</code>查看进程信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./mycmd</span><br><span class=\"line\">ps -la</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-59-12.png\"></p>\n<p>其中的<code>PRI</code>和<code>NI</code>与进程优先级有关,<code>PRI</code>就是进程的优先级，跟排队摇号一样，此值<code>越小</code>，被执行的优先级越高,而<code>NI</code>就是nice值，用于修正原<code>PRI</code>值</p>\n<h3 id=\"PRI值的计算\"><a href=\"#PRI值的计算\" class=\"headerlink\" title=\"PRI值的计算\"></a>PRI值的计算</h3><p>首先在看到的<code>PRI</code>值之外，还有个隐藏的基准值，本文用<code>PRI0</code>指代，这个<code>PRI0</code>是固定的，当<code>NI</code>值为<code>0</code>时，<code>PRI == PRI0</code>,而<br>无论怎么修改多少次<code>NI</code>,<code>PRI</code>的值减去<code>NI</code>值都相等，所以大可以推断在本系统(Linux)中,<code>PRI</code>值有如下计算公式</p>\n<p><code>PRI = PRI0 + NI</code></p>\n<h3 id=\"修改NI值\"><a href=\"#修改NI值\" class=\"headerlink\" title=\"修改NI值\"></a>修改NI值</h3><p>因为修改<code>NI</code>值要管理员权限，所以要么<code>root</code>用户用<code>top</code>，要么信任用户用<code>sudo top</code>打开界面，然后按<code>r</code>,输入待修改进程的<code>PID</code>,按下回车后再输入新的<code>NI</code>值(有效范围<code>-20~19</code>)</p>\n<p><em>此处可以用<code>ps -la</code>查看进程的PID,或调用<code>getpid()</code></em></p>\n<p><em>再写一个例子</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;mypid: %d\\n&quot;</span>,getpid());</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>sudo top</code>然后按<code>r</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-14-38.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-15-50.png\"></p>\n<p><code>ps -la</code>可以看到被修改后的进程优先级</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-17-02.png\"></p>\n<h1 id=\"其它概念\"><a href=\"#其它概念\" class=\"headerlink\" title=\"其它概念\"></a>其它概念</h1><ul>\n<li>竞争性: 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级</li>\n<li>独立性: 多进程运行，需要独享各种资源，多进程运行期间<strong>互不干扰</strong></li>\n<li>并行: 多个进程在<strong>多个CPU</strong>下分别，同时进行运行，这称之为并行</li>\n<li>并发: 多个进程在<strong>一个CPU</strong>下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发</li>\n</ul>\n<p><em>下一章</em><a href=\"https://www.supdriver.top/2024/07/06/evn/\">环境变量</a></p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<hr>\n<p>操作系统平台:Linux<br>服务器系统: CentOS 7</p>\n<hr>\n<h1 id=\"概念抽象\"><a href=\"#概念抽象\" class=\"headerlink\" title=\"概念抽象\"></a>概念抽象</h1><h2 id=\"程序\"><a href=\"#程序\" class=\"headerlink\" title=\"程序\"></a>程序</h2><p><code>程序</code> &#x3D; <code>代码</code> + <code>数据</code></p>\n<p>程序是储存在硬盘上的可执行文件</p>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>将<code>程序</code>加载到<code>内存</code>后，就在<code>内存</code>中程序的就是进程。也就是说一个正在运行的程序就能叫做进程</p>\n<p><em>结构关系如下</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_13-55-08.png\"></p>\n<p>如图，操作系统为了<strong>管理</strong>内存中的进程,使用了<code>PCB</code>结构体来描述进程,通过管理<code>PCB</code>来管理进程,依然是<em>先描述再组织</em></p>\n<p><code>PCB</code>:进程控制块的数据结构(process control block)</p>\n<p>所以实际上:<code>进程</code>&#x3D;<code>PCB</code>+<code>代码和数据</code></p>\n<p>对于<code>代码和数据</code>没什么好说的，接下来主要讨论<code>PCB</code></p>\n<h2 id=\"task-struct\"><a href=\"#task-struct\" class=\"headerlink\" title=\"task_struct\"></a>task_struct</h2><p><code>Linux</code>平台下的<code>PCB</code>叫做<code>task_struct</code></p>\n<blockquote>\n<p><code>task_struct</code>内容分类:</p>\n</blockquote>\n<ul>\n<li><strong>标示符</strong>: 描述本进程的唯一标示符，用来区别其他进程。</li>\n<li><strong>状态</strong>: 任务状态，退出代码，退出信号等。</li>\n<li><strong>优先级</strong>: 相对于其他进程的优先级。</li>\n<li>程序计数器: 程序中即将被执行的下一条指令的地址。</li>\n<li>内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针</li>\n<li>上下文数据: 进程执行时处理器的寄存器中的数据。</li>\n<li>I／O状态信息: 包括显示的I&#x2F;O请求,分配给进程的I／O设备和被进程使用的文件列表。</li>\n<li>记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。</li>\n<li>其他信息</li>\n</ul>\n<p><em>加粗部分会详细介绍</em></p>\n<h1 id=\"查看进程\"><a href=\"#查看进程\" class=\"headerlink\" title=\"查看进程\"></a>查看进程</h1><p>进程的信息可以通过&#x2F;proc 系统文件夹查看,其中文件夹的名字就是进程的<code>PID</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_21-53-59.png\"></p>\n<p>大多数进程信息同样可以使用top和ps这些用户级工具来获取</p>\n<blockquote>\n<p>以我自己编写的一个程序为例</p>\n</blockquote>\n<p><em>Makefile</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mycmd:mycmd.c</span><br><span class=\"line\">\tgcc -o $@ $^</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY:clean</span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -rf mycmd</span><br></pre></td></tr></table></figure>\n\n<p><strong>注</strong>： 后面的程序都是这三个头文件，仅修改<code>main()</code>函数体即可<br><em>mycmd.c</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) sleep(<span class=\"number\">1</span>);<span class=\"comment\">//死循环使该进程常驻内存</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后编译并运行程序<br><em>命令行</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make</span><br><span class=\"line\">./mycmd</span><br><span class=\"line\">ps aux | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_22-56-05.png\"></p>\n<h2 id=\"进程标示符-PID-PPID\"><a href=\"#进程标示符-PID-PPID\" class=\"headerlink\" title=\"进程标示符(PID PPID)\"></a>进程标示符(PID PPID)</h2><p>可以通过系统接口获取进程标示符</p>\n<ul>\n<li>进程id (pid)    使用<code>getpid()</code></li>\n<li>父进程id (ppid) 使用<code>getppid()</code></li>\n</ul>\n<p><em>来修改一下代码</em><br><em>mycmd.c</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;pid: %d\\n&quot;</span>,getpid());<span class=\"comment\">//打印pid (该进程id)</span></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ppid: %d\\n&quot;</span>,getppid());<span class=\"comment\">//打印ppid (父进程id)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>命令行</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make clean</span><br><span class=\"line\">make</span><br><span class=\"line\">./mycmd</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-06_23-28-35.png\"></p>\n<h2 id=\"利用fork-创建子进程\"><a href=\"#利用fork-创建子进程\" class=\"headerlink\" title=\"利用fork()创建子进程\"></a>利用<code>fork()</code>创建子进程</h2><p><em>mycmd.c</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)<span class=\"comment\">//子进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child pid: %d\\n&quot;</span>,getpid());<span class=\"comment\">//打印pid (该进程id)</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child ppid: %d\\n&quot;</span>,getppid());<span class=\"comment\">//打印ppid (父进程id)</span></span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span><span class=\"comment\">//父进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father pid: %d\\n&quot;</span>,getpid());<span class=\"comment\">//打印pid (该进程id)</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father ppid: %d\\n&quot;</span>,getppid());<span class=\"comment\">//打印ppid (父进程id)</span></span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_10-56-48.png\"></p>\n<p>如图，<code>fork()</code>创建了子进程，且子进程的<code>PPID</code>和父进程<code>PID</code>相同</p>\n<h3 id=\"fork-的返回值\"><a href=\"#fork-的返回值\" class=\"headerlink\" title=\"fork()的返回值\"></a>fork()的返回值</h3><p>父子进程中<code>fork()</code>函数的返回值(此处用变量<code>id</code>储存)是不同的:</p>\n<p><strong>父进程</strong>里<code>id</code>的值为子进程的<code>PID</code>,其值<code>&gt;0</code>;<strong>子进程</strong>里<code>id</code>值固定为<code>0</code></p>\n<ul>\n<li><code>id &gt; 0</code> 父进程</li>\n<li><code>id == 0</code> 子进程</li>\n<li><code>id &lt; 0</code> fork()失败</li>\n</ul>\n<h3 id=\"父子进程分流\"><a href=\"#父子进程分流\" class=\"headerlink\" title=\"父子进程分流\"></a>父子进程分流</h3><p>利用<code>fork()</code>返回值不同的特性可以做到分流操作，利用<code>if...else...</code>让父子进程执行不同的代码</p>\n<p><a href=\"https://www.supdriver.top/2024/07/07/fork/\">戳我去fork的详细介绍</a></p>\n<h1 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h1><p><em>状态在kernel源代码里定义</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> task_state_array[] = &#123;</span><br><span class=\"line\"><span class=\"string\">&quot;R (running)&quot;</span>, <span class=\"comment\">/* 0 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;S (sleeping)&quot;</span>, <span class=\"comment\">/* 1 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;D (disk sleep)&quot;</span>, <span class=\"comment\">/* 2 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;T (stopped)&quot;</span>, <span class=\"comment\">/* 4 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;t (tracing stop)&quot;</span>, <span class=\"comment\">/* 8 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;X (dead)&quot;</span>, <span class=\"comment\">/* 16 */</span></span><br><span class=\"line\"><span class=\"string\">&quot;Z (zombie)&quot;</span>, <span class=\"comment\">/* 32 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"R-运行状态-running\"><a href=\"#R-运行状态-running\" class=\"headerlink\" title=\"R 运行状态(running)\"></a>R 运行状态(running)</h2><p>R状态并不一定正在运行，而是<code>正在运行</code>和<code>处于运行队列</code>中的一种</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-14-49.png\"></p>\n<h2 id=\"S-睡眠状态-sleeping\"><a href=\"#S-睡眠状态-sleeping\" class=\"headerlink\" title=\"S 睡眠状态(sleeping)\"></a>S 睡眠状态(sleeping)</h2><p>S 意味着进程在<strong>等待</strong>运行完成</p>\n<p>(<em>这里的睡眠有时也可叫做可中断睡眠 interruptible sleep</em>)</p>\n<p><em>下面展示两种S状态的进程</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  sleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-45-14.png\"></p>\n<p>直接使用<code>sleep()</code>系列的函数直接使进程休眠</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> n;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter the num: &quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_13-47-33.png\"></p>\n<p>像<code>scanf()</code>这种需要等待外设(键盘)的接口，在<strong>阻塞等待</strong>资源的过程中会使进程进入<code>S</code>状态</p>\n<h2 id=\"D-磁盘休眠状态（Disk-sleep）\"><a href=\"#D-磁盘休眠状态（Disk-sleep）\" class=\"headerlink\" title=\"D 磁盘休眠状态（Disk sleep）\"></a>D 磁盘休眠状态（Disk sleep）</h2><p>有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的进程通常会等待<code>IO</code>的结束。</p>\n<h2 id=\"T-停止状态（stopped）\"><a href=\"#T-停止状态（stopped）\" class=\"headerlink\" title=\"T 停止状态（stopped）\"></a>T 停止状态（stopped）</h2><p>可以通过(<em>kill等命令</em>)发送 <code>SIGSTOP</code> 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 <code>SIGCONT </code>信号让进程继续运行。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行前先<strong>复制</strong>ssh渠道，其中一个窗口用于执行进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make clean</span><br><span class=\"line\">make</span><br><span class=\"line\">./mycmd</span><br></pre></td></tr></table></figure>\n<p>另一个进程用于输入命令</p>\n<p>先查看该进程的<code>PID</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-04-51.png\"></p>\n<p>如图，这次的<code>PID</code>是<code>20275</code></p>\n<p>然后用<code>kill</code>发送<code>SIGSTOP</code>,对应参数为<code>-19</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -19 20275</span><br><span class=\"line\">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-06-38.png\"></p>\n<p>可以看到它已经由<code>S</code>状态改为<code>T</code>状态了</p>\n<p>接下来发送<code>SIGCONT</code>,对应参数<code>-18</code>,使进程恢复</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -18 20275</span><br><span class=\"line\">ps ajx | head -1 &amp;&amp; ps ajx | grep mycmd | grep -v grep</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_15-08-45.png\"></p>\n<p>可以看到已经由<code>T</code>变为原本的<code>S</code>状态了</p>\n<h2 id=\"X-死亡状态（dead）\"><a href=\"#X-死亡状态（dead）\" class=\"headerlink\" title=\"X 死亡状态（dead）\"></a>X 死亡状态（dead）</h2><p>这个状态只是一个返回状态，你不会在任务列表里看到这个状态。</p>\n<h2 id=\"Z-僵尸进程-zombie\"><a href=\"#Z-僵尸进程-zombie\" class=\"headerlink\" title=\"Z 僵尸进程(zombie)\"></a>Z 僵尸进程(zombie)</h2><p>这个详细讨论下</p>\n<h3 id=\"产生\"><a href=\"#产生\" class=\"headerlink\" title=\"产生\"></a>产生</h3><p>当该进程退出后，父进程尚未使用<code>wait()</code>之类的接口获取该进程的<code>退出码</code>,且父进程<strong>没有结束</strong>时，该进程会变成僵尸进程</p>\n<p><em>父进程比子进程先退出时，子进程的父进程会改变为PID为1的进程，由新进程托管</em></p>\n<p><em>下面创建一个例子</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)<span class=\"comment\">//子进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child exit\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span><span class=\"comment\">//父进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sleep(<span class=\"number\">30</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father exit\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行程序后的<code>30秒</code>内查看进程状态，可以看到子进程进入了<code>Z</code>状态</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_16-27-27.png\"></p>\n<h3 id=\"行为\"><a href=\"#行为\" class=\"headerlink\" title=\"行为\"></a>行为</h3><p>僵尸进程会以终止状态保持在进程表中，等待父进程读取退出状态代码</p>\n<h3 id=\"危害\"><a href=\"#危害\" class=\"headerlink\" title=\"危害\"></a>危害</h3><ul>\n<li>父进程一直<strong>未获取</strong>子进程的退出码,僵尸状态就会一直保持</li>\n<li>保持<code>Z</code>状态的进程的<code>PCB</code>仍然要一直维护，占用资源</li>\n<li>未退出<code>Z</code>状态的子进程可能造成内存泄漏</li>\n</ul>\n<h2 id=\"孤儿进程\"><a href=\"#孤儿进程\" class=\"headerlink\" title=\"孤儿进程\"></a>孤儿进程</h2><p>当父进程比子进程<strong>先</strong>退出后,这个子进程便成了<code>孤儿进程</code></p>\n<p>既然原本的父进程没了，谁来托管子进程呢？答案是<code>PID</code>为<code>1</code>的那个进程</p>\n<p><em>例子如下</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">pid_t</span> id = fork();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(id == <span class=\"number\">0</span>)<span class=\"comment\">//子进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sleep(<span class=\"number\">30</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child exit\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span><span class=\"comment\">//父进程</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father exit\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-05-32.png\"></p>\n<h1 id=\"进程优先级\"><a href=\"#进程优先级\" class=\"headerlink\" title=\"进程优先级\"></a>进程优先级</h1><h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><ul>\n<li>cpu资源分配的先后顺序，就是指进程的优先权（priority）。</li>\n<li>优先权高的进程有优先执行权利。配置进程优先权对多任务环境的linux很有用，可以改善系统性能。</li>\n<li>还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，可以大大改善系统整体性能</li>\n</ul>\n<h2 id=\"查看优先级\"><a href=\"#查看优先级\" class=\"headerlink\" title=\"查看优先级\"></a>查看优先级</h2><p><em>首先写一个常驻进程</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后使用<code>ps -la</code>查看进程信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./mycmd</span><br><span class=\"line\">ps -la</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_19-59-12.png\"></p>\n<p>其中的<code>PRI</code>和<code>NI</code>与进程优先级有关,<code>PRI</code>就是进程的优先级，跟排队摇号一样，此值<code>越小</code>，被执行的优先级越高,而<code>NI</code>就是nice值，用于修正原<code>PRI</code>值</p>\n<h3 id=\"PRI值的计算\"><a href=\"#PRI值的计算\" class=\"headerlink\" title=\"PRI值的计算\"></a>PRI值的计算</h3><p>首先在看到的<code>PRI</code>值之外，还有个隐藏的基准值，本文用<code>PRI0</code>指代，这个<code>PRI0</code>是固定的，当<code>NI</code>值为<code>0</code>时，<code>PRI == PRI0</code>,而<br>无论怎么修改多少次<code>NI</code>,<code>PRI</code>的值减去<code>NI</code>值都相等，所以大可以推断在本系统(Linux)中,<code>PRI</code>值有如下计算公式</p>\n<p><code>PRI = PRI0 + NI</code></p>\n<h3 id=\"修改NI值\"><a href=\"#修改NI值\" class=\"headerlink\" title=\"修改NI值\"></a>修改NI值</h3><p>因为修改<code>NI</code>值要管理员权限，所以要么<code>root</code>用户用<code>top</code>，要么信任用户用<code>sudo top</code>打开界面，然后按<code>r</code>,输入待修改进程的<code>PID</code>,按下回车后再输入新的<code>NI</code>值(有效范围<code>-20~19</code>)</p>\n<p><em>此处可以用<code>ps -la</code>查看进程的PID,或调用<code>getpid()</code></em></p>\n<p><em>再写一个例子</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;mypid: %d\\n&quot;</span>,getpid());</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>sudo top</code>然后按<code>r</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-14-38.png\"></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-15-50.png\"></p>\n<p><code>ps -la</code>可以看到被修改后的进程优先级</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-07_21-17-02.png\"></p>\n<h1 id=\"其它概念\"><a href=\"#其它概念\" class=\"headerlink\" title=\"其它概念\"></a>其它概念</h1><ul>\n<li>竞争性: 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级</li>\n<li>独立性: 多进程运行，需要独享各种资源，多进程运行期间<strong>互不干扰</strong></li>\n<li>并行: 多个进程在<strong>多个CPU</strong>下分别，同时进行运行，这称之为并行</li>\n<li>并发: 多个进程在<strong>一个CPU</strong>下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发</li>\n</ul>\n<p><em>下一章</em><a href=\"https://www.supdriver.top/2024/07/06/evn/\">环境变量</a></p>\n"},{"title":"C++特殊类的设计","date":"2024-08-12T02:55:17.000Z","_content":"","source":"_posts/spclass.md","raw":"---\ntitle: C++特殊类的设计\ndate: 2024-08-12 10:55:17\ntags:\n---\n","slug":"spclass","published":1,"updated":"2024-08-12T02:55:33.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08n001p4sp53hyq7x6p","content":"","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/6b5d612e0383e5d64f0777b4b979b002.jpg","cover_type":"img","excerpt":"","more":""},{"title":"Ssystem V 共享内存","date":"2024-08-14T06:55:06.000Z","_content":"\n共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递**不再涉及**到\n`内核`，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据,而是直接使用内存中的共享区。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/shared_mm.png)\n\n我们接下来认识一下常用的接口\n\n# 接口\n\n## shmget 创建共享内存\n需要同时引入`<sys/ipc.h>` `<sys/shm.h>`\n\n`int shmget(key_t key, size_t size, int shmflg);`\n\n+ `key` 是生成`共享内存标示符`的 关键字,唯一的`key`值能返回唯一的`共享内存标示符`,这是获得同一个共享内存的关键参数\n+ `size`是指共享内存的大小,按字节算\n+ `shmflg`是一个位图,控制创建时的行为和 共享内存文件的`权限`(缺省时为`0`),常见选项如下\n  + `IPC_CREAT`:单独一个时，如果申请的共享内存不存在，就创建，然后返回；若存在，则获取并返回\n  + `IPC_CREAT | IPC_EXCL`: 如果申请的共享内存不存在，则创建；若存在，则出错并返回`-1`\n  + `IPC_EXCL`:不能单独使用\n  + `IPC_CREAT | 0666`:创建一个权限为`0666`的共享内存文件,注：`0666`可改成其它权限\n+ `返回值`：若成功，则返回`共享内存标示符` ;若失败，则返回`-1`\n\n由上可知，保证`key`的唯一性是获得同一个共享内存的关键步骤，那么如何获得唯一的`key_t`类型的呢？\n\n这里使用新的接口`ftok`,（需同时引入`<sys/types.h>` 和 `<sys/ipc.h>`）\n\n`key_t ftok(const char *pathname, int proj_id);`\n\n+ `pathname`:必须指向一个存在的目录，或者有权限的文件\n+ `proj_id`: 该参数必须是**非零**的且至少有八位有效位的整型,可传`0x8888`这样的大整型\n+ `返回值`：成功时生成`key`,失败时返回`-1`\n\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/keytoshmid.png)\n\n经过一系列操作便可以创建共享内存了\n\n### 查看共享内存\n在`shell`命令里输入命令`ipcs -m`就可以看到的共享内存列表\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202408142027880.png)\n\n可以看到我创建了一个大小为`1145`比特的共享内存\n\n然而共享内存的声明周期与内核相同，必须要**手动**删除，所以在命令行上还有指令`ipcrm -m`指令删除共享内存\n\n那么应该用表里的`key`还是`shmid`呢？结论是在用户层，统一使用`shmid`管理共享内存（毕竟全称就是 `共享内存描述符`）\n\n例如上图就需要输入`ipcrm -m 0`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202408142026217.png)\n\n可以看到共享内存被删掉了\n\n### 共享内存的权限\n`ipcs -m`列表中的`perms`列就是共享内存文件的权限，没错，共享内存也是文件\n\n当创建时没指定权限时，则默认为`全0`，若要指定权限,需要在`shmflg`处在`|`上权限，例如`0666`\n\n### 共享内存的挂接数\n`ipcs -m`列表中的`nattch`下标注了共享内存的挂接数\n\n## shmat 挂接共享内存\n`void *shmat(int shmid, const void *shmaddr, int shmflg);`\n\n+ `shmid`:前面获取的`共享内存描述符`\n+ `shmadder`:一般传`nullptr`让系统自动选择挂接用的共享内存段地址\n+ `shmflg`:位图\n  + `0`:传`0`时默认以`读写模式`挂接\n  + `SHM_RDONLY`: 以`只读模式`挂接\n  + **没有**只写模式挂接\n+ `返回值`: 若成功，返回共享内存段地址；若失败，返回`(void *) -1`\n\n### shmdt 取消挂接\n虽然进程退出时会自动取消挂接，但如果要在进程内取消挂接，就要用`shmdt`函数取消挂接\n\n`int shmdt(const void *shmaddr);`\n\n把`shmat`返回的指针传进去即可\n\n### 读写共享区内存\n挂接上的进程是真正意义上的看到同一块内存，而且完全可以像`malloc`申请出的一段内存一样操作,比如把共享区的内存当成字符串的缓冲区,直接把标准输入用`fgets`拷贝到共享内存中\n\n不过默认的共享内存并没有同步互斥行为,需要额外控制,比如使用`FIFO命名管道`来完成同步操作\n\n## shmctl 控制共享内存\n`int shmctl(int shmid, int cmd, struct shmid_ds *buf);`\n\n该函数内容较多，下面只列举常见用法，更多信息请查阅`man`手册\n\n+ `shmid`:共享内存描述符\n+ `cmd`:控制指令，有很多种\n  + `IPC_RMID`:由共享内存创建者调用，声明该段共享内存已经取消挂接，传该参数时，后面的`buf`可传`nullptr`\n  + `IPC_STAT`:获取共享内存的状态并拷贝到`buf`指向的内存中\n+ `buf`:输出型参数,指向输出的内存缓冲区\n\n`shmid_ds`的部分声明如下\n```C\nstruct shmid_ds {\n    struct ipc_perm shm_perm;    /* Ownership and permissions */\n    size_t          shm_segsz;   /* Size of segment (bytes) */\n    time_t          shm_atime;   /* Last attach time */\n    time_t          shm_dtime;   /* Last detach time */\n    time_t          shm_ctime;   /* Last change time */\n    pid_t           shm_cpid;    /* PID of creator */\n    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */\n    shmatt_t        shm_nattch;  /* No. of current attaches */\n    ...\n};\n```\n\n## 进程互斥\n由于各进程要求共享资源，而且有些资源需要互斥使用，因此各进程间**竞争使用**这些资源，进程的这种关系为进程的互斥。\n\n+ `临街资源`:系统中某些资源一次只允许一个进程使用，称这样的资源为`临界资源`或`互斥资源`。*就好比一个萝卜一个坑*\n+ `临界区`: 在进程中涉及到互斥资源的**程序段**叫`临界区`\n+ `同步`: 内存共享中的同步，主要指使`写入`和`读取`操作`互斥`，使二者有明确的先后顺序，能够在共享内存中一次写入或读取完整报文\n\n在共享内存中，使用`FIFO命名管道`建立另一条进程间通信，就能较为简单地完成同步功能：\n\n1. 读端等待命名管道的信息\n2. 写端完成写入后利用命名管道，写入完成写入的信息，并等待读端的应答\n3. 读端接收到命名管道的信息后，才开始读取共享内存的内容\n4. 读端完成任务后向写端发送应答，写端返回第`1`步\n5. 写端开始继续写入\n\n# 附加：System V 消息队列 和 信号量\nSystem V 还提供了消息队列和信号量用于进程间通信\n\n## 消息队列\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/sharedmsg.png)\n\n消息队列是由内核维护的一种数据结构,用法和普通的队列一样，可以`push`和`pop`数据块，用于进程间通信\n\n## 接口\n\n### 头文件\n```C\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n```\n\n### msgget\n`int msgget(key_t key, int msgflg);`\n\n用于申请消息队列并获得`消息队列id`\n\n+ `key`:用法和获取与上一致，这里不赘述了\n+ `msgflg`:创建消息队列的选项，**基本和上文`shmget`相同**,内容较多，完整内容需翻阅`man`手册\n  + `IPC_CREAT`:单独一个时，如果申请的共享内存不存在，就创建，然后返回；若存在，则获取并返回\n  + `IPC_CREAT | IPC_EXCL`: 如果申请的共享内存不存在，则创建；若存在，则出错并返回`-1`\n  + `IPC_EXCL`:不能单独使用\n  + `IPC_CREAT | 0666`:创建一个权限为`0666`的共享内存文件,注：`0666`可改成其它权限\n+ `返回值`：若成功，则返回`消息队列id` ;若失败，则返回`-1`\n\n#### 查看消息队列\n`ipcs -q`可以查看所有可用的消息队列，剩余操作与上文相同\n\n### msgctl\n`int msgctl(int msqid, int cmd, struct msqid_ds *buf);`\n\n`msgctl`可用于控制消息队列\n\n该函数内容较多，下面只列举常见用法，更多信息请查阅`man`手册\n\n+ `msqid`:共享内存描述符\n+ `cmd`:控制指令，有很多种\n  + `IPC_RMID`:由共享内存创建者调用，声明该段共享内存已经取消挂接，传该参数时，后面的`buf`可传`nullptr`\n  + `IPC_STAT`:获取共享内存的状态并拷贝到`buf`指向的内存中\n+ `buf`:输出型参数,指向输出的内存缓冲区\n\n```C\nstruct msqid_ds {\n    struct ipc_perm msg_perm;   /* Ownership and permissions */\n    time_t          msg_stime;  /* Time of last msgsnd(2) */\n    time_t          msg_rtime;  /* Time of last msgrcv(2) */\n    time_t          msg_ctime;  /* Time of creation or last\n                                  modification by msgctl() */\n    unsigned long   msg_cbytes; /* # of bytes in queue */\n    msgqnum_t       msg_qnum;   /* # number of messages in queue */\n    msglen_t        msg_qbytes; /* Maximum # of bytes in queue */\n    pid_t           msg_lspid;  /* PID of last msgsnd(2) */\n    pid_t           msg_lrpid;  /* PID of last msgrcv(2) */\n};\n```\n\n### 向消息队列收发消息\n\n#### msgsnd\n`int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);`\n\n`msgsnd`用于向消息队列发送消息\n\n+ `msqid`:消息队列的`id`\n+ `msgp`:是指向结构体数据块(消息)的指针\n+ `msgsz`:数据块的大小，按字节算\n+ `msgflg`: 位图,具体选项详见`man`手册，一般使用可以为`0`\n+ 返回值：失败时返回`-1`,成功时返回`0`\n\n其中,`msgp`要遵循如下格式\n\n```C\nstruct msgbuf {\n    long mtype;       /* 消息的类型,必须> 0 */\n    char mtext[1];    /* 消息的数据，长度可比1大 */\n};\n```\n\n其中第一个成员必须是`long mtype`,且大于`0`。\n而第二个成员是字符数组用于储存字节数据，长度没有限制，因此函数传参也是`void*`,适配各种长度的结构体指针\n\n\n#### msgrcv\n`ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);`\n\n`msgrcv`用于从消息队列中接收数据（消息）\n\n+ `msqid`:消息队列的`id`\n+ `msgp`:是指向数据块(消息)的指针\n+ `msgsz`:数据块的大小，按字节算\n+ `msgtyp`:消息的类型\n+ `msgflg`: 位图,具体选项详见`man`手册，一般使用可以为`0`\n+ 返回值：失败时返回`-1`,成功时返回读取的字节数\n\n## 信号量\n信号量的本质是是一种计数器，但它特殊在只能`互斥访问`,它本身就是一种互斥资源,但也可用于描述另一种临界资源的多少\n\n信号量的工作原理:\n1. 申请计数器成功，就表示我有访问资源的**权限**了\n2. 申请了计数器资源，不代表当前我要访问资源了。当前只是预定了资源\n3. 计数器可以有效保证进入共享资源的执行流的量\n\n## 特殊情况\n当信号量只能为`0`或`1`时,即`二元信号量`，该信号量就可以作为一把`互斥锁`来使用，访问前申请信号量，访问完毕再释放信号量即可\n\n### 系统调用接口\n这里不作详细介绍，具体用法请翻阅`man`手册\n\n+ `semget`用于获取一个或多个信号量\n+ `semctl`用于控制信号量，可以`初始化`，`删除`，`获取状态参数`等\n+ `semop`用于获取信号量或释放信号量\n\n\n\n","source":"_posts/shmd.md","raw":"---\ntitle: Ssystem V 共享内存\ndate: 2024-08-14 14:55:06\ntags:\n---\n\n共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递**不再涉及**到\n`内核`，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据,而是直接使用内存中的共享区。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/shared_mm.png)\n\n我们接下来认识一下常用的接口\n\n# 接口\n\n## shmget 创建共享内存\n需要同时引入`<sys/ipc.h>` `<sys/shm.h>`\n\n`int shmget(key_t key, size_t size, int shmflg);`\n\n+ `key` 是生成`共享内存标示符`的 关键字,唯一的`key`值能返回唯一的`共享内存标示符`,这是获得同一个共享内存的关键参数\n+ `size`是指共享内存的大小,按字节算\n+ `shmflg`是一个位图,控制创建时的行为和 共享内存文件的`权限`(缺省时为`0`),常见选项如下\n  + `IPC_CREAT`:单独一个时，如果申请的共享内存不存在，就创建，然后返回；若存在，则获取并返回\n  + `IPC_CREAT | IPC_EXCL`: 如果申请的共享内存不存在，则创建；若存在，则出错并返回`-1`\n  + `IPC_EXCL`:不能单独使用\n  + `IPC_CREAT | 0666`:创建一个权限为`0666`的共享内存文件,注：`0666`可改成其它权限\n+ `返回值`：若成功，则返回`共享内存标示符` ;若失败，则返回`-1`\n\n由上可知，保证`key`的唯一性是获得同一个共享内存的关键步骤，那么如何获得唯一的`key_t`类型的呢？\n\n这里使用新的接口`ftok`,（需同时引入`<sys/types.h>` 和 `<sys/ipc.h>`）\n\n`key_t ftok(const char *pathname, int proj_id);`\n\n+ `pathname`:必须指向一个存在的目录，或者有权限的文件\n+ `proj_id`: 该参数必须是**非零**的且至少有八位有效位的整型,可传`0x8888`这样的大整型\n+ `返回值`：成功时生成`key`,失败时返回`-1`\n\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/keytoshmid.png)\n\n经过一系列操作便可以创建共享内存了\n\n### 查看共享内存\n在`shell`命令里输入命令`ipcs -m`就可以看到的共享内存列表\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202408142027880.png)\n\n可以看到我创建了一个大小为`1145`比特的共享内存\n\n然而共享内存的声明周期与内核相同，必须要**手动**删除，所以在命令行上还有指令`ipcrm -m`指令删除共享内存\n\n那么应该用表里的`key`还是`shmid`呢？结论是在用户层，统一使用`shmid`管理共享内存（毕竟全称就是 `共享内存描述符`）\n\n例如上图就需要输入`ipcrm -m 0`\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202408142026217.png)\n\n可以看到共享内存被删掉了\n\n### 共享内存的权限\n`ipcs -m`列表中的`perms`列就是共享内存文件的权限，没错，共享内存也是文件\n\n当创建时没指定权限时，则默认为`全0`，若要指定权限,需要在`shmflg`处在`|`上权限，例如`0666`\n\n### 共享内存的挂接数\n`ipcs -m`列表中的`nattch`下标注了共享内存的挂接数\n\n## shmat 挂接共享内存\n`void *shmat(int shmid, const void *shmaddr, int shmflg);`\n\n+ `shmid`:前面获取的`共享内存描述符`\n+ `shmadder`:一般传`nullptr`让系统自动选择挂接用的共享内存段地址\n+ `shmflg`:位图\n  + `0`:传`0`时默认以`读写模式`挂接\n  + `SHM_RDONLY`: 以`只读模式`挂接\n  + **没有**只写模式挂接\n+ `返回值`: 若成功，返回共享内存段地址；若失败，返回`(void *) -1`\n\n### shmdt 取消挂接\n虽然进程退出时会自动取消挂接，但如果要在进程内取消挂接，就要用`shmdt`函数取消挂接\n\n`int shmdt(const void *shmaddr);`\n\n把`shmat`返回的指针传进去即可\n\n### 读写共享区内存\n挂接上的进程是真正意义上的看到同一块内存，而且完全可以像`malloc`申请出的一段内存一样操作,比如把共享区的内存当成字符串的缓冲区,直接把标准输入用`fgets`拷贝到共享内存中\n\n不过默认的共享内存并没有同步互斥行为,需要额外控制,比如使用`FIFO命名管道`来完成同步操作\n\n## shmctl 控制共享内存\n`int shmctl(int shmid, int cmd, struct shmid_ds *buf);`\n\n该函数内容较多，下面只列举常见用法，更多信息请查阅`man`手册\n\n+ `shmid`:共享内存描述符\n+ `cmd`:控制指令，有很多种\n  + `IPC_RMID`:由共享内存创建者调用，声明该段共享内存已经取消挂接，传该参数时，后面的`buf`可传`nullptr`\n  + `IPC_STAT`:获取共享内存的状态并拷贝到`buf`指向的内存中\n+ `buf`:输出型参数,指向输出的内存缓冲区\n\n`shmid_ds`的部分声明如下\n```C\nstruct shmid_ds {\n    struct ipc_perm shm_perm;    /* Ownership and permissions */\n    size_t          shm_segsz;   /* Size of segment (bytes) */\n    time_t          shm_atime;   /* Last attach time */\n    time_t          shm_dtime;   /* Last detach time */\n    time_t          shm_ctime;   /* Last change time */\n    pid_t           shm_cpid;    /* PID of creator */\n    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */\n    shmatt_t        shm_nattch;  /* No. of current attaches */\n    ...\n};\n```\n\n## 进程互斥\n由于各进程要求共享资源，而且有些资源需要互斥使用，因此各进程间**竞争使用**这些资源，进程的这种关系为进程的互斥。\n\n+ `临街资源`:系统中某些资源一次只允许一个进程使用，称这样的资源为`临界资源`或`互斥资源`。*就好比一个萝卜一个坑*\n+ `临界区`: 在进程中涉及到互斥资源的**程序段**叫`临界区`\n+ `同步`: 内存共享中的同步，主要指使`写入`和`读取`操作`互斥`，使二者有明确的先后顺序，能够在共享内存中一次写入或读取完整报文\n\n在共享内存中，使用`FIFO命名管道`建立另一条进程间通信，就能较为简单地完成同步功能：\n\n1. 读端等待命名管道的信息\n2. 写端完成写入后利用命名管道，写入完成写入的信息，并等待读端的应答\n3. 读端接收到命名管道的信息后，才开始读取共享内存的内容\n4. 读端完成任务后向写端发送应答，写端返回第`1`步\n5. 写端开始继续写入\n\n# 附加：System V 消息队列 和 信号量\nSystem V 还提供了消息队列和信号量用于进程间通信\n\n## 消息队列\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/sharedmsg.png)\n\n消息队列是由内核维护的一种数据结构,用法和普通的队列一样，可以`push`和`pop`数据块，用于进程间通信\n\n## 接口\n\n### 头文件\n```C\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n```\n\n### msgget\n`int msgget(key_t key, int msgflg);`\n\n用于申请消息队列并获得`消息队列id`\n\n+ `key`:用法和获取与上一致，这里不赘述了\n+ `msgflg`:创建消息队列的选项，**基本和上文`shmget`相同**,内容较多，完整内容需翻阅`man`手册\n  + `IPC_CREAT`:单独一个时，如果申请的共享内存不存在，就创建，然后返回；若存在，则获取并返回\n  + `IPC_CREAT | IPC_EXCL`: 如果申请的共享内存不存在，则创建；若存在，则出错并返回`-1`\n  + `IPC_EXCL`:不能单独使用\n  + `IPC_CREAT | 0666`:创建一个权限为`0666`的共享内存文件,注：`0666`可改成其它权限\n+ `返回值`：若成功，则返回`消息队列id` ;若失败，则返回`-1`\n\n#### 查看消息队列\n`ipcs -q`可以查看所有可用的消息队列，剩余操作与上文相同\n\n### msgctl\n`int msgctl(int msqid, int cmd, struct msqid_ds *buf);`\n\n`msgctl`可用于控制消息队列\n\n该函数内容较多，下面只列举常见用法，更多信息请查阅`man`手册\n\n+ `msqid`:共享内存描述符\n+ `cmd`:控制指令，有很多种\n  + `IPC_RMID`:由共享内存创建者调用，声明该段共享内存已经取消挂接，传该参数时，后面的`buf`可传`nullptr`\n  + `IPC_STAT`:获取共享内存的状态并拷贝到`buf`指向的内存中\n+ `buf`:输出型参数,指向输出的内存缓冲区\n\n```C\nstruct msqid_ds {\n    struct ipc_perm msg_perm;   /* Ownership and permissions */\n    time_t          msg_stime;  /* Time of last msgsnd(2) */\n    time_t          msg_rtime;  /* Time of last msgrcv(2) */\n    time_t          msg_ctime;  /* Time of creation or last\n                                  modification by msgctl() */\n    unsigned long   msg_cbytes; /* # of bytes in queue */\n    msgqnum_t       msg_qnum;   /* # number of messages in queue */\n    msglen_t        msg_qbytes; /* Maximum # of bytes in queue */\n    pid_t           msg_lspid;  /* PID of last msgsnd(2) */\n    pid_t           msg_lrpid;  /* PID of last msgrcv(2) */\n};\n```\n\n### 向消息队列收发消息\n\n#### msgsnd\n`int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);`\n\n`msgsnd`用于向消息队列发送消息\n\n+ `msqid`:消息队列的`id`\n+ `msgp`:是指向结构体数据块(消息)的指针\n+ `msgsz`:数据块的大小，按字节算\n+ `msgflg`: 位图,具体选项详见`man`手册，一般使用可以为`0`\n+ 返回值：失败时返回`-1`,成功时返回`0`\n\n其中,`msgp`要遵循如下格式\n\n```C\nstruct msgbuf {\n    long mtype;       /* 消息的类型,必须> 0 */\n    char mtext[1];    /* 消息的数据，长度可比1大 */\n};\n```\n\n其中第一个成员必须是`long mtype`,且大于`0`。\n而第二个成员是字符数组用于储存字节数据，长度没有限制，因此函数传参也是`void*`,适配各种长度的结构体指针\n\n\n#### msgrcv\n`ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);`\n\n`msgrcv`用于从消息队列中接收数据（消息）\n\n+ `msqid`:消息队列的`id`\n+ `msgp`:是指向数据块(消息)的指针\n+ `msgsz`:数据块的大小，按字节算\n+ `msgtyp`:消息的类型\n+ `msgflg`: 位图,具体选项详见`man`手册，一般使用可以为`0`\n+ 返回值：失败时返回`-1`,成功时返回读取的字节数\n\n## 信号量\n信号量的本质是是一种计数器，但它特殊在只能`互斥访问`,它本身就是一种互斥资源,但也可用于描述另一种临界资源的多少\n\n信号量的工作原理:\n1. 申请计数器成功，就表示我有访问资源的**权限**了\n2. 申请了计数器资源，不代表当前我要访问资源了。当前只是预定了资源\n3. 计数器可以有效保证进入共享资源的执行流的量\n\n## 特殊情况\n当信号量只能为`0`或`1`时,即`二元信号量`，该信号量就可以作为一把`互斥锁`来使用，访问前申请信号量，访问完毕再释放信号量即可\n\n### 系统调用接口\n这里不作详细介绍，具体用法请翻阅`man`手册\n\n+ `semget`用于获取一个或多个信号量\n+ `semctl`用于控制信号量，可以`初始化`，`删除`，`获取状态参数`等\n+ `semop`用于获取信号量或释放信号量\n\n\n\n","slug":"shmd","published":1,"updated":"2024-08-27T02:46:42.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08o001r4sp5eur6emmv","content":"<p>共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递<strong>不再涉及</strong>到<br><code>内核</code>，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据,而是直接使用内存中的共享区。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/shared_mm.png\"></p>\n<p>我们接下来认识一下常用的接口</p>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><h2 id=\"shmget-创建共享内存\"><a href=\"#shmget-创建共享内存\" class=\"headerlink\" title=\"shmget 创建共享内存\"></a>shmget 创建共享内存</h2><p>需要同时引入<code>&lt;sys/ipc.h&gt;</code> <code>&lt;sys/shm.h&gt;</code></p>\n<p><code>int shmget(key_t key, size_t size, int shmflg);</code></p>\n<ul>\n<li><code>key</code> 是生成<code>共享内存标示符</code>的 关键字,唯一的<code>key</code>值能返回唯一的<code>共享内存标示符</code>,这是获得同一个共享内存的关键参数</li>\n<li><code>size</code>是指共享内存的大小,按字节算</li>\n<li><code>shmflg</code>是一个位图,控制创建时的行为和 共享内存文件的<code>权限</code>(缺省时为<code>0</code>),常见选项如下<ul>\n<li><code>IPC_CREAT</code>:单独一个时，如果申请的共享内存不存在，就创建，然后返回；若存在，则获取并返回</li>\n<li><code>IPC_CREAT | IPC_EXCL</code>: 如果申请的共享内存不存在，则创建；若存在，则出错并返回<code>-1</code></li>\n<li><code>IPC_EXCL</code>:不能单独使用</li>\n<li><code>IPC_CREAT | 0666</code>:创建一个权限为<code>0666</code>的共享内存文件,注：<code>0666</code>可改成其它权限</li>\n</ul>\n</li>\n<li><code>返回值</code>：若成功，则返回<code>共享内存标示符</code> ;若失败，则返回<code>-1</code></li>\n</ul>\n<p>由上可知，保证<code>key</code>的唯一性是获得同一个共享内存的关键步骤，那么如何获得唯一的<code>key_t</code>类型的呢？</p>\n<p>这里使用新的接口<code>ftok</code>,（需同时引入<code>&lt;sys/types.h&gt;</code> 和 <code>&lt;sys/ipc.h&gt;</code>）</p>\n<p><code>key_t ftok(const char *pathname, int proj_id);</code></p>\n<ul>\n<li><code>pathname</code>:必须指向一个存在的目录，或者有权限的文件</li>\n<li><code>proj_id</code>: 该参数必须是<strong>非零</strong>的且至少有八位有效位的整型,可传<code>0x8888</code>这样的大整型</li>\n<li><code>返回值</code>：成功时生成<code>key</code>,失败时返回<code>-1</code></li>\n</ul>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/keytoshmid.png\"></p>\n<p>经过一系列操作便可以创建共享内存了</p>\n<h3 id=\"查看共享内存\"><a href=\"#查看共享内存\" class=\"headerlink\" title=\"查看共享内存\"></a>查看共享内存</h3><p>在<code>shell</code>命令里输入命令<code>ipcs -m</code>就可以看到的共享内存列表</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202408142027880.png\"></p>\n<p>可以看到我创建了一个大小为<code>1145</code>比特的共享内存</p>\n<p>然而共享内存的声明周期与内核相同，必须要<strong>手动</strong>删除，所以在命令行上还有指令<code>ipcrm -m</code>指令删除共享内存</p>\n<p>那么应该用表里的<code>key</code>还是<code>shmid</code>呢？结论是在用户层，统一使用<code>shmid</code>管理共享内存（毕竟全称就是 <code>共享内存描述符</code>）</p>\n<p>例如上图就需要输入<code>ipcrm -m 0</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202408142026217.png\"></p>\n<p>可以看到共享内存被删掉了</p>\n<h3 id=\"共享内存的权限\"><a href=\"#共享内存的权限\" class=\"headerlink\" title=\"共享内存的权限\"></a>共享内存的权限</h3><p><code>ipcs -m</code>列表中的<code>perms</code>列就是共享内存文件的权限，没错，共享内存也是文件</p>\n<p>当创建时没指定权限时，则默认为<code>全0</code>，若要指定权限,需要在<code>shmflg</code>处在<code>|</code>上权限，例如<code>0666</code></p>\n<h3 id=\"共享内存的挂接数\"><a href=\"#共享内存的挂接数\" class=\"headerlink\" title=\"共享内存的挂接数\"></a>共享内存的挂接数</h3><p><code>ipcs -m</code>列表中的<code>nattch</code>下标注了共享内存的挂接数</p>\n<h2 id=\"shmat-挂接共享内存\"><a href=\"#shmat-挂接共享内存\" class=\"headerlink\" title=\"shmat 挂接共享内存\"></a>shmat 挂接共享内存</h2><p><code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code></p>\n<ul>\n<li><code>shmid</code>:前面获取的<code>共享内存描述符</code></li>\n<li><code>shmadder</code>:一般传<code>nullptr</code>让系统自动选择挂接用的共享内存段地址</li>\n<li><code>shmflg</code>:位图<ul>\n<li><code>0</code>:传<code>0</code>时默认以<code>读写模式</code>挂接</li>\n<li><code>SHM_RDONLY</code>: 以<code>只读模式</code>挂接</li>\n<li><strong>没有</strong>只写模式挂接</li>\n</ul>\n</li>\n<li><code>返回值</code>: 若成功，返回共享内存段地址；若失败，返回<code>(void *) -1</code></li>\n</ul>\n<h3 id=\"shmdt-取消挂接\"><a href=\"#shmdt-取消挂接\" class=\"headerlink\" title=\"shmdt 取消挂接\"></a>shmdt 取消挂接</h3><p>虽然进程退出时会自动取消挂接，但如果要在进程内取消挂接，就要用<code>shmdt</code>函数取消挂接</p>\n<p><code>int shmdt(const void *shmaddr);</code></p>\n<p>把<code>shmat</code>返回的指针传进去即可</p>\n<h3 id=\"读写共享区内存\"><a href=\"#读写共享区内存\" class=\"headerlink\" title=\"读写共享区内存\"></a>读写共享区内存</h3><p>挂接上的进程是真正意义上的看到同一块内存，而且完全可以像<code>malloc</code>申请出的一段内存一样操作,比如把共享区的内存当成字符串的缓冲区,直接把标准输入用<code>fgets</code>拷贝到共享内存中</p>\n<p>不过默认的共享内存并没有同步互斥行为,需要额外控制,比如使用<code>FIFO命名管道</code>来完成同步操作</p>\n<h2 id=\"shmctl-控制共享内存\"><a href=\"#shmctl-控制共享内存\" class=\"headerlink\" title=\"shmctl 控制共享内存\"></a>shmctl 控制共享内存</h2><p><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</code></p>\n<p>该函数内容较多，下面只列举常见用法，更多信息请查阅<code>man</code>手册</p>\n<ul>\n<li><code>shmid</code>:共享内存描述符</li>\n<li><code>cmd</code>:控制指令，有很多种<ul>\n<li><code>IPC_RMID</code>:由共享内存创建者调用，声明该段共享内存已经取消挂接，传该参数时，后面的<code>buf</code>可传<code>nullptr</code></li>\n<li><code>IPC_STAT</code>:获取共享内存的状态并拷贝到<code>buf</code>指向的内存中</li>\n</ul>\n</li>\n<li><code>buf</code>:输出型参数,指向输出的内存缓冲区</li>\n</ul>\n<p><code>shmid_ds</code>的部分声明如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">shmid_ds</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">shm_perm</span>;</span>    <span class=\"comment\">/* Ownership and permissions */</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span>          shm_segsz;   <span class=\"comment\">/* Size of segment (bytes) */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          shm_atime;   <span class=\"comment\">/* Last attach time */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          shm_dtime;   <span class=\"comment\">/* Last detach time */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          shm_ctime;   <span class=\"comment\">/* Last change time */</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>           shm_cpid;    <span class=\"comment\">/* PID of creator */</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>           shm_lpid;    <span class=\"comment\">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class=\"line\">    <span class=\"type\">shmatt_t</span>        shm_nattch;  <span class=\"comment\">/* No. of current attaches */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进程互斥\"><a href=\"#进程互斥\" class=\"headerlink\" title=\"进程互斥\"></a>进程互斥</h2><p>由于各进程要求共享资源，而且有些资源需要互斥使用，因此各进程间<strong>竞争使用</strong>这些资源，进程的这种关系为进程的互斥。</p>\n<ul>\n<li><code>临街资源</code>:系统中某些资源一次只允许一个进程使用，称这样的资源为<code>临界资源</code>或<code>互斥资源</code>。<em>就好比一个萝卜一个坑</em></li>\n<li><code>临界区</code>: 在进程中涉及到互斥资源的<strong>程序段</strong>叫<code>临界区</code></li>\n<li><code>同步</code>: 内存共享中的同步，主要指使<code>写入</code>和<code>读取</code>操作<code>互斥</code>，使二者有明确的先后顺序，能够在共享内存中一次写入或读取完整报文</li>\n</ul>\n<p>在共享内存中，使用<code>FIFO命名管道</code>建立另一条进程间通信，就能较为简单地完成同步功能：</p>\n<ol>\n<li>读端等待命名管道的信息</li>\n<li>写端完成写入后利用命名管道，写入完成写入的信息，并等待读端的应答</li>\n<li>读端接收到命名管道的信息后，才开始读取共享内存的内容</li>\n<li>读端完成任务后向写端发送应答，写端返回第<code>1</code>步</li>\n<li>写端开始继续写入</li>\n</ol>\n<h1 id=\"附加：System-V-消息队列-和-信号量\"><a href=\"#附加：System-V-消息队列-和-信号量\" class=\"headerlink\" title=\"附加：System V 消息队列 和 信号量\"></a>附加：System V 消息队列 和 信号量</h1><p>System V 还提供了消息队列和信号量用于进程间通信</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/sharedmsg.png\"></p>\n<p>消息队列是由内核维护的一种数据结构,用法和普通的队列一样，可以<code>push</code>和<code>pop</code>数据块，用于进程间通信</p>\n<h2 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h2><h3 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/ipc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/msg.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"msgget\"><a href=\"#msgget\" class=\"headerlink\" title=\"msgget\"></a>msgget</h3><p><code>int msgget(key_t key, int msgflg);</code></p>\n<p>用于申请消息队列并获得<code>消息队列id</code></p>\n<ul>\n<li><code>key</code>:用法和获取与上一致，这里不赘述了</li>\n<li><code>msgflg</code>:创建消息队列的选项，<strong>基本和上文<code>shmget</code>相同</strong>,内容较多，完整内容需翻阅<code>man</code>手册<ul>\n<li><code>IPC_CREAT</code>:单独一个时，如果申请的共享内存不存在，就创建，然后返回；若存在，则获取并返回</li>\n<li><code>IPC_CREAT | IPC_EXCL</code>: 如果申请的共享内存不存在，则创建；若存在，则出错并返回<code>-1</code></li>\n<li><code>IPC_EXCL</code>:不能单独使用</li>\n<li><code>IPC_CREAT | 0666</code>:创建一个权限为<code>0666</code>的共享内存文件,注：<code>0666</code>可改成其它权限</li>\n</ul>\n</li>\n<li><code>返回值</code>：若成功，则返回<code>消息队列id</code> ;若失败，则返回<code>-1</code></li>\n</ul>\n<h4 id=\"查看消息队列\"><a href=\"#查看消息队列\" class=\"headerlink\" title=\"查看消息队列\"></a>查看消息队列</h4><p><code>ipcs -q</code>可以查看所有可用的消息队列，剩余操作与上文相同</p>\n<h3 id=\"msgctl\"><a href=\"#msgctl\" class=\"headerlink\" title=\"msgctl\"></a>msgctl</h3><p><code>int msgctl(int msqid, int cmd, struct msqid_ds *buf);</code></p>\n<p><code>msgctl</code>可用于控制消息队列</p>\n<p>该函数内容较多，下面只列举常见用法，更多信息请查阅<code>man</code>手册</p>\n<ul>\n<li><code>msqid</code>:共享内存描述符</li>\n<li><code>cmd</code>:控制指令，有很多种<ul>\n<li><code>IPC_RMID</code>:由共享内存创建者调用，声明该段共享内存已经取消挂接，传该参数时，后面的<code>buf</code>可传<code>nullptr</code></li>\n<li><code>IPC_STAT</code>:获取共享内存的状态并拷贝到<code>buf</code>指向的内存中</li>\n</ul>\n</li>\n<li><code>buf</code>:输出型参数,指向输出的内存缓冲区</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msqid_ds</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">msg_perm</span>;</span>   <span class=\"comment\">/* Ownership and permissions */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          msg_stime;  <span class=\"comment\">/* Time of last msgsnd(2) */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          msg_rtime;  <span class=\"comment\">/* Time of last msgrcv(2) */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          msg_ctime;  <span class=\"comment\">/* Time of creation or last</span></span><br><span class=\"line\"><span class=\"comment\">                                  modification by msgctl() */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span>   msg_cbytes; <span class=\"comment\">/* # of bytes in queue */</span></span><br><span class=\"line\">    <span class=\"type\">msgqnum_t</span>       msg_qnum;   <span class=\"comment\">/* # number of messages in queue */</span></span><br><span class=\"line\">    <span class=\"type\">msglen_t</span>        msg_qbytes; <span class=\"comment\">/* Maximum # of bytes in queue */</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>           msg_lspid;  <span class=\"comment\">/* PID of last msgsnd(2) */</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>           msg_lrpid;  <span class=\"comment\">/* PID of last msgrcv(2) */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"向消息队列收发消息\"><a href=\"#向消息队列收发消息\" class=\"headerlink\" title=\"向消息队列收发消息\"></a>向消息队列收发消息</h3><h4 id=\"msgsnd\"><a href=\"#msgsnd\" class=\"headerlink\" title=\"msgsnd\"></a>msgsnd</h4><p><code>int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</code></p>\n<p><code>msgsnd</code>用于向消息队列发送消息</p>\n<ul>\n<li><code>msqid</code>:消息队列的<code>id</code></li>\n<li><code>msgp</code>:是指向结构体数据块(消息)的指针</li>\n<li><code>msgsz</code>:数据块的大小，按字节算</li>\n<li><code>msgflg</code>: 位图,具体选项详见<code>man</code>手册，一般使用可以为<code>0</code></li>\n<li>返回值：失败时返回<code>-1</code>,成功时返回<code>0</code></li>\n</ul>\n<p>其中,<code>msgp</code>要遵循如下格式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msgbuf</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">long</span> mtype;       <span class=\"comment\">/* 消息的类型,必须&gt; 0 */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> mtext[<span class=\"number\">1</span>];    <span class=\"comment\">/* 消息的数据，长度可比1大 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中第一个成员必须是<code>long mtype</code>,且大于<code>0</code>。<br>而第二个成员是字符数组用于储存字节数据，长度没有限制，因此函数传参也是<code>void*</code>,适配各种长度的结构体指针</p>\n<h4 id=\"msgrcv\"><a href=\"#msgrcv\" class=\"headerlink\" title=\"msgrcv\"></a>msgrcv</h4><p><code>ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);</code></p>\n<p><code>msgrcv</code>用于从消息队列中接收数据（消息）</p>\n<ul>\n<li><code>msqid</code>:消息队列的<code>id</code></li>\n<li><code>msgp</code>:是指向数据块(消息)的指针</li>\n<li><code>msgsz</code>:数据块的大小，按字节算</li>\n<li><code>msgtyp</code>:消息的类型</li>\n<li><code>msgflg</code>: 位图,具体选项详见<code>man</code>手册，一般使用可以为<code>0</code></li>\n<li>返回值：失败时返回<code>-1</code>,成功时返回读取的字节数</li>\n</ul>\n<h2 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h2><p>信号量的本质是是一种计数器，但它特殊在只能<code>互斥访问</code>,它本身就是一种互斥资源,但也可用于描述另一种临界资源的多少</p>\n<p>信号量的工作原理:</p>\n<ol>\n<li>申请计数器成功，就表示我有访问资源的<strong>权限</strong>了</li>\n<li>申请了计数器资源，不代表当前我要访问资源了。当前只是预定了资源</li>\n<li>计数器可以有效保证进入共享资源的执行流的量</li>\n</ol>\n<h2 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h2><p>当信号量只能为<code>0</code>或<code>1</code>时,即<code>二元信号量</code>，该信号量就可以作为一把<code>互斥锁</code>来使用，访问前申请信号量，访问完毕再释放信号量即可</p>\n<h3 id=\"系统调用接口\"><a href=\"#系统调用接口\" class=\"headerlink\" title=\"系统调用接口\"></a>系统调用接口</h3><p>这里不作详细介绍，具体用法请翻阅<code>man</code>手册</p>\n<ul>\n<li><code>semget</code>用于获取一个或多个信号量</li>\n<li><code>semctl</code>用于控制信号量，可以<code>初始化</code>，<code>删除</code>，<code>获取状态参数</code>等</li>\n<li><code>semop</code>用于获取信号量或释放信号量</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/8c09fac433d3d448ca54bbf0c079c59d.jpg","cover_type":"img","excerpt":"","more":"<p>共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递<strong>不再涉及</strong>到<br><code>内核</code>，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据,而是直接使用内存中的共享区。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/shared_mm.png\"></p>\n<p>我们接下来认识一下常用的接口</p>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><h2 id=\"shmget-创建共享内存\"><a href=\"#shmget-创建共享内存\" class=\"headerlink\" title=\"shmget 创建共享内存\"></a>shmget 创建共享内存</h2><p>需要同时引入<code>&lt;sys/ipc.h&gt;</code> <code>&lt;sys/shm.h&gt;</code></p>\n<p><code>int shmget(key_t key, size_t size, int shmflg);</code></p>\n<ul>\n<li><code>key</code> 是生成<code>共享内存标示符</code>的 关键字,唯一的<code>key</code>值能返回唯一的<code>共享内存标示符</code>,这是获得同一个共享内存的关键参数</li>\n<li><code>size</code>是指共享内存的大小,按字节算</li>\n<li><code>shmflg</code>是一个位图,控制创建时的行为和 共享内存文件的<code>权限</code>(缺省时为<code>0</code>),常见选项如下<ul>\n<li><code>IPC_CREAT</code>:单独一个时，如果申请的共享内存不存在，就创建，然后返回；若存在，则获取并返回</li>\n<li><code>IPC_CREAT | IPC_EXCL</code>: 如果申请的共享内存不存在，则创建；若存在，则出错并返回<code>-1</code></li>\n<li><code>IPC_EXCL</code>:不能单独使用</li>\n<li><code>IPC_CREAT | 0666</code>:创建一个权限为<code>0666</code>的共享内存文件,注：<code>0666</code>可改成其它权限</li>\n</ul>\n</li>\n<li><code>返回值</code>：若成功，则返回<code>共享内存标示符</code> ;若失败，则返回<code>-1</code></li>\n</ul>\n<p>由上可知，保证<code>key</code>的唯一性是获得同一个共享内存的关键步骤，那么如何获得唯一的<code>key_t</code>类型的呢？</p>\n<p>这里使用新的接口<code>ftok</code>,（需同时引入<code>&lt;sys/types.h&gt;</code> 和 <code>&lt;sys/ipc.h&gt;</code>）</p>\n<p><code>key_t ftok(const char *pathname, int proj_id);</code></p>\n<ul>\n<li><code>pathname</code>:必须指向一个存在的目录，或者有权限的文件</li>\n<li><code>proj_id</code>: 该参数必须是<strong>非零</strong>的且至少有八位有效位的整型,可传<code>0x8888</code>这样的大整型</li>\n<li><code>返回值</code>：成功时生成<code>key</code>,失败时返回<code>-1</code></li>\n</ul>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/keytoshmid.png\"></p>\n<p>经过一系列操作便可以创建共享内存了</p>\n<h3 id=\"查看共享内存\"><a href=\"#查看共享内存\" class=\"headerlink\" title=\"查看共享内存\"></a>查看共享内存</h3><p>在<code>shell</code>命令里输入命令<code>ipcs -m</code>就可以看到的共享内存列表</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202408142027880.png\"></p>\n<p>可以看到我创建了一个大小为<code>1145</code>比特的共享内存</p>\n<p>然而共享内存的声明周期与内核相同，必须要<strong>手动</strong>删除，所以在命令行上还有指令<code>ipcrm -m</code>指令删除共享内存</p>\n<p>那么应该用表里的<code>key</code>还是<code>shmid</code>呢？结论是在用户层，统一使用<code>shmid</code>管理共享内存（毕竟全称就是 <code>共享内存描述符</code>）</p>\n<p>例如上图就需要输入<code>ipcrm -m 0</code></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202408142026217.png\"></p>\n<p>可以看到共享内存被删掉了</p>\n<h3 id=\"共享内存的权限\"><a href=\"#共享内存的权限\" class=\"headerlink\" title=\"共享内存的权限\"></a>共享内存的权限</h3><p><code>ipcs -m</code>列表中的<code>perms</code>列就是共享内存文件的权限，没错，共享内存也是文件</p>\n<p>当创建时没指定权限时，则默认为<code>全0</code>，若要指定权限,需要在<code>shmflg</code>处在<code>|</code>上权限，例如<code>0666</code></p>\n<h3 id=\"共享内存的挂接数\"><a href=\"#共享内存的挂接数\" class=\"headerlink\" title=\"共享内存的挂接数\"></a>共享内存的挂接数</h3><p><code>ipcs -m</code>列表中的<code>nattch</code>下标注了共享内存的挂接数</p>\n<h2 id=\"shmat-挂接共享内存\"><a href=\"#shmat-挂接共享内存\" class=\"headerlink\" title=\"shmat 挂接共享内存\"></a>shmat 挂接共享内存</h2><p><code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code></p>\n<ul>\n<li><code>shmid</code>:前面获取的<code>共享内存描述符</code></li>\n<li><code>shmadder</code>:一般传<code>nullptr</code>让系统自动选择挂接用的共享内存段地址</li>\n<li><code>shmflg</code>:位图<ul>\n<li><code>0</code>:传<code>0</code>时默认以<code>读写模式</code>挂接</li>\n<li><code>SHM_RDONLY</code>: 以<code>只读模式</code>挂接</li>\n<li><strong>没有</strong>只写模式挂接</li>\n</ul>\n</li>\n<li><code>返回值</code>: 若成功，返回共享内存段地址；若失败，返回<code>(void *) -1</code></li>\n</ul>\n<h3 id=\"shmdt-取消挂接\"><a href=\"#shmdt-取消挂接\" class=\"headerlink\" title=\"shmdt 取消挂接\"></a>shmdt 取消挂接</h3><p>虽然进程退出时会自动取消挂接，但如果要在进程内取消挂接，就要用<code>shmdt</code>函数取消挂接</p>\n<p><code>int shmdt(const void *shmaddr);</code></p>\n<p>把<code>shmat</code>返回的指针传进去即可</p>\n<h3 id=\"读写共享区内存\"><a href=\"#读写共享区内存\" class=\"headerlink\" title=\"读写共享区内存\"></a>读写共享区内存</h3><p>挂接上的进程是真正意义上的看到同一块内存，而且完全可以像<code>malloc</code>申请出的一段内存一样操作,比如把共享区的内存当成字符串的缓冲区,直接把标准输入用<code>fgets</code>拷贝到共享内存中</p>\n<p>不过默认的共享内存并没有同步互斥行为,需要额外控制,比如使用<code>FIFO命名管道</code>来完成同步操作</p>\n<h2 id=\"shmctl-控制共享内存\"><a href=\"#shmctl-控制共享内存\" class=\"headerlink\" title=\"shmctl 控制共享内存\"></a>shmctl 控制共享内存</h2><p><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</code></p>\n<p>该函数内容较多，下面只列举常见用法，更多信息请查阅<code>man</code>手册</p>\n<ul>\n<li><code>shmid</code>:共享内存描述符</li>\n<li><code>cmd</code>:控制指令，有很多种<ul>\n<li><code>IPC_RMID</code>:由共享内存创建者调用，声明该段共享内存已经取消挂接，传该参数时，后面的<code>buf</code>可传<code>nullptr</code></li>\n<li><code>IPC_STAT</code>:获取共享内存的状态并拷贝到<code>buf</code>指向的内存中</li>\n</ul>\n</li>\n<li><code>buf</code>:输出型参数,指向输出的内存缓冲区</li>\n</ul>\n<p><code>shmid_ds</code>的部分声明如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">shmid_ds</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">shm_perm</span>;</span>    <span class=\"comment\">/* Ownership and permissions */</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span>          shm_segsz;   <span class=\"comment\">/* Size of segment (bytes) */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          shm_atime;   <span class=\"comment\">/* Last attach time */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          shm_dtime;   <span class=\"comment\">/* Last detach time */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          shm_ctime;   <span class=\"comment\">/* Last change time */</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>           shm_cpid;    <span class=\"comment\">/* PID of creator */</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>           shm_lpid;    <span class=\"comment\">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class=\"line\">    <span class=\"type\">shmatt_t</span>        shm_nattch;  <span class=\"comment\">/* No. of current attaches */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进程互斥\"><a href=\"#进程互斥\" class=\"headerlink\" title=\"进程互斥\"></a>进程互斥</h2><p>由于各进程要求共享资源，而且有些资源需要互斥使用，因此各进程间<strong>竞争使用</strong>这些资源，进程的这种关系为进程的互斥。</p>\n<ul>\n<li><code>临街资源</code>:系统中某些资源一次只允许一个进程使用，称这样的资源为<code>临界资源</code>或<code>互斥资源</code>。<em>就好比一个萝卜一个坑</em></li>\n<li><code>临界区</code>: 在进程中涉及到互斥资源的<strong>程序段</strong>叫<code>临界区</code></li>\n<li><code>同步</code>: 内存共享中的同步，主要指使<code>写入</code>和<code>读取</code>操作<code>互斥</code>，使二者有明确的先后顺序，能够在共享内存中一次写入或读取完整报文</li>\n</ul>\n<p>在共享内存中，使用<code>FIFO命名管道</code>建立另一条进程间通信，就能较为简单地完成同步功能：</p>\n<ol>\n<li>读端等待命名管道的信息</li>\n<li>写端完成写入后利用命名管道，写入完成写入的信息，并等待读端的应答</li>\n<li>读端接收到命名管道的信息后，才开始读取共享内存的内容</li>\n<li>读端完成任务后向写端发送应答，写端返回第<code>1</code>步</li>\n<li>写端开始继续写入</li>\n</ol>\n<h1 id=\"附加：System-V-消息队列-和-信号量\"><a href=\"#附加：System-V-消息队列-和-信号量\" class=\"headerlink\" title=\"附加：System V 消息队列 和 信号量\"></a>附加：System V 消息队列 和 信号量</h1><p>System V 还提供了消息队列和信号量用于进程间通信</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/sharedmsg.png\"></p>\n<p>消息队列是由内核维护的一种数据结构,用法和普通的队列一样，可以<code>push</code>和<code>pop</code>数据块，用于进程间通信</p>\n<h2 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h2><h3 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/ipc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/msg.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"msgget\"><a href=\"#msgget\" class=\"headerlink\" title=\"msgget\"></a>msgget</h3><p><code>int msgget(key_t key, int msgflg);</code></p>\n<p>用于申请消息队列并获得<code>消息队列id</code></p>\n<ul>\n<li><code>key</code>:用法和获取与上一致，这里不赘述了</li>\n<li><code>msgflg</code>:创建消息队列的选项，<strong>基本和上文<code>shmget</code>相同</strong>,内容较多，完整内容需翻阅<code>man</code>手册<ul>\n<li><code>IPC_CREAT</code>:单独一个时，如果申请的共享内存不存在，就创建，然后返回；若存在，则获取并返回</li>\n<li><code>IPC_CREAT | IPC_EXCL</code>: 如果申请的共享内存不存在，则创建；若存在，则出错并返回<code>-1</code></li>\n<li><code>IPC_EXCL</code>:不能单独使用</li>\n<li><code>IPC_CREAT | 0666</code>:创建一个权限为<code>0666</code>的共享内存文件,注：<code>0666</code>可改成其它权限</li>\n</ul>\n</li>\n<li><code>返回值</code>：若成功，则返回<code>消息队列id</code> ;若失败，则返回<code>-1</code></li>\n</ul>\n<h4 id=\"查看消息队列\"><a href=\"#查看消息队列\" class=\"headerlink\" title=\"查看消息队列\"></a>查看消息队列</h4><p><code>ipcs -q</code>可以查看所有可用的消息队列，剩余操作与上文相同</p>\n<h3 id=\"msgctl\"><a href=\"#msgctl\" class=\"headerlink\" title=\"msgctl\"></a>msgctl</h3><p><code>int msgctl(int msqid, int cmd, struct msqid_ds *buf);</code></p>\n<p><code>msgctl</code>可用于控制消息队列</p>\n<p>该函数内容较多，下面只列举常见用法，更多信息请查阅<code>man</code>手册</p>\n<ul>\n<li><code>msqid</code>:共享内存描述符</li>\n<li><code>cmd</code>:控制指令，有很多种<ul>\n<li><code>IPC_RMID</code>:由共享内存创建者调用，声明该段共享内存已经取消挂接，传该参数时，后面的<code>buf</code>可传<code>nullptr</code></li>\n<li><code>IPC_STAT</code>:获取共享内存的状态并拷贝到<code>buf</code>指向的内存中</li>\n</ul>\n</li>\n<li><code>buf</code>:输出型参数,指向输出的内存缓冲区</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msqid_ds</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">msg_perm</span>;</span>   <span class=\"comment\">/* Ownership and permissions */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          msg_stime;  <span class=\"comment\">/* Time of last msgsnd(2) */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          msg_rtime;  <span class=\"comment\">/* Time of last msgrcv(2) */</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span>          msg_ctime;  <span class=\"comment\">/* Time of creation or last</span></span><br><span class=\"line\"><span class=\"comment\">                                  modification by msgctl() */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span>   msg_cbytes; <span class=\"comment\">/* # of bytes in queue */</span></span><br><span class=\"line\">    <span class=\"type\">msgqnum_t</span>       msg_qnum;   <span class=\"comment\">/* # number of messages in queue */</span></span><br><span class=\"line\">    <span class=\"type\">msglen_t</span>        msg_qbytes; <span class=\"comment\">/* Maximum # of bytes in queue */</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>           msg_lspid;  <span class=\"comment\">/* PID of last msgsnd(2) */</span></span><br><span class=\"line\">    <span class=\"type\">pid_t</span>           msg_lrpid;  <span class=\"comment\">/* PID of last msgrcv(2) */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"向消息队列收发消息\"><a href=\"#向消息队列收发消息\" class=\"headerlink\" title=\"向消息队列收发消息\"></a>向消息队列收发消息</h3><h4 id=\"msgsnd\"><a href=\"#msgsnd\" class=\"headerlink\" title=\"msgsnd\"></a>msgsnd</h4><p><code>int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</code></p>\n<p><code>msgsnd</code>用于向消息队列发送消息</p>\n<ul>\n<li><code>msqid</code>:消息队列的<code>id</code></li>\n<li><code>msgp</code>:是指向结构体数据块(消息)的指针</li>\n<li><code>msgsz</code>:数据块的大小，按字节算</li>\n<li><code>msgflg</code>: 位图,具体选项详见<code>man</code>手册，一般使用可以为<code>0</code></li>\n<li>返回值：失败时返回<code>-1</code>,成功时返回<code>0</code></li>\n</ul>\n<p>其中,<code>msgp</code>要遵循如下格式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msgbuf</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">long</span> mtype;       <span class=\"comment\">/* 消息的类型,必须&gt; 0 */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> mtext[<span class=\"number\">1</span>];    <span class=\"comment\">/* 消息的数据，长度可比1大 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中第一个成员必须是<code>long mtype</code>,且大于<code>0</code>。<br>而第二个成员是字符数组用于储存字节数据，长度没有限制，因此函数传参也是<code>void*</code>,适配各种长度的结构体指针</p>\n<h4 id=\"msgrcv\"><a href=\"#msgrcv\" class=\"headerlink\" title=\"msgrcv\"></a>msgrcv</h4><p><code>ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);</code></p>\n<p><code>msgrcv</code>用于从消息队列中接收数据（消息）</p>\n<ul>\n<li><code>msqid</code>:消息队列的<code>id</code></li>\n<li><code>msgp</code>:是指向数据块(消息)的指针</li>\n<li><code>msgsz</code>:数据块的大小，按字节算</li>\n<li><code>msgtyp</code>:消息的类型</li>\n<li><code>msgflg</code>: 位图,具体选项详见<code>man</code>手册，一般使用可以为<code>0</code></li>\n<li>返回值：失败时返回<code>-1</code>,成功时返回读取的字节数</li>\n</ul>\n<h2 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h2><p>信号量的本质是是一种计数器，但它特殊在只能<code>互斥访问</code>,它本身就是一种互斥资源,但也可用于描述另一种临界资源的多少</p>\n<p>信号量的工作原理:</p>\n<ol>\n<li>申请计数器成功，就表示我有访问资源的<strong>权限</strong>了</li>\n<li>申请了计数器资源，不代表当前我要访问资源了。当前只是预定了资源</li>\n<li>计数器可以有效保证进入共享资源的执行流的量</li>\n</ol>\n<h2 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h2><p>当信号量只能为<code>0</code>或<code>1</code>时,即<code>二元信号量</code>，该信号量就可以作为一把<code>互斥锁</code>来使用，访问前申请信号量，访问完毕再释放信号量即可</p>\n<h3 id=\"系统调用接口\"><a href=\"#系统调用接口\" class=\"headerlink\" title=\"系统调用接口\"></a>系统调用接口</h3><p>这里不作详细介绍，具体用法请翻阅<code>man</code>手册</p>\n<ul>\n<li><code>semget</code>用于获取一个或多个信号量</li>\n<li><code>semctl</code>用于控制信号量，可以<code>初始化</code>，<code>删除</code>，<code>获取状态参数</code>等</li>\n<li><code>semop</code>用于获取信号量或释放信号量</li>\n</ul>\n"},{"title":"Linux原生线程","date":"2024-08-14T06:55:39.000Z","_content":"\n# 什么是线程\n\n在一个程序（进程）里的一条执行流就叫做`线程`(thread),也就是说有多线程功能的进程内，可以有多个线程同时执行\n\n所以我们可以认为:\n+ 一个进程至少有一个执行进程\n+ 线程在进程内部运行，本质是在进程提供的地址空间内运行\n\n而对于`Linux`实现的线程，本质上是轻量化的进程，还是用的`task_struct`去维护的每一个**线程**\n\n![Linux进程结构](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread.png)\n\n**关于线程间内存共享**\n如上图所示，线程之间只有`栈区`是相互**独立**的， 像是`全局变量`，`堆区数据`都是共享的\n\n## 线程的优点\n+ 创建一个新线程的`代价`要比创建一个新进程小得多\n+ 与进程之间的`切换`相比，线程之间的切换需要操作系统做的`工作`要少很多\n+ 线程占用的`资源`要比进程少很多\n+ 能充分利用多处理器的可`并行`数量\n+ 在等待慢速`I/O`操作结束的同时，程序可执行其他的计算任务\n+ 计算密集型应用，为了能在多处理器系统上运行，将`计算分解`到多个线程中实现\n+ `I/O密集型应用`，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。\n\n## 线程的缺点\n\n### 性能损失\n*一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失*，这里的`性能损失`指的是增加了额外的\n`同步`和`调度`开销，而**可用的资源不变。**\n\n### 健壮性降低\n编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。\n\n### 缺乏访问控制\n`进程`是访问控制的`基本粒度`，在一个线程中调用某些OS函数会对整个进程造成影响。\n\n### 编程难度提高\n编写与调试一个多线程程序比单线程程序困难得多\n\n## 线程异常\n所有线程好比铁索连环，如果单个线程出现诸如 `除零`，`野指针`等异常问题导致线程崩溃,整个`进程`，包括所有线程，都会崩溃退出\n\n## 线程的用途\n+ 合理的使用多线程，能提高CPU密集型程序的执行效率\n+ 合理的使用多线程，能提高IO密集型程序的用户体验\n\n# 线程与进程辨析\n\n## 进程\n资源分配的基本单位,即每个进程都会分配一套独立的进程地址空间/虚拟地址，并且供内部的所有线程共享\n\n## 线程\n线程是调度的基本单位，线程共享进程数据，但也拥有自己的一部分数据<span id = \"qianwen\"></span>\n\n+ `线程ID`\n+ 一组寄存器\n+ 栈\n+ errno\n+ 信号屏蔽字\n+ 调度优先级\n\n进程的多个`线程共享` 同一地址空间,因此`Text Segment`、`Data Segment`都是共享的,如果定义一个函数,在各线程\n中都可以调用,如果定义一个全局变量,在各线程中都可以访问到,除此之外,各线程还共享以下进程资源和环境\n\n+ 文教描述符表\n+ 每种信号的处理方式(SIG_IGN、SIG_DFL或自定义的信号处理函数)\n+ 当前工作目录\n+ 用户id和组id\n\n# Linux线程控制\n这里介绍POSIX线程库，这是一个第三方线程库，且是个动态库,有以下特点\n\n+ 与线程有关的函数构成了个完整的系列，绝大多数函数的名字都是以`pthread_`打头的\n+ 要使用这些函数库，要通过引入头文`<pthread.h>`\n+ 链接这些线程函数库时要使用**编译器**命令的`-lpthread`选项  *很容易忘*\n\n## 创建线程\n```C++\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                          void *(*start_routine) (void *), void *arg);\n```\n使用`pthread_create`函数创建新线程\n\n+ 参数\n  + thread:输出型参数，返回新线程的`线程id`\n  + attr:设置线程属性，为`nullptr`时使用默认属性，一般为`nullptr`\n  + start_routine:函数地址，即新线程**启动时调用**的函数\n  + arg:传给`start_routine`指向函数的参数\n+ 返回值:成功返回`0`，失败返回错误码\n\n关于错误码\n> + 统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。\n> + threads函数出错时不会设置全局变量errno（而大部分其他POSIX函数会这样做）。而是将错误代码通过返回值返回\n> + hreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误,建议通过返回值业判定，因为读取返回值要比读取线程内的errno变量的开销更小\n\n> 使用示例\n```C++\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#include <string.h>\n#include <pthread.h>\nvoid *rout(void *arg)\n{\n    int i;\n    for (;;)\n    {\n        printf(\"I'am thread 1,got arg:%d\\n\",*(int*)arg);\n        sleep(1);\n    }\n}\nint main(void)\n{\n    pthread_t tid;//储存tid的变量\n    int ret;\n    int arg = 114514;//准备参数\n    //创建新线程\n    if ((ret = pthread_create(&tid, NULL, rout, &arg)) != 0)\n    {\n        //创建失败\n        fprintf(stderr, \"pthread_create : %s\\n\", strerror(ret));\n        exit(EXIT_FAILURE);\n    }\n    int i;\n    for (;;)\n    {\n        //主线程输出\n        printf(\"I'am main thread\\n\");\n        sleep(1);\n    }\n}\n```\n\n## 线程id及进程地址空间布局\n+ hread_create函数会产生一个线程id，存放在第一个参数指向的地址中。该线程id和前面说的线程ID(本文用大小写区分)不是一回事。\n+ [前文](#qianwen)的`线程ID`于进程调度的范畴。因为线程是轻量级进程，是操作系统调度器的最小单位，所以需要一个数值来唯一表示该线程。\n+ hread_create函数第一个参数指向一个虚拟内存单元，该内存单元的地址即为新创建线程的线程ID,属于NPTL线程库的范畴。线程库的后续操作，就是根据该线程ID来操作线程的。\n+ 程库NPTL提供了pthread_self函数，可以获得线程自身的ID:\n\n`pthread_t` 到底是什么类型呢？取决于实现。对于Linux目前实现的NPTL实现而言，pthread_t类型的线程ID，本质就是一个进程地址空间上的一个地址。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409091528968.png)\n\n## 线程终止\n如果需要只终止某个线程而不终止整个进程,可以有三种方法:\n\n+ 从线程函数`return`。这种方法对主线程**不适用**,从main函数return相当于调用exit。\n+ 线程可以调用`pthread_exit`终止自己。\n+  一个线程可以调用`pthread_cancel`终止同一进程中的另一个线程。\n\n### pthread_exit函数\n`void pthread_exit(void *retval);`\n\n`retval`为输出型参数，而函数调用后，该线程退出，栈帧销毁，所以,需要注意,pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的,不能在线程函数的栈上分配,因为当其它线程得到这个返回指针时线程函数已经退出了。\n\n","source":"_posts/thread.md","raw":"---\ntitle: Linux原生线程\ndate: 2024-08-14 14:55:39\ntags:\n---\n\n# 什么是线程\n\n在一个程序（进程）里的一条执行流就叫做`线程`(thread),也就是说有多线程功能的进程内，可以有多个线程同时执行\n\n所以我们可以认为:\n+ 一个进程至少有一个执行进程\n+ 线程在进程内部运行，本质是在进程提供的地址空间内运行\n\n而对于`Linux`实现的线程，本质上是轻量化的进程，还是用的`task_struct`去维护的每一个**线程**\n\n![Linux进程结构](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread.png)\n\n**关于线程间内存共享**\n如上图所示，线程之间只有`栈区`是相互**独立**的， 像是`全局变量`，`堆区数据`都是共享的\n\n## 线程的优点\n+ 创建一个新线程的`代价`要比创建一个新进程小得多\n+ 与进程之间的`切换`相比，线程之间的切换需要操作系统做的`工作`要少很多\n+ 线程占用的`资源`要比进程少很多\n+ 能充分利用多处理器的可`并行`数量\n+ 在等待慢速`I/O`操作结束的同时，程序可执行其他的计算任务\n+ 计算密集型应用，为了能在多处理器系统上运行，将`计算分解`到多个线程中实现\n+ `I/O密集型应用`，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。\n\n## 线程的缺点\n\n### 性能损失\n*一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失*，这里的`性能损失`指的是增加了额外的\n`同步`和`调度`开销，而**可用的资源不变。**\n\n### 健壮性降低\n编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。\n\n### 缺乏访问控制\n`进程`是访问控制的`基本粒度`，在一个线程中调用某些OS函数会对整个进程造成影响。\n\n### 编程难度提高\n编写与调试一个多线程程序比单线程程序困难得多\n\n## 线程异常\n所有线程好比铁索连环，如果单个线程出现诸如 `除零`，`野指针`等异常问题导致线程崩溃,整个`进程`，包括所有线程，都会崩溃退出\n\n## 线程的用途\n+ 合理的使用多线程，能提高CPU密集型程序的执行效率\n+ 合理的使用多线程，能提高IO密集型程序的用户体验\n\n# 线程与进程辨析\n\n## 进程\n资源分配的基本单位,即每个进程都会分配一套独立的进程地址空间/虚拟地址，并且供内部的所有线程共享\n\n## 线程\n线程是调度的基本单位，线程共享进程数据，但也拥有自己的一部分数据<span id = \"qianwen\"></span>\n\n+ `线程ID`\n+ 一组寄存器\n+ 栈\n+ errno\n+ 信号屏蔽字\n+ 调度优先级\n\n进程的多个`线程共享` 同一地址空间,因此`Text Segment`、`Data Segment`都是共享的,如果定义一个函数,在各线程\n中都可以调用,如果定义一个全局变量,在各线程中都可以访问到,除此之外,各线程还共享以下进程资源和环境\n\n+ 文教描述符表\n+ 每种信号的处理方式(SIG_IGN、SIG_DFL或自定义的信号处理函数)\n+ 当前工作目录\n+ 用户id和组id\n\n# Linux线程控制\n这里介绍POSIX线程库，这是一个第三方线程库，且是个动态库,有以下特点\n\n+ 与线程有关的函数构成了个完整的系列，绝大多数函数的名字都是以`pthread_`打头的\n+ 要使用这些函数库，要通过引入头文`<pthread.h>`\n+ 链接这些线程函数库时要使用**编译器**命令的`-lpthread`选项  *很容易忘*\n\n## 创建线程\n```C++\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                          void *(*start_routine) (void *), void *arg);\n```\n使用`pthread_create`函数创建新线程\n\n+ 参数\n  + thread:输出型参数，返回新线程的`线程id`\n  + attr:设置线程属性，为`nullptr`时使用默认属性，一般为`nullptr`\n  + start_routine:函数地址，即新线程**启动时调用**的函数\n  + arg:传给`start_routine`指向函数的参数\n+ 返回值:成功返回`0`，失败返回错误码\n\n关于错误码\n> + 统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。\n> + threads函数出错时不会设置全局变量errno（而大部分其他POSIX函数会这样做）。而是将错误代码通过返回值返回\n> + hreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误,建议通过返回值业判定，因为读取返回值要比读取线程内的errno变量的开销更小\n\n> 使用示例\n```C++\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#include <string.h>\n#include <pthread.h>\nvoid *rout(void *arg)\n{\n    int i;\n    for (;;)\n    {\n        printf(\"I'am thread 1,got arg:%d\\n\",*(int*)arg);\n        sleep(1);\n    }\n}\nint main(void)\n{\n    pthread_t tid;//储存tid的变量\n    int ret;\n    int arg = 114514;//准备参数\n    //创建新线程\n    if ((ret = pthread_create(&tid, NULL, rout, &arg)) != 0)\n    {\n        //创建失败\n        fprintf(stderr, \"pthread_create : %s\\n\", strerror(ret));\n        exit(EXIT_FAILURE);\n    }\n    int i;\n    for (;;)\n    {\n        //主线程输出\n        printf(\"I'am main thread\\n\");\n        sleep(1);\n    }\n}\n```\n\n## 线程id及进程地址空间布局\n+ hread_create函数会产生一个线程id，存放在第一个参数指向的地址中。该线程id和前面说的线程ID(本文用大小写区分)不是一回事。\n+ [前文](#qianwen)的`线程ID`于进程调度的范畴。因为线程是轻量级进程，是操作系统调度器的最小单位，所以需要一个数值来唯一表示该线程。\n+ hread_create函数第一个参数指向一个虚拟内存单元，该内存单元的地址即为新创建线程的线程ID,属于NPTL线程库的范畴。线程库的后续操作，就是根据该线程ID来操作线程的。\n+ 程库NPTL提供了pthread_self函数，可以获得线程自身的ID:\n\n`pthread_t` 到底是什么类型呢？取决于实现。对于Linux目前实现的NPTL实现而言，pthread_t类型的线程ID，本质就是一个进程地址空间上的一个地址。\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409091528968.png)\n\n## 线程终止\n如果需要只终止某个线程而不终止整个进程,可以有三种方法:\n\n+ 从线程函数`return`。这种方法对主线程**不适用**,从main函数return相当于调用exit。\n+ 线程可以调用`pthread_exit`终止自己。\n+  一个线程可以调用`pthread_cancel`终止同一进程中的另一个线程。\n\n### pthread_exit函数\n`void pthread_exit(void *retval);`\n\n`retval`为输出型参数，而函数调用后，该线程退出，栈帧销毁，所以,需要注意,pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的,不能在线程函数的栈上分配,因为当其它线程得到这个返回指针时线程函数已经退出了。\n\n","slug":"thread","published":1,"updated":"2024-09-09T07:35:01.246Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08o001t4sp52xaa8sae","content":"<h1 id=\"什么是线程\"><a href=\"#什么是线程\" class=\"headerlink\" title=\"什么是线程\"></a>什么是线程</h1><p>在一个程序（进程）里的一条执行流就叫做<code>线程</code>(thread),也就是说有多线程功能的进程内，可以有多个线程同时执行</p>\n<p>所以我们可以认为:</p>\n<ul>\n<li>一个进程至少有一个执行进程</li>\n<li>线程在进程内部运行，本质是在进程提供的地址空间内运行</li>\n</ul>\n<p>而对于<code>Linux</code>实现的线程，本质上是轻量化的进程，还是用的<code>task_struct</code>去维护的每一个<strong>线程</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread.png\" alt=\"Linux进程结构\"></p>\n<p><strong>关于线程间内存共享</strong><br>如上图所示，线程之间只有<code>栈区</code>是相互<strong>独立</strong>的， 像是<code>全局变量</code>，<code>堆区数据</code>都是共享的</p>\n<h2 id=\"线程的优点\"><a href=\"#线程的优点\" class=\"headerlink\" title=\"线程的优点\"></a>线程的优点</h2><ul>\n<li>创建一个新线程的<code>代价</code>要比创建一个新进程小得多</li>\n<li>与进程之间的<code>切换</code>相比，线程之间的切换需要操作系统做的<code>工作</code>要少很多</li>\n<li>线程占用的<code>资源</code>要比进程少很多</li>\n<li>能充分利用多处理器的可<code>并行</code>数量</li>\n<li>在等待慢速<code>I/O</code>操作结束的同时，程序可执行其他的计算任务</li>\n<li>计算密集型应用，为了能在多处理器系统上运行，将<code>计算分解</code>到多个线程中实现</li>\n<li><code>I/O密集型应用</code>，为了提高性能，将I&#x2F;O操作重叠。线程可以同时等待不同的I&#x2F;O操作。</li>\n</ul>\n<h2 id=\"线程的缺点\"><a href=\"#线程的缺点\" class=\"headerlink\" title=\"线程的缺点\"></a>线程的缺点</h2><h3 id=\"性能损失\"><a href=\"#性能损失\" class=\"headerlink\" title=\"性能损失\"></a>性能损失</h3><p><em>一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失</em>，这里的<code>性能损失</code>指的是增加了额外的<br><code>同步</code>和<code>调度</code>开销，而<strong>可用的资源不变。</strong></p>\n<h3 id=\"健壮性降低\"><a href=\"#健壮性降低\" class=\"headerlink\" title=\"健壮性降低\"></a>健壮性降低</h3><p>编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。</p>\n<h3 id=\"缺乏访问控制\"><a href=\"#缺乏访问控制\" class=\"headerlink\" title=\"缺乏访问控制\"></a>缺乏访问控制</h3><p><code>进程</code>是访问控制的<code>基本粒度</code>，在一个线程中调用某些OS函数会对整个进程造成影响。</p>\n<h3 id=\"编程难度提高\"><a href=\"#编程难度提高\" class=\"headerlink\" title=\"编程难度提高\"></a>编程难度提高</h3><p>编写与调试一个多线程程序比单线程程序困难得多</p>\n<h2 id=\"线程异常\"><a href=\"#线程异常\" class=\"headerlink\" title=\"线程异常\"></a>线程异常</h2><p>所有线程好比铁索连环，如果单个线程出现诸如 <code>除零</code>，<code>野指针</code>等异常问题导致线程崩溃,整个<code>进程</code>，包括所有线程，都会崩溃退出</p>\n<h2 id=\"线程的用途\"><a href=\"#线程的用途\" class=\"headerlink\" title=\"线程的用途\"></a>线程的用途</h2><ul>\n<li>合理的使用多线程，能提高CPU密集型程序的执行效率</li>\n<li>合理的使用多线程，能提高IO密集型程序的用户体验</li>\n</ul>\n<h1 id=\"线程与进程辨析\"><a href=\"#线程与进程辨析\" class=\"headerlink\" title=\"线程与进程辨析\"></a>线程与进程辨析</h1><h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>资源分配的基本单位,即每个进程都会分配一套独立的进程地址空间&#x2F;虚拟地址，并且供内部的所有线程共享</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是调度的基本单位，线程共享进程数据，但也拥有自己的一部分数据<span id = \"qianwen\"></span></p>\n<ul>\n<li><code>线程ID</code></li>\n<li>一组寄存器</li>\n<li>栈</li>\n<li>errno</li>\n<li>信号屏蔽字</li>\n<li>调度优先级</li>\n</ul>\n<p>进程的多个<code>线程共享</code> 同一地址空间,因此<code>Text Segment</code>、<code>Data Segment</code>都是共享的,如果定义一个函数,在各线程<br>中都可以调用,如果定义一个全局变量,在各线程中都可以访问到,除此之外,各线程还共享以下进程资源和环境</p>\n<ul>\n<li>文教描述符表</li>\n<li>每种信号的处理方式(SIG_IGN、SIG_DFL或自定义的信号处理函数)</li>\n<li>当前工作目录</li>\n<li>用户id和组id</li>\n</ul>\n<h1 id=\"Linux线程控制\"><a href=\"#Linux线程控制\" class=\"headerlink\" title=\"Linux线程控制\"></a>Linux线程控制</h1><p>这里介绍POSIX线程库，这是一个第三方线程库，且是个动态库,有以下特点</p>\n<ul>\n<li>与线程有关的函数构成了个完整的系列，绝大多数函数的名字都是以<code>pthread_</code>打头的</li>\n<li>要使用这些函数库，要通过引入头文<code>&lt;pthread.h&gt;</code></li>\n<li>链接这些线程函数库时要使用<strong>编译器</strong>命令的<code>-lpthread</code>选项  <em>很容易忘</em></li>\n</ul>\n<h2 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pthread_create</span><span class=\"params\">(<span class=\"type\">pthread_t</span> *thread, <span class=\"type\">const</span> <span class=\"type\">pthread_attr_t</span> *attr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"type\">void</span> *(*start_routine) (<span class=\"type\">void</span> *), <span class=\"type\">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>使用<code>pthread_create</code>函数创建新线程</p>\n<ul>\n<li>参数<ul>\n<li>thread:输出型参数，返回新线程的<code>线程id</code></li>\n<li>attr:设置线程属性，为<code>nullptr</code>时使用默认属性，一般为<code>nullptr</code></li>\n<li>start_routine:函数地址，即新线程<strong>启动时调用</strong>的函数</li>\n<li>arg:传给<code>start_routine</code>指向函数的参数</li>\n</ul>\n</li>\n<li>返回值:成功返回<code>0</code>，失败返回错误码</li>\n</ul>\n<p>关于错误码</p>\n<blockquote>\n<ul>\n<li>统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。</li>\n<li>threads函数出错时不会设置全局变量errno（而大部分其他POSIX函数会这样做）。而是将错误代码通过返回值返回</li>\n<li>hreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误,建议通过返回值业判定，因为读取返回值要比读取线程内的errno变量的开销更小</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>使用示例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">rout</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I&#x27;am thread 1,got arg:%d\\n&quot;</span>,*(<span class=\"type\">int</span>*)arg);</span><br><span class=\"line\">        <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> tid;<span class=\"comment\">//储存tid的变量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\">    <span class=\"type\">int</span> arg = <span class=\"number\">114514</span>;<span class=\"comment\">//准备参数</span></span><br><span class=\"line\">    <span class=\"comment\">//创建新线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((ret = <span class=\"built_in\">pthread_create</span>(&amp;tid, <span class=\"literal\">NULL</span>, rout, &amp;arg)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建失败</span></span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;pthread_create : %s\\n&quot;</span>, <span class=\"built_in\">strerror</span>(ret));</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//主线程输出</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I&#x27;am main thread\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程id及进程地址空间布局\"><a href=\"#线程id及进程地址空间布局\" class=\"headerlink\" title=\"线程id及进程地址空间布局\"></a>线程id及进程地址空间布局</h2><ul>\n<li>hread_create函数会产生一个线程id，存放在第一个参数指向的地址中。该线程id和前面说的线程ID(本文用大小写区分)不是一回事。</li>\n<li><a href=\"#qianwen\">前文</a>的<code>线程ID</code>于进程调度的范畴。因为线程是轻量级进程，是操作系统调度器的最小单位，所以需要一个数值来唯一表示该线程。</li>\n<li>hread_create函数第一个参数指向一个虚拟内存单元，该内存单元的地址即为新创建线程的线程ID,属于NPTL线程库的范畴。线程库的后续操作，就是根据该线程ID来操作线程的。</li>\n<li>程库NPTL提供了pthread_self函数，可以获得线程自身的ID:</li>\n</ul>\n<p><code>pthread_t</code> 到底是什么类型呢？取决于实现。对于Linux目前实现的NPTL实现而言，pthread_t类型的线程ID，本质就是一个进程地址空间上的一个地址。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409091528968.png\"></p>\n<h2 id=\"线程终止\"><a href=\"#线程终止\" class=\"headerlink\" title=\"线程终止\"></a>线程终止</h2><p>如果需要只终止某个线程而不终止整个进程,可以有三种方法:</p>\n<ul>\n<li>从线程函数<code>return</code>。这种方法对主线程<strong>不适用</strong>,从main函数return相当于调用exit。</li>\n<li>线程可以调用<code>pthread_exit</code>终止自己。</li>\n<li>一个线程可以调用<code>pthread_cancel</code>终止同一进程中的另一个线程。</li>\n</ul>\n<h3 id=\"pthread-exit函数\"><a href=\"#pthread-exit函数\" class=\"headerlink\" title=\"pthread_exit函数\"></a>pthread_exit函数</h3><p><code>void pthread_exit(void *retval);</code></p>\n<p><code>retval</code>为输出型参数，而函数调用后，该线程退出，栈帧销毁，所以,需要注意,pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的,不能在线程函数的栈上分配,因为当其它线程得到这个返回指针时线程函数已经退出了。</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/07c3084a53912063e65735a81fa2ceaf.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"什么是线程\"><a href=\"#什么是线程\" class=\"headerlink\" title=\"什么是线程\"></a>什么是线程</h1><p>在一个程序（进程）里的一条执行流就叫做<code>线程</code>(thread),也就是说有多线程功能的进程内，可以有多个线程同时执行</p>\n<p>所以我们可以认为:</p>\n<ul>\n<li>一个进程至少有一个执行进程</li>\n<li>线程在进程内部运行，本质是在进程提供的地址空间内运行</li>\n</ul>\n<p>而对于<code>Linux</code>实现的线程，本质上是轻量化的进程，还是用的<code>task_struct</code>去维护的每一个<strong>线程</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread.png\" alt=\"Linux进程结构\"></p>\n<p><strong>关于线程间内存共享</strong><br>如上图所示，线程之间只有<code>栈区</code>是相互<strong>独立</strong>的， 像是<code>全局变量</code>，<code>堆区数据</code>都是共享的</p>\n<h2 id=\"线程的优点\"><a href=\"#线程的优点\" class=\"headerlink\" title=\"线程的优点\"></a>线程的优点</h2><ul>\n<li>创建一个新线程的<code>代价</code>要比创建一个新进程小得多</li>\n<li>与进程之间的<code>切换</code>相比，线程之间的切换需要操作系统做的<code>工作</code>要少很多</li>\n<li>线程占用的<code>资源</code>要比进程少很多</li>\n<li>能充分利用多处理器的可<code>并行</code>数量</li>\n<li>在等待慢速<code>I/O</code>操作结束的同时，程序可执行其他的计算任务</li>\n<li>计算密集型应用，为了能在多处理器系统上运行，将<code>计算分解</code>到多个线程中实现</li>\n<li><code>I/O密集型应用</code>，为了提高性能，将I&#x2F;O操作重叠。线程可以同时等待不同的I&#x2F;O操作。</li>\n</ul>\n<h2 id=\"线程的缺点\"><a href=\"#线程的缺点\" class=\"headerlink\" title=\"线程的缺点\"></a>线程的缺点</h2><h3 id=\"性能损失\"><a href=\"#性能损失\" class=\"headerlink\" title=\"性能损失\"></a>性能损失</h3><p><em>一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失</em>，这里的<code>性能损失</code>指的是增加了额外的<br><code>同步</code>和<code>调度</code>开销，而<strong>可用的资源不变。</strong></p>\n<h3 id=\"健壮性降低\"><a href=\"#健壮性降低\" class=\"headerlink\" title=\"健壮性降低\"></a>健壮性降低</h3><p>编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。</p>\n<h3 id=\"缺乏访问控制\"><a href=\"#缺乏访问控制\" class=\"headerlink\" title=\"缺乏访问控制\"></a>缺乏访问控制</h3><p><code>进程</code>是访问控制的<code>基本粒度</code>，在一个线程中调用某些OS函数会对整个进程造成影响。</p>\n<h3 id=\"编程难度提高\"><a href=\"#编程难度提高\" class=\"headerlink\" title=\"编程难度提高\"></a>编程难度提高</h3><p>编写与调试一个多线程程序比单线程程序困难得多</p>\n<h2 id=\"线程异常\"><a href=\"#线程异常\" class=\"headerlink\" title=\"线程异常\"></a>线程异常</h2><p>所有线程好比铁索连环，如果单个线程出现诸如 <code>除零</code>，<code>野指针</code>等异常问题导致线程崩溃,整个<code>进程</code>，包括所有线程，都会崩溃退出</p>\n<h2 id=\"线程的用途\"><a href=\"#线程的用途\" class=\"headerlink\" title=\"线程的用途\"></a>线程的用途</h2><ul>\n<li>合理的使用多线程，能提高CPU密集型程序的执行效率</li>\n<li>合理的使用多线程，能提高IO密集型程序的用户体验</li>\n</ul>\n<h1 id=\"线程与进程辨析\"><a href=\"#线程与进程辨析\" class=\"headerlink\" title=\"线程与进程辨析\"></a>线程与进程辨析</h1><h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>资源分配的基本单位,即每个进程都会分配一套独立的进程地址空间&#x2F;虚拟地址，并且供内部的所有线程共享</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是调度的基本单位，线程共享进程数据，但也拥有自己的一部分数据<span id = \"qianwen\"></span></p>\n<ul>\n<li><code>线程ID</code></li>\n<li>一组寄存器</li>\n<li>栈</li>\n<li>errno</li>\n<li>信号屏蔽字</li>\n<li>调度优先级</li>\n</ul>\n<p>进程的多个<code>线程共享</code> 同一地址空间,因此<code>Text Segment</code>、<code>Data Segment</code>都是共享的,如果定义一个函数,在各线程<br>中都可以调用,如果定义一个全局变量,在各线程中都可以访问到,除此之外,各线程还共享以下进程资源和环境</p>\n<ul>\n<li>文教描述符表</li>\n<li>每种信号的处理方式(SIG_IGN、SIG_DFL或自定义的信号处理函数)</li>\n<li>当前工作目录</li>\n<li>用户id和组id</li>\n</ul>\n<h1 id=\"Linux线程控制\"><a href=\"#Linux线程控制\" class=\"headerlink\" title=\"Linux线程控制\"></a>Linux线程控制</h1><p>这里介绍POSIX线程库，这是一个第三方线程库，且是个动态库,有以下特点</p>\n<ul>\n<li>与线程有关的函数构成了个完整的系列，绝大多数函数的名字都是以<code>pthread_</code>打头的</li>\n<li>要使用这些函数库，要通过引入头文<code>&lt;pthread.h&gt;</code></li>\n<li>链接这些线程函数库时要使用<strong>编译器</strong>命令的<code>-lpthread</code>选项  <em>很容易忘</em></li>\n</ul>\n<h2 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pthread_create</span><span class=\"params\">(<span class=\"type\">pthread_t</span> *thread, <span class=\"type\">const</span> <span class=\"type\">pthread_attr_t</span> *attr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"type\">void</span> *(*start_routine) (<span class=\"type\">void</span> *), <span class=\"type\">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>使用<code>pthread_create</code>函数创建新线程</p>\n<ul>\n<li>参数<ul>\n<li>thread:输出型参数，返回新线程的<code>线程id</code></li>\n<li>attr:设置线程属性，为<code>nullptr</code>时使用默认属性，一般为<code>nullptr</code></li>\n<li>start_routine:函数地址，即新线程<strong>启动时调用</strong>的函数</li>\n<li>arg:传给<code>start_routine</code>指向函数的参数</li>\n</ul>\n</li>\n<li>返回值:成功返回<code>0</code>，失败返回错误码</li>\n</ul>\n<p>关于错误码</p>\n<blockquote>\n<ul>\n<li>统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。</li>\n<li>threads函数出错时不会设置全局变量errno（而大部分其他POSIX函数会这样做）。而是将错误代码通过返回值返回</li>\n<li>hreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误,建议通过返回值业判定，因为读取返回值要比读取线程内的errno变量的开销更小</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>使用示例</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">rout</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I&#x27;am thread 1,got arg:%d\\n&quot;</span>,*(<span class=\"type\">int</span>*)arg);</span><br><span class=\"line\">        <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> tid;<span class=\"comment\">//储存tid的变量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\">    <span class=\"type\">int</span> arg = <span class=\"number\">114514</span>;<span class=\"comment\">//准备参数</span></span><br><span class=\"line\">    <span class=\"comment\">//创建新线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((ret = <span class=\"built_in\">pthread_create</span>(&amp;tid, <span class=\"literal\">NULL</span>, rout, &amp;arg)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建失败</span></span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(stderr, <span class=\"string\">&quot;pthread_create : %s\\n&quot;</span>, <span class=\"built_in\">strerror</span>(ret));</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//主线程输出</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I&#x27;am main thread\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程id及进程地址空间布局\"><a href=\"#线程id及进程地址空间布局\" class=\"headerlink\" title=\"线程id及进程地址空间布局\"></a>线程id及进程地址空间布局</h2><ul>\n<li>hread_create函数会产生一个线程id，存放在第一个参数指向的地址中。该线程id和前面说的线程ID(本文用大小写区分)不是一回事。</li>\n<li><a href=\"#qianwen\">前文</a>的<code>线程ID</code>于进程调度的范畴。因为线程是轻量级进程，是操作系统调度器的最小单位，所以需要一个数值来唯一表示该线程。</li>\n<li>hread_create函数第一个参数指向一个虚拟内存单元，该内存单元的地址即为新创建线程的线程ID,属于NPTL线程库的范畴。线程库的后续操作，就是根据该线程ID来操作线程的。</li>\n<li>程库NPTL提供了pthread_self函数，可以获得线程自身的ID:</li>\n</ul>\n<p><code>pthread_t</code> 到底是什么类型呢？取决于实现。对于Linux目前实现的NPTL实现而言，pthread_t类型的线程ID，本质就是一个进程地址空间上的一个地址。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409091528968.png\"></p>\n<h2 id=\"线程终止\"><a href=\"#线程终止\" class=\"headerlink\" title=\"线程终止\"></a>线程终止</h2><p>如果需要只终止某个线程而不终止整个进程,可以有三种方法:</p>\n<ul>\n<li>从线程函数<code>return</code>。这种方法对主线程<strong>不适用</strong>,从main函数return相当于调用exit。</li>\n<li>线程可以调用<code>pthread_exit</code>终止自己。</li>\n<li>一个线程可以调用<code>pthread_cancel</code>终止同一进程中的另一个线程。</li>\n</ul>\n<h3 id=\"pthread-exit函数\"><a href=\"#pthread-exit函数\" class=\"headerlink\" title=\"pthread_exit函数\"></a>pthread_exit函数</h3><p><code>void pthread_exit(void *retval);</code></p>\n<p><code>retval</code>为输出型参数，而函数调用后，该线程退出，栈帧销毁，所以,需要注意,pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的,不能在线程函数的栈上分配,因为当其它线程得到这个返回指针时线程函数已经退出了。</p>\n"},{"title":"如何在VS里使用scanf","date":"2023-10-05T14:37:32.000Z","_content":"# VS里怎么连scanf都用不了？ #\n不少刚接触[Visual Studio](https://visualstudio.microsoft.com/zh-hans/free-developer-offers/)的可能发现使用scanf会报错(如下)\n\n![报错图片](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/VS_scanf.jpg)\n\nvs告诉你说`scanf`不安全，然后你会发现vs给你提供了`scanf_s`去代替`scanf`,**但是**,只有vs能编译`scanf_s`,**可移植性**太差了，所以我们要用回`scanf`,所以要怎么不让它报错呢？**可以在源文件开头添加一行宏定义(如下)**\n\n`#define  _CRT_SECURE_NO_WARNINGS 1`\n\n这样就能**关闭报错**了,但请先**别急着走**,每次都要复制粘贴一句宏定义太麻烦了，想**一劳永逸**的请往下看。\n\n# 修改newc++file.cpp来自动添加宏定义 #\n**先来看怎么做：**首先搜索找到电脑中叫做`newc++file.cpp`的文件。（这里推荐使用[everything](https://www.voidtools.com/zh-cn/downloads/)）\n\n---\n\n*后半段路径应与图片一致，注意不是快捷方式*\n\n![c++文件的位置](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/newcppfile.jpg)\n\n---\n\n**注意**：由于权限原因，**无法**直接修改此文件\n\n所以先将这个文件复制粘贴到别处，例如桌面，下文用`副本`代称。\n\n用记事本类软件(记事本就行)打开`副本`,在第一行输入上文提到的宏定义代码`#define  _CRT_SECURE_NO_WARNINGS 1`,然后`ctrl+s`保存。\n\n**关闭编辑窗口**，将该`副本`移动到原始文件所在文件夹，弹出如下窗口，然后选择**替换文件**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-18.jpg)\n\n接着弹出下一个提示，点**接续**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-33.jpg)\n\n等待它替换完成，然后**大功告成！**。之后新建的每一个`.c`或`.cpp` 文件都会自带那段宏定义，于是`scanf`从此任君使用。~~当然平时删代码的时候记得别把那段宏定义删了~~\n\n## 原理 #\nVS所新建的`.c`和`.cpp`文件都源自于对上文`newc++file.cpp`文件的拷贝，通过修改它就能改变`VS新建文件`的初始内容","source":"_posts/useScanf.md","raw":"---\ntitle: 如何在VS里使用scanf\ndate: 2023-10-05 22:37:32\ntags: C语言\n---\n# VS里怎么连scanf都用不了？ #\n不少刚接触[Visual Studio](https://visualstudio.microsoft.com/zh-hans/free-developer-offers/)的可能发现使用scanf会报错(如下)\n\n![报错图片](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/VS_scanf.jpg)\n\nvs告诉你说`scanf`不安全，然后你会发现vs给你提供了`scanf_s`去代替`scanf`,**但是**,只有vs能编译`scanf_s`,**可移植性**太差了，所以我们要用回`scanf`,所以要怎么不让它报错呢？**可以在源文件开头添加一行宏定义(如下)**\n\n`#define  _CRT_SECURE_NO_WARNINGS 1`\n\n这样就能**关闭报错**了,但请先**别急着走**,每次都要复制粘贴一句宏定义太麻烦了，想**一劳永逸**的请往下看。\n\n# 修改newc++file.cpp来自动添加宏定义 #\n**先来看怎么做：**首先搜索找到电脑中叫做`newc++file.cpp`的文件。（这里推荐使用[everything](https://www.voidtools.com/zh-cn/downloads/)）\n\n---\n\n*后半段路径应与图片一致，注意不是快捷方式*\n\n![c++文件的位置](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/newcppfile.jpg)\n\n---\n\n**注意**：由于权限原因，**无法**直接修改此文件\n\n所以先将这个文件复制粘贴到别处，例如桌面，下文用`副本`代称。\n\n用记事本类软件(记事本就行)打开`副本`,在第一行输入上文提到的宏定义代码`#define  _CRT_SECURE_NO_WARNINGS 1`,然后`ctrl+s`保存。\n\n**关闭编辑窗口**，将该`副本`移动到原始文件所在文件夹，弹出如下窗口，然后选择**替换文件**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-18.jpg)\n\n接着弹出下一个提示，点**接续**\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-33.jpg)\n\n等待它替换完成，然后**大功告成！**。之后新建的每一个`.c`或`.cpp` 文件都会自带那段宏定义，于是`scanf`从此任君使用。~~当然平时删代码的时候记得别把那段宏定义删了~~\n\n## 原理 #\nVS所新建的`.c`和`.cpp`文件都源自于对上文`newc++file.cpp`文件的拷贝，通过修改它就能改变`VS新建文件`的初始内容","slug":"useScanf","published":1,"updated":"2024-05-14T02:21:45.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08p001v4sp50atagrwg","content":"<h1 id=\"VS里怎么连scanf都用不了？\"><a href=\"#VS里怎么连scanf都用不了？\" class=\"headerlink\" title=\"VS里怎么连scanf都用不了？\"></a>VS里怎么连scanf都用不了？</h1><p>不少刚接触<a href=\"https://visualstudio.microsoft.com/zh-hans/free-developer-offers/\">Visual Studio</a>的可能发现使用scanf会报错(如下)</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/VS_scanf.jpg\" alt=\"报错图片\"></p>\n<p>vs告诉你说<code>scanf</code>不安全，然后你会发现vs给你提供了<code>scanf_s</code>去代替<code>scanf</code>,<strong>但是</strong>,只有vs能编译<code>scanf_s</code>,<strong>可移植性</strong>太差了，所以我们要用回<code>scanf</code>,所以要怎么不让它报错呢？<strong>可以在源文件开头添加一行宏定义(如下)</strong></p>\n<p><code>#define  _CRT_SECURE_NO_WARNINGS 1</code></p>\n<p>这样就能<strong>关闭报错</strong>了,但请先<strong>别急着走</strong>,每次都要复制粘贴一句宏定义太麻烦了，想<strong>一劳永逸</strong>的请往下看。</p>\n<h1 id=\"修改newc-file-cpp来自动添加宏定义\"><a href=\"#修改newc-file-cpp来自动添加宏定义\" class=\"headerlink\" title=\"修改newc++file.cpp来自动添加宏定义\"></a>修改newc++file.cpp来自动添加宏定义</h1><p><strong>先来看怎么做：</strong>首先搜索找到电脑中叫做<code>newc++file.cpp</code>的文件。（这里推荐使用<a href=\"https://www.voidtools.com/zh-cn/downloads/\">everything</a>）</p>\n<hr>\n<p><em>后半段路径应与图片一致，注意不是快捷方式</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/newcppfile.jpg\" alt=\"c++文件的位置\"></p>\n<hr>\n<p><strong>注意</strong>：由于权限原因，<strong>无法</strong>直接修改此文件</p>\n<p>所以先将这个文件复制粘贴到别处，例如桌面，下文用<code>副本</code>代称。</p>\n<p>用记事本类软件(记事本就行)打开<code>副本</code>,在第一行输入上文提到的宏定义代码<code>#define  _CRT_SECURE_NO_WARNINGS 1</code>,然后<code>ctrl+s</code>保存。</p>\n<p><strong>关闭编辑窗口</strong>，将该<code>副本</code>移动到原始文件所在文件夹，弹出如下窗口，然后选择<strong>替换文件</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-18.jpg\"></p>\n<p>接着弹出下一个提示，点<strong>接续</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-33.jpg\"></p>\n<p>等待它替换完成，然后<strong>大功告成！</strong>。之后新建的每一个<code>.c</code>或<code>.cpp</code> 文件都会自带那段宏定义，于是<code>scanf</code>从此任君使用。<del>当然平时删代码的时候记得别把那段宏定义删了</del></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>VS所新建的<code>.c</code>和<code>.cpp</code>文件都源自于对上文<code>newc++file.cpp</code>文件的拷贝，通过修改它就能改变<code>VS新建文件</code>的初始内容</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/7be4e5cabc1892f13a8ce4d55cbd787c.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"VS里怎么连scanf都用不了？\"><a href=\"#VS里怎么连scanf都用不了？\" class=\"headerlink\" title=\"VS里怎么连scanf都用不了？\"></a>VS里怎么连scanf都用不了？</h1><p>不少刚接触<a href=\"https://visualstudio.microsoft.com/zh-hans/free-developer-offers/\">Visual Studio</a>的可能发现使用scanf会报错(如下)</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/VS_scanf.jpg\" alt=\"报错图片\"></p>\n<p>vs告诉你说<code>scanf</code>不安全，然后你会发现vs给你提供了<code>scanf_s</code>去代替<code>scanf</code>,<strong>但是</strong>,只有vs能编译<code>scanf_s</code>,<strong>可移植性</strong>太差了，所以我们要用回<code>scanf</code>,所以要怎么不让它报错呢？<strong>可以在源文件开头添加一行宏定义(如下)</strong></p>\n<p><code>#define  _CRT_SECURE_NO_WARNINGS 1</code></p>\n<p>这样就能<strong>关闭报错</strong>了,但请先<strong>别急着走</strong>,每次都要复制粘贴一句宏定义太麻烦了，想<strong>一劳永逸</strong>的请往下看。</p>\n<h1 id=\"修改newc-file-cpp来自动添加宏定义\"><a href=\"#修改newc-file-cpp来自动添加宏定义\" class=\"headerlink\" title=\"修改newc++file.cpp来自动添加宏定义\"></a>修改newc++file.cpp来自动添加宏定义</h1><p><strong>先来看怎么做：</strong>首先搜索找到电脑中叫做<code>newc++file.cpp</code>的文件。（这里推荐使用<a href=\"https://www.voidtools.com/zh-cn/downloads/\">everything</a>）</p>\n<hr>\n<p><em>后半段路径应与图片一致，注意不是快捷方式</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/newcppfile.jpg\" alt=\"c++文件的位置\"></p>\n<hr>\n<p><strong>注意</strong>：由于权限原因，<strong>无法</strong>直接修改此文件</p>\n<p>所以先将这个文件复制粘贴到别处，例如桌面，下文用<code>副本</code>代称。</p>\n<p>用记事本类软件(记事本就行)打开<code>副本</code>,在第一行输入上文提到的宏定义代码<code>#define  _CRT_SECURE_NO_WARNINGS 1</code>,然后<code>ctrl+s</code>保存。</p>\n<p><strong>关闭编辑窗口</strong>，将该<code>副本</code>移动到原始文件所在文件夹，弹出如下窗口，然后选择<strong>替换文件</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-18.jpg\"></p>\n<p>接着弹出下一个提示，点<strong>接续</strong></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-10-08_12-28-33.jpg\"></p>\n<p>等待它替换完成，然后<strong>大功告成！</strong>。之后新建的每一个<code>.c</code>或<code>.cpp</code> 文件都会自带那段宏定义，于是<code>scanf</code>从此任君使用。<del>当然平时删代码的时候记得别把那段宏定义删了</del></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>VS所新建的<code>.c</code>和<code>.cpp</code>文件都源自于对上文<code>newc++file.cpp</code>文件的拷贝，通过修改它就能改变<code>VS新建文件</code>的初始内容</p>\n"},{"title":"C/C++ static关键字的使用","date":"2024-06-30T10:21:50.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/static.png","_content":"\n因为`static`的用法又多又杂，值得单出一篇博客用以汇总\n\n# C/C++ 通用用法\n\n## 局部变量->全局属性\n当对原本声明在函数栈帧里的`变量`使用`static`修饰时,该`变量`的存储空间会改变到`静态区`，不会随着函数栈帧的销毁而销毁。\n\n初始化：初次调用声明语句时会执行声明操作，而之后再执行到该语句处时会自动跳过。\n\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_10-51-24.png)\n\n作用范围：与不加`static`时的作用范围相同，还是局部可用\n\n销毁：和全局变量一样在`main`函数的栈帧销毁时一并销毁\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-09-04.png)\n\n## 全局变量->限制访问\n原本同级文件夹下的源文件可以用`extern`关键字互相获取全局变量,但如果用`static`修饰本地全局变量，那么这个全局变量只能在本文件调用，而其它文件看不到它\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-56-27.png)\n\n## 全局函数->限制访问\n原本同级文件夹下的源文件可以用`extern`关键字声明函数，然后去其它源文件的全局函数中寻找`实现方式`,但如果用`static`修饰本地全局函数，那么这个全局函数的实现只能在本文件调用，而其它文件看不到它\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_12-02-16.png)\n\n# C++类和对象\n\n## 成员变量->静态成员 (全局变量)\n原本声明的成员变量在实例化后，属于由`类`实例化出来的`对象`，生命周期与所属对象相同，但在加了`static`后，该变量属于该类域中的全局变量，不再属于某个**具体**的`对象`\n\n**初始化**: 因为已经不属于某一个对象，初始化也不能在类的接口中完成了，因此在类中声明`static`成员变量后，**必须**在全局区初始化`类域`中的成员变量。  #*在main函数等非全局域中无法初始化*\n\n常见应用：引用计数\n\n```C++\nclass A\n{\npublic:\n\tA()\n\t{\n\t\tcnt++;\n\t}\n\nprivate:\n\tstatic int cnt;\n};\n\nint A::cnt = 0;\n```\n\n## 成员函数->静态成员函数 (不含this指针)\n一般声明在类中的成员函数的参数列表隐藏`this`指针，要调用函数时得用类实例化出的`对象`来调用，由这个对象提供`this`指针\n\n而使用`static`修饰后的静态成员函数不含`this`指针，该函数属于整个类域，调用时使用类域调用\n\n```C++\nclass A\n{\npublic:\n\tA()\n\t{\n\t\tcnt++;\n\t}\n\nstatic int getCNT()\n{\n    return cnt;\n}\n\nprivate:\n\tstatic int cnt;\n};\n\nint A::cnt = 0;\n\nint main()\n{\n    A a,b,c;\n    cout<<A::getCNT();//此时输出3\n    return 0;\n}\n``` ","source":"_posts/usestatic.md","raw":"---\ntitle: C/C++ static关键字的使用\ndate: 2024-06-30 18:21:50\ntags:\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/static.png\n---\n\n因为`static`的用法又多又杂，值得单出一篇博客用以汇总\n\n# C/C++ 通用用法\n\n## 局部变量->全局属性\n当对原本声明在函数栈帧里的`变量`使用`static`修饰时,该`变量`的存储空间会改变到`静态区`，不会随着函数栈帧的销毁而销毁。\n\n初始化：初次调用声明语句时会执行声明操作，而之后再执行到该语句处时会自动跳过。\n\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_10-51-24.png)\n\n作用范围：与不加`static`时的作用范围相同，还是局部可用\n\n销毁：和全局变量一样在`main`函数的栈帧销毁时一并销毁\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-09-04.png)\n\n## 全局变量->限制访问\n原本同级文件夹下的源文件可以用`extern`关键字互相获取全局变量,但如果用`static`修饰本地全局变量，那么这个全局变量只能在本文件调用，而其它文件看不到它\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-56-27.png)\n\n## 全局函数->限制访问\n原本同级文件夹下的源文件可以用`extern`关键字声明函数，然后去其它源文件的全局函数中寻找`实现方式`,但如果用`static`修饰本地全局函数，那么这个全局函数的实现只能在本文件调用，而其它文件看不到它\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_12-02-16.png)\n\n# C++类和对象\n\n## 成员变量->静态成员 (全局变量)\n原本声明的成员变量在实例化后，属于由`类`实例化出来的`对象`，生命周期与所属对象相同，但在加了`static`后，该变量属于该类域中的全局变量，不再属于某个**具体**的`对象`\n\n**初始化**: 因为已经不属于某一个对象，初始化也不能在类的接口中完成了，因此在类中声明`static`成员变量后，**必须**在全局区初始化`类域`中的成员变量。  #*在main函数等非全局域中无法初始化*\n\n常见应用：引用计数\n\n```C++\nclass A\n{\npublic:\n\tA()\n\t{\n\t\tcnt++;\n\t}\n\nprivate:\n\tstatic int cnt;\n};\n\nint A::cnt = 0;\n```\n\n## 成员函数->静态成员函数 (不含this指针)\n一般声明在类中的成员函数的参数列表隐藏`this`指针，要调用函数时得用类实例化出的`对象`来调用，由这个对象提供`this`指针\n\n而使用`static`修饰后的静态成员函数不含`this`指针，该函数属于整个类域，调用时使用类域调用\n\n```C++\nclass A\n{\npublic:\n\tA()\n\t{\n\t\tcnt++;\n\t}\n\nstatic int getCNT()\n{\n    return cnt;\n}\n\nprivate:\n\tstatic int cnt;\n};\n\nint A::cnt = 0;\n\nint main()\n{\n    A a,b,c;\n    cout<<A::getCNT();//此时输出3\n    return 0;\n}\n``` ","slug":"usestatic","published":1,"updated":"2024-07-03T08:01:05.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08p001x4sp50ud1bwh1","content":"<p>因为<code>static</code>的用法又多又杂，值得单出一篇博客用以汇总</p>\n<h1 id=\"C-C-通用用法\"><a href=\"#C-C-通用用法\" class=\"headerlink\" title=\"C&#x2F;C++ 通用用法\"></a>C&#x2F;C++ 通用用法</h1><h2 id=\"局部变量-全局属性\"><a href=\"#局部变量-全局属性\" class=\"headerlink\" title=\"局部变量-&gt;全局属性\"></a>局部变量-&gt;全局属性</h2><p>当对原本声明在函数栈帧里的<code>变量</code>使用<code>static</code>修饰时,该<code>变量</code>的存储空间会改变到<code>静态区</code>，不会随着函数栈帧的销毁而销毁。</p>\n<p>初始化：初次调用声明语句时会执行声明操作，而之后再执行到该语句处时会自动跳过。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_10-51-24.png\"></p>\n<p>作用范围：与不加<code>static</code>时的作用范围相同，还是局部可用</p>\n<p>销毁：和全局变量一样在<code>main</code>函数的栈帧销毁时一并销毁</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-09-04.png\"></p>\n<h2 id=\"全局变量-限制访问\"><a href=\"#全局变量-限制访问\" class=\"headerlink\" title=\"全局变量-&gt;限制访问\"></a>全局变量-&gt;限制访问</h2><p>原本同级文件夹下的源文件可以用<code>extern</code>关键字互相获取全局变量,但如果用<code>static</code>修饰本地全局变量，那么这个全局变量只能在本文件调用，而其它文件看不到它</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-56-27.png\"></p>\n<h2 id=\"全局函数-限制访问\"><a href=\"#全局函数-限制访问\" class=\"headerlink\" title=\"全局函数-&gt;限制访问\"></a>全局函数-&gt;限制访问</h2><p>原本同级文件夹下的源文件可以用<code>extern</code>关键字声明函数，然后去其它源文件的全局函数中寻找<code>实现方式</code>,但如果用<code>static</code>修饰本地全局函数，那么这个全局函数的实现只能在本文件调用，而其它文件看不到它</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_12-02-16.png\"></p>\n<h1 id=\"C-类和对象\"><a href=\"#C-类和对象\" class=\"headerlink\" title=\"C++类和对象\"></a>C++类和对象</h1><h2 id=\"成员变量-静态成员-全局变量\"><a href=\"#成员变量-静态成员-全局变量\" class=\"headerlink\" title=\"成员变量-&gt;静态成员 (全局变量)\"></a>成员变量-&gt;静态成员 (全局变量)</h2><p>原本声明的成员变量在实例化后，属于由<code>类</code>实例化出来的<code>对象</code>，生命周期与所属对象相同，但在加了<code>static</code>后，该变量属于该类域中的全局变量，不再属于某个<strong>具体</strong>的<code>对象</code></p>\n<p><strong>初始化</strong>: 因为已经不属于某一个对象，初始化也不能在类的接口中完成了，因此在类中声明<code>static</code>成员变量后，<strong>必须</strong>在全局区初始化<code>类域</code>中的成员变量。  #<em>在main函数等非全局域中无法初始化</em></p>\n<p>常见应用：引用计数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">A</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> cnt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> A::cnt = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"成员函数-静态成员函数-不含this指针\"><a href=\"#成员函数-静态成员函数-不含this指针\" class=\"headerlink\" title=\"成员函数-&gt;静态成员函数 (不含this指针)\"></a>成员函数-&gt;静态成员函数 (不含this指针)</h2><p>一般声明在类中的成员函数的参数列表隐藏<code>this</code>指针，要调用函数时得用类实例化出的<code>对象</code>来调用，由这个对象提供<code>this</code>指针</p>\n<p>而使用<code>static</code>修饰后的静态成员函数不含<code>this</code>指针，该函数属于整个类域，调用时使用类域调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">A</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">getCNT</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> cnt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> A::cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a,b,c;</span><br><span class=\"line\">    cout&lt;&lt;A::<span class=\"built_in\">getCNT</span>();<span class=\"comment\">//此时输出3</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<p>因为<code>static</code>的用法又多又杂，值得单出一篇博客用以汇总</p>\n<h1 id=\"C-C-通用用法\"><a href=\"#C-C-通用用法\" class=\"headerlink\" title=\"C&#x2F;C++ 通用用法\"></a>C&#x2F;C++ 通用用法</h1><h2 id=\"局部变量-全局属性\"><a href=\"#局部变量-全局属性\" class=\"headerlink\" title=\"局部变量-&gt;全局属性\"></a>局部变量-&gt;全局属性</h2><p>当对原本声明在函数栈帧里的<code>变量</code>使用<code>static</code>修饰时,该<code>变量</code>的存储空间会改变到<code>静态区</code>，不会随着函数栈帧的销毁而销毁。</p>\n<p>初始化：初次调用声明语句时会执行声明操作，而之后再执行到该语句处时会自动跳过。</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_10-51-24.png\"></p>\n<p>作用范围：与不加<code>static</code>时的作用范围相同，还是局部可用</p>\n<p>销毁：和全局变量一样在<code>main</code>函数的栈帧销毁时一并销毁</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-09-04.png\"></p>\n<h2 id=\"全局变量-限制访问\"><a href=\"#全局变量-限制访问\" class=\"headerlink\" title=\"全局变量-&gt;限制访问\"></a>全局变量-&gt;限制访问</h2><p>原本同级文件夹下的源文件可以用<code>extern</code>关键字互相获取全局变量,但如果用<code>static</code>修饰本地全局变量，那么这个全局变量只能在本文件调用，而其它文件看不到它</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_11-56-27.png\"></p>\n<h2 id=\"全局函数-限制访问\"><a href=\"#全局函数-限制访问\" class=\"headerlink\" title=\"全局函数-&gt;限制访问\"></a>全局函数-&gt;限制访问</h2><p>原本同级文件夹下的源文件可以用<code>extern</code>关键字声明函数，然后去其它源文件的全局函数中寻找<code>实现方式</code>,但如果用<code>static</code>修饰本地全局函数，那么这个全局函数的实现只能在本文件调用，而其它文件看不到它</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2024-07-03_12-02-16.png\"></p>\n<h1 id=\"C-类和对象\"><a href=\"#C-类和对象\" class=\"headerlink\" title=\"C++类和对象\"></a>C++类和对象</h1><h2 id=\"成员变量-静态成员-全局变量\"><a href=\"#成员变量-静态成员-全局变量\" class=\"headerlink\" title=\"成员变量-&gt;静态成员 (全局变量)\"></a>成员变量-&gt;静态成员 (全局变量)</h2><p>原本声明的成员变量在实例化后，属于由<code>类</code>实例化出来的<code>对象</code>，生命周期与所属对象相同，但在加了<code>static</code>后，该变量属于该类域中的全局变量，不再属于某个<strong>具体</strong>的<code>对象</code></p>\n<p><strong>初始化</strong>: 因为已经不属于某一个对象，初始化也不能在类的接口中完成了，因此在类中声明<code>static</code>成员变量后，<strong>必须</strong>在全局区初始化<code>类域</code>中的成员变量。  #<em>在main函数等非全局域中无法初始化</em></p>\n<p>常见应用：引用计数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">A</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> cnt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> A::cnt = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"成员函数-静态成员函数-不含this指针\"><a href=\"#成员函数-静态成员函数-不含this指针\" class=\"headerlink\" title=\"成员函数-&gt;静态成员函数 (不含this指针)\"></a>成员函数-&gt;静态成员函数 (不含this指针)</h2><p>一般声明在类中的成员函数的参数列表隐藏<code>this</code>指针，要调用函数时得用类实例化出的<code>对象</code>来调用，由这个对象提供<code>this</code>指针</p>\n<p>而使用<code>static</code>修饰后的静态成员函数不含<code>this</code>指针，该函数属于整个类域，调用时使用类域调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">A</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">getCNT</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> cnt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> A::cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a,b,c;</span><br><span class=\"line\">    cout&lt;&lt;A::<span class=\"built_in\">getCNT</span>();<span class=\"comment\">//此时输出3</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"=C入门=深入研究 字符串与字符数组","date":"2023-11-08T13:11:51.000Z","_content":"# 什么是字符串 #\n## 初见字符串 #\n我们最先遇到的字符串,一般是`hello_world`程序中用到的`\"hello world\"`,也就是**两个双引号括起来的一串字符**,输出时的占位符是`%s`,可以直接拿去传值，代码如下\n```C\nprintf(\"%s\",\"hello world\");\n```\n## 声明字符串变量 #\n有时我们想要先把字符串存起来，再进行操作，那么就使用**字符数组**，并在**初始化**的时候把字符串传给它,这样在**创建数组**时会编译器会自动分配内存给它，代码如下\n\n```C\nchar str[] = \"abcdef\";\n```\n\n此时我们也可以开启VS的**调试**，并打开**内存**和**监视**窗口观察字符串是如何在内存中储存的,如下图\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_10-06-06.jpg)\n\n通过观察可以发现，C语⾔字符串的字符串有个`规定`(特点)，就是以字符`\\0`结尾，无论是初始化数组时，还是在分配内存时，都有`\\0`的位置。\n\n### strlen()函数 #\n依据以`\\0`为字符串结尾的规则，`strlen`函数就可以计算字符串的长度，它会从字符串的第一个字符向后扫描，直到遇到`\\0`结束,且`\\0`不进入计数，最后返回字符串的长度,代码如下\n```C\n#include <string.h> //需要引对应的头文件\n\nint len = strlen(\"abcdef\");//len的值为6\nint sz = sizeof(\"abcdef\");//sz的大小为7(\\0被计入总数)\n```\n\n### 验证字符串的结尾 #\n\n#### 正向验证 #\n我们做在字符数组里插入一个`\\0`,来看看函数`printf`和`strlen`找到的结尾在哪里,如下图\n\n```C\nchar str[] = {'a','b','c','\\0','d','e','f','\\0'};\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_11-01-35.jpg)\n\n可以看到字符数组似乎被“截断”了，`printf`只输出了`\\0`前面的内容, `strlen`算出来的长度也只有`3`,可见插入的`\\0`被作为了**字符串**的结尾，字符串提前中指,而没到达**字符数组**的结尾\n\n\n\n#### 反向验证 #\n\n我们来**反向**验证一下，`\\0`是字符串结尾的标志,如下图，我们声明一个**没有**`\\0`结尾的字符数组，看看函数`printf`和`strlen`还找不找得到我们“认为”的结尾\n```C\nchar str[] = {'a','b','c','d','e','f'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-02-07.jpg)\n\n可以看到函数对字符串的判断出现了严重**失误**，所以**字符数组**里没有`\\0`标记结尾是非常严重的问题，不光是找不到字符串的结尾，而且会**越界访问**！危险操作，写代码的时候一定要注意\n\n---\n\n## 从字符串到字符数组 #\n虽然上面已经用到了字符数组，但主要还是为了方便讨论**字符串**,接下来着重研究字符数组。\n\n### 先整清楚几个概念 #\n`什么是数组`：数组是⼀组相同类型元素的集合,会在内存中开辟一段连续的空间，将元素储存在那段内存中\n\n`什么是数组元素`：存放在数组的值被称为数组的元素，数组在创建的时候可以指定数组的⼤⼩和数组的元素类型。\n\n所以`字符数组`是一组`字符`的集合，字符数组里的`元素`都是`字符`!,访问到的字符数组里的**元素**都是**字符**，像`'a'`,`'b'`,`'c'`这种的单个的字符,别和`字符串`混为一谈！\n\n```C\nchar str = \"abc\";\nint sz = sizeof(str);//这里str代表了整个数组,所以包括\\0\n,sz的值为4\n\n```\n\n### 字符数组的声明 #\n字符数组的声明和其他类型的数组差不多，有**初始化**，**不完全初始化**，**声明长度**，**不声明长度**\n\n*正确的声明代码如下*\n```C\nchar str1[] = \"abc\";//初始化,不声明长度\n\nchar str2[] = {'a','b','c','\\0'};//这也是初始化，且不声明长度\n\nchar str3[10] = { 0 };//初始化，用值0(等价于`\\0`)填充\n\nchar str4[10] = \"abc\";//不完全初始化，存入字符串\"abc\",后面都用'\\0'填充\n\nchar str5[10] = {'a','b','c','d'};//不完全初始化,从下标为0开始，依次往后填充字符 a,b,c,\\0\n\n```\n*错误的声明代码*\n```C\nchar str1[3] = \"abc\";//数组声明短了，放不下结尾的\\0,编译过不了\n\nchar str2[3] = {'a','b','c','d'};//同上,放不下\n\nchar str3[] = { 0 };//能声明，但是字符数组长度为1，这个数组大概率是用不了的/会被拿去错误使用的\n\n```\n### 来看看这些声明方式在内存中的表现 #\n\n#### 不初始化的声明(极度不推荐) #\n```C\nchar str[];//这个不加长度，直接编译失败（如下图）\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-39-10.jpg)\n\n```C\nchar str[10];//语法没有问题，来看看此时数组里存了什么\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-46-49.jpg)\n可以看到全都存了`-52`,对应的中文字符是`烫`，这样**不好**，请在声明字符数组的时候**初始化数组**\n#### 不声明长度的数组声明\n```C\nchar str1[] = \"abc\";\n\nchar str2[] = {'a','b','c','\\0'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-59-34.jpg)\n\n如上图，不声明长度时，编译器自动给字符数组分配内存，既不给多，也不给少，初始化给的`字符串`或者`{...}`多长，创建的数组就多长。\n\n**注意红框**，再强调一遍，字符串以`\\0`结尾,看到双引号括起来的字符串，要记得最后隐藏了一个`\\0`,用字符数组储存的时候一定要留足空间\n\n#### 声明长度的数组声明 #\n```C\nchar str3[10] = { 0 };\n\nchar str4[10] = \"abc\";\n\nchar str5[10] = {'a','b','c','d'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_15-25-54.jpg)\n\n可以看到，在声明的长度**足够长**时，你初始化的时候给它多少字符，它就从`下标0`处开始**按顺序**存进去多少,剩下的部分**自动**用`'\\0'`填充,\n\n所以实际上上面代码中的`str5`因为长度`10`>初始化给的`4`个字符，后面六个元素用`\\0`填充了，所以`str5`里存了有**结尾**的完整字符串\n\n#### 错误声明 #\n```C\nchar str1[3] = \"abc\";\nchar str2[3] = { 'a','b','c','d' };\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-44-57.jpg)\n\n可以看到上面两种错误的声明方式，甚至直接**编译失败**,所以声明字符数组的时候一定要**留足空间**\n\n```C\nchar str3[] = { 0 };\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-51-55.jpg)\n\n如上图，可以看到这样写还是编译成功了，但是在监视查看**数组长度**的时候，发现长度为`1`,里面存了一个`\\0`,这么**短**的数组能用吗？只能**用一点点**，甚至还不如直接声明一个`char`类型的字符变量\n\n## 当字符数组加上const #\n```C\nconst char str[5] = \"abc\";\n```\n### 一些性质 #\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_18-55-52.jpg)\n\n可以看到，声明时加了`const`之后，字符数组`str`在声明时的**初始化**之后便不可更改了，只能**访问**其元素,而**不能通过访问元素来改变数组内容**\n\n那么`scanf`还能写入内容吗？答案是**可以**!*(如下图)*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-10-43.jpg)\n\n那它能拿来初始化别的数组吗？很遗憾，**不能**\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-05-15.jpg)\n\n### 对应的指针类型 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-15-32.jpg)\n\n可以看到，这里得用`const char*`来储存字符数组的地址，而使用`char*`就会报错\n\n那么用`双引号括起来的字符串`，是否也有地址，能用指针储存它的地址呢？\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-21-10.jpg)\n\n如图，可以看到,字符串`\"abc\"`是属于`const char`类型的数组，对应的指针是`const char*`,不能通过访问元素来改变内部的值，也不能用`char*`来储存地址\n\n#### 在内存中的表现 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_str.gif)\n\n可以看到哪怕是字符串`\"abc\"`,也是在内存中开辟了一段空间，并把字符**储存在内存中**了的\n\n但是，**不要**试图用`scanf`去改变字符串的值\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_strrrr.gif)\n\n---\n\n## 如何向字符数组里添加内容 #\n添加的方法多种多样，搞不好可能还会出错，所以把字符数组**学明白**很重要！\n\n以下使用的数组样例声明如下\n```C\nchar str[10] = { 0 };\n```\n\n### 初始化 #\n在初始化的时候就把值传进去，有哪些初始化方式**上面**已经介绍过了，这里不多赘述\n\n### 访问数组元素 #\n通过`[]`可以访问数组元素，并对没有`const`修饰的数组，修改其元素,例如:\n\n```C\nstr[0] = 'A';//将数组的第一个元素改成字符A\n```\n\n我们也可以通过循环的方式，将数组的所有元素填充为某个字符\n\n```C\nchar place_holder = 'A';\nfor(int i = 0; i < 10 ; i++)//这里使用左闭右开区间，10为数组的大小\n{\n    str[i] = place_holder;\n}\n```\n\n### 使用`scanf`函数 #\n由上面的探究已知：对于已声明的字符数组，**无论**有没有`const`修饰，都可已用`scanf`修改内容,那么`scanf`怎么用，又具体怎么工作的，我们接着往下探究\n\n#### 使用示例 #\n```C\nchar str[10] = { 0 };\nscanf(\"%s\",str);//占位符是 %s ,右边的参数是 str ,也就是数组名\n//或者 scanf(\"%s\",&str)\n```\n**注意**！这边的数组名`str`储存的是**数组首元素的地址**，而`&str`储存的是`整个数组的地址`，值是一样的，两者皆可用于传参，但**指针类型不一样**，要做好区分\n\n#### `scanf`都做了什么 #\n先来看看它分别对用`{ 0 }`**初始化**和**不初始化**的数组做了什么\n```C\nchar str1[10] = { 0 };\nscanf(\"%s\",str1);\nchar str2[10];\nscanf(\"%s\",str2);\n```\n*两个数组的输入均为abc*\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-11_19-09-50.jpg)\n\n可以看到，对`str1`,字符非常正常地填充进去了，因为整个数组原本是用`\\0`填充的,看不出什么端倪\n\n而对于`str2`,观察发现，除了输入进去的字符`a`,`b`,`c`,它还自动在结尾补了一个`\\0`,使`str2`里储存了一个完整的字符串。**但是**，剩下的部分还是用**值**`-52`填充，即未初始化的状态，所以依然**不提倡**声明的时候没有初始化\n\n然后是在字符数组内已有内容的情况下，再次使用`scanf`的情况\n```C\nchar str1[5] = \"abc\";\nchar str2[5] = \"abc\";\n\nscanf(\"%s %s\",str1,str2);\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-33-02.jpg)\n\n如图，`scanf`做的是把输入的字符串`覆盖`式存入字符数组，比原来长，就完全覆盖，比原来短，就部分覆盖，未覆盖的部分无改动\n\n#### 关于`scanf`的危险操作 #\n由于`scanf`无法预测**字符数组**能否存下输入的**字符串**，如果**字符数组**声明的长度不够，就可能出现**越界访问**,随之而来的便是奇奇怪怪的`bug`\n\n```C\nchar str[4] = { 0 };//先声明一个长度为4的数组\nscanf(\"%s\",str);//这次输入abcdef试试\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-47-00.jpg)\n\n可以看到，确实**越界访问**了，所以声明字符数组的时候，建议比预计最大输入，在多些长度，防止越界访问。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/str-arr.md","raw":"---\ntitle: =C入门=深入研究 字符串与字符数组\ndate: 2023-11-08 21:11:51\ntags: C语言 字符串 数组\n---\n# 什么是字符串 #\n## 初见字符串 #\n我们最先遇到的字符串,一般是`hello_world`程序中用到的`\"hello world\"`,也就是**两个双引号括起来的一串字符**,输出时的占位符是`%s`,可以直接拿去传值，代码如下\n```C\nprintf(\"%s\",\"hello world\");\n```\n## 声明字符串变量 #\n有时我们想要先把字符串存起来，再进行操作，那么就使用**字符数组**，并在**初始化**的时候把字符串传给它,这样在**创建数组**时会编译器会自动分配内存给它，代码如下\n\n```C\nchar str[] = \"abcdef\";\n```\n\n此时我们也可以开启VS的**调试**，并打开**内存**和**监视**窗口观察字符串是如何在内存中储存的,如下图\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_10-06-06.jpg)\n\n通过观察可以发现，C语⾔字符串的字符串有个`规定`(特点)，就是以字符`\\0`结尾，无论是初始化数组时，还是在分配内存时，都有`\\0`的位置。\n\n### strlen()函数 #\n依据以`\\0`为字符串结尾的规则，`strlen`函数就可以计算字符串的长度，它会从字符串的第一个字符向后扫描，直到遇到`\\0`结束,且`\\0`不进入计数，最后返回字符串的长度,代码如下\n```C\n#include <string.h> //需要引对应的头文件\n\nint len = strlen(\"abcdef\");//len的值为6\nint sz = sizeof(\"abcdef\");//sz的大小为7(\\0被计入总数)\n```\n\n### 验证字符串的结尾 #\n\n#### 正向验证 #\n我们做在字符数组里插入一个`\\0`,来看看函数`printf`和`strlen`找到的结尾在哪里,如下图\n\n```C\nchar str[] = {'a','b','c','\\0','d','e','f','\\0'};\n```\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_11-01-35.jpg)\n\n可以看到字符数组似乎被“截断”了，`printf`只输出了`\\0`前面的内容, `strlen`算出来的长度也只有`3`,可见插入的`\\0`被作为了**字符串**的结尾，字符串提前中指,而没到达**字符数组**的结尾\n\n\n\n#### 反向验证 #\n\n我们来**反向**验证一下，`\\0`是字符串结尾的标志,如下图，我们声明一个**没有**`\\0`结尾的字符数组，看看函数`printf`和`strlen`还找不找得到我们“认为”的结尾\n```C\nchar str[] = {'a','b','c','d','e','f'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-02-07.jpg)\n\n可以看到函数对字符串的判断出现了严重**失误**，所以**字符数组**里没有`\\0`标记结尾是非常严重的问题，不光是找不到字符串的结尾，而且会**越界访问**！危险操作，写代码的时候一定要注意\n\n---\n\n## 从字符串到字符数组 #\n虽然上面已经用到了字符数组，但主要还是为了方便讨论**字符串**,接下来着重研究字符数组。\n\n### 先整清楚几个概念 #\n`什么是数组`：数组是⼀组相同类型元素的集合,会在内存中开辟一段连续的空间，将元素储存在那段内存中\n\n`什么是数组元素`：存放在数组的值被称为数组的元素，数组在创建的时候可以指定数组的⼤⼩和数组的元素类型。\n\n所以`字符数组`是一组`字符`的集合，字符数组里的`元素`都是`字符`!,访问到的字符数组里的**元素**都是**字符**，像`'a'`,`'b'`,`'c'`这种的单个的字符,别和`字符串`混为一谈！\n\n```C\nchar str = \"abc\";\nint sz = sizeof(str);//这里str代表了整个数组,所以包括\\0\n,sz的值为4\n\n```\n\n### 字符数组的声明 #\n字符数组的声明和其他类型的数组差不多，有**初始化**，**不完全初始化**，**声明长度**，**不声明长度**\n\n*正确的声明代码如下*\n```C\nchar str1[] = \"abc\";//初始化,不声明长度\n\nchar str2[] = {'a','b','c','\\0'};//这也是初始化，且不声明长度\n\nchar str3[10] = { 0 };//初始化，用值0(等价于`\\0`)填充\n\nchar str4[10] = \"abc\";//不完全初始化，存入字符串\"abc\",后面都用'\\0'填充\n\nchar str5[10] = {'a','b','c','d'};//不完全初始化,从下标为0开始，依次往后填充字符 a,b,c,\\0\n\n```\n*错误的声明代码*\n```C\nchar str1[3] = \"abc\";//数组声明短了，放不下结尾的\\0,编译过不了\n\nchar str2[3] = {'a','b','c','d'};//同上,放不下\n\nchar str3[] = { 0 };//能声明，但是字符数组长度为1，这个数组大概率是用不了的/会被拿去错误使用的\n\n```\n### 来看看这些声明方式在内存中的表现 #\n\n#### 不初始化的声明(极度不推荐) #\n```C\nchar str[];//这个不加长度，直接编译失败（如下图）\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-39-10.jpg)\n\n```C\nchar str[10];//语法没有问题，来看看此时数组里存了什么\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-46-49.jpg)\n可以看到全都存了`-52`,对应的中文字符是`烫`，这样**不好**，请在声明字符数组的时候**初始化数组**\n#### 不声明长度的数组声明\n```C\nchar str1[] = \"abc\";\n\nchar str2[] = {'a','b','c','\\0'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-59-34.jpg)\n\n如上图，不声明长度时，编译器自动给字符数组分配内存，既不给多，也不给少，初始化给的`字符串`或者`{...}`多长，创建的数组就多长。\n\n**注意红框**，再强调一遍，字符串以`\\0`结尾,看到双引号括起来的字符串，要记得最后隐藏了一个`\\0`,用字符数组储存的时候一定要留足空间\n\n#### 声明长度的数组声明 #\n```C\nchar str3[10] = { 0 };\n\nchar str4[10] = \"abc\";\n\nchar str5[10] = {'a','b','c','d'};\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_15-25-54.jpg)\n\n可以看到，在声明的长度**足够长**时，你初始化的时候给它多少字符，它就从`下标0`处开始**按顺序**存进去多少,剩下的部分**自动**用`'\\0'`填充,\n\n所以实际上上面代码中的`str5`因为长度`10`>初始化给的`4`个字符，后面六个元素用`\\0`填充了，所以`str5`里存了有**结尾**的完整字符串\n\n#### 错误声明 #\n```C\nchar str1[3] = \"abc\";\nchar str2[3] = { 'a','b','c','d' };\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-44-57.jpg)\n\n可以看到上面两种错误的声明方式，甚至直接**编译失败**,所以声明字符数组的时候一定要**留足空间**\n\n```C\nchar str3[] = { 0 };\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-51-55.jpg)\n\n如上图，可以看到这样写还是编译成功了，但是在监视查看**数组长度**的时候，发现长度为`1`,里面存了一个`\\0`,这么**短**的数组能用吗？只能**用一点点**，甚至还不如直接声明一个`char`类型的字符变量\n\n## 当字符数组加上const #\n```C\nconst char str[5] = \"abc\";\n```\n### 一些性质 #\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_18-55-52.jpg)\n\n可以看到，声明时加了`const`之后，字符数组`str`在声明时的**初始化**之后便不可更改了，只能**访问**其元素,而**不能通过访问元素来改变数组内容**\n\n那么`scanf`还能写入内容吗？答案是**可以**!*(如下图)*\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-10-43.jpg)\n\n那它能拿来初始化别的数组吗？很遗憾，**不能**\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-05-15.jpg)\n\n### 对应的指针类型 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-15-32.jpg)\n\n可以看到，这里得用`const char*`来储存字符数组的地址，而使用`char*`就会报错\n\n那么用`双引号括起来的字符串`，是否也有地址，能用指针储存它的地址呢？\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-21-10.jpg)\n\n如图，可以看到,字符串`\"abc\"`是属于`const char`类型的数组，对应的指针是`const char*`,不能通过访问元素来改变内部的值，也不能用`char*`来储存地址\n\n#### 在内存中的表现 #\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_str.gif)\n\n可以看到哪怕是字符串`\"abc\"`,也是在内存中开辟了一段空间，并把字符**储存在内存中**了的\n\n但是，**不要**试图用`scanf`去改变字符串的值\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_strrrr.gif)\n\n---\n\n## 如何向字符数组里添加内容 #\n添加的方法多种多样，搞不好可能还会出错，所以把字符数组**学明白**很重要！\n\n以下使用的数组样例声明如下\n```C\nchar str[10] = { 0 };\n```\n\n### 初始化 #\n在初始化的时候就把值传进去，有哪些初始化方式**上面**已经介绍过了，这里不多赘述\n\n### 访问数组元素 #\n通过`[]`可以访问数组元素，并对没有`const`修饰的数组，修改其元素,例如:\n\n```C\nstr[0] = 'A';//将数组的第一个元素改成字符A\n```\n\n我们也可以通过循环的方式，将数组的所有元素填充为某个字符\n\n```C\nchar place_holder = 'A';\nfor(int i = 0; i < 10 ; i++)//这里使用左闭右开区间，10为数组的大小\n{\n    str[i] = place_holder;\n}\n```\n\n### 使用`scanf`函数 #\n由上面的探究已知：对于已声明的字符数组，**无论**有没有`const`修饰，都可已用`scanf`修改内容,那么`scanf`怎么用，又具体怎么工作的，我们接着往下探究\n\n#### 使用示例 #\n```C\nchar str[10] = { 0 };\nscanf(\"%s\",str);//占位符是 %s ,右边的参数是 str ,也就是数组名\n//或者 scanf(\"%s\",&str)\n```\n**注意**！这边的数组名`str`储存的是**数组首元素的地址**，而`&str`储存的是`整个数组的地址`，值是一样的，两者皆可用于传参，但**指针类型不一样**，要做好区分\n\n#### `scanf`都做了什么 #\n先来看看它分别对用`{ 0 }`**初始化**和**不初始化**的数组做了什么\n```C\nchar str1[10] = { 0 };\nscanf(\"%s\",str1);\nchar str2[10];\nscanf(\"%s\",str2);\n```\n*两个数组的输入均为abc*\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-11_19-09-50.jpg)\n\n可以看到，对`str1`,字符非常正常地填充进去了，因为整个数组原本是用`\\0`填充的,看不出什么端倪\n\n而对于`str2`,观察发现，除了输入进去的字符`a`,`b`,`c`,它还自动在结尾补了一个`\\0`,使`str2`里储存了一个完整的字符串。**但是**，剩下的部分还是用**值**`-52`填充，即未初始化的状态，所以依然**不提倡**声明的时候没有初始化\n\n然后是在字符数组内已有内容的情况下，再次使用`scanf`的情况\n```C\nchar str1[5] = \"abc\";\nchar str2[5] = \"abc\";\n\nscanf(\"%s %s\",str1,str2);\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-33-02.jpg)\n\n如图，`scanf`做的是把输入的字符串`覆盖`式存入字符数组，比原来长，就完全覆盖，比原来短，就部分覆盖，未覆盖的部分无改动\n\n#### 关于`scanf`的危险操作 #\n由于`scanf`无法预测**字符数组**能否存下输入的**字符串**，如果**字符数组**声明的长度不够，就可能出现**越界访问**,随之而来的便是奇奇怪怪的`bug`\n\n```C\nchar str[4] = { 0 };//先声明一个长度为4的数组\nscanf(\"%s\",str);//这次输入abcdef试试\n```\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-47-00.jpg)\n\n可以看到，确实**越界访问**了，所以声明字符数组的时候，建议比预计最大输入，在多些长度，防止越界访问。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"str-arr","published":1,"updated":"2024-05-14T02:21:56.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08q001z4sp50ojx7ljk","content":"<h1 id=\"什么是字符串\"><a href=\"#什么是字符串\" class=\"headerlink\" title=\"什么是字符串\"></a>什么是字符串</h1><h2 id=\"初见字符串\"><a href=\"#初见字符串\" class=\"headerlink\" title=\"初见字符串\"></a>初见字符串</h2><p>我们最先遇到的字符串,一般是<code>hello_world</code>程序中用到的<code>&quot;hello world&quot;</code>,也就是<strong>两个双引号括起来的一串字符</strong>,输出时的占位符是<code>%s</code>,可以直接拿去传值，代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>,<span class=\"string\">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明字符串变量\"><a href=\"#声明字符串变量\" class=\"headerlink\" title=\"声明字符串变量\"></a>声明字符串变量</h2><p>有时我们想要先把字符串存起来，再进行操作，那么就使用<strong>字符数组</strong>，并在<strong>初始化</strong>的时候把字符串传给它,这样在<strong>创建数组</strong>时会编译器会自动分配内存给它，代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = <span class=\"string\">&quot;abcdef&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们也可以开启VS的<strong>调试</strong>，并打开<strong>内存</strong>和<strong>监视</strong>窗口观察字符串是如何在内存中储存的,如下图</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_10-06-06.jpg\"></p>\n<p>通过观察可以发现，C语⾔字符串的字符串有个<code>规定</code>(特点)，就是以字符<code>\\0</code>结尾，无论是初始化数组时，还是在分配内存时，都有<code>\\0</code>的位置。</p>\n<h3 id=\"strlen-函数\"><a href=\"#strlen-函数\" class=\"headerlink\" title=\"strlen()函数\"></a>strlen()函数</h3><p>依据以<code>\\0</code>为字符串结尾的规则，<code>strlen</code>函数就可以计算字符串的长度，它会从字符串的第一个字符向后扫描，直到遇到<code>\\0</code>结束,且<code>\\0</code>不进入计数，最后返回字符串的长度,代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span> <span class=\"comment\">//需要引对应的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(<span class=\"string\">&quot;abcdef&quot;</span>);<span class=\"comment\">//len的值为6</span></span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(<span class=\"string\">&quot;abcdef&quot;</span>);<span class=\"comment\">//sz的大小为7(\\0被计入总数)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"验证字符串的结尾\"><a href=\"#验证字符串的结尾\" class=\"headerlink\" title=\"验证字符串的结尾\"></a>验证字符串的结尾</h3><h4 id=\"正向验证\"><a href=\"#正向验证\" class=\"headerlink\" title=\"正向验证\"></a>正向验证</h4><p>我们做在字符数组里插入一个<code>\\0</code>,来看看函数<code>printf</code>和<code>strlen</code>找到的结尾在哪里,如下图</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;f&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_11-01-35.jpg\"></p>\n<p>可以看到字符数组似乎被“截断”了，<code>printf</code>只输出了<code>\\0</code>前面的内容, <code>strlen</code>算出来的长度也只有<code>3</code>,可见插入的<code>\\0</code>被作为了<strong>字符串</strong>的结尾，字符串提前中指,而没到达<strong>字符数组</strong>的结尾</p>\n<h4 id=\"反向验证\"><a href=\"#反向验证\" class=\"headerlink\" title=\"反向验证\"></a>反向验证</h4><p>我们来<strong>反向</strong>验证一下，<code>\\0</code>是字符串结尾的标志,如下图，我们声明一个<strong>没有</strong><code>\\0</code>结尾的字符数组，看看函数<code>printf</code>和<code>strlen</code>还找不找得到我们“认为”的结尾</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;f&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-02-07.jpg\"></p>\n<p>可以看到函数对字符串的判断出现了严重<strong>失误</strong>，所以<strong>字符数组</strong>里没有<code>\\0</code>标记结尾是非常严重的问题，不光是找不到字符串的结尾，而且会<strong>越界访问</strong>！危险操作，写代码的时候一定要注意</p>\n<hr>\n<h2 id=\"从字符串到字符数组\"><a href=\"#从字符串到字符数组\" class=\"headerlink\" title=\"从字符串到字符数组\"></a>从字符串到字符数组</h2><p>虽然上面已经用到了字符数组，但主要还是为了方便讨论<strong>字符串</strong>,接下来着重研究字符数组。</p>\n<h3 id=\"先整清楚几个概念\"><a href=\"#先整清楚几个概念\" class=\"headerlink\" title=\"先整清楚几个概念\"></a>先整清楚几个概念</h3><p><code>什么是数组</code>：数组是⼀组相同类型元素的集合,会在内存中开辟一段连续的空间，将元素储存在那段内存中</p>\n<p><code>什么是数组元素</code>：存放在数组的值被称为数组的元素，数组在创建的时候可以指定数组的⼤⼩和数组的元素类型。</p>\n<p>所以<code>字符数组</code>是一组<code>字符</code>的集合，字符数组里的<code>元素</code>都是<code>字符</code>!,访问到的字符数组里的<strong>元素</strong>都是<strong>字符</strong>，像<code>&#39;a&#39;</code>,<code>&#39;b&#39;</code>,<code>&#39;c&#39;</code>这种的单个的字符,别和<code>字符串</code>混为一谈！</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(str);<span class=\"comment\">//这里str代表了整个数组,所以包括\\0</span></span><br><span class=\"line\">,sz的值为<span class=\"number\">4</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符数组的声明\"><a href=\"#字符数组的声明\" class=\"headerlink\" title=\"字符数组的声明\"></a>字符数组的声明</h3><p>字符数组的声明和其他类型的数组差不多，有<strong>初始化</strong>，<strong>不完全初始化</strong>，<strong>声明长度</strong>，<strong>不声明长度</strong></p>\n<p><em>正确的声明代码如下</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//初始化,不声明长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;<span class=\"comment\">//这也是初始化，且不声明长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str3[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//初始化，用值0(等价于`\\0`)填充</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str4[<span class=\"number\">10</span>] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//不完全初始化，存入字符串&quot;abc&quot;,后面都用&#x27;\\0&#x27;填充</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str5[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;<span class=\"comment\">//不完全初始化,从下标为0开始，依次往后填充字符 a,b,c,\\0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em>错误的声明代码</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">3</span>] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//数组声明短了，放不下结尾的\\0,编译过不了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">3</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;<span class=\"comment\">//同上,放不下</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str3[] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//能声明，但是字符数组长度为1，这个数组大概率是用不了的/会被拿去错误使用的</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"来看看这些声明方式在内存中的表现\"><a href=\"#来看看这些声明方式在内存中的表现\" class=\"headerlink\" title=\"来看看这些声明方式在内存中的表现\"></a>来看看这些声明方式在内存中的表现</h3><h4 id=\"不初始化的声明-极度不推荐\"><a href=\"#不初始化的声明-极度不推荐\" class=\"headerlink\" title=\"不初始化的声明(极度不推荐)\"></a>不初始化的声明(极度不推荐)</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[];<span class=\"comment\">//这个不加长度，直接编译失败（如下图）</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-39-10.jpg\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>];<span class=\"comment\">//语法没有问题，来看看此时数组里存了什么</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-46-49.jpg\"><br>可以看到全都存了<code>-52</code>,对应的中文字符是<code>烫</code>，这样<strong>不好</strong>，请在声明字符数组的时候<strong>初始化数组</strong></p>\n<h4 id=\"不声明长度的数组声明\"><a href=\"#不声明长度的数组声明\" class=\"headerlink\" title=\"不声明长度的数组声明\"></a>不声明长度的数组声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-59-34.jpg\"></p>\n<p>如上图，不声明长度时，编译器自动给字符数组分配内存，既不给多，也不给少，初始化给的<code>字符串</code>或者<code>&#123;...&#125;</code>多长，创建的数组就多长。</p>\n<p><strong>注意红框</strong>，再强调一遍，字符串以<code>\\0</code>结尾,看到双引号括起来的字符串，要记得最后隐藏了一个<code>\\0</code>,用字符数组储存的时候一定要留足空间</p>\n<h4 id=\"声明长度的数组声明\"><a href=\"#声明长度的数组声明\" class=\"headerlink\" title=\"声明长度的数组声明\"></a>声明长度的数组声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str3[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str4[<span class=\"number\">10</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str5[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_15-25-54.jpg\"></p>\n<p>可以看到，在声明的长度<strong>足够长</strong>时，你初始化的时候给它多少字符，它就从<code>下标0</code>处开始<strong>按顺序</strong>存进去多少,剩下的部分<strong>自动</strong>用<code>&#39;\\0&#39;</code>填充,</p>\n<p>所以实际上上面代码中的<code>str5</code>因为长度<code>10</code>&gt;初始化给的<code>4</code>个字符，后面六个元素用<code>\\0</code>填充了，所以<code>str5</code>里存了有<strong>结尾</strong>的完整字符串</p>\n<h4 id=\"错误声明\"><a href=\"#错误声明\" class=\"headerlink\" title=\"错误声明\"></a>错误声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">3</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">3</span>] = &#123; <span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-44-57.jpg\"></p>\n<p>可以看到上面两种错误的声明方式，甚至直接<strong>编译失败</strong>,所以声明字符数组的时候一定要<strong>留足空间</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str3[] = &#123; <span class=\"number\">0</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-51-55.jpg\"></p>\n<p>如上图，可以看到这样写还是编译成功了，但是在监视查看<strong>数组长度</strong>的时候，发现长度为<code>1</code>,里面存了一个<code>\\0</code>,这么<strong>短</strong>的数组能用吗？只能<strong>用一点点</strong>，甚至还不如直接声明一个<code>char</code>类型的字符变量</p>\n<h2 id=\"当字符数组加上const\"><a href=\"#当字符数组加上const\" class=\"headerlink\" title=\"当字符数组加上const\"></a>当字符数组加上const</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> str[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"一些性质\"><a href=\"#一些性质\" class=\"headerlink\" title=\"一些性质\"></a>一些性质</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_18-55-52.jpg\"></p>\n<p>可以看到，声明时加了<code>const</code>之后，字符数组<code>str</code>在声明时的<strong>初始化</strong>之后便不可更改了，只能<strong>访问</strong>其元素,而<strong>不能通过访问元素来改变数组内容</strong></p>\n<p>那么<code>scanf</code>还能写入内容吗？答案是<strong>可以</strong>!<em>(如下图)</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-10-43.jpg\"></p>\n<p>那它能拿来初始化别的数组吗？很遗憾，<strong>不能</strong><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-05-15.jpg\"></p>\n<h3 id=\"对应的指针类型\"><a href=\"#对应的指针类型\" class=\"headerlink\" title=\"对应的指针类型\"></a>对应的指针类型</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-15-32.jpg\"></p>\n<p>可以看到，这里得用<code>const char*</code>来储存字符数组的地址，而使用<code>char*</code>就会报错</p>\n<p>那么用<code>双引号括起来的字符串</code>，是否也有地址，能用指针储存它的地址呢？</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-21-10.jpg\"></p>\n<p>如图，可以看到,字符串<code>&quot;abc&quot;</code>是属于<code>const char</code>类型的数组，对应的指针是<code>const char*</code>,不能通过访问元素来改变内部的值，也不能用<code>char*</code>来储存地址</p>\n<h4 id=\"在内存中的表现\"><a href=\"#在内存中的表现\" class=\"headerlink\" title=\"在内存中的表现\"></a>在内存中的表现</h4><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_str.gif\"></p>\n<p>可以看到哪怕是字符串<code>&quot;abc&quot;</code>,也是在内存中开辟了一段空间，并把字符<strong>储存在内存中</strong>了的</p>\n<p>但是，<strong>不要</strong>试图用<code>scanf</code>去改变字符串的值<br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_strrrr.gif\"></p>\n<hr>\n<h2 id=\"如何向字符数组里添加内容\"><a href=\"#如何向字符数组里添加内容\" class=\"headerlink\" title=\"如何向字符数组里添加内容\"></a>如何向字符数组里添加内容</h2><p>添加的方法多种多样，搞不好可能还会出错，所以把字符数组<strong>学明白</strong>很重要！</p>\n<p>以下使用的数组样例声明如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>在初始化的时候就把值传进去，有哪些初始化方式<strong>上面</strong>已经介绍过了，这里不多赘述</p>\n<h3 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h3><p>通过<code>[]</code>可以访问数组元素，并对没有<code>const</code>修饰的数组，修改其元素,例如:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;A&#x27;</span>;<span class=\"comment\">//将数组的第一个元素改成字符A</span></span><br></pre></td></tr></table></figure>\n\n<p>我们也可以通过循环的方式，将数组的所有元素填充为某个字符</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> place_holder = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++)<span class=\"comment\">//这里使用左闭右开区间，10为数组的大小</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    str[i] = place_holder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用scanf函数\"><a href=\"#使用scanf函数\" class=\"headerlink\" title=\"使用scanf函数\"></a>使用<code>scanf</code>函数</h3><p>由上面的探究已知：对于已声明的字符数组，<strong>无论</strong>有没有<code>const</code>修饰，都可已用<code>scanf</code>修改内容,那么<code>scanf</code>怎么用，又具体怎么工作的，我们接着往下探究</p>\n<h4 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str);<span class=\"comment\">//占位符是 %s ,右边的参数是 str ,也就是数组名</span></span><br><span class=\"line\"><span class=\"comment\">//或者 scanf(&quot;%s&quot;,&amp;str)</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>！这边的数组名<code>str</code>储存的是<strong>数组首元素的地址</strong>，而<code>&amp;str</code>储存的是<code>整个数组的地址</code>，值是一样的，两者皆可用于传参，但<strong>指针类型不一样</strong>，要做好区分</p>\n<h4 id=\"scanf都做了什么\"><a href=\"#scanf都做了什么\" class=\"headerlink\" title=\"scanf都做了什么\"></a><code>scanf</code>都做了什么</h4><p>先来看看它分别对用<code>&#123; 0 &#125;</code><strong>初始化</strong>和<strong>不初始化</strong>的数组做了什么</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str1);</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str2);</span><br></pre></td></tr></table></figure>\n<p><em>两个数组的输入均为abc</em><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-11_19-09-50.jpg\"></p>\n<p>可以看到，对<code>str1</code>,字符非常正常地填充进去了，因为整个数组原本是用<code>\\0</code>填充的,看不出什么端倪</p>\n<p>而对于<code>str2</code>,观察发现，除了输入进去的字符<code>a</code>,<code>b</code>,<code>c</code>,它还自动在结尾补了一个<code>\\0</code>,使<code>str2</code>里储存了一个完整的字符串。<strong>但是</strong>，剩下的部分还是用<strong>值</strong><code>-52</code>填充，即未初始化的状态，所以依然<strong>不提倡</strong>声明的时候没有初始化</p>\n<p>然后是在字符数组内已有内容的情况下，再次使用<code>scanf</code>的情况</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s %s&quot;</span>,str1,str2);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-33-02.jpg\"></p>\n<p>如图，<code>scanf</code>做的是把输入的字符串<code>覆盖</code>式存入字符数组，比原来长，就完全覆盖，比原来短，就部分覆盖，未覆盖的部分无改动</p>\n<h4 id=\"关于scanf的危险操作\"><a href=\"#关于scanf的危险操作\" class=\"headerlink\" title=\"关于scanf的危险操作\"></a>关于<code>scanf</code>的危险操作</h4><p>由于<code>scanf</code>无法预测<strong>字符数组</strong>能否存下输入的<strong>字符串</strong>，如果<strong>字符数组</strong>声明的长度不够，就可能出现<strong>越界访问</strong>,随之而来的便是奇奇怪怪的<code>bug</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">4</span>] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//先声明一个长度为4的数组</span></span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str);<span class=\"comment\">//这次输入abcdef试试</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-47-00.jpg\"></p>\n<p>可以看到，确实<strong>越界访问</strong>了，所以声明字符数组的时候，建议比预计最大输入，在多些长度，防止越界访问。</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409052350159.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"什么是字符串\"><a href=\"#什么是字符串\" class=\"headerlink\" title=\"什么是字符串\"></a>什么是字符串</h1><h2 id=\"初见字符串\"><a href=\"#初见字符串\" class=\"headerlink\" title=\"初见字符串\"></a>初见字符串</h2><p>我们最先遇到的字符串,一般是<code>hello_world</code>程序中用到的<code>&quot;hello world&quot;</code>,也就是<strong>两个双引号括起来的一串字符</strong>,输出时的占位符是<code>%s</code>,可以直接拿去传值，代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>,<span class=\"string\">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明字符串变量\"><a href=\"#声明字符串变量\" class=\"headerlink\" title=\"声明字符串变量\"></a>声明字符串变量</h2><p>有时我们想要先把字符串存起来，再进行操作，那么就使用<strong>字符数组</strong>，并在<strong>初始化</strong>的时候把字符串传给它,这样在<strong>创建数组</strong>时会编译器会自动分配内存给它，代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = <span class=\"string\">&quot;abcdef&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们也可以开启VS的<strong>调试</strong>，并打开<strong>内存</strong>和<strong>监视</strong>窗口观察字符串是如何在内存中储存的,如下图</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_10-06-06.jpg\"></p>\n<p>通过观察可以发现，C语⾔字符串的字符串有个<code>规定</code>(特点)，就是以字符<code>\\0</code>结尾，无论是初始化数组时，还是在分配内存时，都有<code>\\0</code>的位置。</p>\n<h3 id=\"strlen-函数\"><a href=\"#strlen-函数\" class=\"headerlink\" title=\"strlen()函数\"></a>strlen()函数</h3><p>依据以<code>\\0</code>为字符串结尾的规则，<code>strlen</code>函数就可以计算字符串的长度，它会从字符串的第一个字符向后扫描，直到遇到<code>\\0</code>结束,且<code>\\0</code>不进入计数，最后返回字符串的长度,代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span> <span class=\"comment\">//需要引对应的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(<span class=\"string\">&quot;abcdef&quot;</span>);<span class=\"comment\">//len的值为6</span></span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(<span class=\"string\">&quot;abcdef&quot;</span>);<span class=\"comment\">//sz的大小为7(\\0被计入总数)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"验证字符串的结尾\"><a href=\"#验证字符串的结尾\" class=\"headerlink\" title=\"验证字符串的结尾\"></a>验证字符串的结尾</h3><h4 id=\"正向验证\"><a href=\"#正向验证\" class=\"headerlink\" title=\"正向验证\"></a>正向验证</h4><p>我们做在字符数组里插入一个<code>\\0</code>,来看看函数<code>printf</code>和<code>strlen</code>找到的结尾在哪里,如下图</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;f&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_11-01-35.jpg\"></p>\n<p>可以看到字符数组似乎被“截断”了，<code>printf</code>只输出了<code>\\0</code>前面的内容, <code>strlen</code>算出来的长度也只有<code>3</code>,可见插入的<code>\\0</code>被作为了<strong>字符串</strong>的结尾，字符串提前中指,而没到达<strong>字符数组</strong>的结尾</p>\n<h4 id=\"反向验证\"><a href=\"#反向验证\" class=\"headerlink\" title=\"反向验证\"></a>反向验证</h4><p>我们来<strong>反向</strong>验证一下，<code>\\0</code>是字符串结尾的标志,如下图，我们声明一个<strong>没有</strong><code>\\0</code>结尾的字符数组，看看函数<code>printf</code>和<code>strlen</code>还找不找得到我们“认为”的结尾</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;f&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-02-07.jpg\"></p>\n<p>可以看到函数对字符串的判断出现了严重<strong>失误</strong>，所以<strong>字符数组</strong>里没有<code>\\0</code>标记结尾是非常严重的问题，不光是找不到字符串的结尾，而且会<strong>越界访问</strong>！危险操作，写代码的时候一定要注意</p>\n<hr>\n<h2 id=\"从字符串到字符数组\"><a href=\"#从字符串到字符数组\" class=\"headerlink\" title=\"从字符串到字符数组\"></a>从字符串到字符数组</h2><p>虽然上面已经用到了字符数组，但主要还是为了方便讨论<strong>字符串</strong>,接下来着重研究字符数组。</p>\n<h3 id=\"先整清楚几个概念\"><a href=\"#先整清楚几个概念\" class=\"headerlink\" title=\"先整清楚几个概念\"></a>先整清楚几个概念</h3><p><code>什么是数组</code>：数组是⼀组相同类型元素的集合,会在内存中开辟一段连续的空间，将元素储存在那段内存中</p>\n<p><code>什么是数组元素</code>：存放在数组的值被称为数组的元素，数组在创建的时候可以指定数组的⼤⼩和数组的元素类型。</p>\n<p>所以<code>字符数组</code>是一组<code>字符</code>的集合，字符数组里的<code>元素</code>都是<code>字符</code>!,访问到的字符数组里的<strong>元素</strong>都是<strong>字符</strong>，像<code>&#39;a&#39;</code>,<code>&#39;b&#39;</code>,<code>&#39;c&#39;</code>这种的单个的字符,别和<code>字符串</code>混为一谈！</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(str);<span class=\"comment\">//这里str代表了整个数组,所以包括\\0</span></span><br><span class=\"line\">,sz的值为<span class=\"number\">4</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符数组的声明\"><a href=\"#字符数组的声明\" class=\"headerlink\" title=\"字符数组的声明\"></a>字符数组的声明</h3><p>字符数组的声明和其他类型的数组差不多，有<strong>初始化</strong>，<strong>不完全初始化</strong>，<strong>声明长度</strong>，<strong>不声明长度</strong></p>\n<p><em>正确的声明代码如下</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//初始化,不声明长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;<span class=\"comment\">//这也是初始化，且不声明长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str3[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//初始化，用值0(等价于`\\0`)填充</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str4[<span class=\"number\">10</span>] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//不完全初始化，存入字符串&quot;abc&quot;,后面都用&#x27;\\0&#x27;填充</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str5[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;<span class=\"comment\">//不完全初始化,从下标为0开始，依次往后填充字符 a,b,c,\\0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><em>错误的声明代码</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">3</span>] = <span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//数组声明短了，放不下结尾的\\0,编译过不了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">3</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;<span class=\"comment\">//同上,放不下</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str3[] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//能声明，但是字符数组长度为1，这个数组大概率是用不了的/会被拿去错误使用的</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"来看看这些声明方式在内存中的表现\"><a href=\"#来看看这些声明方式在内存中的表现\" class=\"headerlink\" title=\"来看看这些声明方式在内存中的表现\"></a>来看看这些声明方式在内存中的表现</h3><h4 id=\"不初始化的声明-极度不推荐\"><a href=\"#不初始化的声明-极度不推荐\" class=\"headerlink\" title=\"不初始化的声明(极度不推荐)\"></a>不初始化的声明(极度不推荐)</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[];<span class=\"comment\">//这个不加长度，直接编译失败（如下图）</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-39-10.jpg\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>];<span class=\"comment\">//语法没有问题，来看看此时数组里存了什么</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_11-46-49.jpg\"><br>可以看到全都存了<code>-52</code>,对应的中文字符是<code>烫</code>，这样<strong>不好</strong>，请在声明字符数组的时候<strong>初始化数组</strong></p>\n<h4 id=\"不声明长度的数组声明\"><a href=\"#不声明长度的数组声明\" class=\"headerlink\" title=\"不声明长度的数组声明\"></a>不声明长度的数组声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str2[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_14-59-34.jpg\"></p>\n<p>如上图，不声明长度时，编译器自动给字符数组分配内存，既不给多，也不给少，初始化给的<code>字符串</code>或者<code>&#123;...&#125;</code>多长，创建的数组就多长。</p>\n<p><strong>注意红框</strong>，再强调一遍，字符串以<code>\\0</code>结尾,看到双引号括起来的字符串，要记得最后隐藏了一个<code>\\0</code>,用字符数组储存的时候一定要留足空间</p>\n<h4 id=\"声明长度的数组声明\"><a href=\"#声明长度的数组声明\" class=\"headerlink\" title=\"声明长度的数组声明\"></a>声明长度的数组声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str3[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str4[<span class=\"number\">10</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str5[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-09_15-25-54.jpg\"></p>\n<p>可以看到，在声明的长度<strong>足够长</strong>时，你初始化的时候给它多少字符，它就从<code>下标0</code>处开始<strong>按顺序</strong>存进去多少,剩下的部分<strong>自动</strong>用<code>&#39;\\0&#39;</code>填充,</p>\n<p>所以实际上上面代码中的<code>str5</code>因为长度<code>10</code>&gt;初始化给的<code>4</code>个字符，后面六个元素用<code>\\0</code>填充了，所以<code>str5</code>里存了有<strong>结尾</strong>的完整字符串</p>\n<h4 id=\"错误声明\"><a href=\"#错误声明\" class=\"headerlink\" title=\"错误声明\"></a>错误声明</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">3</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">3</span>] = &#123; <span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-44-57.jpg\"></p>\n<p>可以看到上面两种错误的声明方式，甚至直接<strong>编译失败</strong>,所以声明字符数组的时候一定要<strong>留足空间</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str3[] = &#123; <span class=\"number\">0</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_07-51-55.jpg\"></p>\n<p>如上图，可以看到这样写还是编译成功了，但是在监视查看<strong>数组长度</strong>的时候，发现长度为<code>1</code>,里面存了一个<code>\\0</code>,这么<strong>短</strong>的数组能用吗？只能<strong>用一点点</strong>，甚至还不如直接声明一个<code>char</code>类型的字符变量</p>\n<h2 id=\"当字符数组加上const\"><a href=\"#当字符数组加上const\" class=\"headerlink\" title=\"当字符数组加上const\"></a>当字符数组加上const</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> str[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"一些性质\"><a href=\"#一些性质\" class=\"headerlink\" title=\"一些性质\"></a>一些性质</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_18-55-52.jpg\"></p>\n<p>可以看到，声明时加了<code>const</code>之后，字符数组<code>str</code>在声明时的<strong>初始化</strong>之后便不可更改了，只能<strong>访问</strong>其元素,而<strong>不能通过访问元素来改变数组内容</strong></p>\n<p>那么<code>scanf</code>还能写入内容吗？答案是<strong>可以</strong>!<em>(如下图)</em></p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-10-43.jpg\"></p>\n<p>那它能拿来初始化别的数组吗？很遗憾，<strong>不能</strong><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-05-15.jpg\"></p>\n<h3 id=\"对应的指针类型\"><a href=\"#对应的指针类型\" class=\"headerlink\" title=\"对应的指针类型\"></a>对应的指针类型</h3><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-15-32.jpg\"></p>\n<p>可以看到，这里得用<code>const char*</code>来储存字符数组的地址，而使用<code>char*</code>就会报错</p>\n<p>那么用<code>双引号括起来的字符串</code>，是否也有地址，能用指针储存它的地址呢？</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-10_19-21-10.jpg\"></p>\n<p>如图，可以看到,字符串<code>&quot;abc&quot;</code>是属于<code>const char</code>类型的数组，对应的指针是<code>const char*</code>,不能通过访问元素来改变内部的值，也不能用<code>char*</code>来储存地址</p>\n<h4 id=\"在内存中的表现\"><a href=\"#在内存中的表现\" class=\"headerlink\" title=\"在内存中的表现\"></a>在内存中的表现</h4><p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_str.gif\"></p>\n<p>可以看到哪怕是字符串<code>&quot;abc&quot;</code>,也是在内存中开辟了一段空间，并把字符<strong>储存在内存中</strong>了的</p>\n<p>但是，<strong>不要</strong>试图用<code>scanf</code>去改变字符串的值<br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/const_strrrr.gif\"></p>\n<hr>\n<h2 id=\"如何向字符数组里添加内容\"><a href=\"#如何向字符数组里添加内容\" class=\"headerlink\" title=\"如何向字符数组里添加内容\"></a>如何向字符数组里添加内容</h2><p>添加的方法多种多样，搞不好可能还会出错，所以把字符数组<strong>学明白</strong>很重要！</p>\n<p>以下使用的数组样例声明如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>在初始化的时候就把值传进去，有哪些初始化方式<strong>上面</strong>已经介绍过了，这里不多赘述</p>\n<h3 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h3><p>通过<code>[]</code>可以访问数组元素，并对没有<code>const</code>修饰的数组，修改其元素,例如:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;A&#x27;</span>;<span class=\"comment\">//将数组的第一个元素改成字符A</span></span><br></pre></td></tr></table></figure>\n\n<p>我们也可以通过循环的方式，将数组的所有元素填充为某个字符</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> place_holder = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++)<span class=\"comment\">//这里使用左闭右开区间，10为数组的大小</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    str[i] = place_holder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用scanf函数\"><a href=\"#使用scanf函数\" class=\"headerlink\" title=\"使用scanf函数\"></a>使用<code>scanf</code>函数</h3><p>由上面的探究已知：对于已声明的字符数组，<strong>无论</strong>有没有<code>const</code>修饰，都可已用<code>scanf</code>修改内容,那么<code>scanf</code>怎么用，又具体怎么工作的，我们接着往下探究</p>\n<h4 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str);<span class=\"comment\">//占位符是 %s ,右边的参数是 str ,也就是数组名</span></span><br><span class=\"line\"><span class=\"comment\">//或者 scanf(&quot;%s&quot;,&amp;str)</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>！这边的数组名<code>str</code>储存的是<strong>数组首元素的地址</strong>，而<code>&amp;str</code>储存的是<code>整个数组的地址</code>，值是一样的，两者皆可用于传参，但<strong>指针类型不一样</strong>，要做好区分</p>\n<h4 id=\"scanf都做了什么\"><a href=\"#scanf都做了什么\" class=\"headerlink\" title=\"scanf都做了什么\"></a><code>scanf</code>都做了什么</h4><p>先来看看它分别对用<code>&#123; 0 &#125;</code><strong>初始化</strong>和<strong>不初始化</strong>的数组做了什么</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">10</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str1);</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str2);</span><br></pre></td></tr></table></figure>\n<p><em>两个数组的输入均为abc</em><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-11_19-09-50.jpg\"></p>\n<p>可以看到，对<code>str1</code>,字符非常正常地填充进去了，因为整个数组原本是用<code>\\0</code>填充的,看不出什么端倪</p>\n<p>而对于<code>str2</code>,观察发现，除了输入进去的字符<code>a</code>,<code>b</code>,<code>c</code>,它还自动在结尾补了一个<code>\\0</code>,使<code>str2</code>里储存了一个完整的字符串。<strong>但是</strong>，剩下的部分还是用<strong>值</strong><code>-52</code>填充，即未初始化的状态，所以依然<strong>不提倡</strong>声明的时候没有初始化</p>\n<p>然后是在字符数组内已有内容的情况下，再次使用<code>scanf</code>的情况</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">5</span>] = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s %s&quot;</span>,str1,str2);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-33-02.jpg\"></p>\n<p>如图，<code>scanf</code>做的是把输入的字符串<code>覆盖</code>式存入字符数组，比原来长，就完全覆盖，比原来短，就部分覆盖，未覆盖的部分无改动</p>\n<h4 id=\"关于scanf的危险操作\"><a href=\"#关于scanf的危险操作\" class=\"headerlink\" title=\"关于scanf的危险操作\"></a>关于<code>scanf</code>的危险操作</h4><p>由于<code>scanf</code>无法预测<strong>字符数组</strong>能否存下输入的<strong>字符串</strong>，如果<strong>字符数组</strong>声明的长度不够，就可能出现<strong>越界访问</strong>,随之而来的便是奇奇怪怪的<code>bug</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">4</span>] = &#123; <span class=\"number\">0</span> &#125;;<span class=\"comment\">//先声明一个长度为4的数组</span></span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,str);<span class=\"comment\">//这次输入abcdef试试</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-12_09-47-00.jpg\"></p>\n<p>可以看到，确实<strong>越界访问</strong>了，所以声明字符数组的时候，建议比预计最大输入，在多些长度，防止越界访问。</p>\n"},{"title":"vim基础指令集","date":"2023-12-10T23:41:57.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/terminalpng.png","_content":"`Vim`是一款文本编辑器,下面介绍在vim界面中的常用指令\n\n**三种模式**:`命令模式(Command Mode)` `插入模式（Insert Mode` `命令行模式（Command-Line Mode）`（这里称命令行模式为`底行模式`）\n\n三者关系如下图\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_10-39-04.png)\n\n# 命令模式\n`vim`界面中多摁几次`ESC`就能退出其它模式回到`命令模式`，在这个模式下可以使用一系列vim[快捷键](https://linux.cn/article-8144-1.html)\n\n# 底行模式 #\n`tips`:不管目前是什么模式,先狂按`ESC`,回到`命令模式`,然后输入`:`进入`底行模式`,准备开始输命令\n\n`命令组成`\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_12-48-54.png)\n\n+ 保存`:w`->强制保存`!w`\n+ 退出`:q`->强制退出`:!q`\n+ 保存并退出`:wq`-.强制保存并退出`:!wq`\n+ 对比`:vs `+`(源文件路径)`\n\n\n# 插入模式\n在`命令模式`下按键盘`i`进入`插入模式`，执行正常的文本编辑功能","source":"_posts/vim-cmd.md","raw":"---\ntitle: vim基础指令集\ndate: 2023-12-11 07:41:57\ntags: Linux vim\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/terminalpng.png\n---\n`Vim`是一款文本编辑器,下面介绍在vim界面中的常用指令\n\n**三种模式**:`命令模式(Command Mode)` `插入模式（Insert Mode` `命令行模式（Command-Line Mode）`（这里称命令行模式为`底行模式`）\n\n三者关系如下图\n\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_10-39-04.png)\n\n# 命令模式\n`vim`界面中多摁几次`ESC`就能退出其它模式回到`命令模式`，在这个模式下可以使用一系列vim[快捷键](https://linux.cn/article-8144-1.html)\n\n# 底行模式 #\n`tips`:不管目前是什么模式,先狂按`ESC`,回到`命令模式`,然后输入`:`进入`底行模式`,准备开始输命令\n\n`命令组成`\n![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_12-48-54.png)\n\n+ 保存`:w`->强制保存`!w`\n+ 退出`:q`->强制退出`:!q`\n+ 保存并退出`:wq`-.强制保存并退出`:!wq`\n+ 对比`:vs `+`(源文件路径)`\n\n\n# 插入模式\n在`命令模式`下按键盘`i`进入`插入模式`，执行正常的文本编辑功能","slug":"vim-cmd","published":1,"updated":"2024-07-03T10:03:53.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08r00224sp5hnp61wsz","content":"<p><code>Vim</code>是一款文本编辑器,下面介绍在vim界面中的常用指令</p>\n<p><strong>三种模式</strong>:<code>命令模式(Command Mode)</code> <code>插入模式（Insert Mode</code> <code>命令行模式（Command-Line Mode）</code>（这里称命令行模式为<code>底行模式</code>）</p>\n<p>三者关系如下图</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_10-39-04.png\"></p>\n<h1 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h1><p><code>vim</code>界面中多摁几次<code>ESC</code>就能退出其它模式回到<code>命令模式</code>，在这个模式下可以使用一系列vim<a href=\"https://linux.cn/article-8144-1.html\">快捷键</a></p>\n<h1 id=\"底行模式\"><a href=\"#底行模式\" class=\"headerlink\" title=\"底行模式\"></a>底行模式</h1><p><code>tips</code>:不管目前是什么模式,先狂按<code>ESC</code>,回到<code>命令模式</code>,然后输入<code>:</code>进入<code>底行模式</code>,准备开始输命令</p>\n<p><code>命令组成</code><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_12-48-54.png\"></p>\n<ul>\n<li>保存<code>:w</code>-&gt;强制保存<code>!w</code></li>\n<li>退出<code>:q</code>-&gt;强制退出<code>:!q</code></li>\n<li>保存并退出<code>:wq</code>-.强制保存并退出<code>:!wq</code></li>\n<li>对比<code>:vs </code>+<code>(源文件路径)</code></li>\n</ul>\n<h1 id=\"插入模式\"><a href=\"#插入模式\" class=\"headerlink\" title=\"插入模式\"></a>插入模式</h1><p>在<code>命令模式</code>下按键盘<code>i</code>进入<code>插入模式</code>，执行正常的文本编辑功能</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<p><code>Vim</code>是一款文本编辑器,下面介绍在vim界面中的常用指令</p>\n<p><strong>三种模式</strong>:<code>命令模式(Command Mode)</code> <code>插入模式（Insert Mode</code> <code>命令行模式（Command-Line Mode）</code>（这里称命令行模式为<code>底行模式</code>）</p>\n<p>三者关系如下图</p>\n<p><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_10-39-04.png\"></p>\n<h1 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h1><p><code>vim</code>界面中多摁几次<code>ESC</code>就能退出其它模式回到<code>命令模式</code>，在这个模式下可以使用一系列vim<a href=\"https://linux.cn/article-8144-1.html\">快捷键</a></p>\n<h1 id=\"底行模式\"><a href=\"#底行模式\" class=\"headerlink\" title=\"底行模式\"></a>底行模式</h1><p><code>tips</code>:不管目前是什么模式,先狂按<code>ESC</code>,回到<code>命令模式</code>,然后输入<code>:</code>进入<code>底行模式</code>,准备开始输命令</p>\n<p><code>命令组成</code><br><img src=\"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/PixPin_2023-12-11_12-48-54.png\"></p>\n<ul>\n<li>保存<code>:w</code>-&gt;强制保存<code>!w</code></li>\n<li>退出<code>:q</code>-&gt;强制退出<code>:!q</code></li>\n<li>保存并退出<code>:wq</code>-.强制保存并退出<code>:!wq</code></li>\n<li>对比<code>:vs </code>+<code>(源文件路径)</code></li>\n</ul>\n<h1 id=\"插入模式\"><a href=\"#插入模式\" class=\"headerlink\" title=\"插入模式\"></a>插入模式</h1><p>在<code>命令模式</code>下按键盘<code>i</code>进入<code>插入模式</code>，执行正常的文本编辑功能</p>\n"},{"title":"=算法=按位异或^的种种玩法","date":"2023-09-03T23:05:48.000Z","_content":"## 什么是按位异或``^`` #\n首先将不同数制的数写成**二进制**,例如``9->0b1001``.\\\n然后最末位对齐，依次**按位异或**.\\\n规则:``0 ^ 0= 0 ; 1 ^ 1 = 0; 1 ^ 0 = 1``\\\n推论:任意整数``x``,都有``0^x = x``  ;   ``x ^ x = 0``\\\n***\n**来看看应用**\n## 寻找一个单身狗数 #\n像``[1,3,2,2,3]``这样除了某一个数``1``,剩下的数字都是成对的,也就是说遍历一次数组，把所有的元素**按位异或**在一起，结果便是落单的那个``1``\n```C\n//代码实现\nint arr[] = {1,3,2,2,3};\nint sz = sizeof(arr)/sizeof(arr[0]);//求数组大小\nint ret  = 0;\nfor (int i =0;i<sz;i++)\n{\n    ret^=arr[i];\n}\n\nreturn ret; //此时ret即为落单的那个数\n```\n**_变形_**\n## 消失的数 #\n已知一个由0\\~n(缺失一个数)填充的数组，例``[0,6,4,2,3,1]``,例中的数组少了一个``5``,而我们已知数组包含0\\~6中的5个数，就可以将数组元素与0~6**按位异或**到一起，将问题*消失的数*转化为问题*寻找单身狗*,消失的数变成剩下的那个单身狗\n```C\n//代码实现\nint missingNumber(int* nums, int numsSize)\n{\n    int ret = 0;\n    for(int i = 0;i<numsSize;i++>)\n    {\n        ret^=nums[i];//历遍nums的所有元素\n        ret^=i;//历遍0~numsSize-1\n    }\n    ret^=numsSize;//补上numsSize;\n    return ret;\n}\n```\n**_进阶_**\n## 找到两个单身狗 #\n数组再升级，单身狗变成了**两个**，导致不能粗暴地把所有元素按位异或来求出两个数,但我们仍可以将问题简化：能否将两个单身狗分到两个数组，使之转化为两个独立的*求单个单身狗问题*。于是难点来到了如何**分组**\n\n### 方案之一便是运用**按位异或**和**右移运算符** #\n因为两个不同的数，在二进制上作比较，就至少有一位是不同的，以那一位为``0``或``1``分成两组，便可将两个单身狗分开.而若要查找具体是哪一位，将列表中**所有元素**（就包括了两数）**按位异或**后再用**右移运算符**逐位检验是否为``1``,之后便可轻松分组，并直接**按位异或**得出结果\n\n```C\n//代码实现\nint* singleNumber(int* nums, int numsSize, int ret[2]){\n    int ret1 = 0;\n    int ret2 = 0;\n    int n = 0;//用于记录\"1\"在哪一位\n    int tmp = 0;\n    for(int i =0;i<numsSize;i++)\n    {\n        tmp^=nums[i];\n    }\n    while((tmp>>n) !=1 )\n    {\n        n++;\n    }\n    for(int i = 0; i<nums;i++>)//再次历遍\n    {\n        if((nums[i]>>n ==1))//分组1\n        {\n            ret1^=nums[i];\n        }\n        else  //分组2\n        {\n            ret2^=nums[i];\n        }\n    }\n    ret[0] = ret1;\n    ret[1] = ret2;\n    return ret;\n}\n\n```\n\n思考:3个，4个....N个单身狗时呢？","source":"_posts/算法_按位异或.md","raw":"---\ntitle: =算法=按位异或^的种种玩法\ndate: 2023-09-04 07:05:48\ntags: 算法\n---\n## 什么是按位异或``^`` #\n首先将不同数制的数写成**二进制**,例如``9->0b1001``.\\\n然后最末位对齐，依次**按位异或**.\\\n规则:``0 ^ 0= 0 ; 1 ^ 1 = 0; 1 ^ 0 = 1``\\\n推论:任意整数``x``,都有``0^x = x``  ;   ``x ^ x = 0``\\\n***\n**来看看应用**\n## 寻找一个单身狗数 #\n像``[1,3,2,2,3]``这样除了某一个数``1``,剩下的数字都是成对的,也就是说遍历一次数组，把所有的元素**按位异或**在一起，结果便是落单的那个``1``\n```C\n//代码实现\nint arr[] = {1,3,2,2,3};\nint sz = sizeof(arr)/sizeof(arr[0]);//求数组大小\nint ret  = 0;\nfor (int i =0;i<sz;i++)\n{\n    ret^=arr[i];\n}\n\nreturn ret; //此时ret即为落单的那个数\n```\n**_变形_**\n## 消失的数 #\n已知一个由0\\~n(缺失一个数)填充的数组，例``[0,6,4,2,3,1]``,例中的数组少了一个``5``,而我们已知数组包含0\\~6中的5个数，就可以将数组元素与0~6**按位异或**到一起，将问题*消失的数*转化为问题*寻找单身狗*,消失的数变成剩下的那个单身狗\n```C\n//代码实现\nint missingNumber(int* nums, int numsSize)\n{\n    int ret = 0;\n    for(int i = 0;i<numsSize;i++>)\n    {\n        ret^=nums[i];//历遍nums的所有元素\n        ret^=i;//历遍0~numsSize-1\n    }\n    ret^=numsSize;//补上numsSize;\n    return ret;\n}\n```\n**_进阶_**\n## 找到两个单身狗 #\n数组再升级，单身狗变成了**两个**，导致不能粗暴地把所有元素按位异或来求出两个数,但我们仍可以将问题简化：能否将两个单身狗分到两个数组，使之转化为两个独立的*求单个单身狗问题*。于是难点来到了如何**分组**\n\n### 方案之一便是运用**按位异或**和**右移运算符** #\n因为两个不同的数，在二进制上作比较，就至少有一位是不同的，以那一位为``0``或``1``分成两组，便可将两个单身狗分开.而若要查找具体是哪一位，将列表中**所有元素**（就包括了两数）**按位异或**后再用**右移运算符**逐位检验是否为``1``,之后便可轻松分组，并直接**按位异或**得出结果\n\n```C\n//代码实现\nint* singleNumber(int* nums, int numsSize, int ret[2]){\n    int ret1 = 0;\n    int ret2 = 0;\n    int n = 0;//用于记录\"1\"在哪一位\n    int tmp = 0;\n    for(int i =0;i<numsSize;i++)\n    {\n        tmp^=nums[i];\n    }\n    while((tmp>>n) !=1 )\n    {\n        n++;\n    }\n    for(int i = 0; i<nums;i++>)//再次历遍\n    {\n        if((nums[i]>>n ==1))//分组1\n        {\n            ret1^=nums[i];\n        }\n        else  //分组2\n        {\n            ret2^=nums[i];\n        }\n    }\n    ret[0] = ret1;\n    ret[1] = ret2;\n    return ret;\n}\n\n```\n\n思考:3个，4个....N个单身狗时呢？","slug":"算法_按位异或","published":1,"updated":"2023-11-14T00:32:03.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08s00234sp577p5530m","content":"<h2 id=\"什么是按位异或\"><a href=\"#什么是按位异或\" class=\"headerlink\" title=\"什么是按位异或^\"></a>什么是按位异或<code>^</code></h2><p>首先将不同数制的数写成<strong>二进制</strong>,例如<code>9-&gt;0b1001</code>.<br>然后最末位对齐，依次<strong>按位异或</strong>.<br>规则:<code>0 ^ 0= 0 ; 1 ^ 1 = 0; 1 ^ 0 = 1</code><br>推论:任意整数<code>x</code>,都有<code>0^x = x</code>  ;   <code>x ^ x = 0</code>\\</p>\n<hr>\n<p><strong>来看看应用</strong></p>\n<h2 id=\"寻找一个单身狗数\"><a href=\"#寻找一个单身狗数\" class=\"headerlink\" title=\"寻找一个单身狗数\"></a>寻找一个单身狗数</h2><p>像<code>[1,3,2,2,3]</code>这样除了某一个数<code>1</code>,剩下的数字都是成对的,也就是说遍历一次数组，把所有的元素<strong>按位异或</strong>在一起，结果便是落单的那个<code>1</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>]);<span class=\"comment\">//求数组大小</span></span><br><span class=\"line\"><span class=\"type\">int</span> ret  = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;sz;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ret^=arr[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> ret; <span class=\"comment\">//此时ret即为落单的那个数</span></span><br></pre></td></tr></table></figure>\n<p><strong><em>变形</em></strong></p>\n<h2 id=\"消失的数\"><a href=\"#消失的数\" class=\"headerlink\" title=\"消失的数\"></a>消失的数</h2><p>已知一个由0~n(缺失一个数)填充的数组，例<code>[0,6,4,2,3,1]</code>,例中的数组少了一个<code>5</code>,而我们已知数组包含0~6中的5个数，就可以将数组元素与0~6<strong>按位异或</strong>到一起，将问题<em>消失的数</em>转化为问题<em>寻找单身狗</em>,消失的数变成剩下的那个单身狗</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">missingNumber</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;numsSize;i++&gt;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret^=nums[i];<span class=\"comment\">//历遍nums的所有元素</span></span><br><span class=\"line\">        ret^=i;<span class=\"comment\">//历遍0~numsSize-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret^=numsSize;<span class=\"comment\">//补上numsSize;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><em>进阶</em></strong></p>\n<h2 id=\"找到两个单身狗\"><a href=\"#找到两个单身狗\" class=\"headerlink\" title=\"找到两个单身狗\"></a>找到两个单身狗</h2><p>数组再升级，单身狗变成了<strong>两个</strong>，导致不能粗暴地把所有元素按位异或来求出两个数,但我们仍可以将问题简化：能否将两个单身狗分到两个数组，使之转化为两个独立的<em>求单个单身狗问题</em>。于是难点来到了如何<strong>分组</strong></p>\n<h3 id=\"方案之一便是运用按位异或和右移运算符\"><a href=\"#方案之一便是运用按位异或和右移运算符\" class=\"headerlink\" title=\"方案之一便是运用按位异或和右移运算符\"></a>方案之一便是运用<strong>按位异或</strong>和<strong>右移运算符</strong></h3><p>因为两个不同的数，在二进制上作比较，就至少有一位是不同的，以那一位为<code>0</code>或<code>1</code>分成两组，便可将两个单身狗分开.而若要查找具体是哪一位，将列表中<strong>所有元素</strong>（就包括了两数）<strong>按位异或</strong>后再用<strong>右移运算符</strong>逐位检验是否为<code>1</code>,之后便可轻松分组，并直接<strong>按位异或</strong>得出结果</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span>* <span class=\"title function_\">singleNumber</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize, <span class=\"type\">int</span> ret[<span class=\"number\">2</span>])</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;<span class=\"comment\">//用于记录&quot;1&quot;在哪一位</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;numsSize;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp^=nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((tmp&gt;&gt;n) !=<span class=\"number\">1</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;nums;i++&gt;)<span class=\"comment\">//再次历遍</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((nums[i]&gt;&gt;n ==<span class=\"number\">1</span>))<span class=\"comment\">//分组1</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ret1^=nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"comment\">//分组2</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ret2^=nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret[<span class=\"number\">0</span>] = ret1;</span><br><span class=\"line\">    ret[<span class=\"number\">1</span>] = ret2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>思考:3个，4个….N个单身狗时呢？</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/8329fbf20c80cb47e69112360c9d351e.jpg","cover_type":"img","excerpt":"","more":"<h2 id=\"什么是按位异或\"><a href=\"#什么是按位异或\" class=\"headerlink\" title=\"什么是按位异或^\"></a>什么是按位异或<code>^</code></h2><p>首先将不同数制的数写成<strong>二进制</strong>,例如<code>9-&gt;0b1001</code>.<br>然后最末位对齐，依次<strong>按位异或</strong>.<br>规则:<code>0 ^ 0= 0 ; 1 ^ 1 = 0; 1 ^ 0 = 1</code><br>推论:任意整数<code>x</code>,都有<code>0^x = x</code>  ;   <code>x ^ x = 0</code>\\</p>\n<hr>\n<p><strong>来看看应用</strong></p>\n<h2 id=\"寻找一个单身狗数\"><a href=\"#寻找一个单身狗数\" class=\"headerlink\" title=\"寻找一个单身狗数\"></a>寻找一个单身狗数</h2><p>像<code>[1,3,2,2,3]</code>这样除了某一个数<code>1</code>,剩下的数字都是成对的,也就是说遍历一次数组，把所有的元素<strong>按位异或</strong>在一起，结果便是落单的那个<code>1</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> sz = <span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>]);<span class=\"comment\">//求数组大小</span></span><br><span class=\"line\"><span class=\"type\">int</span> ret  = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;sz;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ret^=arr[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> ret; <span class=\"comment\">//此时ret即为落单的那个数</span></span><br></pre></td></tr></table></figure>\n<p><strong><em>变形</em></strong></p>\n<h2 id=\"消失的数\"><a href=\"#消失的数\" class=\"headerlink\" title=\"消失的数\"></a>消失的数</h2><p>已知一个由0~n(缺失一个数)填充的数组，例<code>[0,6,4,2,3,1]</code>,例中的数组少了一个<code>5</code>,而我们已知数组包含0~6中的5个数，就可以将数组元素与0~6<strong>按位异或</strong>到一起，将问题<em>消失的数</em>转化为问题<em>寻找单身狗</em>,消失的数变成剩下的那个单身狗</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">missingNumber</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;numsSize;i++&gt;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret^=nums[i];<span class=\"comment\">//历遍nums的所有元素</span></span><br><span class=\"line\">        ret^=i;<span class=\"comment\">//历遍0~numsSize-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret^=numsSize;<span class=\"comment\">//补上numsSize;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><em>进阶</em></strong></p>\n<h2 id=\"找到两个单身狗\"><a href=\"#找到两个单身狗\" class=\"headerlink\" title=\"找到两个单身狗\"></a>找到两个单身狗</h2><p>数组再升级，单身狗变成了<strong>两个</strong>，导致不能粗暴地把所有元素按位异或来求出两个数,但我们仍可以将问题简化：能否将两个单身狗分到两个数组，使之转化为两个独立的<em>求单个单身狗问题</em>。于是难点来到了如何<strong>分组</strong></p>\n<h3 id=\"方案之一便是运用按位异或和右移运算符\"><a href=\"#方案之一便是运用按位异或和右移运算符\" class=\"headerlink\" title=\"方案之一便是运用按位异或和右移运算符\"></a>方案之一便是运用<strong>按位异或</strong>和<strong>右移运算符</strong></h3><p>因为两个不同的数，在二进制上作比较，就至少有一位是不同的，以那一位为<code>0</code>或<code>1</code>分成两组，便可将两个单身狗分开.而若要查找具体是哪一位，将列表中<strong>所有元素</strong>（就包括了两数）<strong>按位异或</strong>后再用<strong>右移运算符</strong>逐位检验是否为<code>1</code>,之后便可轻松分组，并直接<strong>按位异或</strong>得出结果</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span>* <span class=\"title function_\">singleNumber</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize, <span class=\"type\">int</span> ret[<span class=\"number\">2</span>])</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;<span class=\"comment\">//用于记录&quot;1&quot;在哪一位</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>;i&lt;numsSize;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp^=nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((tmp&gt;&gt;n) !=<span class=\"number\">1</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;nums;i++&gt;)<span class=\"comment\">//再次历遍</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((nums[i]&gt;&gt;n ==<span class=\"number\">1</span>))<span class=\"comment\">//分组1</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ret1^=nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"comment\">//分组2</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ret2^=nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret[<span class=\"number\">0</span>] = ret1;</span><br><span class=\"line\">    ret[<span class=\"number\">1</span>] = ret2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>思考:3个，4个….N个单身狗时呢？</p>\n"},{"title":"=回顾-前端=从简陋的html到单网页再到全栈开发","date":"2023-09-23T01:58:24.000Z","_content":"[👉点我去作业一](https://picbed.supdriver.top/html/prj_basis++/index.html)\n\n[👉点我去作业二](https://picbed.supdriver.top/html/adc_v2/index.html)\n\n[👉点我去作业三](http://localhost:5173/)(抱歉，还没部署到服务器里，这个只能在我自己的电脑里用)\n\n[👉点我去作业四](https://picbed.supdriver.top/video/never.mp4)\n\n~~其实这依然是个博客~~\n\n---\n# 粗糙的作业一 #\n当时只学过html,css,js的快速入门，对盒子`<div>`的玩法还不太熟，还只会用浮动盒子`float`和绝对定位,结局就是写两句html就得清除浮动~~233~~,甚至`<lenged>`也不认识，结果手动用css给实现了。总之就挺简陋的\n\n# 精致~~(并不)~~作业二 #\n用vscode写作业二的时候，写一半发现鼠标悬停在`tag`时，它会给出去往[*MDN*](https://developer.mozilla.org/zh-CN/)对应参考页的连接,然后就开始一边写一边阅读MDN,结果一发不可收拾，开始读的时间比写的时间还长。最后成功学到神器~~bushi~~`flex`**弹性盒子模型。**。\n\n但还没完，除了参阅文档，我还多次在B站首页和MC百度百科首页打开`F12`,查看，学习他们是如何布局盒子的，别说，学成品也挺有用的，对盒子的排版，嵌套的想法成熟多了\n\n结合二者，照着图片做一个网页便没什么问题了。那个作业二我甚至直接弃掉了初版（已经把顶部做好了）version2基本完全采用`flex盒子`。比较遗憾的是，虽然每个菜单按钮都加了超链接，但是对应的网页并没有做出来（创作力有限）。但至少是个合格的花瓶，嘿嘿\n\n# 速成作业三 #\n因为作业三没部署到服务器上，只能文字描述了（悲）\n\n作业三我选的是用`vue`搭建个人博客，我先是自学了几天vue,结果发现光学vue就做不了个人博客，于是在B站上找了个时长6小时的全栈开发，用`js`写的服务端，数据库用`sqlite`,前端框架是`vue`.\n\n好家伙，5天爆肝项目（包括但不限于*抄代码*,*找bug*,*找bug*,*找bug*），成功把博客的基本功能写完了。除了`Naive UI`的代码是复制**组件库**里的，剩下的代码基本都是我**手打**的，可以说忙得不亦乐乎，而且当时我并不太懂`js语法`，体验可以说是相当刺激了。\n\n但**回报不小**，就算不能说入门吧，到时候自己加功能，照葫芦画瓢，自己写`js`的能力还是有了滴。而且这也是我首次**接触数据库**,混个脸熟，嘿嘿。而且**最重要**的一点，我成功增加了一个**高自由度的个人博客**，~~讲真hexo的各自魔改我不太玩的懂~~。\n\n## 尾声 #\n作业三部曲之后，我大概就不太去碰前端了，至少一周爆肝一个全栈开发项目这种疯狂的行为不会再有了，权当是一次挑战罢，一次冒险，一次对边界的探索罢。重心很明确，对前端顶多写写像这篇博客一样的感悟，技术博客主要还是在后端语言，算法，数据结构之类\n","source":"_posts/vueTheRoad.md","raw":"---\ntitle: =回顾-前端=从简陋的html到单网页再到全栈开发\ndate: 2023-09-23 09:58:24\ntags: 回顾\n---\n[👉点我去作业一](https://picbed.supdriver.top/html/prj_basis++/index.html)\n\n[👉点我去作业二](https://picbed.supdriver.top/html/adc_v2/index.html)\n\n[👉点我去作业三](http://localhost:5173/)(抱歉，还没部署到服务器里，这个只能在我自己的电脑里用)\n\n[👉点我去作业四](https://picbed.supdriver.top/video/never.mp4)\n\n~~其实这依然是个博客~~\n\n---\n# 粗糙的作业一 #\n当时只学过html,css,js的快速入门，对盒子`<div>`的玩法还不太熟，还只会用浮动盒子`float`和绝对定位,结局就是写两句html就得清除浮动~~233~~,甚至`<lenged>`也不认识，结果手动用css给实现了。总之就挺简陋的\n\n# 精致~~(并不)~~作业二 #\n用vscode写作业二的时候，写一半发现鼠标悬停在`tag`时，它会给出去往[*MDN*](https://developer.mozilla.org/zh-CN/)对应参考页的连接,然后就开始一边写一边阅读MDN,结果一发不可收拾，开始读的时间比写的时间还长。最后成功学到神器~~bushi~~`flex`**弹性盒子模型。**。\n\n但还没完，除了参阅文档，我还多次在B站首页和MC百度百科首页打开`F12`,查看，学习他们是如何布局盒子的，别说，学成品也挺有用的，对盒子的排版，嵌套的想法成熟多了\n\n结合二者，照着图片做一个网页便没什么问题了。那个作业二我甚至直接弃掉了初版（已经把顶部做好了）version2基本完全采用`flex盒子`。比较遗憾的是，虽然每个菜单按钮都加了超链接，但是对应的网页并没有做出来（创作力有限）。但至少是个合格的花瓶，嘿嘿\n\n# 速成作业三 #\n因为作业三没部署到服务器上，只能文字描述了（悲）\n\n作业三我选的是用`vue`搭建个人博客，我先是自学了几天vue,结果发现光学vue就做不了个人博客，于是在B站上找了个时长6小时的全栈开发，用`js`写的服务端，数据库用`sqlite`,前端框架是`vue`.\n\n好家伙，5天爆肝项目（包括但不限于*抄代码*,*找bug*,*找bug*,*找bug*），成功把博客的基本功能写完了。除了`Naive UI`的代码是复制**组件库**里的，剩下的代码基本都是我**手打**的，可以说忙得不亦乐乎，而且当时我并不太懂`js语法`，体验可以说是相当刺激了。\n\n但**回报不小**，就算不能说入门吧，到时候自己加功能，照葫芦画瓢，自己写`js`的能力还是有了滴。而且这也是我首次**接触数据库**,混个脸熟，嘿嘿。而且**最重要**的一点，我成功增加了一个**高自由度的个人博客**，~~讲真hexo的各自魔改我不太玩的懂~~。\n\n## 尾声 #\n作业三部曲之后，我大概就不太去碰前端了，至少一周爆肝一个全栈开发项目这种疯狂的行为不会再有了，权当是一次挑战罢，一次冒险，一次对边界的探索罢。重心很明确，对前端顶多写写像这篇博客一样的感悟，技术博客主要还是在后端语言，算法，数据结构之类\n","slug":"vueTheRoad","published":1,"updated":"2024-05-14T02:22:12.821Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08t00254sp51g1xbwp7","content":"<p><a href=\"https://picbed.supdriver.top/html/prj_basis++/index.html\">👉点我去作业一</a></p>\n<p><a href=\"https://picbed.supdriver.top/html/adc_v2/index.html\">👉点我去作业二</a></p>\n<p><a href=\"http://localhost:5173/\">👉点我去作业三</a>(抱歉，还没部署到服务器里，这个只能在我自己的电脑里用)</p>\n<p><a href=\"https://picbed.supdriver.top/video/never.mp4\">👉点我去作业四</a></p>\n<p><del>其实这依然是个博客</del></p>\n<hr>\n<h1 id=\"粗糙的作业一\"><a href=\"#粗糙的作业一\" class=\"headerlink\" title=\"粗糙的作业一\"></a>粗糙的作业一</h1><p>当时只学过html,css,js的快速入门，对盒子<code>&lt;div&gt;</code>的玩法还不太熟，还只会用浮动盒子<code>float</code>和绝对定位,结局就是写两句html就得清除浮动<del>233</del>,甚至<code>&lt;lenged&gt;</code>也不认识，结果手动用css给实现了。总之就挺简陋的</p>\n<h1 id=\"精致-并不-作业二\"><a href=\"#精致-并不-作业二\" class=\"headerlink\" title=\"精致(并不)作业二\"></a>精致<del>(并不)</del>作业二</h1><p>用vscode写作业二的时候，写一半发现鼠标悬停在<code>tag</code>时，它会给出去往<a href=\"https://developer.mozilla.org/zh-CN/\"><em>MDN</em></a>对应参考页的连接,然后就开始一边写一边阅读MDN,结果一发不可收拾，开始读的时间比写的时间还长。最后成功学到神器<del>bushi</del><code>flex</code><strong>弹性盒子模型。</strong>。</p>\n<p>但还没完，除了参阅文档，我还多次在B站首页和MC百度百科首页打开<code>F12</code>,查看，学习他们是如何布局盒子的，别说，学成品也挺有用的，对盒子的排版，嵌套的想法成熟多了</p>\n<p>结合二者，照着图片做一个网页便没什么问题了。那个作业二我甚至直接弃掉了初版（已经把顶部做好了）version2基本完全采用<code>flex盒子</code>。比较遗憾的是，虽然每个菜单按钮都加了超链接，但是对应的网页并没有做出来（创作力有限）。但至少是个合格的花瓶，嘿嘿</p>\n<h1 id=\"速成作业三\"><a href=\"#速成作业三\" class=\"headerlink\" title=\"速成作业三\"></a>速成作业三</h1><p>因为作业三没部署到服务器上，只能文字描述了（悲）</p>\n<p>作业三我选的是用<code>vue</code>搭建个人博客，我先是自学了几天vue,结果发现光学vue就做不了个人博客，于是在B站上找了个时长6小时的全栈开发，用<code>js</code>写的服务端，数据库用<code>sqlite</code>,前端框架是<code>vue</code>.</p>\n<p>好家伙，5天爆肝项目（包括但不限于<em>抄代码</em>,<em>找bug</em>,<em>找bug</em>,<em>找bug</em>），成功把博客的基本功能写完了。除了<code>Naive UI</code>的代码是复制<strong>组件库</strong>里的，剩下的代码基本都是我<strong>手打</strong>的，可以说忙得不亦乐乎，而且当时我并不太懂<code>js语法</code>，体验可以说是相当刺激了。</p>\n<p>但<strong>回报不小</strong>，就算不能说入门吧，到时候自己加功能，照葫芦画瓢，自己写<code>js</code>的能力还是有了滴。而且这也是我首次<strong>接触数据库</strong>,混个脸熟，嘿嘿。而且<strong>最重要</strong>的一点，我成功增加了一个<strong>高自由度的个人博客</strong>，<del>讲真hexo的各自魔改我不太玩的懂</del>。</p>\n<h2 id=\"尾声\"><a href=\"#尾声\" class=\"headerlink\" title=\"尾声\"></a>尾声</h2><p>作业三部曲之后，我大概就不太去碰前端了，至少一周爆肝一个全栈开发项目这种疯狂的行为不会再有了，权当是一次挑战罢，一次冒险，一次对边界的探索罢。重心很明确，对前端顶多写写像这篇博客一样的感悟，技术博客主要还是在后端语言，算法，数据结构之类</p>\n","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/416b331ca8312ea153216646882e9ed9.jpg","cover_type":"img","excerpt":"","more":"<p><a href=\"https://picbed.supdriver.top/html/prj_basis++/index.html\">👉点我去作业一</a></p>\n<p><a href=\"https://picbed.supdriver.top/html/adc_v2/index.html\">👉点我去作业二</a></p>\n<p><a href=\"http://localhost:5173/\">👉点我去作业三</a>(抱歉，还没部署到服务器里，这个只能在我自己的电脑里用)</p>\n<p><a href=\"https://picbed.supdriver.top/video/never.mp4\">👉点我去作业四</a></p>\n<p><del>其实这依然是个博客</del></p>\n<hr>\n<h1 id=\"粗糙的作业一\"><a href=\"#粗糙的作业一\" class=\"headerlink\" title=\"粗糙的作业一\"></a>粗糙的作业一</h1><p>当时只学过html,css,js的快速入门，对盒子<code>&lt;div&gt;</code>的玩法还不太熟，还只会用浮动盒子<code>float</code>和绝对定位,结局就是写两句html就得清除浮动<del>233</del>,甚至<code>&lt;lenged&gt;</code>也不认识，结果手动用css给实现了。总之就挺简陋的</p>\n<h1 id=\"精致-并不-作业二\"><a href=\"#精致-并不-作业二\" class=\"headerlink\" title=\"精致(并不)作业二\"></a>精致<del>(并不)</del>作业二</h1><p>用vscode写作业二的时候，写一半发现鼠标悬停在<code>tag</code>时，它会给出去往<a href=\"https://developer.mozilla.org/zh-CN/\"><em>MDN</em></a>对应参考页的连接,然后就开始一边写一边阅读MDN,结果一发不可收拾，开始读的时间比写的时间还长。最后成功学到神器<del>bushi</del><code>flex</code><strong>弹性盒子模型。</strong>。</p>\n<p>但还没完，除了参阅文档，我还多次在B站首页和MC百度百科首页打开<code>F12</code>,查看，学习他们是如何布局盒子的，别说，学成品也挺有用的，对盒子的排版，嵌套的想法成熟多了</p>\n<p>结合二者，照着图片做一个网页便没什么问题了。那个作业二我甚至直接弃掉了初版（已经把顶部做好了）version2基本完全采用<code>flex盒子</code>。比较遗憾的是，虽然每个菜单按钮都加了超链接，但是对应的网页并没有做出来（创作力有限）。但至少是个合格的花瓶，嘿嘿</p>\n<h1 id=\"速成作业三\"><a href=\"#速成作业三\" class=\"headerlink\" title=\"速成作业三\"></a>速成作业三</h1><p>因为作业三没部署到服务器上，只能文字描述了（悲）</p>\n<p>作业三我选的是用<code>vue</code>搭建个人博客，我先是自学了几天vue,结果发现光学vue就做不了个人博客，于是在B站上找了个时长6小时的全栈开发，用<code>js</code>写的服务端，数据库用<code>sqlite</code>,前端框架是<code>vue</code>.</p>\n<p>好家伙，5天爆肝项目（包括但不限于<em>抄代码</em>,<em>找bug</em>,<em>找bug</em>,<em>找bug</em>），成功把博客的基本功能写完了。除了<code>Naive UI</code>的代码是复制<strong>组件库</strong>里的，剩下的代码基本都是我<strong>手打</strong>的，可以说忙得不亦乐乎，而且当时我并不太懂<code>js语法</code>，体验可以说是相当刺激了。</p>\n<p>但<strong>回报不小</strong>，就算不能说入门吧，到时候自己加功能，照葫芦画瓢，自己写<code>js</code>的能力还是有了滴。而且这也是我首次<strong>接触数据库</strong>,混个脸熟，嘿嘿。而且<strong>最重要</strong>的一点，我成功增加了一个<strong>高自由度的个人博客</strong>，<del>讲真hexo的各自魔改我不太玩的懂</del>。</p>\n<h2 id=\"尾声\"><a href=\"#尾声\" class=\"headerlink\" title=\"尾声\"></a>尾声</h2><p>作业三部曲之后，我大概就不太去碰前端了，至少一周爆肝一个全栈开发项目这种疯狂的行为不会再有了，权当是一次挑战罢，一次冒险，一次对边界的探索罢。重心很明确，对前端顶多写写像这篇博客一样的感悟，技术博客主要还是在后端语言，算法，数据结构之类</p>\n"},{"title":"=算法=双指针的种种应用(更新中)","date":"2023-09-12T10:40:44.000Z","cover":"https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-34-45.jpg","_content":"\n*注：本文写于C语言学习早期，双指针的用法较为基础且不全面。本文章将涉及C语言数组至数据结构的链表*\n\n## Q:为什么要用双指针? #\nA:因为\n通过使用双指针可以使算法的**时间复杂度降低**(或者降低遍历次数),有时也能**降低空间复杂度**\n\n## 分类 #\n根据双指针的用法，可分为**前后双指针**,**头尾双指针**,**快慢双指针**.....\n\n---\n# 以下为各种双指针的应用及介绍 #\n## 前后双指针 #\n\n#### 应用一 删除排序数组中的重复项 #\n**要求**:原地删除,并返回新数组的长度，不需要考虑数组中超出新长度后面的元素。\n\n**思路**:通过创建一前一后两个指针，**前指针**指向**上一个元素**，**后指针**向后历遍,一旦**找到**不同的元素,前指针指向**下一个位置，并视为空位**，通过**后指针**找到目标元素,并存入前指针目前所指向的**空位**。然后**后指针**接着遍历，直至遍历整个数组.\n\n```C\n//代码实现\nint removeDuplicates(int* nums, int numsSize){\n    int* left = nums;\n    int*right = nums+1;\n    int ret = 1;\n    //遍历数组\n    for (int i=0;i<numsSize-1;i++)\n    {\n        if(*left != *right)\n        {\n            left++;\n            *left = *right;\n            right++;\n            ret++;\n        }\n        else\n        {\n            right++;\n        }\n    }\n    return ret;\n}\n```\n**分析**:这个函数只遍历的一遍数组，没有复制数组,所以**时间复杂度**为``O(n)``,**空间复杂度**为``O(1)``;\n\n---\n## 头尾双指针 #\n#### 应用一 翻转数组/字符串 #\n关于翻转，首先想到的应该是创建一个**等长的空数组**，再同时顺序遍历**原数组**和逆序遍历**空数组**，逐位储存到空数组，然后再同时顺序遍历两个数组，将**已逆序**的数组拷贝至原数组\n\n**缺点**：需要**多次**遍历，且**空间复杂度**为O(n)\n\n**使用双指针优化**：整个数组的翻转可逐步拆解为：第一个和最后一个互换、第二个和倒数第二个互换、、、第N个数和倒数第N个数互换，直至中间。此处便可使用**双指针**，头尾指针各自一边**交换**所指向的内容，一边**向中间靠近**\n```C\n//代码实现-这里是翻转字符串\nvoid reverseString(char* s, int sSize){\n    int *left = s;//头指针\n    int *right = s + sSize-1;//尾指针\n    while(left<right)//尚未到达中间时\n    {\n        char tmp = *left;\n        *left = *right;\n        *right = tmp;\n        left++;\n        right--;\n    }\n}\n```\n\n---\n## 快慢双指针 #\n#### 应用一 删除链表倒数第K个节点  #\n**一般解法**：先遍历一遍链表获得链表总数N,再二次遍历到N-K处的节点，并执行删除\n\n**如何优化**：使用快慢双指针，仅需遍历一次，就能用慢指针定位目标节点\n\n```C\n//代码实现\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\n    //创建哨兵位解决头删问题\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n    dummy->val = 0;\n    dummy->next = head;\n\n    struct ListNode* slow = dummy;\n    struct ListNode* fast = dummy;\n    while (int i = 0;i<n+1;n++)//移动fast\n    {\n        fast = fast->next;\n    }\n    \n    while(fast != NULL)//同时遍历\n    {\n        fast= fast->next;\n        slow= slow->next;\n    }\n    //此时slow指向目标节点的前一个节点\n    struct ListNode* tmp = slow->next;\n    slow->next = slow->next->next;\n    free(tmp);\n    return dummy->next;\n}\n```\n\n\n#### 应用二 找出并返回链表中间的节点 #\n\n**注**:偶数个节点时删除**前一个**中间节点\n\n**一般解法**：依然是先遍历一遍链表，然后定位中间的节点,二次遍历\n\n**如何优化**：使用**慢指针**(一步走一个节点)和**快指针**(一步走两个节点)，二者同时遍历，直至**快指针**指向`NULL`或快指针指向`尾节点`\n\n当遍历结束时，慢指针指向目标中间节点\n\n```C\n//代码实现\nstruct ListNode* middleNode(struct ListNode* head){\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n    while(fast && fast->next)\n    {\n        slow = slow->next;\n        fast = fast->next->next; \n    }\n\n    return slow;\n}\n```\n\n## 应用三 循环链表问题 #\n","source":"_posts/双指针.md","raw":"---\ntitle: =算法=双指针的种种应用(更新中)\ndate: 2023-09-12 18:40:44\ntags: 算法\ncover: https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/Snipaste_2023-11-02_10-34-45.jpg\n---\n\n*注：本文写于C语言学习早期，双指针的用法较为基础且不全面。本文章将涉及C语言数组至数据结构的链表*\n\n## Q:为什么要用双指针? #\nA:因为\n通过使用双指针可以使算法的**时间复杂度降低**(或者降低遍历次数),有时也能**降低空间复杂度**\n\n## 分类 #\n根据双指针的用法，可分为**前后双指针**,**头尾双指针**,**快慢双指针**.....\n\n---\n# 以下为各种双指针的应用及介绍 #\n## 前后双指针 #\n\n#### 应用一 删除排序数组中的重复项 #\n**要求**:原地删除,并返回新数组的长度，不需要考虑数组中超出新长度后面的元素。\n\n**思路**:通过创建一前一后两个指针，**前指针**指向**上一个元素**，**后指针**向后历遍,一旦**找到**不同的元素,前指针指向**下一个位置，并视为空位**，通过**后指针**找到目标元素,并存入前指针目前所指向的**空位**。然后**后指针**接着遍历，直至遍历整个数组.\n\n```C\n//代码实现\nint removeDuplicates(int* nums, int numsSize){\n    int* left = nums;\n    int*right = nums+1;\n    int ret = 1;\n    //遍历数组\n    for (int i=0;i<numsSize-1;i++)\n    {\n        if(*left != *right)\n        {\n            left++;\n            *left = *right;\n            right++;\n            ret++;\n        }\n        else\n        {\n            right++;\n        }\n    }\n    return ret;\n}\n```\n**分析**:这个函数只遍历的一遍数组，没有复制数组,所以**时间复杂度**为``O(n)``,**空间复杂度**为``O(1)``;\n\n---\n## 头尾双指针 #\n#### 应用一 翻转数组/字符串 #\n关于翻转，首先想到的应该是创建一个**等长的空数组**，再同时顺序遍历**原数组**和逆序遍历**空数组**，逐位储存到空数组，然后再同时顺序遍历两个数组，将**已逆序**的数组拷贝至原数组\n\n**缺点**：需要**多次**遍历，且**空间复杂度**为O(n)\n\n**使用双指针优化**：整个数组的翻转可逐步拆解为：第一个和最后一个互换、第二个和倒数第二个互换、、、第N个数和倒数第N个数互换，直至中间。此处便可使用**双指针**，头尾指针各自一边**交换**所指向的内容，一边**向中间靠近**\n```C\n//代码实现-这里是翻转字符串\nvoid reverseString(char* s, int sSize){\n    int *left = s;//头指针\n    int *right = s + sSize-1;//尾指针\n    while(left<right)//尚未到达中间时\n    {\n        char tmp = *left;\n        *left = *right;\n        *right = tmp;\n        left++;\n        right--;\n    }\n}\n```\n\n---\n## 快慢双指针 #\n#### 应用一 删除链表倒数第K个节点  #\n**一般解法**：先遍历一遍链表获得链表总数N,再二次遍历到N-K处的节点，并执行删除\n\n**如何优化**：使用快慢双指针，仅需遍历一次，就能用慢指针定位目标节点\n\n```C\n//代码实现\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\n    //创建哨兵位解决头删问题\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n    dummy->val = 0;\n    dummy->next = head;\n\n    struct ListNode* slow = dummy;\n    struct ListNode* fast = dummy;\n    while (int i = 0;i<n+1;n++)//移动fast\n    {\n        fast = fast->next;\n    }\n    \n    while(fast != NULL)//同时遍历\n    {\n        fast= fast->next;\n        slow= slow->next;\n    }\n    //此时slow指向目标节点的前一个节点\n    struct ListNode* tmp = slow->next;\n    slow->next = slow->next->next;\n    free(tmp);\n    return dummy->next;\n}\n```\n\n\n#### 应用二 找出并返回链表中间的节点 #\n\n**注**:偶数个节点时删除**前一个**中间节点\n\n**一般解法**：依然是先遍历一遍链表，然后定位中间的节点,二次遍历\n\n**如何优化**：使用**慢指针**(一步走一个节点)和**快指针**(一步走两个节点)，二者同时遍历，直至**快指针**指向`NULL`或快指针指向`尾节点`\n\n当遍历结束时，慢指针指向目标中间节点\n\n```C\n//代码实现\nstruct ListNode* middleNode(struct ListNode* head){\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n    while(fast && fast->next)\n    {\n        slow = slow->next;\n        fast = fast->next->next; \n    }\n\n    return slow;\n}\n```\n\n## 应用三 循环链表问题 #\n","slug":"双指针","published":1,"updated":"2024-05-08T23:46:46.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm155p08u00274sp5btru5cjt","content":"<p><em>注：本文写于C语言学习早期，双指针的用法较为基础且不全面。本文章将涉及C语言数组至数据结构的链表</em></p>\n<h2 id=\"Q-为什么要用双指针\"><a href=\"#Q-为什么要用双指针\" class=\"headerlink\" title=\"Q:为什么要用双指针?\"></a>Q:为什么要用双指针?</h2><p>A:因为<br>通过使用双指针可以使算法的<strong>时间复杂度降低</strong>(或者降低遍历次数),有时也能<strong>降低空间复杂度</strong></p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>根据双指针的用法，可分为<strong>前后双指针</strong>,<strong>头尾双指针</strong>,<strong>快慢双指针</strong>…..</p>\n<hr>\n<h1 id=\"以下为各种双指针的应用及介绍\"><a href=\"#以下为各种双指针的应用及介绍\" class=\"headerlink\" title=\"以下为各种双指针的应用及介绍\"></a>以下为各种双指针的应用及介绍</h1><h2 id=\"前后双指针\"><a href=\"#前后双指针\" class=\"headerlink\" title=\"前后双指针\"></a>前后双指针</h2><h4 id=\"应用一-删除排序数组中的重复项\"><a href=\"#应用一-删除排序数组中的重复项\" class=\"headerlink\" title=\"应用一 删除排序数组中的重复项\"></a>应用一 删除排序数组中的重复项</h4><p><strong>要求</strong>:原地删除,并返回新数组的长度，不需要考虑数组中超出新长度后面的元素。</p>\n<p><strong>思路</strong>:通过创建一前一后两个指针，<strong>前指针</strong>指向<strong>上一个元素</strong>，<strong>后指针</strong>向后历遍,一旦<strong>找到</strong>不同的元素,前指针指向<strong>下一个位置，并视为空位</strong>，通过<strong>后指针</strong>找到目标元素,并存入前指针目前所指向的<strong>空位</strong>。然后<strong>后指针</strong>接着遍历，直至遍历整个数组.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">removeDuplicates</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>* left = nums;</span><br><span class=\"line\">    <span class=\"type\">int</span>*right = nums+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//遍历数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*left != *right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            *left = *right;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">            ret++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析</strong>:这个函数只遍历的一遍数组，没有复制数组,所以<strong>时间复杂度</strong>为<code>O(n)</code>,<strong>空间复杂度</strong>为<code>O(1)</code>;</p>\n<hr>\n<h2 id=\"头尾双指针\"><a href=\"#头尾双指针\" class=\"headerlink\" title=\"头尾双指针\"></a>头尾双指针</h2><h4 id=\"应用一-翻转数组-字符串\"><a href=\"#应用一-翻转数组-字符串\" class=\"headerlink\" title=\"应用一 翻转数组&#x2F;字符串\"></a>应用一 翻转数组&#x2F;字符串</h4><p>关于翻转，首先想到的应该是创建一个<strong>等长的空数组</strong>，再同时顺序遍历<strong>原数组</strong>和逆序遍历<strong>空数组</strong>，逐位储存到空数组，然后再同时顺序遍历两个数组，将<strong>已逆序</strong>的数组拷贝至原数组</p>\n<p><strong>缺点</strong>：需要<strong>多次</strong>遍历，且<strong>空间复杂度</strong>为O(n)</p>\n<p><strong>使用双指针优化</strong>：整个数组的翻转可逐步拆解为：第一个和最后一个互换、第二个和倒数第二个互换、、、第N个数和倒数第N个数互换，直至中间。此处便可使用<strong>双指针</strong>，头尾指针各自一边<strong>交换</strong>所指向的内容，一边<strong>向中间靠近</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现-这里是翻转字符串</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">reverseString</span><span class=\"params\">(<span class=\"type\">char</span>* s, <span class=\"type\">int</span> sSize)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *left = s;<span class=\"comment\">//头指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *right = s + sSize<span class=\"number\">-1</span>;<span class=\"comment\">//尾指针</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left&lt;right)<span class=\"comment\">//尚未到达中间时</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> tmp = *left;</span><br><span class=\"line\">        *left = *right;</span><br><span class=\"line\">        *right = tmp;</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"快慢双指针\"><a href=\"#快慢双指针\" class=\"headerlink\" title=\"快慢双指针\"></a>快慢双指针</h2><h4 id=\"应用一-删除链表倒数第K个节点\"><a href=\"#应用一-删除链表倒数第K个节点\" class=\"headerlink\" title=\"应用一 删除链表倒数第K个节点\"></a>应用一 删除链表倒数第K个节点</h4><p><strong>一般解法</strong>：先遍历一遍链表获得链表总数N,再二次遍历到N-K处的节点，并执行删除</p>\n<p><strong>如何优化</strong>：使用快慢双指针，仅需遍历一次，就能用慢指针定位目标节点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">removeNthFromEnd</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head, <span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建哨兵位解决头删问题</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">dummy</span> =</span> (<span class=\"keyword\">struct</span> ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> ListNode));</span><br><span class=\"line\">    dummy-&gt;val = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dummy-&gt;next = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">slow</span> =</span> dummy;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">fast</span> =</span> dummy;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n+<span class=\"number\">1</span>;n++)<span class=\"comment\">//移动fast</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast != <span class=\"literal\">NULL</span>)<span class=\"comment\">//同时遍历</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fast= fast-&gt;next;</span><br><span class=\"line\">        slow= slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//此时slow指向目标节点的前一个节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">tmp</span> =</span> slow-&gt;next;</span><br><span class=\"line\">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"应用二-找出并返回链表中间的节点\"><a href=\"#应用二-找出并返回链表中间的节点\" class=\"headerlink\" title=\"应用二 找出并返回链表中间的节点\"></a>应用二 找出并返回链表中间的节点</h4><p><strong>注</strong>:偶数个节点时删除<strong>前一个</strong>中间节点</p>\n<p><strong>一般解法</strong>：依然是先遍历一遍链表，然后定位中间的节点,二次遍历</p>\n<p><strong>如何优化</strong>：使用<strong>慢指针</strong>(一步走一个节点)和<strong>快指针</strong>(一步走两个节点)，二者同时遍历，直至<strong>快指针</strong>指向<code>NULL</code>或快指针指向<code>尾节点</code></p>\n<p>当遍历结束时，慢指针指向目标中间节点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">middleNode</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head)</span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">slow</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">fast</span> =</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用三-循环链表问题\"><a href=\"#应用三-循环链表问题\" class=\"headerlink\" title=\"应用三 循环链表问题\"></a>应用三 循环链表问题</h2>","site":{"data":{"link":[{"class_name":"1.技术支持","class_desc":"本网站的搭建由以下开源作者提供技术支持","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-cn/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架","siteshot":"https://source.fomal.cc/siteshot/hexo.io.jpg"}]},{"class_name":"2.友情链接","class_desc":"一些好朋友~~","link_list":[{"name":"Fomalhaut🥝","link":"https://fomal.cc/","avatar":"/assets/head.jpg","descr":"Future is now 🍭🍭🍭","siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"},{"name":"Lwt","link":"https://www.lwt-server.cn/","avatar":"https://www.lwt-server.cn/images/avatar.jpg","descr":null,"siteshot":"https://source.fomal.cc/siteshot/www.fomal.cn.jpg"}]}]}},"cover_type":"img","excerpt":"","more":"<p><em>注：本文写于C语言学习早期，双指针的用法较为基础且不全面。本文章将涉及C语言数组至数据结构的链表</em></p>\n<h2 id=\"Q-为什么要用双指针\"><a href=\"#Q-为什么要用双指针\" class=\"headerlink\" title=\"Q:为什么要用双指针?\"></a>Q:为什么要用双指针?</h2><p>A:因为<br>通过使用双指针可以使算法的<strong>时间复杂度降低</strong>(或者降低遍历次数),有时也能<strong>降低空间复杂度</strong></p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>根据双指针的用法，可分为<strong>前后双指针</strong>,<strong>头尾双指针</strong>,<strong>快慢双指针</strong>…..</p>\n<hr>\n<h1 id=\"以下为各种双指针的应用及介绍\"><a href=\"#以下为各种双指针的应用及介绍\" class=\"headerlink\" title=\"以下为各种双指针的应用及介绍\"></a>以下为各种双指针的应用及介绍</h1><h2 id=\"前后双指针\"><a href=\"#前后双指针\" class=\"headerlink\" title=\"前后双指针\"></a>前后双指针</h2><h4 id=\"应用一-删除排序数组中的重复项\"><a href=\"#应用一-删除排序数组中的重复项\" class=\"headerlink\" title=\"应用一 删除排序数组中的重复项\"></a>应用一 删除排序数组中的重复项</h4><p><strong>要求</strong>:原地删除,并返回新数组的长度，不需要考虑数组中超出新长度后面的元素。</p>\n<p><strong>思路</strong>:通过创建一前一后两个指针，<strong>前指针</strong>指向<strong>上一个元素</strong>，<strong>后指针</strong>向后历遍,一旦<strong>找到</strong>不同的元素,前指针指向<strong>下一个位置，并视为空位</strong>，通过<strong>后指针</strong>找到目标元素,并存入前指针目前所指向的<strong>空位</strong>。然后<strong>后指针</strong>接着遍历，直至遍历整个数组.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">removeDuplicates</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> numsSize)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>* left = nums;</span><br><span class=\"line\">    <span class=\"type\">int</span>*right = nums+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//遍历数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*left != *right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            *left = *right;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">            ret++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析</strong>:这个函数只遍历的一遍数组，没有复制数组,所以<strong>时间复杂度</strong>为<code>O(n)</code>,<strong>空间复杂度</strong>为<code>O(1)</code>;</p>\n<hr>\n<h2 id=\"头尾双指针\"><a href=\"#头尾双指针\" class=\"headerlink\" title=\"头尾双指针\"></a>头尾双指针</h2><h4 id=\"应用一-翻转数组-字符串\"><a href=\"#应用一-翻转数组-字符串\" class=\"headerlink\" title=\"应用一 翻转数组&#x2F;字符串\"></a>应用一 翻转数组&#x2F;字符串</h4><p>关于翻转，首先想到的应该是创建一个<strong>等长的空数组</strong>，再同时顺序遍历<strong>原数组</strong>和逆序遍历<strong>空数组</strong>，逐位储存到空数组，然后再同时顺序遍历两个数组，将<strong>已逆序</strong>的数组拷贝至原数组</p>\n<p><strong>缺点</strong>：需要<strong>多次</strong>遍历，且<strong>空间复杂度</strong>为O(n)</p>\n<p><strong>使用双指针优化</strong>：整个数组的翻转可逐步拆解为：第一个和最后一个互换、第二个和倒数第二个互换、、、第N个数和倒数第N个数互换，直至中间。此处便可使用<strong>双指针</strong>，头尾指针各自一边<strong>交换</strong>所指向的内容，一边<strong>向中间靠近</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现-这里是翻转字符串</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">reverseString</span><span class=\"params\">(<span class=\"type\">char</span>* s, <span class=\"type\">int</span> sSize)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *left = s;<span class=\"comment\">//头指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *right = s + sSize<span class=\"number\">-1</span>;<span class=\"comment\">//尾指针</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left&lt;right)<span class=\"comment\">//尚未到达中间时</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> tmp = *left;</span><br><span class=\"line\">        *left = *right;</span><br><span class=\"line\">        *right = tmp;</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"快慢双指针\"><a href=\"#快慢双指针\" class=\"headerlink\" title=\"快慢双指针\"></a>快慢双指针</h2><h4 id=\"应用一-删除链表倒数第K个节点\"><a href=\"#应用一-删除链表倒数第K个节点\" class=\"headerlink\" title=\"应用一 删除链表倒数第K个节点\"></a>应用一 删除链表倒数第K个节点</h4><p><strong>一般解法</strong>：先遍历一遍链表获得链表总数N,再二次遍历到N-K处的节点，并执行删除</p>\n<p><strong>如何优化</strong>：使用快慢双指针，仅需遍历一次，就能用慢指针定位目标节点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">removeNthFromEnd</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head, <span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建哨兵位解决头删问题</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">dummy</span> =</span> (<span class=\"keyword\">struct</span> ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> ListNode));</span><br><span class=\"line\">    dummy-&gt;val = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dummy-&gt;next = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">slow</span> =</span> dummy;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">fast</span> =</span> dummy;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;n+<span class=\"number\">1</span>;n++)<span class=\"comment\">//移动fast</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast != <span class=\"literal\">NULL</span>)<span class=\"comment\">//同时遍历</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fast= fast-&gt;next;</span><br><span class=\"line\">        slow= slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//此时slow指向目标节点的前一个节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">tmp</span> =</span> slow-&gt;next;</span><br><span class=\"line\">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"应用二-找出并返回链表中间的节点\"><a href=\"#应用二-找出并返回链表中间的节点\" class=\"headerlink\" title=\"应用二 找出并返回链表中间的节点\"></a>应用二 找出并返回链表中间的节点</h4><p><strong>注</strong>:偶数个节点时删除<strong>前一个</strong>中间节点</p>\n<p><strong>一般解法</strong>：依然是先遍历一遍链表，然后定位中间的节点,二次遍历</p>\n<p><strong>如何优化</strong>：使用<strong>慢指针</strong>(一步走一个节点)和<strong>快指针</strong>(一步走两个节点)，二者同时遍历，直至<strong>快指针</strong>指向<code>NULL</code>或快指针指向<code>尾节点</code></p>\n<p>当遍历结束时，慢指针指向目标中间节点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码实现</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">middleNode</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head)</span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">slow</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">fast</span> =</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用三-循环链表问题\"><a href=\"#应用三-循环链表问题\" class=\"headerlink\" title=\"应用三 循环链表问题\"></a>应用三 循环链表问题</h2>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cm155p08100054sp51602g02t","tag_id":"cm155p08200084sp52bwi7gxi","_id":"cm155p085000e4sp5ht18en3i"},{"post_id":"cm155p083000a4sp5fvrv2l07","tag_id":"cm155p085000d4sp59gsudsff","_id":"cm155p087000j4sp58n220ynj"},{"post_id":"cm155p084000b4sp57qlzhyhs","tag_id":"cm155p087000h4sp5gh0jbvm1","_id":"cm155p088000n4sp59nst3fg6"},{"post_id":"cm155p085000f4sp591vb490r","tag_id":"cm155p088000l4sp588i12z11","_id":"cm155p089000q4sp5e26v6o9j"},{"post_id":"cm155p088000o4sp510an6p9m","tag_id":"cm155p089000r4sp50mimfw6p","_id":"cm155p08b000w4sp5clblgobq"},{"post_id":"cm155p08b000x4sp5au7v7dwe","tag_id":"cm155p088000l4sp588i12z11","_id":"cm155p08e00104sp52j0wcqb8"},{"post_id":"cm155p089000p4sp5fyj19yjb","tag_id":"cm155p08b000v4sp5dpbdgnf7","_id":"cm155p08f00124sp59oei4x6v"},{"post_id":"cm155p089000s4sp57c05hhha","tag_id":"cm155p089000r4sp50mimfw6p","_id":"cm155p08h00164sp55b1u7h0u"},{"post_id":"cm155p08a000t4sp5auovesbe","tag_id":"cm155p08g00144sp537oe6r8r","_id":"cm155p08i001a4sp50sx37b6j"},{"post_id":"cm155p08a000u4sp5572pad7i","tag_id":"cm155p08h00184sp5hiat2dk3","_id":"cm155p08k001e4sp5b3p9hlbp"},{"post_id":"cm155p08k001f4sp54hdhhoc9","tag_id":"cm155p088000l4sp588i12z11","_id":"cm155p08l001i4sp5aes7bvx9"},{"post_id":"cm155p08c000y4sp5atr052kq","tag_id":"cm155p08j001c4sp5drgdev8f","_id":"cm155p08n001k4sp598t0dh6i"},{"post_id":"cm155p08e00114sp5gxxw4ykc","tag_id":"cm155p08k001h4sp53r7rhm19","_id":"cm155p08n001o4sp5dseb9kje"},{"post_id":"cm155p08f00134sp5b1dygapk","tag_id":"cm155p08n001m4sp56jz4e92h","_id":"cm155p08o001s4sp50llx9fnp"},{"post_id":"cm155p08g00154sp5ckt95hzd","tag_id":"cm155p08o001q4sp5hvtbgcc5","_id":"cm155p08p001w4sp5f178g9hh"},{"post_id":"cm155p08p001v4sp50atagrwg","tag_id":"cm155p085000d4sp59gsudsff","_id":"cm155p08q001y4sp5cil972vn"},{"post_id":"cm155p08h00174sp5dx794z57","tag_id":"cm155p08p001u4sp54t2i0t5i","_id":"cm155p08r00214sp54is42fae"},{"post_id":"cm155p08i00194sp5bibd6yv5","tag_id":"cm155p08r00204sp5gtaj5ldg","_id":"cm155p08t00264sp57zle2j1y"},{"post_id":"cm155p08i001b4sp55qv827ki","tag_id":"cm155p08s00244sp5cfphcqx9","_id":"cm155p08u00294sp53na92ue0"},{"post_id":"cm155p08n001n4sp52kuqep25","tag_id":"cm155p08u00284sp5abvq0v1t","_id":"cm155p08u002b4sp5fjjd9usd"},{"post_id":"cm155p08q001z4sp50ojx7ljk","tag_id":"cm155p08u002a4sp510bwax2c","_id":"cm155p08v002d4sp51xh1ct0h"},{"post_id":"cm155p08r00224sp5hnp61wsz","tag_id":"cm155p08v002c4sp59fc22vgc","_id":"cm155p08v002f4sp5anbz2ni8"},{"post_id":"cm155p08s00234sp577p5530m","tag_id":"cm155p08v002e4sp5cnsgfcww","_id":"cm155p08v002h4sp52ohjbarr"},{"post_id":"cm155p08t00254sp51g1xbwp7","tag_id":"cm155p08v002g4sp5eoana3ev","_id":"cm155p08w002j4sp55voy8ayq"},{"post_id":"cm155p08u00274sp5btru5cjt","tag_id":"cm155p08v002e4sp5cnsgfcww","_id":"cm155p08w002k4sp5dknd78qn"}],"Tag":[{"name":"数据结构 二叉树 搜索树","_id":"cm155p08200084sp52bwi7gxi"},{"name":"C语言","_id":"cm155p085000d4sp59gsudsff"},{"name":"C++ 继承","_id":"cm155p087000h4sp5gh0jbvm1"},{"name":"Linux","_id":"cm155p088000l4sp588i12z11"},{"name":"C++ 类和对象","_id":"cm155p089000r4sp50mimfw6p"},{"name":"C++ 文件","_id":"cm155p08b000v4sp5dpbdgnf7"},{"name":"环境变量","_id":"cm155p08g00144sp537oe6r8r"},{"name":"fork Linux","_id":"cm155p08h00184sp5hiat2dk3"},{"name":"七大排序 堆排序 排序","_id":"cm155p08j001c4sp5drgdev8f"},{"name":"排序 算法","_id":"cm155p08k001h4sp53r7rhm19"},{"name":"动态库 静态库","_id":"cm155p08n001m4sp56jz4e92h"},{"name":"C语言 实践项目","_id":"cm155p08o001q4sp5hvtbgcc5"},{"name":"Linux C++ 日志","_id":"cm155p08p001u4sp54t2i0t5i"},{"name":"C语言 多组输入","_id":"cm155p08r00204sp5gtaj5ldg"},{"name":"Linux C","_id":"cm155p08s00244sp5cfphcqx9"},{"name":"进程 Linux","_id":"cm155p08u00284sp5abvq0v1t"},{"name":"C语言 字符串 数组","_id":"cm155p08u002a4sp510bwax2c"},{"name":"Linux vim","_id":"cm155p08v002c4sp59fc22vgc"},{"name":"算法","_id":"cm155p08v002e4sp5cnsgfcww"},{"name":"回顾","_id":"cm155p08v002g4sp5eoana3ev"}]}}