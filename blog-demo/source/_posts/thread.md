---
title: Linux原生线程
date: 2024-08-14 14:55:39
tags:
---

# 什么是线程

在一个程序（进程）里的一条执行流就叫做`线程`(thread),也就是说有多线程功能的进程内，可以有多个线程同时执行

所以我们可以认为:
+ 一个进程至少有一个执行进程
+ 线程在进程内部运行，本质是在进程提供的地址空间内运行

而对于`Linux`实现的线程，本质上是轻量化的进程，还是用的`task_struct`去维护的每一个**线程**

![Linux进程结构](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/thread.png)

**关于线程间内存共享**
如上图所示，线程之间只有`栈区`是相互**独立**的， 像是`全局变量`，`堆区数据`都是共享的

## 线程的优点
+ 创建一个新线程的`代价`要比创建一个新进程小得多
+ 与进程之间的`切换`相比，线程之间的切换需要操作系统做的`工作`要少很多
+ 线程占用的`资源`要比进程少很多
+ 能充分利用多处理器的可`并行`数量
+ 在等待慢速`I/O`操作结束的同时，程序可执行其他的计算任务
+ 计算密集型应用，为了能在多处理器系统上运行，将`计算分解`到多个线程中实现
+ `I/O密集型应用`，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。

## 线程的缺点

### 性能损失
*一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失*，这里的`性能损失`指的是增加了额外的
`同步`和`调度`开销，而**可用的资源不变。**

### 健壮性降低
编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。

### 缺乏访问控制
`进程`是访问控制的`基本粒度`，在一个线程中调用某些OS函数会对整个进程造成影响。

### 编程难度提高
编写与调试一个多线程程序比单线程程序困难得多

## 线程异常
所有线程好比铁索连环，如果单个线程出现诸如 `除零`，`野指针`等异常问题导致线程崩溃,整个`进程`，包括所有线程，都会崩溃退出

## 线程的用途
+ 合理的使用多线程，能提高CPU密集型程序的执行效率
+ 合理的使用多线程，能提高IO密集型程序的用户体验

# 线程与进程辨析

## 进程
资源分配的基本单位,即每个进程都会分配一套独立的进程地址空间/虚拟地址，并且供内部的所有线程共享

## 线程
线程是调度的基本单位，线程共享进程数据，但也拥有自己的一部分数据<span id = "qianwen"></span>

+ `线程ID`
+ 一组寄存器
+ 栈
+ errno
+ 信号屏蔽字
+ 调度优先级

进程的多个`线程共享` 同一地址空间,因此`Text Segment`、`Data Segment`都是共享的,如果定义一个函数,在各线程
中都可以调用,如果定义一个全局变量,在各线程中都可以访问到,除此之外,各线程还共享以下进程资源和环境

+ 文教描述符表
+ 每种信号的处理方式(SIG_IGN、SIG_DFL或自定义的信号处理函数)
+ 当前工作目录
+ 用户id和组id

# Linux线程控制
这里介绍POSIX线程库，这是一个第三方线程库，且是个动态库,有以下特点

+ 与线程有关的函数构成了个完整的系列，绝大多数函数的名字都是以`pthread_`打头的
+ 要使用这些函数库，要通过引入头文`<pthread.h>`
+ 链接这些线程函数库时要使用**编译器**命令的`-lpthread`选项  *很容易忘*

## 创建线程
```C++
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);
```
使用`pthread_create`函数创建新线程

+ 参数
  + thread:输出型参数，返回新线程的`线程id`
  + attr:设置线程属性，为`nullptr`时使用默认属性，一般为`nullptr`
  + start_routine:函数地址，即新线程**启动时调用**的函数
  + arg:传给`start_routine`指向函数的参数
+ 返回值:成功返回`0`，失败返回错误码

关于错误码
> + 统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。
> + threads函数出错时不会设置全局变量errno（而大部分其他POSIX函数会这样做）。而是将错误代码通过返回值返回
> + hreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误,建议通过返回值业判定，因为读取返回值要比读取线程内的errno变量的开销更小

> 使用示例
```C++
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

#include <string.h>
#include <pthread.h>
void *rout(void *arg)
{
    int i;
    for (;;)
    {
        printf("I'am thread 1,got arg:%d\n",*(int*)arg);
        sleep(1);
    }
}
int main(void)
{
    pthread_t tid;//储存tid的变量
    int ret;
    int arg = 114514;//准备参数
    //创建新线程
    if ((ret = pthread_create(&tid, NULL, rout, &arg)) != 0)
    {
        //创建失败
        fprintf(stderr, "pthread_create : %s\n", strerror(ret));
        exit(EXIT_FAILURE);
    }
    int i;
    for (;;)
    {
        //主线程输出
        printf("I'am main thread\n");
        sleep(1);
    }
}
```

## 线程id及进程地址空间布局
+ hread_create函数会产生一个线程id，存放在第一个参数指向的地址中。该线程id和前面说的线程ID(本文用大小写区分)不是一回事。
+ [前文](#qianwen)的`线程ID`于进程调度的范畴。因为线程是轻量级进程，是操作系统调度器的最小单位，所以需要一个数值来唯一表示该线程。
+ hread_create函数第一个参数指向一个虚拟内存单元，该内存单元的地址即为新创建线程的线程ID,属于NPTL线程库的范畴。线程库的后续操作，就是根据该线程ID来操作线程的。
+ 程库NPTL提供了pthread_self函数，可以获得线程自身的ID:

`pthread_t` 到底是什么类型呢？取决于实现。对于Linux目前实现的NPTL实现而言，pthread_t类型的线程ID，本质就是一个进程地址空间上的一个地址。

![](https://picbed0521.oss-cn-shanghai.aliyuncs.com/blogpic/202409091528968.png)

## 线程终止
如果需要只终止某个线程而不终止整个进程,可以有三种方法:

+ 从线程函数`return`。这种方法对主线程**不适用**,从main函数return相当于调用exit。
+ 线程可以调用`pthread_exit`终止自己。
+  一个线程可以调用`pthread_cancel`终止同一进程中的另一个线程。

### pthread_exit函数
`void pthread_exit(void *retval);`

`retval`为输出型参数，而函数调用后，该线程退出，栈帧销毁，所以,需要注意,pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的,不能在线程函数的栈上分配,因为当其它线程得到这个返回指针时线程函数已经退出了。

