---
title: Rust自学一周初印象
date: 2025-03-31 13:56:54
tags:
---
经过一周对[Rust语言圣经](https://course.rs/about-book.html)的学习和第三方包的使用体验，我成功从纯`Rust小白`成为了`Rust爱好者`,已经有了能进行网络编程和数据库交互的基本能力。

# 概括一下Rust的特点
+ 超高效的运行时效率
+ 大聪明编译器
+ 干费我2核2G服务器的rust analyzer
+ 安全，安全，还是安全！
+ 特征，特征对象,超牛的泛型编程方式

# 又见堆栈
我原本是以`C/C++`为主语言的，在使用`Python`或`Java`这种有`GC垃圾回收机制`的语言时，对堆栈并不强调，没想到遇上`Rust`，堆栈的概念再一次被强调了起来，但与`C/C++`这种对堆栈，尤其是堆区的分配的过于自由的管理相比，`Rust`对堆栈的管理十分严格，且涉及到`Rust`是如何在没有`GC`机制的前提下，既能高效使用内存，又能保证安全。

## 所有权与借用
对于变量的数据，它有一个所有权规则，没错，变量和数据之间的联系更为松散，**存在通过所有权转移导致数据还在，但变量已经失效的情况**

以上是一点，而还有一点就是当变量拥有分配在堆上的数据的所有权时，变量一旦带着所有权被释放时，堆上的数据会一并被自动回收，这样就不用担心内存泄漏的问题了，也不用手动释放内存。

**不想转移所有权?**,那就试试使用`克隆clone`吧，这样就会额外在堆上创建新的数据，把新数据的所有权转移给变量

**只想访问而不想要所有权？**，那就试试`借用&`吧,借用变量本质是一个指针，它没有被借用变量的所有权，它的释放不会导致数据的释放。不过由于只读和可读写不能存在安全问题，所以编译器对各种借用的数量和生命周期管理有严格要求

## 生命周期
`Rust`对生命周期有着严格的管理，防止各种`借用`有权限访问到已经被释放的资源（这是非常不安全的！），尽管编译器很聪明，绝大部分生命周期它都能自动推导出来，但是当出现复杂的，多样的情况时，还是需要程序员手动标注**生命周期约束**。

## 模式匹配
`match`很好理解，主要是`if let`需要特别关注一下，它只匹配某一种模式条件，因此有很多巧用，但是可能一时又想不起来`if let`怎么用的

类型/枚举匹配可以用`matches!`宏

# 泛型编程和特征

## 模板
与许多其它语言一样，rust提供了函数模板和结构体模板，好吧，还有枚举模板

## const泛型
特别的，针对那些因为值不同而导致的类型不同的一类类型（比如列表类型`[i32,T]`），我们使用const泛型编程把它们统一起来,例子如下

```rust
fn func<T:std::fmt::Debug,const N:usize>(arr:[T])
```

*const fn常量函数*

emm,它们只是长得像,不属于泛型编程，但是这个函数非常好用，既能简化代码，又没有运行时损耗，因为函数的求值都在编译阶段完成！

##　特征
特征规定了一系列必须实现的方法，它有很好的**约束作用**

## 特征约束
有了特征约束，我们就能约束模板参数中的类型必须实现了什么方法才是合法的，这样我们就能放心地在函数中调用方法了。

## 特征对象
让函数的传参只需满足特征即可，而对具体类型没有要求